!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/velocity_a.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c  ----------------------------------------------------------------------
!c  subroutine velocityg
!c  --------------------
!c
!c  compute average interfacial velocities in x,y,z directions 
!c  for rectangular, cartesian finite volume discretization 
!c  in the gas phase
!c  
!c  compute advection & diffusion fluxes for output visualization
!c
!c  written by:      Pejman Rasouli - July 25, 2012
!c
!c  last modified:   Pejman Rasouli - July 30, 2012
!c
!c                   Danyang Su - March. 14, 2014
!c                   HPC capabilities
!c                   
!c
!c  definition of variables:
!c
!c  I --> on input   * arbitrary  - initialized  + entries expected
!c  O --> on output  * arbitrary  - unaltered    + altered
!c                                                                     I O
!c  passed:   integer*4:
!c            ----------
!c            l_sufx             = length of file suffix               + -
!c
!c            character:
!c            ----------
!c            suffix             = file suffix                         + -
!c
!c  gen.f:
!c            real*8:
!c            -------
!c            dimcv(3,nn)        = dimension of cells in x,y,z         + -
!c                                 direction
!c            xg(nn)             = spatial coordinates in x-direction  + -
!c            yg(nn)             = spatial coordinates in y-direction  + -
!c            zg(nn)             = spatial coordinates in z-direction  + -
!c  
!c  added for multicomponent diffusion
!c
!c            deltaij(njavs)     = distance between i-j                + -
!c            tauij(njavs)       = tortuosity (gas phase)              + -
!c
!c            character:
!c            ----------
!c            iupsg(i1)
!c  -----------------------
!c
!c            integer*4:
!c            ----------
!c            iavs(nn+1)         = row pointer array for 1d-scalar     + -
!c                                 matrix
!c            idbg               = output for debugging information    + -
!c            ifls               = unit number, file information       + -
!c            igsa               = unit number, molar fluxes           + -
!c                                              - contour
!c            igsa2              = unit number, molar fluxes           + -
!c                                              - contour
!c            igsa_first         = unit number, molar fluxes           + -
!c                                              - contour
!c            igsa_last          = unit number, molar fluxes           * +
!c                                              - contour
!c            ilog               = unit number, logbook                + -
!c            javs(njavs)        = connectivity list for 1d-scalar     + -
!c                                 matrix
!c            nn                 = total number of control volumes     + -
!c            nvx                = number of control volumes           + -
!c                                 in x direction
!c            nvy                = number of control volumes           + -
!c                                 in y direction
!c            nvz                = number of control volumes           + -
!c                                 in z direction
!c
!c            logical:
!c            --------
!c            half_cells         = .true.  -> half cells on boundary   + -
!c
!c            character:
!c            ----------
!c            spatial_weighting  = 'upstream'
!c                                 'centered'
!c
!c  phys.f:
!c            real*8:
!c            -------
!c
!c
!c  chem.f:
!c            character:
!c            ----------
!c            namec(nc)          = component names
!c            nameg(ng)          = names of gases
!c
!c            integer*4:
!c            ----------
!c            nc                  = number of components
!c
!c  dgml.f    logical:
!c            --------
!c
!c
!c
!c  common:   -
!c
!c  local:    real*8:
!c            -------
!c            aread(3,12)        = A_ij/d_ij for current "pseudo
!c                                 dispersion element" associated
!c                                 with control volume ivol, up to 4
!c                                 entries for each dimension
!c            areai              = interfacial area
!c            dd(3,12)           = distance between nodes
!c            dgflux             = interfacial gas velocity
!c           dgflux_ca(n)       = interfacial gas advective flux
!c           dgflux_cd(n)       = interfacial gas diffusive flux
!c           diff(n,3)          = diffusive coefficient (LeBlancs approx)
!c           eps                = constant
!c           r0                 = constant
!c           r1                 = constant
!c           rhalf              = constant
!c           velg(3)            = gas velocity
!c           velg_ca(n,3)       = gas advective flux
!c           velg_cd(n,3)       = gas diffusive flux
!c           rverysmall         = constant
!c
!c added for gas transport:
!c
!c           cinfrt             = influence coefficients              * +
!c           densgij            = gas density at interface i-j
!c           dgm_gflux(nc)      = diffusive flux (as computed w/DGM)  * +
!c           dgflux_cd_dgm(n)   = diffusive flux cal!c w/DGM           * +
!c           fmat(ng)           = right hand side DGM system          * +
!c           gdens(nn)          = gas density at control volume i     * +
!c           gij(ng)            = gas concentration at i-j            * +
!c           gmfracij(ng)       = gas molar fractions at i-j          * +
!c           gpivol(nn)         = gas pressure at control volume i    * +
!c           grad_diff(ng,3)    = gradient that drives diffusion      * +
!c           grad_adv(3)        = gradient that drives advection      * +
!c           gvisc(ivol)        = gas viscosity at control vol i      * +
!c           ludecomp(ng,ng)    = LU decomp of matrix of DGM system * +
!c           ms_gflux(nc)       = diffusive flux (as computed w/S-M)  * +
!c           neflux(nc)         = non-equimolar flux for multi-comp   * +
!c                                diffusion
!c           relpgij            = relative perm (gas) at i-j          * +
!c           totgij             = total gas concentrations of         * +
!c                                components at interface i-j         * +
!c           velg_dgm(n,3)      = diffusive flux cal w/ dgm           * +
!c           velg_neq(n,3)      = non-equimolar flux                  * +
!c           rverysmall         = constant 
!c           viscgij            = gas viscosity at interface i-j      * +
!c
!c           character:
!c           ----------
!c           spt_weight         = spatial weighting for gas transp    * +
!c
!c           integer*4:
!c           ----------
!c           ipvt(ng)           = pivot pointer
!c
!c -------------------------
!c
!c           integer*4:
!c           ----------
!c           cvpair(3,12,2)     = pointers to connected control 
!c                                volumes in each pair for each 
!c                                dimension
!c           i1                 = pointer (connectivity list)
!c           i1sav              = pointer (connectivity list)
!c           idim               = pointer (dimensions)
!c           idim2              = pointer (dimensions)
!c           idim3              = pointer (dimensions)
!c           ipair              = counter (control volume pairs in
!c                                         dimension)
!c           ivol               = pointer (control volume i)
!c           jvol               = pointer (connected control volume j)
!c           ivol2              = counter (control volumes)
!c           ivx                = counter (number of control
!c                                volumes in x-direction)
!c           ivy                = counter (number of control
!c                                volumes in y-direction)
!c           ivz                = counter (number of control
!c                                volumes in z-direction)
!c           npair(3)           = number of control volume pairs
!c                                in dimension
!c
!c external: cliqdisp  = find control volume pairs for computation of 
!c                       average interfacial velocities
!c           fluxvg    = compute advective flux + gas phase velocity
!c           gasp_m    = compute gas pressure
!c           gasd_m    = compute gas density
!c           gasv      = compute gas viscosity
!c           dgm_fluxdg = compute gas diffusive fluxes with DGM
!c           wgprop    = spatial weighting for gas transport properties
!c ----------------------------------------------------------------------

      subroutine velocity_a (l_sufx, suffix,nmax,njamxc,cinfradx,      &
     &                       radial_coordx)

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use gen
      use chem
      use phys
      use writeversion      
      use file_unit, only : lun_get, lun_set
      use multidiff, only: cinfrt_mcd
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      use module_binary_mpiio, only :  binary_file_open,               &
                                     tecplot_binary_write_header,      &
                                     tecplot_binary_write_variable,    &
                                     tecplot_binary_write_zoneinfo,    &
                                     tecplot_binary_write_section,     &
                                     binary_write_data,                &
                                     binary_file_close,                &
                                     binary_subarray_initialize

#ifdef OPENMP
      use omp_lib 
#endif 
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
    
      integer :: i, ic, ierr, igsa2, ivol_l
      real*8 :: xg_out, yg_out, zg_out
      real*8, external :: fluxd, fluxv_vl

      external cliqdisp, elecmigration, checkerr

!c  passed variables
      character*3  suffix
      integer l_sufx, nmax

!c  local variables
      real*8, parameter :: eps = 1.0d-300, r0 = 0.0d0, rhalf = 0.5d0
      real*8, parameter :: r1 = 1.0d0, rverysmall = 1.d-30
      
      real*8 aread(3,12), vela_adv(n,3), vela_dif(n,3),                &
             vela_mig(n,3),vela_tot(n,3),areai,aflux,aflux_adv(n),     &
             aflux_dif(n),aflux_mig(n),aflux_tot(n),diff(n,3),         &
             dd(3,12),vel(3),dist(3,12),d(3,nmax),areax(3,12)

      integer ivol, ivol2, ivz, ivy, ivx, i1, jvol, i1sav, idim,       &
              npair(3), cvpair(3,12,2), ipair, idim2, idim3,           &
              njamxc,ia(nmax+1), ja(njamxc)
    
!c  I/O variables  
      integer*4    :: l_sfx2, tid
      character*12 :: suffix2
      character*2048 :: strbuffer
      character*72 :: tec_variables(100)
#ifdef PETSC
      integer(kind=MPI_OFFSET_KIND), allocatable :: offset_igsa2(:),   &
                                     offset_igsa2_temp(:)
#else
      integer*8, allocatable :: offset_igsa2(:), offset_igsa2_temp(:)
#endif
      integer*4, allocatable :: igsa2_list(:)
      
!c  advective flux calculations                   
      character*12 spt_weight
      logical      flux

!c  other 
      real*8     cinfrt,        &
                 dgflux_cd_dgm(n),    &
                 cinfradx(njamxc),    &
                 vela_net(n,3)
      
      logical radial_coordx 


!c  open output files___________________________________________

#ifdef OPENMP
        tid = omp_get_thread_num() + 1
#else
        tid = 1
#endif

      igsa = igsa_first

!c  aqueous phase velocity
      if (b_output_binary) then
        allocate(offset_igsa2(n), stat = ierr)
        call checkerr(ierr,'offset_igsa2',ilog)
        offset_igsa2 = 0
        call memory_monitor(sizeof(offset_igsa2),'offset_igsa2',.true.)

        allocate(offset_igsa2_temp(n), stat = ierr)
        call checkerr(ierr,'offset_igsa2_temp',ilog)
        offset_igsa2_temp = 0
        call memory_monitor(sizeof(offset_igsa2_temp),'offset_igsa2_temp',.true.)

        allocate(igsa2_list(n), stat = ierr)
        call checkerr(ierr,'igsa2_list',ilog)
        igsa2_list = 0
        call memory_monitor(sizeof(igsa2_list),'igsa2_list',.true.)
      end if
      
      if (b_output_binary) then
        tec_variables(1:15) = [character(len=72) ::                        &
                              "x", "y", "z", "vx adv", "vy adv", "vz adv", &
                              "vx dif", "vy dif", "vz dif", "vx mig",      &
                              "vy mig", "vz mig", "vx tot", "vy tot",      &
                              "vz tot"]
      end if

      igsa2 = igsa 

!c  velocity of aqueous species in mixture
      do ic=1,n

        igsa2 = igsa2+1
      
        call icnvrt(0,ic,suffix2,l_sfx2,ierr)

        if (b_output_binary) then
          if (b_output_mpiio_single) then
            strbuffer = prefix(:l_prfx)//'_'//suffix(:l_sufx)//'_'//   &
               suffix2(:l_sfx2)//'.gsa'
          else
            strbuffer = prefix(:l_prfx)//'_'//suffix(:l_sufx)//'_'//   &
                        suffix2(:l_sfx2)//trim(adjustl(str_rank))//'.gsa'
          end if

          call binary_file_open(Petsc_Comm_World,igsa2_list(ic), &
                       trim(strbuffer),b_output_mpiio_single)
        else
          open(igsa2,file=prefix(:l_prfx)//'_'//suffix(:l_sufx)//'_'// &
               suffix2(:l_sfx2)//trim(adjustl(str_rank))//'.gsa',      &
               status='unknown', form='formatted')
        end if

!c  version information
        if (b_writeversion_tecplot .and. .not. b_output_binary) then
          call writeversion2file(igsa2, "#")
        end if
      
        if (b_output_binary) then
          strbuffer = 'dataset '//prefix(:l_prfx)//''
          offset_igsa2(ic) = 0
          call tecplot_binary_write_header(Petsc_Comm_World,           &
                       igsa2_list(ic),"#!TDV102", trim(strbuffer),     &
                       offset_igsa2(ic),b_output_mpiio_single,.false.)

          call tecplot_binary_write_variable(Petsc_Comm_World,         &
                       igsa2_list(ic),15, tec_variables(1:15),         &
                       offset_igsa2(ic),b_output_mpiio_single,.false.)

          strbuffer = 'advection and diffusion fluxes'
          offset_igsa2_temp(ic) = offset_igsa2(ic)

          if (b_output_multizone) then
            call tecplot_binary_write_zoneinfo(                        &
                         Petsc_Comm_World, igsa2_list(ic),             &
                         trim(strbuffer),offset_igsa2(ic),             &
                         itec_vel,jtec_vel,ktec_vel,                   &
                         b_output_mpiio_single,.false.,b_output_multizone)
            offset_igsa2(ic) = offset_igsa2_temp(ic) +                 &
                          (11+len_trim(strbuffer))*4*nprcs + 4
          else
            call tecplot_binary_write_zoneinfo(                        &
                         Petsc_Comm_World, igsa2_list(ic),             &
                         trim(strbuffer),offset_igsa2(ic),             &
                         itec_vel_gbl,jtec_vel_gbl,ktec_vel_gbl,       &
                         b_output_mpiio_single,.false.,b_output_multizone)
            offset_igsa2(ic) = offset_igsa2_temp(ic) +                 &
                          (12+len_trim(strbuffer))*4
          end if
        else
          write(igsa2,'(3a)') 'title = "dataset ',prefix(:l_prfx),'"'
          write(igsa2,'(6a)') 'variables = "x", "y", "z", ',           &
                            '"vx adv", "vy adv", "vz adv", ',          &
                            '"vx dif", "vy dif", "vz dif", ',          &
                            '"vx mig", "vy mig", "vz mig", ',          &
                            '"vx tot", "vy tot", "vz tot"'
          write(igsa2,'(a,3(a,i5),a)')                                 &
                'zone t = "advection and diffusion fluxes" ',          &
                ', i =',itec_vel,                                      &
                ', j =',jtec_vel,                                      &
                ', k =',ktec_vel,',  f=point'
        end if

        if (rank == 0 .and. b_enable_output) then
          write(ifls,'(/a, a, 1x, a, 1p, 1pe15.6e3, 1x, a, /, 72a)')   &
               'Average interfacial aqueous fluxes for component: ',   &
                namec(ic)(:l_namec(ic)),' T = ',            &
                time_io,time_unit,('-',i=1,72)
      
          write(ifls,'(/a/)') prefix(:l_prfx)//'_'//                   &
                suffix(:l_sufx)//'_'//suffix2(:l_sfx2)//               &
                trim(adjustl(str_rank))//'.gsa'

          write(ifls,'(2a)')                        &
              'column   entry                           ','unit'
          write(ifls,'(2a)')                        &
              '1        x                               ','m'
          write(ifls,'(2a)')                        &
              '2        y                               ','m'
          write(ifls,'(2a)')                        &
              '3        z                               ','m'
          write(ifls,'(2a)')                        &
              '4        v_x Advection                   ','moles/m^2/d'
          write(ifls,'(2a)')                        &
              '5        v_y Advection                   ','moles/m^2/d'
          write(ifls,'(2a)')                        &
              '6        v_z Advection                   ','moles/m^2/d'
          write(ifls,'(2a)')                        &
              '7        v_x Diffusion                   ','moles/m^2/d'
          write(ifls,'(2a)')                        &
              '8        v_y Diffusion                   ','moles/m^2/d'
          write(ifls,'(2a)')                        &
              '9        v_z Diffusion                   ','moles/m^2/d'
          write(ifls,'(2a)')                        &
              '10       v_x Electromigration            ','moles/m^2/d'
          write(ifls,'(2a)')                        &
              '11       v_y Electromigration            ','moles/m^2/d'
          write(ifls,'(2a)')                        &
              '12       v_z Electromigration            ','moles/m^2/d'
          write(ifls,'(2a)')                        &
              '13       v_x Total                       ','moles/m^2/d'
          write(ifls,'(2a)')                        &
              '14       v_y Total                       ','moles/m^2/d'
          write(ifls,'(2a)')                        &
              '15       v_z Total                       ','moles/m^2/d'
          
        end if
    
      enddo

     
!c  write section information for binary output
      if (b_output_binary) then
        do ic = 1, n  
          offset_igsa2_temp(ic) = offset_igsa2(ic)
          call tecplot_binary_write_section(Petsc_Comm_World,          &
                       igsa2_list(ic),15,nn_interfacial_offset,        &
                       offset_igsa2(ic),b_output_mpiio_single,.false., &
                       b_output_multizone)
        end do
        allocate(realbuffer2d(nn*15, n), stat = ierr)
        call checkerr(ierr,'velocity_a-realbuffer2d',ilog)
        realbuffer2d = 0.0d0
        call memory_monitor(sizeof(realbuffer2d),'realbuffer2d',.true.)
      end if
    
!c  compute average interfacial velocities________________________

      ivol2 = 0
      ivol_l = 0

      do ivz = 1, nvzgl          !increments in z-direction
        do ivy = 1, nvygl        !increments in y-direction
          do ivx = 1, nvxgl      !increments in x-direction

            ivol2 = ivol2 + 1  !counter - control volumes
            
!c  skip ghost nodes
#ifdef PETSC
            if(node_idx_lg2l(ivol2) < 0) then
                cycle
            end if
#endif
            
!c  find node pairs for interfacial velocities

            call cliqdisp(nvxgl, nvygl, nvzgl, ivx, ivy, ivz,          &
                         cvpair, npair,                                &
                         aread, areax,dist,dimcv,half_cells,           &
                         iavs,javs, njamxc,                            &
                         nmax, idbg, cinfradx, radial_coordx)
     
!c  check connections

            if ((nvxgl .gt. 1 .and. npair(1) .eq. 0) .or.              &
                (nvygl .gt. 1 .and. npair(2) .eq. 0) .or.              &
                (nvzgl .gt. 1 .and. npair(3) .eq. 0)) goto 400
            
              ivol_l = ivol_l + 1

!c  loop over the dimensions x,y,z

              do idim = 1, 3

                idim2 = idim + 1
                idim3 = idim + 2
                if (idim2 .gt. 3) idim2 = idim2 - 3
                if (idim3 .gt. 3) idim3 = idim3 - 3

!c  zero average interfacial velocity

                do ic=1,n

                  vela_adv(ic,idim)= r0
                  vela_dif(ic,idim)= r0
                  vela_mig(ic,idim) = r0
                  vela_tot(ic,idim) = r0
                enddo
            

!c  loop over the number of control volume pairs in the dimension

                do ipair = 1, npair(idim)

                  ivol = cvpair(idim, ipair, 1)
                  jvol = cvpair(idim, ipair, 2)

!c  calculate average interfacial area between control volumes

                  areai = areax(idim, ipair)

                  do i1 = iavs(ivol), iavs(ivol+1)-1
                    if (javs(i1) .eq. jvol) then
                      i1sav = i1
                      go to 500
                    endif
                  end do
                  if (rank == 0) then
                    write(ilog,*) ' error-cannot find jvol in list'
                    write(ilog,*) ' ivol, jvol ', ivol, jvol
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
500               continue

!c  find flux between control volume pair


!c when gas advection, report velocity and flux results
                  if (multi_diff) then
                    call totdyvisc(ivol,jvol,cnew(:,ivol),cx(:,ivol),  &
                                   cnew(:,jvol),cx(:,jvol),            &
                                   delta_totviscnew(:,tid))

                    call elecmigration(ivol,jvol,cnew(:,ivol),cx(:,ivol),  &
                                       cnew(:,jvol),cx(:,jvol),            &
                                       delta_electromignew(:,tid))
                  end if

                  do ic=1,n


!c  compute aqueous phase flux

                    if (multi_diff) then

                      aflux_adv(ic) = fluxv_vl(totcnew(ic,ivol),             &    !advective term
                                               totcnew(ic,jvol),             &
                                               ivol,jvol,                    &
                                               cinfrt_va(i1),ic)
                      aflux_dif(ic) = - fluxd(r0,delta_totviscnew(ic,tid),   & !diffusive term
                                              cinfrt_mcd(i1))
                      aflux_mig(ic) = - fluxd(r0,delta_electromignew(ic,tid),& !electromigration term
                                              cinfrt_mcd(i1))

                    else

!c ---------------- fick's law, business as usual -------------------------     

                      aflux_adv(ic) = fluxv_vl(totcnew(ic,ivol),       &    !advective term
                                                totcnew(ic,jvol),      &
                                                ivol,jvol,             &
                                                cinfrt_va(i1),ic)
                      aflux_dif(ic) = - fluxd(totcnew(ic,ivol),        &        !dispersive term
                                             totcnew(ic,jvol),         &
                                             cinfrt_da(i1))

                    end if

!c  total flux

                    aflux_tot(ic) = aflux_adv(ic) + aflux_dif(ic) + aflux_mig(ic)

                  enddo
         
!c------------------------------------------------------------------------

!c  velocity is the flux (m^3/day) divided
!c  by the interfacial area between the two control volumes

                  do ic=1,n

                    vela_adv(ic,idim) = vela_adv(ic,idim) - aflux_adv(ic)  &
                                                          / areai * 1.d+3

                    vela_dif(ic,idim) = vela_dif(ic,idim) - aflux_dif(ic)  &
                                                          / areai * 1.d+3

                    vela_mig(ic,idim) = vela_mig(ic,idim) - aflux_mig(ic)  &
                                                          / areai * 1.d+3

                    vela_tot(ic,idim) = vela_tot(ic,idim) - aflux_tot(ic)  &
                                                          / areai * 1.d+3
                  enddo
          
                end do          !end do ipair

!c  find the average interfacial velocity in the x,y,z directions

                do ic=1,n

                  vela_adv(ic,idim) = vela_adv(ic,idim)      &
                                     / (float(npair(idim))+eps)

                  vela_dif(ic,idim) = vela_dif(ic,idim)      &
                                     / (float(npair(idim))+eps)

                  vela_mig(ic,idim) = vela_mig(ic,idim)      &
                                     / (float(npair(idim))+eps)

                  vela_tot(ic,idim) = vela_tot(ic,idim)      &
                                     / (float(npair(idim))+eps)
                enddo

              end do            !end do idim

!c  write average interfacial velocities to output file__________________

              if (nvxgl.gt.1) then
                xg_out = xg(ivol2) - rhalf * dimcv(1,ivol2)
              else
                xg_out = xg(ivol2)
              end if

              if (nvygl.gt.1) then
                yg_out = yg(ivol2) - rhalf * dimcv(2,ivol2)
              else
                yg_out = yg(ivol2)
              end if
              
              if (nvzgl.gt.1) then
                zg_out = zg(ivol2) - rhalf * dimcv(3,ivol2)
              else
                zg_out = zg(ivol2)
              end if


!c           mass fluxes
              igsa2 = igsa

              do ic=1,n

                igsa2 = igsa2 + 1
              
                if (b_output_binary) then
                  realbuffer2d((ivol_l-1)*15+1:ivol_l*15,ic) = (/      &
                                       xg_out,yg_out,zg_out,           &
                                       (vela_adv(ic,idim),idim=1,3),   &
                                       (vela_dif(ic,idim),idim=1,3),   &
                                       (vela_mig(ic,idim),idim=1,3),   &
                                       (vela_tot(ic,idim),idim=1,3)/)
                else
                  write(igsa2,ascii_fmt) xg_out,yg_out,zg_out,         &
                                       (vela_adv(ic,idim),idim=1,3),   &
                                       (vela_dif(ic,idim),idim=1,3),   &
                                       (vela_mig(ic,idim),idim=1,3),   &
                                       (vela_tot(ic,idim),idim=1,3)
                end if
              enddo
        
400         continue

          end do
        end do
      end do
      
      if (b_output_binary) then
        if (b_output_multizone .or. .not.b_output_mpiio_single) then
          do ic = 1, n
            call binary_write_data(igsa2_list(ic), ivol_l*15,          &
                         realbuffer2d(:,ic), offset_igsa2(ic),         &
                         b_output_mpiio_single)
          end do
        else
          do ic = 1, n
            call binary_subarray_initialize(15,b_mpiarray_igsa2_init,  &
                        .true.,mpiarray_filetype_igsa2,                &
                        mpiarray_sizes_gbl_igsa2,                      &
                        mpiarray_sizes_sub_igsa2,                      &
                        mpiarray_starts_sub_igsa2)
            call binary_write_data(igsa2_list(ic), ivol_l*15,          &
                         realbuffer2d(:,ic), offset_igsa2(ic),         &
                         mpiarray_filetype_igsa2)
          end do
        end if
      end if
      
      if(b_output_binary) then
        do ic=1,n 
          call binary_file_close(igsa2_list(ic),b_output_mpiio_single)  
        end do
      else
        igsa2 = igsa              
        do ic=1,n        
          igsa2 = igsa2 + 1
          close(igsa2)
          !Keep the file unit, this will be used later
          !call lun_free(igsa2)
        end do
      end if
      
      if (b_output_binary) then
        call memory_monitor(-sizeof(offset_igsa2),'offset_igsa2',.true.)
        call memory_monitor(-sizeof(offset_igsa2_temp),'offset_igsa2_temp',.true.)
        call memory_monitor(-sizeof(igsa2_list),'igsa2_list',.true.)
        call memory_monitor(-sizeof(realbuffer2d),'realbuffer2d',.true.)
        deallocate(offset_igsa2)
        deallocate(offset_igsa2_temp)
        deallocate(igsa2_list)
        deallocate(realbuffer2d)
      end if

      return
      end
