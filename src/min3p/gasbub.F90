!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 877 $
!> $Author: dsu $
!> $Date: 2024-02-08 21:51:08 -0800 (Thu, 08 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/gasbub.F90 $
!---------------------------------------------------------------------
!********************************************************************!


!c -----------------------------------------------------------------------
!c subroutine gasbub
!c -----------------
!c
!c compute gas saturation below the water table for bubble problem
!c
!c written by:      Rich Amos - June 23, 2003
!c
!c last modified:   - 
!c
!c                  Danyang Su - March 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c gen.f       real*8:
!c             -------
!c             sanew(nn)          = aqueous phase saturation 
!c                                  (new time level)
!c             sgnew(nn)          = gaseous phase saturation 
!c                                  (new time level)
!c             uvsnew(nn)         = solution vector (new time level)
!c             gnew(ng,nn)        = gas concentrations                  + *
!c                                - new time level [moles/l air]
!c             cnew(nc,nn)        = concentrations of free species
!c                                - new time level [moles/l water]
!c            mpropvs(nn)        = pointer array for allocation of     + -
!c                                  material properties
!c            totcnew(n,nn)      = total aqueous component
!c                                  concentrations
!c                                  - new time level [moles/l water]
!c             gamma(nc+nx,nn)    = activity coefficients of aqueous    + +
!c                                  species
!c             delt               = time step 
!c
!c             integer:
!c             --------
!c             nn                 = total number of control volumes
!c            mtime              = current time step
!c
!c bbls.f        real*8
!c             -------
!c            k_henry(ig,ivol)    = henry's law constant for gas(i)->gas pair(i)
!c            tot_gas(ig,ivol)    = total concentration of gas in aqueous 
!c                                  plus gas phase (mole/pore volume)
!c            aqueous_gas(ig)        = concentration of gas pair in the aqueous phase
!c                                  (either as a component or a secondary species)
!c                                   (mole/L)
!c            c_update(nc,nn)        = component concentration at previous inner
!c                                  bubble iteration.
!c             sanew_c(nn)         = sanew prior to gasbub for non-gas component update and
!c                                   relaxation scheme 
!c             sanew_b(nn)            = water saturation prior to reactran and gasbub
!c                                  for convergence check of outer bubble loop
!c             maxsg_update        = maximum update in gas saturation per loop
!c             dsadt_max           = maximum rate of saturation change (del sa/day)
!c
!c             integer:
!c             --------
!c            gas_pair(ig)        = component or species number for
!c                                    gas pair for each gas
!c            ibub                = counter for inner bubble iteration loop
!c            ibubflow            = counter for outer bubble iteration loop
!c
!c            character
!c            ---------
!c            logical
!c            ---------
!c            gas_species(ng,nx)    = .true.-> species ix has a common 
!c                                  component with gas ig
!c             bubble_out          = .true.-> output bubble info
!c             sgsolved            = .true. -> routine solvsg called and bubble size is calculated 
!c                               for at least one control volume during the bubble iteration
!c             unsaturated(nn)      = .true. -> control volume was unsaturated during last time step
!c             solvegb(nn)          = .true. -> gasbub calculated for this volume during this time step
!c             double_bubble        = .true. -> double bubble iterations
!c
!c chem.f:   real*8:
!c           ------- 
!c           rgasatm            = ideal gas constant 
!c                                [liter atm/(deg K mole)]
!c           rho_w              = density of water [kg m^-3]          + -
!c           pa_atm             = conversion factor [Pa atm ^-1]  
!c           tkel(nn)           = nodal temperatures in Kelvin
!c           pres_atm           = atmospheric pressure (default = 1 atm)
!c           eqg(ng)           = equilibrium constants for gases
!c           eqx(nx)           = equilibrium constants for 
!c                                secondary aqueous species
!c           xnug(ng*nc)        = stoichiometric coefficient matrix 
!c                                for formation of gases from
!c                                components
!c           xnux(nx*nc)        = stoichiometric coefficient matrix 
!c                                for formation of secondary aqueous 
!c                                species from components
!c
!c          integer
!c          -------
!c           ng                 = number of gases 
!c           nx                 = number of secondary aqueous species
!c           nc                 = number of components including h2o
!c           iax(nx+1)          = row pointer array to 
!c                                stoichiometric coefficients of 
!c                                components in secondary aqueous
!c                                species
!c           jax(nx*nc)         = column pointer array to 
!c                                stoichiometric coefficients of 
!c                                components in secondary aqueous
!c                                species
!c           iaga(ng+1)         = row pointer array to 
!c                                stoichiometric coefficients of 
!c                                components in gases
!c           jaga(ng*nc)        = column pointer array to 
!c                                stoichiometric coefficients of 
!c                                components in gases
!c
!c          character
!c          ---------
!c          namec(nc)          = component names
!c
!c phys.f      real*8
!c          ------
!c           aentry(nzn)        = air entry pressure 
!c
!c local      real*8
!c           ------
!c          sum_pressure         = sum of partial pressures (atm)
!c           tot_press             = hydrodynamic pressure (atm)
!c          g_term             = gas term for henry's law factor
!c          x_term             = species term for henry's law factor
!c          partial_pressure   = partial pressure of each gas after bubble 
!c                               calculation used to calculate new component
!c                               concentrations
!c           delsa              = change in water saturation
!c           delsa_max          = largest update in water saturation
!c           ivol_max           = control volume with largest update in water saturation
!c           sfactor            = factor for relaxation scheme
!c           updatefactor       = update factor for relaxation scheme
!c           updatefactor_old   = update factor at previous bubble iteration
!c           delsa_maxold       = largest update in water saturation at previous 
!c                                bubble iteration
!c           delsa_delt         = maximum chnage in saturation for time step
!c           
!c
!c          initeger
!c          --------
!c          ivol                 = counter (nodes)
!c          ig                 = counter (gases)
!c          izn                 = counter (zones)   
!c          igas                 = file number for bubble output file 
!c          ip                 = component number for gas pair 
!c           ic                 = counter (components)
!c           ix                 = counter (secondary species)
!c           iend               = pointer (stoichiometric
!c                                coefficients)
!c           istart             = pointer (stoichiometric
!c                                coefficients)              
!c 
!c---------------------------------------------------------------------
    subroutine gasbub(bflag_dbg, bflag_bubout)

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use bbls
      use chem
      use phys
      use file_unit, only : lun_get
#ifdef OPENMP
      use omp_lib
#endif

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      use module_binary_mpiio, only :  binary_file_open,               &
                                       tecplot_binary_write_header,    &
                                       tecplot_binary_write_variable,  &
                                       tecplot_binary_write_zoneinfo,  &
                                       tecplot_binary_write_section,   &
                                       binary_write_data,              &
                                       binary_file_close,              &
                                       binary_subarray_initialize

    implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

    logical :: bflag_dbg, bflag_bubout
    
    integer :: i, ic, ig, igsbub, ip, ivol, ivol_l, istart, iend, ix,  &
               iz, izn, tid, l_sufx, ivar, nvars, ierr
    real*8 :: delsa, delsa_delt, delsa_max, g_term, sanew_temp,        &
              sfactor, x_term, update_sa, partial_pressure, zout,      &
              sum_pressure, tot_press, aentry_loc

    logical:: relaxation, reduce_timestep_bub
    logical, allocatable :: sgsolve_failed(:)
    logical, allocatable :: sgsolved_temp(:)    
    
    character*3 :: suffix
    character*72, allocatable :: tec_variables(:)
    character*2048 :: strbuffer
    
    real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r3 = 3.0d0,           &
                         r365 = 3.65d2, r3_4 = 0.75d0, rhalf = 0.5d0,  &
                         r100 = 1.00d2
    real*8, external :: acoff, zoutput
    
    external :: checkerr

#ifdef PETSC
      integer(kind=MPI_OFFSET_KIND) :: offset_igsbub, offset_igsbub_temp
#else
      integer*8 :: offset_igsbub, offset_igsbub_temp
#endif

#ifdef PETSC
      DOUBLE PRECISION :: mpireduce_in(2), mpireduce_out(2)
      integer*4 :: mpireduce_irank
      logical :: sgsolved_gbl
      PetscErrorCode :: ierrcode
#endif
    
#ifdef OPENMP
    tid = omp_get_thread_num() + 1
#else
    tid = 1
#endif

    !c only included in the structured grid code, to be modified later for USG code
    if (bflag_bubout .and. b_enable_output .and. discretization_type == 0) then
      igsbub = lun_get()
    end if
    
    sgsolved = .false. 
#ifdef OPENMP
    allocate(sgsolved_temp(nthreads))
    sgsolved_temp = .false.
    
    allocate(sgsolve_failed(nthreads))
    sgsolve_failed = .false.
#else
    allocate(sgsolved_temp(1))
    sgsolved_temp = .false.

    allocate(sgsolve_failed(1))
    sgsolve_failed = .false.
#endif
    
    nvars = 6+4*ng
    
    if (bubble_out .and. b_enable_output .and. discretization_type == 0) then
        
      !rewind(icnv)           !Deprecated, use internal convert instead. DSU
      if (b_output_restart) then
        suffix = "r"
        l_sufx = 1
      else
        if (igstime.lt.10) then
          write(suffix,'(i1)') igstime
          l_sufx = 1
        elseif (igstime.ge.10.and.igstime.lt.100) then
          write(suffix,'(i2)') igstime
          l_sufx = 2
        elseif (igstime.ge.100.and.igstime.lt.1000) then
          write(suffix,'(i3)') igstime
          l_sufx = 3
        elseif (igstime.ge.1000) then
          if (rank == 0) then  
            write(ilog,'(/a)')'error in input file'
            write(ilog,'(a)')'max. number of output times exceeded'
            write(ilog,'(a)')'abnormal exit in routine outputrt'
            close(ilog)
#ifdef DEBUG
            write(idbg,'(/a)') 'error in input file'
            write(idbg,'(a)') 'max. number of output times exceeded'
            write(idbg,'(a)') 'abnormal exit in routine outputrt'
            close(idbg)
#endif
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      end if
     
      if (bflag_bubout .and. b_enable_output .and. discretization_type == 0) then
        if (b_output_binary) then
          if (b_output_mpiio_single) then
            strbuffer = prefix(:l_prfx)//'_'//suffix(:l_sufx)//'.bub'
          else
            strbuffer = prefix(:l_prfx)//'_'//                         &
                        suffix(:l_sufx)//trim(adjustl(str_rank))//'.bub'
          end if
          call binary_file_open(Petsc_Comm_World, igsbub,              &
                       trim(strbuffer),b_output_mpiio_single)
        else
          open(igsbub,file=prefix(:l_prfx)//'_'//                      &
                    suffix(:l_sufx)//trim(adjustl(str_rank))//'.bub',  &
                    status='unknown',form='formatted')
        end if
      
        !variables to be output
        allocate(tec_variables(nvars))
        tec_variables(1:6) = [character(len=72):: "x", "y", "z",       &
                              'hydro_press','sanew','sgnew']
        do ig=1,ng  
          tec_variables(2+ig*4+1) = 'aqueous_gas '//trim(nameg(ig))
          tec_variables(2+ig*4+2) = 'tot_gas '//trim(nameg(ig))
          tec_variables(2+ig*4+3) = 'cnew '//trim(nameg(ig))
          tec_variables(2+ig*4+4) = 'gnew '//trim(nameg(ig))
        end do
      
        !tecplot header
        if (b_writeversion_tecplot .and. .not. b_output_binary) then
          call writeversion2file(igsbub, "#")
        end if
          
        if (b_output_binary) then
          strbuffer = 'dataset '//prefix(:l_prfx) 
          offset_igsbub = 0
          call tecplot_binary_write_header(Petsc_Comm_World, igsbub,   &
                       "#!TDV102", trim(strbuffer), offset_igsbub,     &
                       b_output_mpiio_single,.false.)
        
          call tecplot_binary_write_variable(Petsc_Comm_World, igsbub, &
                       nvars, tec_variables(1:nvars), offset_igsbub,   &
                       b_output_mpiio_single,.false.)
        else        
          write(igsbub,'(3a)') 'title = "dataset ',prefix(:l_prfx),'"'
          write(igsbub,'(1000a)') 'variables = "x", "y", "z"',          &
                                 ', "hydro_press", "sanew", "sgnew"',  &
                       (', "',trim(tec_variables(ivar)),'"',           &
                        ivar=7,nvars)
        end if
      
        if (initial_condition) then

!c  zone record for initial condition
          if (b_output_binary) then
            strbuffer = 'T_j, initial'
            offset_igsbub_temp = offset_igsbub 
            
            if (b_output_multizone) then
              call tecplot_binary_write_zoneinfo(Petsc_Comm_World,     &
                           igsbub,trim(strbuffer),offset_igsbub,       &
                           itec,jtec,ktec,                             &
                           b_output_mpiio_single,.false.,              &
                           b_output_multizone)                         
              offset_igsbub = offset_igsbub_temp +                     &
                            (11+len_trim(strbuffer))*4*nprcs + 4       
            else                                                       
              call tecplot_binary_write_zoneinfo(Petsc_Comm_World,     &
                           igsbub,trim(strbuffer),offset_igsbub,       &
                           itec_gbl,jtec_gbl,ktec_gbl,                 &
                           b_output_mpiio_single,.false.,              &
                           b_output_multizone)                         
              offset_igsbub = offset_igsbub_temp +                     &
                            (12+len_trim(strbuffer))*4                 
            end if                                                     
          else                                                         
            write(igsbub,'(a,3(a,i5),a)')                              &
                  'zone t = "T_j, ',                                   &
                  'initial", i =',itec,', j =',jtec,', k =',           &
                  ktec,',  f=point'
          end if
          
        else
            
!c  zone record for current time step
          if (b_output_binary) then
            write(strbuffer,'(a,1pe15.6e3,1x,a)')                      &
                  'T_j, T = ', time_io,time_unit                         
            offset_igsbub_temp = offset_igsbub                            
                                                                         
            if (b_output_multizone) then                                 
              call tecplot_binary_write_zoneinfo(Petsc_Comm_World,     &
                           igsbub,trim(strbuffer),offset_igsbub,       &
                           itec, jtec, ktec,                           &
                           b_output_mpiio_single,.false.,              &
                           b_output_multizone)                         
              offset_igsbub = offset_igsbub_temp +                     &
                            (11+len_trim(strbuffer))*4*nprcs + 4       
            else                                                       
              call tecplot_binary_write_zoneinfo(Petsc_Comm_World,     &
                           igsbub, trim(strbuffer),offset_igsbub,      &
                           itec_gbl,jtec_gbl,ktec_gbl,                 &
                           b_output_mpiio_single,.false.,              &
                           b_output_multizone)                         
              offset_igsbub = offset_igsbub_temp +                     &
                            (12+len_trim(strbuffer))*4                 
            end if                                                     
          else                                                         
            write(igsbub,'(2a,1pe15.6e3,1x,a,3(a,i5),a)')              &
                 'zone t = "T_j, ',                                    &
                 'T = ',time_io,time_unit(:l_time_unit),               &
                 '", i =',itec,', j =',jtec,', k =',ktec,',  f=point'
          end if
          
        end if
      
        !write section information
        if (b_output_binary) then          
          offset_igsbub_temp = offset_igsbub         
          call tecplot_binary_write_section(Petsc_Comm_World,igsbub,   &
                       nvars,nn_offset,offset_igsbub,                  &
                       b_output_mpiio_single,.false.,b_output_multizone)
          allocate(realbuffer(nn*nvars), stat = ierr)
          realbuffer = 0.0d0
          call checkerr(ierr,'gasbub-realbuffer',ilog)
          call memory_monitor(sizeof(realbuffer),'gasbub-realbuffer',.true.)
        end if
        
      end if
    end if

!c loop over all nodes
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_gasbub_1)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(i, ivol, ic, ig, ip, istart, iend, ix, izn, tid,    &
    !$omp aqueous_gas, g_term, x_term, sum_pressure, tot_press,       &
    !$omp aentry_loc)
    !$omp do schedule(static)
#endif
    do ivol = 1,nngl
#ifdef OPENMP    
      tid = omp_get_thread_num()+1
#else
      tid = 1
#endif 

      if (sgsolve_failed(tid)) then
        cycle    
      end if
      
      do ic=1,nc
        gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),                &
                               sionnew(ivol),chargec(ic),              &
                               dhac(ic),dhbc(ic),dhad(tid),dhbd(tid),  &
                               adav,bdav,acth2omin,nc,                 &
                               nx,namec(ic),namec,ic,issit,asit,basit, &
                   coepsil,iasit,jasit)
      end do
         
!c initialize variables
      sum_pressure = r0
      tot_press = r0
      aqueous_gas = r0

!c check to see if control volume is saturated
!c_trap exclude volume if this is the first time step that it is saturated       
      izn = mpropvs(ivol)                   !material property zone

      if (soilhydrfunc_field) then
        aentry_loc = aentry_vol(ivol)
      else
        aentry_loc = aentry(izn)
      end if

      if ((uvsnew(ivol).ge.aentry_loc)                                &
               .and.(.not.unsaturated(ivol))) then    ! if saturated 

        do ig=1,ng
            
          call gasconc(cnew(1,ivol),gamma(1,ivol),gnew(ig,ivol),ig,    & 
                       tkel(ivol),tid)

          ip=gas_pair(ig)

!c get total aqueous component concentrations
          aqueous_gas(ig)=totcnew(ip,ivol)

!c calculate henry's law factor
!c calculate gas term
          g_term=eqg(ig,tid)
          istart = iaga(ig)
          iend = iaga(ig+1)-1
          do i = istart,iend
              ic = jaga(i)
              if (namec(ic).ne.namec(ip)) then
                g_term = g_term/((gamma(ic,ivol)*cnew(ic,ivol))**xnug(i))
              end if
          end do

!c calculate henry's law factor starting with component term

          k_henry(ig,ivol)=g_term/gamma(ip,ivol)

!c calculate species terms
            
            
          do ix = 1,nx
            if(gas_species(ig,ix))then
              x_term=g_term
              istart = iax(ix)
              iend = iax(ix+1)-1
              do i=istart,iend
                ic = jax(i)
                if (namec(ic).ne.namec(ip)) then
                  x_term = x_term*((gamma(ic,ivol)*cnew(ic,ivol))**xnux(i))
                else if(xnux(i).gt.1)then
                  if (rank == 0) then  
                    write(ilog,'(72a)')('-',iz=1,72)
                    write(ilog,*)'species',namex(ix)
                    write(ilog,'(a)')'cannot have stoichiometric'
                    write(ilog,'(a)')'coefficient greater than 1'
                    write(ilog,'(a)')'for species with gas component'
                    write(ilog,'(a)')'so long sucker'
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
                end if
              end do

!c add species term to henry's law factor
              k_henry(ig,ivol) = k_henry(ig,ivol) + x_term/eqx(ix,tid)/  &
                                 gamma(nc+ix,ivol)
            end if
          end do    
                
        
!c calculate total component concentration in aq. and gas phase

        
          tot_gas(ig,ivol) = sanew(ivol) * aqueous_gas(ig) +           &
                            (r1-sanew(ivol)) * gnew(ig,ivol)            

!c calculate total pressure based on tot_gas               

          sum_pressure = sum_pressure+tot_gas(ig,ivol)/k_henry(ig,ivol)
        
        end do


!c calculate hydrodynamic pressure 

        tot_press = pres_atm+uvsnew(ivol)*rho_w*gacc/pa_atm


!c if sum_pressure is greater than tot_press then a gas phase is present 
!c and calculate the volume of the gas phase

        if (sum_pressure.gt.tot_press) then            !if gas phase present

            call solvsg(ivol,tot_press,sgsolve_failed(tid))

            if (sgsolve_failed(tid)) then
              sgsolved_temp(tid)=.true.
            end if
        else
            sanew(ivol) = r1
        end if
                !if (sanew(ivol).gt.(r1-1.0d-06))then
                 !  sanew(ivol)=r1
        if (sanew(ivol).lt.swr(izn)) then
          sanew(ivol)=swr(izn)
        end if
        
        solvegb(ivol)=.true.

      end if                                !if saturated
      
    end do                                  !ivol
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

    if (any(sgsolved_temp .eqv. .true.)) then
      reduce_timestep = .true.
    end if

#ifdef PETSC  
    call MPI_Allreduce(reduce_timestep, reduce_timestep_bub,1,         &
                  MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
    CHKERRQ(ierrcode)
    reduce_timestep = reduce_timestep_bub
#endif

    if (reduce_timestep) then
      goto 999
    end if


    if (all(sgsolved_temp .eqv. .false.)) then
      sgsolved = .true.
    end if

#ifdef PETSC  
    call MPI_Allreduce(sgsolved, sgsolved_gbl,1,                       &
                  MPI_LOGICAL,MPI_LOR,Petsc_Comm_World,ierrcode)
    CHKERRQ(ierrcode)
    sgsolved = sgsolved_gbl
#endif

!c_relaxation scheme

    relaxation = .false.

    !if(.not.double_bubble) then

!c calculate maximum update in saturation    
 
    delsa_max = r0
#ifdef OPENMP
    maxval_omp = delsa_max      
#endif 

    if(relaxation) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_gasbub_2)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, ivol_max, izn, tid, delsa, delsa_max,         &
    !$omp aentry_loc)
    !$omp do schedule(static)
#endif
      do ivol = 1,nngl
#ifdef OPENMP    
        tid = omp_get_thread_num()+1
#else
        tid = 1
#endif 
!c check to see if control volume is saturated
!c_trap exclude volume if this is the first time step that it is saturated              
        izn = mpropvs(ivol)                   !material property zone

        if (soilhydrfunc_field) then
          aentry_loc = aentry_vol(ivol)
        else
          aentry_loc = aentry(izn)
        end if

        if ((uvsnew(ivol).ge.aentry_loc)                              &
             .and.(.not.unsaturated(ivol))) then    ! if saturated
          
          delsa = sanew(ivol) - sanew_c(ivol)
#ifdef OPENMP
          if (dabs(delsa).gt.dabs(maxval_omp(tid))) then
            maxval_omp(tid) = delsa
            maxvol_omp(tid) = ivol 
          end if
#else
          if (dabs(delsa).gt.dabs(delsa_max)) then
            delsa_max = delsa
            ivol_max = ivol
          end if
#endif
        end if            ! if saturated
      end do             ! do ivol
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef OPENMP
      i = maxloc(abs(maxval_omp), 1)
      delsa_max = maxval_omp(i)
      ivol_max = maxvol_omp(i)
#endif

#ifdef PETSC
      mpireduce_in(1) = dabs(delsa_max)      !returns the reduced value
      mpireduce_in(2) = rank                 !returns the rank of process that owns it
      call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,               &
                         MPI_2DOUBLE_PRECISION,MPI_MAXLOC,             &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      mpireduce_irank = int(mpireduce_out(2))
      call MPI_BCAST(delsa_max, 1, MPI_REAL8, mpireduce_irank,         &
                     Petsc_Comm_World, ierrcode)
      CHKERRQ(ierrcode)
      call MPI_BCAST(ivol_max, 1, MPI_INTEGER4, mpireduce_irank,       &
                     Petsc_Comm_World, ierrcode)
      CHKERRQ(ierrcode)
#endif
      
!c calculate updatefactor based on maximum change in saturation: as per cooley 1983

      if (ibub.eq.1) then 
        sfactor = r1
        if (dabs(delsa_max).ge.maxsg_update) then
          updatefactor = maxsg_update/dabs(delsa_max)
        else
          updatefactor = r1
        end if
      else if (dabs(delsa_max).gt.r0) then
        sfactor = delsa_max/updatefactor_old/delsa_maxold
      
        if (sfactor.ge.-r1) then
          updatefactor = (r3 + sfactor)/(r3 + dabs(sfactor))
        else
          updatefactor = r3_4/dabs(sfactor)
        end if
      end if
    end if  !relaxation

#ifdef DEBUG  
    if (b_enable_output .and. discretization_type == 0 .and.           &
        bflag_dbg .and. mtime.eq.2 .and. ibub.eq.r1) then     
        write(idbg,'(8a,8a,8a,15a,15a,15a,15a,15a,15a)')               &
          '    time','    ibub',' ivol_max', '    sanew_c    ',        &
          '     sanew     ',' updated_sanew','    delsamax   ',        &
          '    sfactor    ','  updatefactor '                           
    end if
#endif
                                                                        
    if (delsa_max.ne.r0) then                                         
      if(sanew(ivol_max).lt.sanew_c(ivol_max)) then                
        update_sa=sanew_c(ivol_max)-                                   &
        updatefactor*(dabs(sanew(ivol_max)-sanew_c(ivol_max)))     
      else                                                           
        update_sa=sanew_c(ivol_max)+                                   &
        updatefactor*(dabs(sanew(ivol_max)-sanew_c(ivol_max)))     
      end if                                                         
#ifdef DEBUG   
      if (b_enable_output .and. discretization_type == 0 .and. bflag_dbg) then
        write(idbg,'(i8,i8,i8)', ADVANCE='NO') mtime,ibub, ivol_max     
        write(idbg,ascii_fmt) sanew_c(ivol_max), sanew(ivol_max),    &
              update_sa, delsa_max, sfactor, updatefactor
      end if
#endif
    end if
     
!c update saturations using updatefactor of maximum update
    delsa_delt = dsadt_max*delt
    ivol_max = 1
    sanew_temp = r1
#ifdef OPENMP
    maxval_omp = delsa_max 
#endif 

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_gasbub_2)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, izn, tid, delsa, aentry_loc)
    !$omp do schedule(static)
#endif
    do ivol = 1,nngl
#ifdef OPENMP    
      tid = omp_get_thread_num()+1
#else
      tid = 1
#endif 

!c check to see if control volume is saturated
!c_trap exclude volume if this is the first time step that it is saturated 

      izn = mpropvs(ivol)                   !material property zone

      if (soilhydrfunc_field) then
        aentry_loc = aentry_vol(ivol)
      else
        aentry_loc = aentry(izn)
      end if

      if ((uvsnew(ivol).ge.aentry_loc).and.                           &
          (.not.unsaturated(ivol))) then    ! if saturated
          if (relaxation) then
            if(sanew(ivol).lt.sanew_c(ivol)) then
               sanew(ivol)=sanew_c(ivol)-                              &
                 updatefactor*(dabs(sanew(ivol)-sanew_c(ivol)))
            else
               sanew(ivol)=sanew_c(ivol)+                              &
                 updatefactor*(dabs(sanew(ivol)-sanew_c(ivol)))
            end if
          end if !relaxation

!c limit del Sa for very small timesteps
          !if (mtime.lt.r100) then
          delsa = dabs(sanew(ivol) - sanew_b(ivol))
#ifdef OPENMP
          if (dabs(delsa).gt.dabs(maxval_omp(tid))) then
             maxval_omp(tid) = delsa
             maxvol_omp(tid) = ivol  
          end if
#else
          if (dabs(delsa).gt.dabs(delsa_max)) then
             delsa_max = delsa
             ivol_max = ivol
             sanew_temp = sanew(ivol)
          end if
#endif

          if (delsa.gt.delsa_delt) then
             if (sanew(ivol).lt.sanew_b(ivol)) then
                 sanew(ivol) = sanew_b(ivol) - delsa_delt   
             else
                 sanew(ivol) = sanew_b(ivol) + delsa_delt
             end if
          end if    
      end if    ! if saturated
    end do       ! do ivol
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef OPENMP
    i = maxloc(abs(maxval_omp), 1)
    delsa_max = maxval_omp(i)
    ivol_max = maxvol_omp(i)
    sanew_temp = sanew(ivol_max)
#endif

#ifdef PETSC
    mpireduce_in(1) = dabs(delsa_max)      !returns the reduced value
    mpireduce_in(2) = rank                 !returns the rank of process that owns it
    call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,                 &
                       MPI_2DOUBLE_PRECISION,MPI_MAXLOC,               &
                       Petsc_Comm_World,ierrcode)
    CHKERRQ(ierrcode)
    mpireduce_irank = int(mpireduce_out(2))                            
    call MPI_BCAST(delsa_max, 1, MPI_REAL8, mpireduce_irank,           &
                   Petsc_Comm_World, ierrcode)
    CHKERRQ(ierrcode)
    call MPI_BCAST(ivol_max, 1, MPI_INTEGER4, mpireduce_irank,         &
                   Petsc_Comm_World, ierrcode)
    CHKERRQ(ierrcode)
    call MPI_BCAST(sanew_temp, 1, MPI_REAL8, mpireduce_irank,          &
                   Petsc_Comm_World, ierrcode)
    CHKERRQ(ierrcode)
#endif

#ifdef DEBUG
    if (b_enable_output .and. discretization_type == 0 .and. bflag_dbg) then
      write(idbg,'(i8,i8,i8)', ADVANCE='NO') mtime,ibub, ivol_max 
      write(idbg,ascii_fmt) sanew_b(ivol_max), sanew_c(ivol_max),  &
            sanew(ivol_max), sanew_temp, delsa_max, delsa_delt,            &
            dsadt_max, delt
      
    end if
#endif

    delsa_maxold = delsa_max
    updatefactor_old = updatefactor
    

!c calculate new component, species and gas concentrations based on new value of sa
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_gasbub_3)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(i, ic, ivol, izn, ip, istart, iend, tid,            &
    !$omp partial_pressure, aentry_loc)
    !$omp do schedule(static)
#endif
    do ivol = 1,nngl
#ifdef OPENMP    
      tid = omp_get_thread_num()+1
#else
      tid = 1
#endif 

!c check to see if control volume is saturated
!c_trap exclude volume if this is the first time step that it is saturated 
             
      izn = mpropvs(ivol)                   !material property zone

      if (soilhydrfunc_field) then
        aentry_loc = aentry_vol(ivol)
      else
        aentry_loc = aentry(izn)
      end if

      if ((uvsnew(ivol).ge.aentry_loc).and.                           &
          (.not.unsaturated(ivol))) then    ! if saturated            
          do ig=1,ng
              ip=gas_pair(ig)

              partial_pressure=tot_gas(ig,ivol)/                       &
                        (k_henry(ig,ivol)*sanew(ivol)+(r1-sanew(ivol))/&
                           rgasatm/tkel(ivol))   
              cnew(ip,ivol)=partial_pressure*eqg(ig,tid)/gamma(ip,ivol)

              istart = iaga(ig)
              iend = iaga(ig+1)-1
              do i = istart,iend
                  ic = jaga(i)
                  if (namec(ic).ne.namec(ip)) then
                      cnew(ip,ivol) = cnew(ip,ivol)  /                 &
                          ((gamma(ic,ivol)*cnew(ic,ivol))**xnug(i))
                  end if
              end do
          end do      ! do ig

          do ic=1,nc-1
            if (.not.update_component(ic)) then
              cnew(ic,ivol)=c_update(ic,ivol)*sanew_c(ivol)/sanew(ivol)
            end if
          end do
          sgnew(ivol)=r1-sanew(ivol)
      end if                                !if saturated
    end do                                  !ivol 
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
    
    !output 
    if (bflag_bubout .and. b_enable_output .and. discretization_type == 0) then
      ivol_l = 0  
      do ivol = 1,nngl   
!c  skip ghost nodes
#ifdef PETSC
        if(node_idx_lg2l(ivol) < 0) then
            cycle
        end if
#endif
        ivol_l = ivol_l + 1
        
!c  assign depth coordinate in terms of depth or elevation
        zout = zoutput(depth_output,zg(ivol),elevmax)
        
        if (b_output_binary) then
          realbuffer((ivol_l-1)*nvars+1:(ivol_l-1)*nvars+6) = (/       &
                     xg(ivol),yg(ivol),zout,tot_press,sanew(ivol),     &
                     r1-sanew(ivol)/)
          do ig = 1,ng
             i=gas_pair(ig) 
             realbuffer((ivol_l-1)*nvars+ig*4+3) = aqueous_gas(ig)
             realbuffer((ivol_l-1)*nvars+ig*4+4) = tot_gas(ig,ivol)
             realbuffer((ivol_l-1)*nvars+ig*4+5) = cnew(i,ivol)
             realbuffer((ivol_l-1)*nvars+ig*4+6) = gnew(ig,ivol) 
          end do 
        else        
          write(igsbub,ascii_fmt,ADVANCE='NO')                         &
                xg(ivol),yg(ivol),zout,tot_press,sanew(ivol),          &
                r1-sanew(ivol)
          do ig = 1,ng
            i=gas_pair(ig)
            if(ig < ng) then
              write(igsbub,ascii_fmt,ADVANCE='NO')                     &
                    aqueous_gas(ig),tot_gas(ig,ivol),cnew(i,ivol),     &
                    gnew(ig,ivol)
            else
              write(igsbub,ascii_fmt)                                  &
                    aqueous_gas(ig),tot_gas(ig,ivol),cnew(i,ivol),     &
                    gnew(ig,ivol)  
            end if
          end do 
          
        end if
      end do
      
      if (b_output_binary) then
        if (b_output_multizone .or. .not.b_output_mpiio_single) then
          call binary_write_data(igsbub, size(realbuffer,1),           &
                       realbuffer, offset_igsbub,b_output_mpiio_single) 
        else
          call binary_subarray_initialize(nvars,b_mpiarray_igsbub_init,&
                  .false.,mpiarray_filetype_igsbub,                    &
                  mpiarray_sizes_gbl_igsbub,mpiarray_sizes_sub_igsbub, &
                  mpiarray_starts_sub_igsbub)
          call binary_write_data(igsbub,size(realbuffer,1),realbuffer, &
                      offset_igsbub,mpiarray_filetype_igsbub)  
        end if
        call memory_monitor(-sizeof(realbuffer),'gasbub-realbuffer',.true.)
        deallocate(realbuffer)
      end if
      
      if (b_output_binary) then
        call binary_file_close(igsbub,b_output_mpiio_single)  
      else
        close(igsbub)
      end if
      
    end if
    
999 continue
    
    deallocate(sgsolve_failed)
    deallocate(sgsolved_temp)
    
    if (bflag_bubout .and. b_enable_output .and. discretization_type == 0) then
      call lun_free(igsbub)
    end if

    return
    end
