!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 609 $
!> $Author: dsu $
!> $Date: 2018-09-14 11:47:55 -0700 (Fri, 14 Sep 2018) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/fluxv_vl.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c real*8 function fluxv_vl
!c ------------------------
!c
!c compute advective mass flux
!c
!c written by:      Uli Mayer - August 15, 96
!c
!c last modified:   Uli Mayer - February 10, 98
!c                  - included van Leer flux limiter
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           totc_i             = total aqueous component             + -
!c                                concentration in control volume i
!c           totc_j             = total aqueous component             + -
!c                                concentration in control volume j
!c           cinfrt_v           = influence coeffcient for            + -
!c                                advective flux
!c           fluxv_vl           = advective flux                      * +
!c
!c           integer*4:
!c           ----------
!c           i                  = pointer to control volume i         + -
!c           j                  = pointer to control volume j         + -
!c           ic                 = pointer to current component        + -
!c
!c
!c gen.f:    real*8:
!c           -------
!c           totcnew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c
!c           integer*4:
!c           ----------
!c           i2up               = pointer to control volume i2up      + -
!c                                (second upstream point), 
!c                                i2up = 0 -> second upstream point 
!c                                does not exist
!c
!c           character:
!c           ----------
!c           spatial_weighting  = 'upstream' -> upstream weigthing    + -
!c                                'centered' -> centered weighting
!c                                'vanleer' -> Van Leer flux limiter
!c                                              (upstream-downstream)
!c                                'vanleer2' -> Van Leer flux limiter
!c                                              (upstream-centered)
!c
!c common:   -
!c
!c local:    real*8:
!c           -------
!c           eps              = constant
!c           r0               = constant
!c           r1               = constant
!c           r2               = constant
!c           rhalf            = constant
!c           rquarter         = constant
!c           theta_r_ij       = Van Leer flux limiter
!c           r_ij             = smoothness sensor for Van Leer flux
!c                              limiter
!c           totc_dwn         = total aqueous component concentration
!c                              at downstream control volume
!c           totc_ij          = total aqueous component concentration
!c                              at for flux computation at interface
!c           totc_ups         = total aqueous component concentration
!c                              at upstream control volume
!c
!c external: -  
!c ----------------------------------------------------------------------
 
    real*8 function fluxv_vl(totc_i,totc_j,i,j,cinfrt_v,ic)
 
      use parm
      use gen

      implicit none
      
      integer, intent(in) :: i, j, ic
      real*8, intent(in) :: totc_i, totc_j, cinfrt_v

      real*8, parameter :: r0 = 0.0d0, rquarter = 0.25d0,              &
                rhalf = 0.5d0, r1 = 1.0d0, r2 = 2.0d0, eps = 1.d-300,  &
                hugevalue = 1.0d200
      
      integer :: i2
      
      real*8 :: totc_ij, totc_ups, totc_dwn, totc_i2up, r_ij,          &
                theta_r_ij, delta_temp

      totc_ij = r0

!c  upstream weigthing 

      if (spatial_weighting.eq.'upstream') then

        if (cinfrt_v.gt.r0) then
          totc_ij = totc_i
        else
          totc_ij = totc_j
        end if

!c  centered weigthing 

      elseif (spatial_weighting.eq.'centered') then

        totc_ij = rhalf*(totc_i+totc_j)

!c  Van Leer flux limiter

      elseif (spatial_weighting.eq.'vanleer'.or.      &
             spatial_weighting.eq.'vanleer2') then

!c  define upstream and downstream point and retrieve pointer
!c  to second upstream point

        if (cinfrt_v.gt.r0) then
          totc_ups = totc_i
          totc_dwn = totc_j
          i2 = i2up(i)
        else
          totc_ups = totc_j
          totc_dwn = totc_i
          i2 = i2up(j)
        end if

!c  second upstream point exitsts 
!c  compute weighting term

        if (i2.ne.0) then

!c  define second upstream point

!cff       totc_i2up = totcnew(ic,i2)
          totc_i2up = totcold(ic,i2)

!c  second upstream node exists
!c  compute smoothness sensor r_ij
!c  fix bug of infinity value when divided by eps, use hugevalue instead. DSU,2014-11-13

          if (cinfrt_v.gt.r0) then
            delta_temp = totcold(ic,j) - totcold(ic,i)
            if (abs(delta_temp) < eps) then
              if (delta_temp  + eps > 0) then
                r_ij = (totcold(ic,i) - totc_i2up) * hugevalue
              else
                r_ij = -(totcold(ic,i) - totc_i2up) * hugevalue
              end if
            else
              r_ij = (totcold(ic,i) - totc_i2up)/           &
                    (totcold(ic,j) - totcold(ic,i) + eps)
            end if
          else
            delta_temp = totcold(ic,i) - totcold(ic,j)
            if (abs(delta_temp) < eps) then
              if (delta_temp  + eps > 0) then
                r_ij = (totcold(ic,j) - totc_i2up) * hugevalue
              else
                r_ij = -(totcold(ic,j) - totc_i2up) * hugevalue
              end if
            else
              r_ij = (totcold(ic,j) - totc_i2up)/           &
                    (totcold(ic,i) - totcold(ic,j) + eps)
            end if
          end if
!cff       if (cinfrt_v.gt.r0) then
!cff         r_ij = (totcnew(ic,i) - totc_i2up)/
!cff  &             (totcnew(ic,j) - totcnew(ic,i) + eps)
!cff       else
!cff         r_ij = (totcnew(ic,j) - totc_i2up)/
!cff  &             (totcnew(ic,i) - totcnew(ic,j) + eps)
!cff       end if

!c  compute Van Leer flux limiter theta_r_ij

          if (r_ij.gt.0) then
            theta_r_ij = r2 * r_ij/(r1 + r_ij)
          else
            theta_r_ij = r0
          end if

!c  second upstream point does not exist
!c  set weighting term to zero

        else

          theta_r_ij = r0

        end if

!c  compute total aqueous component concentration at interface

        if (spatial_weighting.eq.'vanleer') then
          totc_ij = totc_ups                                  &
                 + rhalf * theta_r_ij * (totc_dwn - totc_ups) 
        elseif (spatial_weighting.eq.'vanleer2') then
          totc_ij = totc_ups                                  &
                 + rquarter * theta_r_ij * (totc_dwn - totc_ups) 
        end if

      end if

!c  compute advective flux

      fluxv_vl = cinfrt_v * totc_ij
 
      return
    end function fluxv_vl
