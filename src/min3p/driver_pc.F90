!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/driver_pc.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ---------------------------------------------------------------------- 
!c                  M     M  I  N     N  333333  PPPPPP
!c                  MM   MM  I  NN    N       3  P    P
!c                  M M M M  I  N N   N       3  P    P
!c                  M  M  M  I  N  N  N    3333  PPPPPP
!c                  M     M  I  N   N N       3  P
!c                  M     M  I  N    NN       3  P
!c                  M     M  I  N     N  333333  P
!c
!c                            THCm Version 1.0
!c
!c                  A Numerical Model for the Analysis
!c                               of the
!c                        Geochemical Evolution
!c                                 of
!c                      Mineral-Water-Air Systems
!c
!c                          (c) 1997 U. Mayer
!c ---------------------------------------------------------------------- 
!c
!c Ulrich Mayer, University of Waterloo
!c basic version: September 1995
!c
!c last modified: November 09, 2012
!c
!c                Danyang Su    - Sept. 10, 2018
!c                Unstructured grid and HPC capabilities
!c
!c duplication of this program or any part thereof without
!c the express written consent of the author is prohibited.
!c
!c ----------------------------------------------------------------------
!c driver code - MIN3P
!c ---------------------
!c
!c Features:
!c ---------
!c variably saturated density dependent flow and/or 
!c reactive transport or batch systems with kinetically 
!c controlled disssolution-precipitation reactions 
!c
!c variably saturated flow:
!c ------------------------
!c optional density dependent flow simulation
!c steady state and transient simulations
!c fully saturated and variably saturated
!c fully implicit time-stepping
!c FVM assembly for scalar conservation law
!c Newton-linearization for variably saturated conditions
!c
!c reactive transport: 
!c -------------------
!c fully implicit time stepping
!c FVM assembly for vector conservation law for n components
!c Newton linearization
!c
!c geochemistry module:
!c --------------------
!c equilibrium reactions for complexation, redox and phase partitioning
!c kinetically controlled dissolution-precipitation reactions
!c for surface and transport controlled reactions
!c geochemical system defined by means of database files for:
!c - components
!c - secondary aqueous species  
!c - minerals
!c - gases
!c activity coefficients: extended Debye Huckel equation and/or Davies
!c                        equation
!c multicomponent diffusion
!c ----------------------------------------------------------------------
!c parameter definitions:
!c ----------------------
!c see parm.f   
!c
!c ----------------------------------------------------------------------
!c variables definitions: 
!c ----------------------
!c general variables:   'gen.f'
!c physical variables:  'phys.f'
!c chemical variables:  'chem.f'
!c density variables:   'dens.f' 
!c
!c variables used in a specific routine are defined therein,
!c
!c ----------------------------------------------------------------------
!c common:
!c gen.f:    real*8:
!c           -------
!c           area(nm,nn)        = mineral reactivity term
!c                                (global system)
!c           cnew(nc,nn)        = concentrations of free species
!c                                - new time level [moles/l water]
!c           cec_g(nn)          = cation exchange capacity (meq/100g)
!c                                - global system
!c           gnew(ng,nn)        = gas concentrations
!c                                - new time level [moles/l air]
!c           cmnew(nm,nn)       = mineral concentrations
!c                                - new time level [moles/l bulk]
!c           cx(nx,nn)          = concentrations of secondary aqueous
!c                                species [moles/l water]
!c           gamma(nc+nx,nn)    = activity coefficients for aqueous
!c                                species
!c           delt               = time step
!c           distcoff_rt(nc,nn) = sorption distribution coefficient
!c                                [-], [l bulk/l bulk]
!c                                - reactive transport
!c           gs_tout(ngs)       = specified output times for
!c                                contour data
!c           hhead(nn)          = hydraulic head
!c           phi(nm,nn)         = volume fractions of minerals
!c           phiold(nm,nn)      = volume fractions of minerals
!c                                - old time level
!c           pornew(nn)         = porosity  
!c           sanew(nn)          = aqueous phase saturation 
!c                                (new time level)
!c           sionnew(nn)        = ionic strength of solution
!c                                - new time level
!c           uvsnew(nn)         = solution vector (new time level)
!c           uvsold(nn)         = solution vector (old time level)
!c           tkel(nn)           = nodal temperatures in Kelvin
!c           time_io            = current solution time (I/O units)
!c           totcnew(n,nn)      = total aqueous component
!c                                concentrations
!c                                - new time level [moles/l water]
!c           zg(nn)             = spatial coordinates in z-direction
!c
!c           integer*4:
!c           ----------
!c           igen               = unit number, generic output file
!c           ilog               = unit number, logbook
!c           igbb               = unit number, concentrations of
!c                                             sorbed species
!c                                             - transient data
!c                                               global system
!c           igbt               = unit number, total aqueous
!c                                             component
!c                                             concentrations
!c                                             - transient data
!c                                               global system
!c           igbc               = unit number, species
!c                                             concentrations
!c                                             - transient data
!c                                               global system
!c           igbac              = unit number, activity coefficient
!c                                              - transient data
!c                                                global system
!c           igbd               = unit number, dissolution-
!c                                             precipitation
!c                                             rates
!c                                             - transient data
!c                                               global system
!c           igbg               = unit number, gas concentrations
!c                                             - transient data
!c                                               global system
!c           igbgr              = unit number, degassing rates
!c                                             - transient data
!c                                               global system
!c           igbm               = unit number, master variables
!c                                             - transient data
!c                                               global system
!c           igbi               = unit number, rates of intra-aqueous
!c                                             kinetic reactions
!c                                             - transient data
!c                                               global system
!c           igbs               = unit number, saturation indices
!c                                             - transient data
!c                                               global system
!c           igbv               = unit number, mineral volume
!c                                             fractions
!c                                             - transient data
!c                                               global system
!c           igbx               = unit number, saturation indices
!c                                             (excluded minerals)
!c                                             - transient data
!c                                               global system
!c           igstime            = pointer to next output time for
!c                                contour data
!c           itseep_tot         = total number of seepage face
!c                                iterations
!c           itsolvtot_vs       = total number of solver
!c                                iterations
!c                                (variably saturated flow)
!c           ittot_vs           = total number of iterations
!c                                (variably saturated flow)
!c           l_prfx             = length of prefix of I/O files
!c           l_zone_name        = length of zone name
!c           n                  = number of components excluding h2o
!c                                equals number of unknowns per
!c                                control volume
!c           ngb                = number of output locations for
!c                                transient data
!c           ngb_vol(ngb)       = control volume numbers for output
!c                                of transient data
!c           nn                 = total number of control volumes
!c         pos        = position of the last '/' of the directory path string, CBF RLD
!c
!c
!c           logical:
!c           --------
!c           analyt_deriv_rt    = .true.  -> form derivatives
!c                                           analytically
!c           gb_output          = .true.  -> output of transient data
!c           gs_output          = .true.  -> output of contour data
!c           geo_chemistry      = .true.  -> local or background and
!c                                           source chemistry
!c           initial_condition  = .true.  -> output of initial
!c                                           condition for contour
!c                                           data
!c                                .false. -> output of contour data
!c                                           for steady state or
!c                                           transient solutions
!c           mass_balance_vs    = .true.  -> compute mass balance
!c                                           (variably_saturated
!c                                            flow)
!c           mass_balance_rt    = .true.  -> compute mass balance
!c                                           (reactive tramsport)
!c           reactive_transport = .true.  -> perform reactice
!c                                           transport simulation
!c           redox_equil_rt     = .true.  -> equilibrium redox
!c                                           reactions
!c           show_module        = .true.  -> write current module
!c                                           name to screen
!c           steady_flow        = .true.  -> steady state flow
!c           tec_header         = .true.  -> write header for tecplot
!c                                           postprocessing to output
!c                                           files
!c                                .false. -> skip headers
!c           transient_flow     = .true.  -> .not.steady_flow,
!c                                        -> transient flow
!c           update_porosity    = .true.  -> update porosity as
!c                                           a result of dissolution-
!c                                           precipitation reactions
!c           varsat_flow        = .true.  -> perform flow simulation
!c
!c           character:
!c           ----------
!c           prefix             = prefix name for all I/O files
!c           zone_name          = name of zone
!c
!c chem.f:   integer*4:
!c           ----------
!c           nx                 = number of secondary aqueous species
!c           nm                 = number of minerals
!c
!c           logical:
!c           --------
!c           finite_minerals    = .true.  -> finite minerals 
!c
!c dens.f:   real*8:
!c           -------
!c           pressure(nn)       = fluid pressure
!c           density(nn)        = fluid density         
!c           viscosity(nn)      = fluid viscosity
!c           dcoef(ncon-1)      = coefficient including density,
!c                                viscosity, and relative 
!c                                permeability
!c           ref_dens           = reference density to convert 
!c                                from freshwater heads to pressures
!c           logical:
!c           --------
!c           density_dependence = .true.  -> simulate density 
!c                                           dependent flow
!c           fluid_pressure     = .true.  -> initial and boundary
!c                                           conditions in terms 
!c                                           of fluid pressure 
!c           fresh_head         = .true.  -> initial and boundary
!c                                           conditions in terms 
!c                                           of freshwater head 
!c           init_perm          = .true. -> initial media properties
!c                                           in permeability units
!c           init_cond          = .true. -> initial media properties
!c                                           in hydraulic conductivity
!c                                           units    
!c
!c biol.F90: 
!c         real*8:
!c         -------
!c         rld(nn)                = root length density used to compute qroot ! CBF RLD
!c
!c         logical:
!c           --------
!c           coupled_as         = .true. -> update root length density by coupling with ArchiSimple software ! CBF RLD
!c           coupled_rt         = .true. -> update root length density by coupling with RootTyp software ! CBF RLD
!c
!c    
!c root_modu.F90: 
!c         real:
!c         -----
!c         RSD_coupled(nn)        = RLD array passed during coupling and assigned to rld(nn) ! CBF RLD
!c
!c         subroutine for coupling interface:
!c         ----------------------------------
!c         END_ARCHI            = ArchiSimple root architecture program finalization ! CBF RLD
!c         END_ROOTTYP        = Root Typ root architecture program finalization ! CBF RLD
!c
!c   
!c local:    integer*4:
!c           ----------
!c           igb                = counter
!c           ivol               = counter
!c
!c external: welcome  = welcome the user and read problem 
!c                      prefix name
!c           opngfls  = open general problem specific files
!c           initcpgs = control parameters for global system
!c           constnts = assign constants for global use
!c           initprob = initialize variably saturated flow 
!c                      and/or reactive transport simulation 
!c                      or perform batch simulation
!c           batreac  = driver subroutine for local chemistry
!c           opnpgfls = open files for postprocessing 
!c                      (global system)
!c           outputvs = write contour data for variably saturated 
!c                      flow simulation to output file
!c           outputdd = write contour data for variably saturated 
!c                      density dependent flow simulation to 
!c                      output file
!c           outputrt = write contour data of reactive transport 
!c                      simulation to output file
!c           tprfrtlc = write transient data to output file
!c                      (reactive transport)
!c           msysrt   = compute total system mass 
!c                      (reactive transport)
!c           msysvs   = compute total system mass 
!c                      (variably saturated flow)
!c           msysdd   = compute total system mass 
!c                      (variably saturated density dependent flow)
!c           setsize  = define number of primary unknowns
!c           stedflow = driver subroutine for steady state 
!c                      variably saturated flow 
!c           timeloop = driver subroutine for transient flow 
!c                      and/or eactive transport
!c           tranunit = assign unit numbers for output of transient 
!c                      data
!c           clsgfls  = close I/O files (global system)
!c ----------------------------------------------------------------------

Program driver_pc

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use chem
      use dens
      use mip_bubble, only : mip_mt_enable
      use mip_output, only : mip_output_spatial
      use root_output, only : root_output_spatial
      use serveParams
      use nobleGasIngrowth, only : b_use_ngi, ngre_i, conc_ngre,       &
                                   conc_ngre_loc
      use biol
#ifdef ARCHISIMPLE
      use, intrinsic :: ISO_C_BINDING
      use root_modu
#endif

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_initialize,               &
                                   petsc_mpi_finalize
#endif

#ifdef OPENMP
      use omp_lib 
#endif

#ifdef PETSC
     use solver_dd, only : solver_dd_snes_create_flow_heat,            &
                           solver_dd_snes_create_react,                &
                           solver_dd_release_flow,                     &
                           solver_dd_release_heat,                     &
                           solver_dd_release_react
#endif

#ifdef LIS
     use solver_lis, only : solver_lis_initialize,                     &
                            solver_lis_finalize,                       &
                            solver_lis_create_flow,                    &
                            solver_lis_create_heat,                    &
                            solver_lis_create_react,                   &
                            solver_lis_release_flow,                   &
                            solver_lis_release_heat,                   &
                            solver_lis_release_react
#endif

      use solver, only : initsolver, mem_solver, releasesolver
      use solver_runtime, only : openruntimefile, closeruntimefile
      use writeversion, only : initwriteversion

#ifdef CGAL
      !c the following codes are for cgal library test only, by DSU, 2015-11-18
      use cgal_polygon_iface
      use cgal_triangulation_2d_iface
      use cgal_triangulation_3d_iface
      use cgal_make_mesh_2d_iface
      use cgal_make_mesh_3d_iface
      use cgal_make_mesh_3d_polyhedra_iface
      use gms_mesh_domain
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      integer :: i, ivol, igb, ierrcode, tid, itz
      logical :: bflag
      
      external welcome, opngfls, initcpgs, constnts, initprob,    &
              opnpgfls, outputvs, outputdd, outputrt, tprfrtlc,   &
              msysrt, msysvs, msysdd, stedflow, timeloop,         &
              tranunit, clsgfls, initcpice, outputmech
#ifdef USG
      external outputvs_usg, outputdd_usg, outputice_usg, outputmech_usg
#endif

!c  initialize MPI parallel environment  
#ifdef PETSC
      call petsc_mpi_initialize(rank, nprcs)
      
      !If run with threadcomm, use the number of threads from '-threadcomm_nthreads'

      call PetscOptionsGetInt(                                         &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                          PETSC_NULL_OPTIONS,PETSC_NULL_CHARACTER,     &
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR == 7)
                          PETSC_NULL_OBJECT,PETSC_NULL_CHARACTER,      &
#else
                          PETSC_NULL_CHARACTER,                        &
#endif
                          '-threadcomm_nthreads',nthreads_per_proc,    &
                          bflag,ierrcode)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
      CHKERRA(ierrcode)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 8)
      CHKERRQ(ierrcode)
#endif

      
      !If run without threadcomm, use the number of threads from '-mpicomm_nthreads'
      if (.not. bflag) then

        call PetscOptionsGetInt(                                       &
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
                            PETSC_NULL_OPTIONS,PETSC_NULL_CHARACTER,   &
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR == 7)
                            PETSC_NULL_OBJECT,PETSC_NULL_CHARACTER,    &
#else
                            PETSC_NULL_CHARACTER,                      &
#endif
                            '-mpicomm_nthreads',nthreads_per_proc,     &
                            bflag,ierrcode)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
        CHKERRA(ierrcode)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 8)
        CHKERRQ(ierrcode)
#endif

      end if
      
      if (.not. bflag) then
        nthreads_per_proc = 1 
      else
        if (nthreads_per_proc <1) then
          if (rank == 0) then
            write(*,*) "Error: number of threads < 1"
          end if
          call petsc_mpi_finalize  
          stop
        end if
      end if

      call PetscMemorySetGetMaximumUsage(ierrcode)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
      CHKERRA(ierrcode)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 8)
      CHKERRQ(ierrcode)
#endif
#else
      rank = 0
      nprcs = 1
      nthreads_per_proc = 1
      Petsc_Comm_World = 0
      Petsc_Comm_Self = 0
#endif

#ifdef MEMORY_MONITOR
      mem_cur = 0
      mem_max = 0
      mem_cur_tot = 0
      mem_max_tot = 0
#ifdef PETSC
      mem_petsc_cur = 0
      mem_petsc_max = 0
      mem_petsc_cur_tot = 0
      mem_petsc_max_tot = 0
#endif
#endif

#ifdef LIS
      call solver_lis_initialize
#endif

!#ifdef OPENMP
!      call omp_set_dynamic(.true.)
!#endif

#ifdef PETSC
      if(nprcs > 1) then
          write(str_rank,'(A,I0)')"_rank_", rank 
      else
          str_rank = ""
      end if
#else
      str_rank = ""
#endif

#ifdef CGAL
      !c the following codes are for cgal library test only, by DSU, 2015-11-18

      !write(*,*) "Start testing cgal_polygon library"
      !call cgal_is_polygon_simple_test
      !call cgal_check_inside_test
      !write(*,*) "Finish testing cgal_polygon library"
      !write(*,*)

      !write(*,*) "Start testing cgal_triangulation_2d library"
      !call cgal_triangulation_test_2d
      !write(*,*) "Finish testing cgal_triangulation_2d library"

      !
      !write(*,*) "Start testing cgal_triangulation 3d library"
      !call cgal_triangulation_test
      !write(*,*) "Finish testing cgal_triangulation 3d library"
      !write(*,*)
      !
      !write(*,*) "Start testing cgal_make_mesh_2d_test"
      !call cgal_make_mesh_2d_test
      !write(*,*) "Finish testing cgal_make_mesh_2d_test"
      !write(*,*)
      !
      !write(*,*) "Start testing cgal_make_mesh_3d_test"
      !call cgal_make_mesh_3d_test
      !write(*,*) "Finish testing cgal_make_mesh_3d_test"
      !write(*,*)
      !
      !write(*,*) "Start testing cgal_make_mesh_3d_polyhedra_test"
      !call cgal_make_mesh_3d_polyhedra_test
      !write(*,*) "Finish testing cgal_make_mesh_3d_polyhedra_test"
      !write(*,*)


      !write(*,*) "Start testing gms_mesh_domain"
      !call gms_mesh_test
      !write(*,*) "Finish testing gms_mesh_domain"

      !goto 1000
#endif

!c  hardwired logical variables

      show_module = .true.
!!cprovi-------------------------------------------------
!!cprovi We can swith the option of analytic and numerical
!!cprovi derivatives 
!!cprovi-------------------------------------------------
      analyt_deriv_rt = .false.
!!cprovi-------------------------------------------------

!c  welcome the user and read problem read prefix name
      call welcome

!c  initialize code version and builder information
      call initwriteversion

!c  open problem specific input file, generic output file
!c  and scratch file for temporary data storage
      call opngfls
      
!c  initialize global control parameters
      call initcpgs
      
!c  define constants for global use
      call constnts
     
!c  initialize solver
      call initsolver(str_solvercfg) 
      call mem_solver

#ifdef OPENMP
      !set this will affect all the openmp parallel code without num_threads(n)
      call omp_set_num_threads(numofthreads_global)
      if (len_trim(str_solvercfg) == 0 .and. numofthreads_global > 0) then
        if (rank == 0 .and. b_enable_output) then
          write(*,'(a,1x,i0,1x,a)') 'Default OpenMP configuration with',   &
                                    numofthreads_global,'threads'
          write(ilog,'(a,1x,i0,1x,a)') 'Default OpenMP configuration with',&
                                    numofthreads_global,'threads'
        end if
      end if
#endif
     
!c  open runtime file
      if(rank == 0 .and. b_prtfile) then      !if MPI rank 0
        call openruntimefile
      end if                  !end if MPI rank 0

!c CBF RLD: Find the exact length of the IN/out directory path to transfer it 
!c CBF RLD: during coupling to ArchiSimple / Root Typ software
!c DSU: the backward slash "\" has been replace with forward slash "/" when prefix is read.
      pos=scan(trim(prefix),"/",BACK=.true.)
     
!c  initialize variably saturated flow and/or reactive transport simulation 
!c  or initialize equilibrium or reaction path simulation
!c  Parallelized, OpenMP, MPI
      call initprob
      
!c  initialize iteration parameters
      ittot_glob = 0 
      ittot_vs  = 0
      ittot_rt  = 0
      itsolvtot_vs = 0
      iter_seep = 0
      itseep_tot = 0

!c  initialize component-mineral recycle parameters
      call serveParams_rcm_uptake

!c  initialize rate coefficient for intermittent reaction of minerals. 
      call serveParams_irm      

!c  equilibrium or reaction path simulation
!c  parallelized, OpenMP, DSU
      if (.not.reactive_transport.and.geo_chemistry) then
        call batreac
      end if

!c  reset problem size for reaction-transport problem
      if (reactive_transport) then
        call setsize(redox_equil_rt)
        if (nm.gt.0) then
          finite_minerals = .true.
        end if
      end if

!c  open files for postprocessing
      if (varsat_flow.or.reactive_transport) then
        call opnpgfls
      end if

!c  write initial contour data to output file
!c  and define next output time
      if (varsat_flow.or.reactive_transport) then
        initial_condition = .true.
        igstime = 0
        if (gs_output) then
          if(b_enable_output) then
            if(discretization_type == 0) then
              if (varsat_flow) then
                if (density_dependence) then
                  call outputdd
                else
                  call outputvs
                end if  !densit_dependence
                if (root_uptake) then
                  call root_output_spatial 
                end if
              end if    !varsat_flow
              if (compute_ice_sheet_loading) then
                call outputmech
              end if
              if (reactive_transport) then
                call outputrt
                if (mip_mt_enable) then
                  call mip_output_spatial  
                end if
              end if
#ifdef USG
            else
              if (varsat_flow) then
                if (density_dependence) then
                  call outputdd_usg
                else
                  call outputvs_usg
                end if  !densit_dependence
                if (compute_ice_sheet_loading) then
                  call outputmech_usg
                end if
                if (compute_ice_sheet_loading .and. ice_sheet_type == 1) then
                  call outputice_usg
                end if
              end if    !varsat_flow
              if (reactive_transport) then
                call outputrt_usg
              end if
#endif
            end if
          end if
          igstime = 1
          initial_condition = .false.
        end if
      end if

!c  write initial condition of transient data to output file
      if (reactive_transport) then
        if (gb_output .and. b_enable_output) then
          do igb = 1,ngb

#ifdef OPENMP    
            tid = omp_get_thread_num() + 1
#else
            tid = 1
#endif

!c  assign unit numbers for output of transient data

            call tranunit(igb)
!cprovi----------------------------------------------------------------------
!cprovi The point of activity coefficients corresponding to aqueous 
!cprovi complexes was corrected. 
!cprovi Now is nc+1
!cprovi----------------------------------------------------------------------
            ivol = ngb_vol(igb)
!cdsu  When domain docomposition is used, the output transient data is 
!cdsu  distributed into different sub-domain. ivol = -1 indicates that 
!cdsu  this transient data (igb) is not in the current sub-domain.
            if (ivol > 0) then

              if (b_output_trans_binary) then                    
                igbt  = igbt_mpi(igb)
                igbc  = igbc_mpi(igb)
                igbm  = igbm_mpi(igb)
                igbgr = igbgr_mpi(igb)
                igbg  = igbg_mpi(igb)
                igbi  = igbi_mpi(igb)
                igbb  = igbb_mpi(igb)
                igbs  = igbs_mpi(igb)
                igbv  = igbv_mpi(igb)
                igbd  = igbd_mpi(igb)
                igbx  = igbx_mpi(igb)
                igbis = igbis_mpi(igb)
                igbac = igbac_mpi(igb)
!cdsu concentration of radioelement related to noble gas ingrowth
                if (b_use_ngi .and. ngre_i > 0) then
                  igbre  = igbre_mpi(igb)
                end if
              end if 

!cdsu concentration of radioelement related to noble gas ingrowth
              if (b_use_ngi .and. ngre_i > 0) then
                conc_ngre_loc(:) = conc_ngre(:,ivol)
              end if

              call tprfrtlc(totcnew(1,ivol),cnew(1,ivol),cx(1,ivol),  &
                         gamma(1,ivol),gamma(nc+1,ivol),cmnew(1,ivol),&
                         gnew(1,ivol),cec_g(ivol),distcoff_rt(1,ivol),&
                         area(1,ivol),phi(1,ivol),phiold(1,ivol),     &
                         sionnew(ivol),tkel(ivol),                    &
                         hhead(ivol),xg(ivol),yg(ivol),zg(ivol),      &
                         time_io,delt,sanew(ivol),                    &
                         pornew(ivol),igbt,igbc,igbm,igbg,igbgr,igbi, &
                         igbb,igbs,igbv,igbd,igbx,igbis,igbac,igbre,  &
                         offset_igbt(igb),offset_igbc(igb),           &
                         offset_igbm(igb),offset_igbg(igb),           &
                         offset_igbgr(igb),offset_igbi(igb),          &
                         offset_igbb(igb),offset_igbs(igb),           &
                         offset_igbv(igb),offset_igbd(igb),           &
                         offset_igbx(igb),offset_igbis(igb),          &
                         offset_igbac(igb),offset_igbre(igb),         &
                         offset_igbt_ijk(igb),offset_igbc_ijk(igb),   &
                         offset_igbm_ijk(igb),offset_igbg_ijk(igb),   &
                         offset_igbgr_ijk(igb),offset_igbi_ijk(igb),  &
                         offset_igbb_ijk(igb),offset_igbs_ijk(igb),   &
                         offset_igbv_ijk(igb),offset_igbd_ijk(igb),   &
                         offset_igbx_ijk(igb),offset_igbis_ijk(igb),  &
                         offset_igbac_ijk(igb),offset_igbre_ijk(igb), &
                         prefix,l_prfx,tec_header,                    &
                         ivol,tid,0,1,zone_name,l_zone_name,          &
                         update_porosity,mtime,i_append_sim,          &
                         mtime_append)
            end if
          end do
        end if
      end if

      if (i_solver_type_flow == 2) then
        !> create petsc solver space for flow problem
#ifdef PETSC
        if(varsat_flow) then
          call solver_dd_snes_create_flow_heat(.true.)
        end if
        if (heat_transport .and. decoupled_type_vs_heat > 1) then
          call solver_dd_snes_create_flow_heat(.false.)
        end if
#endif
      else if (i_solver_type_flow == 3 .or. b_solver_test_lis) then
        !> create LIS solver space for flow problem
#ifdef LIS
        if (varsat_flow) then
          call solver_lis_create_flow
        end if
        if (heat_transport .and. decoupled_type_vs_heat > 1) then
          call solver_lis_create_heat
        end if
#endif
      end if

      if (i_solver_type_react == 2) then
        !> create petsc solver space for reactive transport problem
#ifdef PETSC
        if (reactive_transport) then
          call solver_dd_snes_create_react
        end if
#endif
      else if (i_solver_type_react == 3 .or. b_solver_test_lis) then
        !> create LIS solver space for reactive transport problem
#ifdef LIS
        if (reactive_transport) then
          call solver_lis_create_react
        end if
#endif
      end if

      if (varsat_flow) then
!c  initialize iteration parameters for variably saturated flow

!c  steady state flow
!c  Parallelized, OpenMP, DSU 
        if (steady_flow) then
          call stedflow
        end if

      end if
      
!c  compute initial system mass - variably saturated flow
!c  transient conditions
!c  Parallelized, OpenMP, DSU
      if (varsat_flow.and.transient_flow.and.mass_balance_vs) then
        if (density_dependence) then
          call msysdd
        else
          call msysvs
        end if      
      end if
      
!c  compute initial system energy
!c  transient conditions
!c  Parallelized, OpenMP, DSU
      if (heat_transport.and.transient_flow.and.energy_balance) then
         call energysys 
      end if  
      
!c  compute initial system mass - reactive transport
!c  Parallelized, OpenMP, DSU
      if (mass_balance_rt) then
        call msysrt
      end if
     
!c  transient simulation for variably saturated flow and 
!c  reactive transport
!c  Parallelized, OpenMP, DSU     
      if ((varsat_flow.and.transient_flow).or.reactive_transport) then
        call timeloop
      end if
      
#ifdef ARCHISIMPLE
!c  End ArchiSimple software if RLD are updated by coupling ! CBF RLD
!c  DSU: Move this part before mpi_finialize, otherwise, the variables in the slave processors will not be released.
      if (root_uptake .and. coupled_as) then
        call END_ARCHI()
        call memory_monitor(-sizeof(RSD_coupled),'RSD_coupled',.true.)
        call memory_monitor(-sizeof(rld),'rld',.true.)
        deallocate(RSD_coupled)
        deallocate(rld)
        if (rank == 0 .and. b_enable_output) then
          write(*,*) ' ------------------------------------------------------------------------- '
          write(*,*) 'ArchiSimple (c) 2014, L. Pages, INRA, Apache License, Version 2.0'
          write(*,*) 'ArchiSimple is registered at the french Agence de Protection des Programmes'
          write(*,*) 'For more informations and citation, please refer to Pages et al., 2014 :  '
          write(*,*) 'Calibration and evaluation of ArchiSimple, a simple model of root system '
          write(*,*) 'architecture. Ecol. Model. 290:76-84'
          write(*,*) ' ------------------------------------------------------------------------- '
        end if
      endif

!c  End RootTyp software if RLD are updated by coupling ! CBF RLD
      if (root_uptake .and. coupled_rt) then
        call END_ROOTTYP()
        call memory_monitor(-sizeof(RSD_coupled),'RSD_coupled',.true.)
        call memory_monitor(-sizeof(rld),'rld',.true.)
        deallocate(RSD_coupled)
        deallocate(rld)
        if (rank == 0 .and. b_enable_output) then
          write(*,*) ' ------------------------------------------------------------------------- '
          write(*,*) 'Root Typ (c) 2004, L. Pages, INRA, Apache License, Version 2.0'
          write(*,*) 'For more informations and citation, please refer to Pages et al., 2004 :'
          write(*,*) 'Root Typ : a generic model to depict and analyse the root system architecture.'
          write(*,*) 'Plant and Soil. 258:103-119'
          write(*,*) ' ------------------------------------------------------------------------- '
        end if
      endif
#endif

!c  memory usage
#ifdef MEMORY_MONITOR
      if (rank == 0) then
        write(ilog,'(a)') "statistics - memory consumption ..."
        write(ilog,'(72a)') ('-',i=1,72)
        write(ilog,'(a,f10.2,1x,a)')                                   &
              "current memory consumption (rank 0)     = ",            &
              (mem_cur/1.0d6),"MB"
        write(ilog,'(a,f10.2,1x,a)')                                   &
              "maximum memory consumption (rank 0)     = ",            &
              (mem_max/1.0d6),"MB"
      end if
#ifdef PETSC
      call PetscMemoryGetCurrentUsage(mem_petsc_cur,ierrcode)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
      CHKERRA(ierrcode)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 8)
      CHKERRQ(ierrcode)
#endif

      call PetscMemoryGetMaximumUsage(mem_petsc_max,ierrcode)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
      CHKERRA(ierrcode)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 8)
      CHKERRQ(ierrcode)
#endif

      !c collective memory usage for all processors
      call MPI_Allreduce(mem_cur, mem_cur_tot,1,MPI_INTEGER8,MPI_SUM,  &
                         Petsc_Comm_World,ierrcode)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
      CHKERRA(ierrcode)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 8)
      CHKERRQ(ierrcode)
#endif

      call MPI_Allreduce(mem_max, mem_max_tot,1,MPI_INTEGER8,MPI_SUM,  &
                         Petsc_Comm_World,ierrcode)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
      CHKERRA(ierrcode)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 8)
      CHKERRQ(ierrcode)
#endif

      call MPI_Allreduce(mem_petsc_cur, mem_petsc_cur_tot,1,           &
                         MPI_REAL8,MPI_SUM,                            &
                         Petsc_Comm_World,ierrcode)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
      CHKERRA(ierrcode)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 8)
      CHKERRQ(ierrcode)
#endif

      call MPI_Allreduce(mem_petsc_max, mem_petsc_max_tot,1,           &
                         MPI_REAL8,MPI_SUM,                            &
                         Petsc_Comm_World,ierrcode)
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
      CHKERRA(ierrcode)
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 8)
      CHKERRQ(ierrcode)
#endif

      if (rank == 0) then

        write(ilog,'(a,f10.2,1x,a)')                                   &
              "current memory consumption in total     = ",            &
              (mem_cur_tot/1.0d6),"MB"
        write(ilog,'(a,f10.2,1x,a)')                                   &
              "maximum memory consumption in total     = ",            &
              (mem_max_tot/1.0d6),"MB"

        write(ilog,'(a,f10.2,1x,a)')                                   &
              "current PETSc memory (rank 0)           = ",            &
              (mem_petsc_cur/1.0d6),"MB"
        write(ilog,'(a,f10.2,1x,a)')                                   &
              "maximum PETSc memory (rank 0)           = ",            &
              (mem_petsc_max/1.0d6),"MB"
        write(ilog,'(a,f10.2,1x,a)')                                   &
              "current PETSc memory in total           = ",            &
              (mem_petsc_cur_tot/1.0d6),"MB"
        write(ilog,'(a,f10.2,1x,a)')                                   &
              "maximum PETSc memory in total           = ",            &
              (mem_petsc_max_tot/1.0d6),"MB"

      end if
#endif
      if (rank == 0) then
        write(ilog,'(72a)') ('-',i=1,72)
      end if
#endif

!c   release memory used by solver
      call releasesolver

!c   close runtime file
      if(rank == 0 .and. b_prtfile) then      !if MPI rank 0
        call closeruntimefile
      end if                  !end if MPI rank 0
      
!c  cputime and statistics to screen and generic output file
      if (varsat_flow.or.reactive_transport) then
        if (rank == 0) then
          call rstatgs(ilog)
        end if
        if (b_enable_output .and. b_enable_output_gen) then
          call rstatgs(igen)
        end if
      end if

      if(rank == 0) then      !if MPI rank 0
        write(*,'(/a//)')                                              &
        '     ***************** normal exit ******************'
      end if                  !end if MPI rank 0
      
      if(rank == 0) then
        write(ilog,'(72a)')('-',i=1,72)
        write(ilog,'(/a//)')                                           &
        '         ***************** normal exit *****************'
      end if
      
      if(b_enable_output .and. b_enable_output_gen) then
        write(igen,'(72a)')('-',i=1,72)
        write(igen,'(/a//)')                                           &
        '         ***************** normal exit ******************'
      end if


!c  close I/O files (global system)
      call clsgfls
      
!cprovi---------------------------------------------------------
!cprovi Destroy and nullify the phase object
!cprovi It was added by Sergio Andrï¿½s Bea Jofr?
!cprovi 24/01/2009
!cprovi---------------------------------------------------------
      call closepitzer 
!cprovi---------------------------------------------------------

!1000  continue

      if (i_solver_type_flow == 2) then
        !> create petsc solver space for flow problem
#ifdef PETSC
        if (varsat_flow) then
          call solver_dd_release_flow
        end if

        if (heat_transport .and. decoupled_type_vs_heat > 1) then
          call solver_dd_release_heat
        end if
#endif
      else if (i_solver_type_flow == 3 .or. b_solver_test_lis) then
        !> create LIS solver space for flow problem
#ifdef LIS
        if(varsat_flow) then
          call solver_lis_release_flow
        end if

        if(heat_transport .and. decoupled_type_vs_heat > 1) then
          call solver_lis_release_heat
        end if
#endif
      end if

      if (i_solver_type_react == 2) then
        !> create petsc solver space for reactive transport problem
#ifdef PETSC
        if(reactive_transport) then
          call solver_dd_release_react
        end if
#endif
      else if (i_solver_type_react == 3 .or. b_solver_test_lis) then
        !> create LIS solver space for reactive transport problem
#ifdef LIS
        if(reactive_transport) then
          call solver_lis_release_react
        end if
#endif
      end if

!c    finalize lis solver
#ifdef LIS
      call solver_lis_finalize
#endif      

!c    finalize petsc solver
#ifdef PETSC
      call petsc_mpi_finalize
#endif

      !c stop
      
End Program
