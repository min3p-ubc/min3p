!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/datstr_1.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine datstr_1
!c -------------------
!c
!c set up data structure, generate ordering vectors 
!c and perform symbolic factorization for 1d-scalar matrix
!c
!c written by:      Uli Mayer - August 6, 96
!c
!c last modified:   Uli Mayer - November 19, 96
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c parm.f:   - 
!c
!c gen.f:    integer*4:
!c           ----------
!c           ilog               = unit number, log file               + -
!c           mnjavs             = max. number of global connections   * +
!c           mnjafvs            = max. number of factored connections * +
!c           nn                 = total number of control volumes     + -
!c           njavs              = number of global connections        * +
!c           njafvs             = number of factored connections      * +
!c           iavs(nn+1)         = row pointer array for avs           * + 
!c           javs(njavs)        = connectivity list                   * +
!c           iafvs(nn+1)        = row pointer array for afvs          * +
!c           iafdvs(nn)         = diagonal pointer array for afvs     * +
!c           isymvs(njavs)      = symmetry pointer array              * +
!c           jafvs(njafvs)      = column pointer array for afvs       * +
!c           lordervs(nn)       = array containing ordering           * +
!c           invordvs(nn)       = array containing inverse ordering   * +
!c           iwork(*)           = integer work array                  * +
!c           idbg               = unit number, debugging file         + -
!c           level_vs           = incomplete factoriztaion level      + -
!c
!c           logical:
!c           --------
!c           lwork(*)           = logical work array                  * +
!c           rcm_ordering_vs    = .true.  -> rcm ordering             + -
!c                                .false. -> natural ordering
!c           varsat_flow        = .true.  -> perform flow simulation  + -
!c
!c dual.f:   logical:
!c           --------
!c           dual_porosity      = .true.  -> dual porosity            + - 
!c                                 simulation
!c
!c local:    integer*4:
!c           ----------
!c           ierr               = 0 -> memory allocation successful
!c           ilist              = pointer for work array list
!c           irow               = pointer for work array irow
!c           ilevptr            = pointer for work array levptr
!c
!c external: checkerr  = check for error during memory allocation
!c           iajavs    = set up ia-ja data-structure for
!c                       1d-scalar matrix
!c           iajavs_dp = set up ia-ja data-structure for
!c                       1d-scalar matrix - secondary porosity
!c           mem_njavs = allocate memory for one-dimensional arrays
!c                       of size njavs
!c           naturalordering = assigns ordering vectors for natural 
!c                             ordering
!c           rcmordering =  assigns ordering vectors for reverse 
!c                          Cuthill-McKee ordering
!c           symbolicfactorization = incomplete symbolic lower/
!c                                   upper factorization 
!c                                   - brute force factor
!c ----------------------------------------------------------------------
 
      subroutine datstr_1
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif 
      use parm
      use gen
      use dual
      use matrix_utility, only : export_mmformat_pattern, remap_matrix_ja
#ifdef PARDISO
      use solver_pardiso, only : ptvs, ptglob 
#endif
#ifdef METIS
      use metis_iface, only : metis_fill_reducing_ordering
#endif
#ifdef USG
      use usg_mesh_data, only :                                        &
#ifdef PETSC
                                num_nodes_gbl, num_cells_gbl,          &
#endif
                                num_nodes, num_cells
#endif
      implicit none
      
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      integer :: i1, ierr, ilist, ilevptr, irow
      
      integer :: ivol, jvol, istart, iend, jtemp, info_debug

      real*8 :: EdgeLen, EdgeLenMin, EdgeLenMax

#ifdef PETSC
      real*8 :: EdgeLenMin_gbl, EdgeLenMax_gbl
      PetscErrorCode :: ierrcode
#endif

      real*8, parameter :: r0 = 0.0d0

      external checkerr, iajavs, iajavs_dp, mem_njavs, rcmordering, &
              naturalordering, symbolicfactorization

!c  final memory allocation for row pointer array iavs,
!c  preliminary memory allocation for pointer arrays javs and isymvs

      if (discretization_type == 0) then
        if (.not.dual_porosity) then
          mnjavs = 3*nngl*ncon
        else
          mnjavs = 6*nngl*ncon
        end if
      else
#ifdef USG
        if (dual_porosity) then
          mnjavs = 2*mnjavs
        end if
#endif
      end if
      
      if (heat_transport) then
        if (decoupled_type_vs_heat > 1) then
          mnjaheat = mnjavs
        else
          mnjaglob = 4*mnjavs   
        end if         
      end if
      
     if (dual_porosity) then
        call memory_monitor(-sizeof(iavs),'iavs',.true.)
        deallocate (iavs, stat = ierr)
        call checkerr(ierr,'iavs',ilog)

        allocate(iavs(2*nngl+1), stat = ierr)
        iavs=0 
        call checkerr(ierr,'iavs',ilog)
        call memory_monitor(sizeof(iavs),'iavs',.true.)


!c  only needed for PETSc solver
#ifdef PETSC
        call memory_monitor(-sizeof(row_idx_l2pg_vs),'row_idx_l2pg_vs',.true.)
        deallocate (row_idx_l2pg_vs, stat = ierr)
        call checkerr(ierr,'row_idx_l2pg_vs',ilog)


        allocate(row_idx_l2pg_vs(2*nngl+1), stat = ierr)
        row_idx_l2pg_vs=0 
        call checkerr(ierr,'row_idx_l2pg_vs',ilog)
        call memory_monitor(sizeof(row_idx_l2pg_vs),'row_idx_l2pg_vs',.true.)
#endif

      end if                     !(dual_porosity)

      allocate(javs(mnjavs), stat = ierr)
      javs=0 
      call checkerr(ierr,'javs',ilog)
      call memory_monitor(sizeof(javs),'javs',.true.)

#ifdef PETSC
      allocate(col_idx_l2pg_vs(mnjavs), stat = ierr)
      col_idx_l2pg_vs=0 
      call checkerr(ierr,'col_idx_l2pg_vs',ilog)
      call memory_monitor(sizeof(col_idx_l2pg_vs),'col_idx_l2pg_vs',.true.)

#endif

      allocate(isymvs(mnjavs), stat = ierr)
      isymvs=0 
      call checkerr(ierr,'isymvs',ilog)
      call memory_monitor(sizeof(isymvs),'isymvs',.true.)

!c  set up data-structure for 1D-scalar matrix
!c  Parallelized, OpenMP, DSU
      if (discretization_type == 0) then
        call iajavs
      else
#ifdef USG
        call iajavs_usg
#endif
      end if

!c  set up data-structure for secondary porosity for 1D-scalar matrix
!c  Parallelized, OpenMP, DSU
      if (dual_porosity) then
        call iajavs_dp
      end if                     
    
!c  set up data-structure for flow and energy balance equations 
!c  Parallelized, OpenMP, DSU
      if (heat_transport) then
        call iajavs_energybal 
      end if                     

!c  final memory allocation for one-dimensional arrays of size njavs
!c  Parallelized, OpenMP, DSU
      call mem_njavs
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------

    ! use ws209 solver
    if (i_solver_type_flow == 0) then
               
      if (heat_transport .and. decoupled_type_vs_heat <= 1) then
        !c DSU, 2019-11-26  
        !c previous estimated value is 3, which may be not sufficient in USG code
        mnjafglob  = coeff_fac_conn_glob*(level_glob+1)*njaglob

!c  allocate memory for temporary work-arrays
        allocate(lwork(2*nngl), stat = ierr)
        lwork=.false.
        call checkerr(ierr,'lwork',ilog)
        call memory_monitor(sizeof(lwork),'lwork',.true.)

!c  preliminary memory allocation for temporary work arrays 
!c  of undefined size
        allocate (iwork(4*nngl+mnjafglob), stat = ierr)
        iwork=0 
        call checkerr(ierr,'iwork',ilog)
        call memory_monitor(sizeof(iwork),'iwork',.true.)

        allocate (jafglob(mnjafglob), stat = ierr)
        jafglob=0 
        call checkerr(ierr,'jafglob',ilog)
        call memory_monitor(sizeof(jafglob),'jafglob',.true.)

        if (varsat_flow) then          !variably saturated flow

    !c  ordering vectors
          if (rcm_ordering_vs) then    !rcm ordering    

            call rcmordering (2*nngl,njaglob,iaglob,jaglob,            &
                              lorderglob,invordglob,lwork,iwork)

#ifdef METIS
          else if (metis_ordering_vs) then
            call metis_fill_reducing_ordering(2*nngl,njaglob,iaglob,   &
                       jaglob,lorderglob,invordglob)
#endif

          else                         !natural ordering
            call naturalordering (2*nngl,lorderglob,invordglob)
          endif

    !c  write memory-requirements to log file

          if(rank == 0 .and. b_enable_output)  then
                
            write(ilog,'(/2a/)') 'memory requirements for coupled',   &
                  ' flow and heat transport simulation:'

#ifdef USG
            if (discretization_type > 0) then
#ifdef PETSC
              write(ilog,'(2(a,i10/))')                               &
                'number of nodes:                          ',         &
                num_nodes_gbl,                                        &
                'number of cells:                          ',         &
                num_cells_gbl
#else
              write(ilog,'(2(a,i10/))')                               &
                'number of nodes:                          ',         &
                num_nodes,                                            &
                'number of cells:                          ',         &
                num_cells
#endif
            end if
#endif

            write(ilog,'(2(a,i10/),a,i10)')                           &
              'estimated number of connections:          ',mnjaglob,  &
              'actual number of connections:             ',njaglob,   &
              'estimated number of factored connections: ',mnjafglob
          end if
       
    !c  symbolic factorization
          njafglob = 0
          ilist = 1                  !pointer for work array list
          irow = 2*nngl+1            !pointer for work array irow
          ilevptr = 4*nngl+1         !pointer for work array levptr

          call symbolicfactorization (ilog,2*nngl,njaglob,njafglob,       &
                                      mnjafglob,level_vs,                 &
                                      iwork(ilist),iaglob,jaglob,         &
                                      iwork(irow),iwork(ilevptr),iafglob, &
                                      iafdglob,jafglob,lorderglob,        &
                                      invordglob,rank,b_enable_output)
       

!c  write actual number of factored connections to log file
          if(rank == 0 .and. b_enable_output)  then  
            write(ilog,'(a,i10/)') &
                    'actual number of factored connections:    ',njafglob   
          end if
!c  deallocate memory for temporary arrays
          call memory_monitor(-sizeof(iwork),'iwork',.true.)
          deallocate (iwork, stat = ierr)
          call checkerr(ierr,'iwork',ilog)
    

!c  minimize memory requirements for array jafglob
          allocate (iwork(njafglob), stat = ierr)
          iwork=0 
          call checkerr(ierr,'iwork',ilog)
          call memory_monitor(sizeof(iwork),'iwork',.true.)
  
          do i1 = 1,njafglob
            iwork(i1) = jafglob(i1)
          end do
  
          call memory_monitor(-sizeof(jafglob),'jafglob',.true.)
          deallocate (jafglob, stat = ierr)
          call checkerr(ierr,'jafglob',ilog)
  
          allocate (jafglob(njafglob), stat = ierr)
          call checkerr(ierr,'jafglob',ilog)
          call memory_monitor(sizeof(jafglob),'jafglob',.true.)
  
          do i1 = 1,njafglob
            jafglob(i1) = iwork(i1)
          end do

        end if
        
        call memory_monitor(-sizeof(iwork),'iwork',.true.)
        deallocate (iwork, stat = ierr)
        call checkerr(ierr,'iwork',ilog)

        call memory_monitor(-sizeof(lwork),'lwork',.true.)
        deallocate(lwork, stat = ierr)
        call checkerr(ierr,'lwork',ilog)

      else if (heat_transport .and. decoupled_type_vs_heat > 1) then
        mnjafheat  = coeff_fac_conn_heat*(level_heat+1)*njaheat
     
!c  allocate memory for temporary work-arrays
        allocate(lwork(nngl), stat = ierr)
        lwork=.false.
        call checkerr(ierr,'lwork',ilog)
        call memory_monitor(sizeof(lwork),'lwork',.true.)

!c  preliminary memory allocation for temporary work arrays 
!c  of undefined size
        allocate (iwork(2*nngl+mnjafheat), stat = ierr)
        iwork=0 
        call checkerr(ierr,'iwork',ilog)
        call memory_monitor(sizeof(iwork),'iwork',.true.)

        allocate (jafheat(mnjafheat), stat = ierr)
        jafheat=0 
        call checkerr(ierr,'jafheat',ilog)
        call memory_monitor(sizeof(jafheat),'jafheat',.true.)

    !c  ordering vectors

        if (rcm_ordering_heat) then    !rcm ordering
          call rcmordering (nngl,njaheat,iaheat,jaheat,lorderheat,     &
                            invordheat,lwork,iwork)
#ifdef METIS
        else if (metis_ordering_heat) then
          call metis_fill_reducing_ordering(nngl,njaheat,iaheat,jaheat,&
                     lorderheat,invordheat)
#endif
        else                         !natural ordering
          call naturalordering (nngl,lorderheat,invordheat)
        endif

#ifdef DEBUG
        info_debug = 0
        if(info_debug > 0) then
          call export_mmformat_pattern(nngl, njaheat, iaheat, jaheat,  &
                      "heatflow_order", invordheat)
        end if
#endif

    !c  write memory-requirements to log file
        if(rank == 0 .and. b_enable_output)  then

          write(ilog,'(/2a/)') 'memory requirements for decoupled',    &
                ' heat transport simulation:'

#ifdef USG
          if (discretization_type > 0) then
#ifdef PETSC
            write(ilog,'(2(a,i10/))')                                  &
              'number of nodes:                          ',            &
              num_nodes_gbl,                                           &
              'number of cells:                          ',            &
              num_cells_gbl
#else
            write(ilog,'(2(a,i10/))')                                  &
              'number of nodes:                          ',            &
              num_nodes,                                               &
              'number of cells:                          ',            &
              num_cells
#endif
          end if
#endif

          write(ilog,'(2(a,i10/),a,i10)')                              &
            'estimated number of connections:          ',mnjaheat,     &
            'actual number of connections:             ',njaheat,      &
            'estimated number of factored connections: ',mnjafheat
        end if
       
    !c  symbolic factorization
        njafheat = 0
        ilist = 1                  !pointer for work array list
        irow = nngl+1              !pointer for work array irow
        ilevptr = 2*nngl+1         !pointer for work array levptr

        call symbolicfactorization (ilog,nngl,njaheat,njafheat,mnjafheat,  &
                                   level_heat,iwork(ilist),iaheat,jaheat,  &
                                   iwork(irow),iwork(ilevptr),iafheat,     &
                                   iafdheat,jafheat,lorderheat,invordheat, &
                                   rank,b_enable_output)

    !c  write actual number of factored connections to log file
        if(rank == 0 .and. b_enable_output)  then            
          write(ilog,'(a,i10/)')                                       &
                'actual number of factored connections:    ',njafheat
        end if
          
!c  deallocate memory for temporary arrays
        call memory_monitor(-sizeof(iwork),'iwork',.true.)
        deallocate (iwork, stat = ierr)
        call checkerr(ierr,'iwork',ilog)

!c  minimize memory requirements for array jafheat

        allocate (iwork(njafheat), stat = ierr)
        iwork=0
        call checkerr(ierr,'iwork',ilog)
        call memory_monitor(sizeof(iwork),'iwork',.true.)

        do i1 = 1,njafheat
          iwork(i1) = jafheat(i1)
        end do

        call memory_monitor(-sizeof(jafheat),'jafheat',.true.)
        deallocate (jafheat, stat = ierr)
        call checkerr(ierr,'jafheat',ilog)

        allocate (jafheat(njafheat), stat = ierr)
        call checkerr(ierr,'jafheat',ilog)
        call memory_monitor(sizeof(jafheat),'jafheat',.true.)

        do i1 = 1,njafheat
          jafheat(i1) = iwork(i1)
        end do
   
        call memory_monitor(-sizeof(iwork),'iwork',.true.)
        deallocate (iwork, stat = ierr)
        call checkerr(ierr,'iwork',ilog)

        call memory_monitor(-sizeof(lwork),'lwork',.true.)
        deallocate(lwork, stat = ierr)
        call checkerr(ierr,'lwork',ilog)        
      end if     !  energy balance
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
!cptovi--------------------------------------------------------------------
      mnjafvs  = coeff_fac_conn_vs*(level_vs+1)*njavs
      
!c  allocate memory for temporary work-arrays
      allocate(lwork(nngl), stat = ierr)
      lwork=.false.
      call checkerr(ierr,'lwork',ilog)
      call memory_monitor(sizeof(lwork),'lwork',.true.)

!c  preliminary memory allocation for temporary work arrays 
!c  of undefined size
      allocate (iwork(2*nngl+mnjafvs), stat = ierr)
      iwork=0 
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'iwork',.true.)

      allocate (jafvs(mnjafvs), stat = ierr)
      jafvs=0 
      call checkerr(ierr,'jafvs',ilog)
      call memory_monitor(sizeof(jafvs),'jafvs',.true.)

      if (varsat_flow) then          !variably saturated flow

    !c  ordering vectors

        if (rcm_ordering_vs) then    !rcm ordering

          call rcmordering (nngl,njavs,iavs,javs,lordervs,invordvs,    &
                           lwork,iwork)
#ifdef METIS
        else if (metis_ordering_vs) then
          call metis_fill_reducing_ordering(nngl,njavs,iavs,javs,      &
                     lordervs,invordvs)
#endif
        else                         !natural ordering

          call naturalordering (nngl,lordervs,invordvs)

        endif

#ifdef DEBUG
        info_debug = 0
        if(info_debug > 0) then
          call export_mmformat_pattern(nngl, njavs, iavs, javs,        &
                      "vsflow_order", invordvs)
        end if
#endif

    !c  write memory-requirements to log file
        if(rank == 0 .and. b_enable_output)  then

          write(ilog,'(/2a/)') 'memory requirements for',              &
                ' variably-saturated flow simulation:'

#ifdef USG
          if (discretization_type > 0) then
#ifdef PETSC
              write(ilog,'(2(a,i10/))')                                &
              'number of nodes:                          ',            &
              num_nodes_gbl,                                           &
              'number of cells:                          ',            &
              num_cells_gbl
#else
              write(ilog,'(2(a,i10/))')                                &
              'number of nodes:                          ',            &
              num_nodes,                                               &
              'number of cells:                          ',            &
              num_cells
#endif
          end if
#endif

          write(ilog,'(2(a,i10/),a,i10)')                              &
         'estimated number of connections:          ',mnjavs,          &
         'actual number of connections:             ',njavs,           &
         'estimated number of factored connections: ',mnjafvs
        end if
       
    !c  symbolic factorization
        njafvs = 0
        ilist = 1                  !pointer for work array list
        irow = nngl+1              !pointer for work array irow
        ilevptr = 2*nngl+1         !pointer for work array levptr

        call symbolicfactorization (ilog,nngl,njavs,njafvs,mnjafvs,    &
                                   level_vs,iwork(ilist),iavs,javs,    &
                                   iwork(irow),iwork(ilevptr),iafvs,   &
                                   iafdvs,jafvs,lordervs,invordvs,     &
                                   rank,b_enable_output)

    !c  write actual number of factored connections to log file
        if(rank == 0 .and. b_enable_output)  then
            
          write(ilog,'(a,i10/)')                                       &
                'actual number of factored connections:    ',njafvs

        end if

      end if                       !variably saturated flow      
            
!c  deallocate memory for temporary arrays
      call memory_monitor(-sizeof(iwork),'iwork',.true.)
      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)

!c  minimize memory requirements for array jafvs

      allocate (iwork(njafvs), stat = ierr)
      iwork=0
      call checkerr(ierr,'iwork',ilog)
      call memory_monitor(sizeof(iwork),'iwork',.true.)

      do i1 = 1,njafvs
      iwork(i1) = jafvs(i1)
      end do

      call memory_monitor(-sizeof(jafvs),'jafvs',.true.)
      deallocate (jafvs, stat = ierr)
      call checkerr(ierr,'jafvs',ilog)

      allocate (jafvs(njafvs), stat = ierr)
      call checkerr(ierr,'jafvs',ilog)
      call memory_monitor(sizeof(jafvs),'jafvs',.true.)

      do i1 = 1,njafvs
      jafvs(i1) = iwork(i1)
      end do
   
      call memory_monitor(-sizeof(iwork),'iwork',.true.)
      deallocate (iwork, stat = ierr)
      call checkerr(ierr,'iwork',ilog)

      call memory_monitor(-sizeof(lwork),'lwork',.true.)
      deallocate(lwork, stat = ierr)
      call checkerr(ierr,'lwork',ilog)
    end if
    
    ! use pardiso solver
#ifdef PARDISO
    if (i_solver_type_flow == 1 .or. (i_solver_type_flow == 0 .and.    &
        b_solver_test_pardiso .eqv. .true.)) then
        
      if (heat_transport) then

        if (decoupled_type_vs_heat > 1) then
          if (allocated(jaheat_std)) then
            call memory_monitor(-sizeof(jaheat_std),'jaheat_std',.true.)
            deallocate(jaheat_std, stat = ierr)
            call checkerr(ierr,'jaheat_std',ilog) 
          end if
          allocate(jaheat_std(njaheat), stat = ierr)
          jaheat_std = 0
          call checkerr(ierr,'jaheat_std',ilog)
          call memory_monitor(sizeof(jaheat_std),'jaheat_std',.true.)
            
          if (allocated(imapheat_std)) then
            call memory_monitor(-sizeof(imapheat_std),'imapheat_std',.true.)
            deallocate(imapheat_std, stat = ierr)
            call checkerr(ierr,'imapheat_std',ilog) 
          end if
          allocate(imapheat_std(njaheat), stat = ierr)
          imapheat_std = 0
          call checkerr(ierr,'imapheat_std',ilog)
          call memory_monitor(sizeof(imapheat_std),'imapheat_std',.true.)
            
          if (allocated(aheat_std)) then
            call memory_monitor(-sizeof(aheat_std),'aheat_std',.true.)
            deallocate(aheat_std, stat = ierr)
            call checkerr(ierr,'aheat_std',ilog) 
          end if
          allocate(aheat_std(njaheat), stat = ierr)
          aheat_std = 0.0d0
          call checkerr(ierr,'aheat_std',ilog)
          call memory_monitor(sizeof(aheat_std),'aheat_std',.true.)
            
          if (b_solver_test_pardiso) then
            if (allocated(uheat_std)) then
              call memory_monitor(-sizeof(uheat_std),'uheat_std',.true.)
              deallocate(uheat_std, stat = ierr)
              call checkerr(ierr,'uheat_std',ilog) 
            end if

            allocate(uheat_std(nngl), stat = ierr)
            uheat_std = 0.0d0
            call checkerr(ierr,'uheat_std',ilog)
            call memory_monitor(sizeof(uheat_std),'uheat_std',.true.)
          end if
                         
          !map ja array to standard sparse matrix structure, increasing column number for each row
          jaheat_std = jaheat
          do i1 = 1, njaheat
              imapheat_std (i1) = i1
          end do
          !write(idbg, *) "remap jaheat"
          call remap_matrix_ja(nngl, iaheat, njaheat, jaheat_std, imapheat_std)

        else
       
          if (varsat_flow) then          !variably saturated flow
              
            if (allocated(jaglob_std)) then
              call memory_monitor(-sizeof(jaglob_std),'jaglob_std',.true.)
              deallocate(jaglob_std, stat = ierr)
              call checkerr(ierr,'jaglob_std',ilog) 
            end if
            allocate(jaglob_std(njaglob), stat = ierr)
            jaglob_std = 0
            call checkerr(ierr,'jaglob_std',ilog)
            call memory_monitor(sizeof(jaglob_std),'jaglob_std',.true.)
               
            if (allocated(imapglob_std)) then
              call memory_monitor(-sizeof(imapglob_std),'imapglob_std',.true.)
              deallocate(imapglob_std, stat = ierr)
              call checkerr(ierr,'imapglob_std',ilog) 
            end if

            allocate(imapglob_std(njaglob), stat = ierr)
            imapglob_std = 0
            call checkerr(ierr,'imapglob_std',ilog)
            call memory_monitor(sizeof(imapglob_std),'imapglob_std',.true.)
            
            if (allocated(aglob_std)) then
              call memory_monitor(-sizeof(aglob_std),'aglob_std',.true.)
              deallocate(aglob_std, stat = ierr)
              call checkerr(ierr,'aglob_std',ilog) 
            end if

            allocate(aglob_std(njaglob), stat = ierr)
            aglob_std = 0
            call checkerr(ierr,'aglob_std',ilog)
            call memory_monitor(sizeof(aglob_std),'aglob_std',.true.)
            
            if (b_solver_test_pardiso) then
              if (allocated(uglob_std)) then
                call memory_monitor(-sizeof(uglob_std),'uglob_std',.true.)
                deallocate(uglob_std, stat = ierr)
                call checkerr(ierr,'uglob_std',ilog) 
              end if

              allocate(uglob_std(2*nngl), stat = ierr)
              uglob_std = 0
              call checkerr(ierr,'uglob_std',ilog)
              call memory_monitor(sizeof(uglob_std),'uglob_std',.true.)
            end if

            !map ja array to standard sparse matrix structure, increasing column number for each row
            jaglob_std = jaglob
            do i1 = 1, njaglob
              imapglob_std (i1) = i1
            end do
            call remap_matrix_ja(2*nngl, iaglob, njaglob, jaglob_std, imapglob_std)            
          end if
        end if
      end if  

      if (.not.heat_transport .or. decoupled_type_vs_heat > 1) then

        if (varsat_flow) then          !variably saturated flow              
          if (allocated(javs_std)) then
            call memory_monitor(-sizeof(javs_std),'javs_std',.true.)
            deallocate(javs_std, stat = ierr)
            call checkerr(ierr,'javs_std',ilog) 
          end if
          allocate(javs_std(njavs), stat = ierr)
          javs_std = 0
          call checkerr(ierr,'javs_std',ilog)
          call memory_monitor(sizeof(javs_std),'javs_std',.true.)
            
          if (allocated(imapvs_std)) then
            call memory_monitor(-sizeof(imapvs_std),'imapvs_std',.true.)
            deallocate(imapvs_std, stat = ierr)
            call checkerr(ierr,'imapvs_std',ilog) 
          end if
          allocate(imapvs_std(njavs), stat = ierr)
          imapvs_std = 0
          call checkerr(ierr,'imapvs_std',ilog)
          call memory_monitor(sizeof(imapvs_std),'imapvs_std',.true.)
            
          if (allocated(avs_std)) then
            call memory_monitor(-sizeof(avs_std),'avs_std',.true.)
            deallocate(avs_std, stat = ierr)
            call checkerr(ierr,'avs_std',ilog) 
          end if
          allocate(avs_std(njavs), stat = ierr)
          avs_std = 0.0d0
          call checkerr(ierr,'avs_std',ilog)
          call memory_monitor(sizeof(avs_std),'avs_std',.true.)
            
          if (b_solver_test_pardiso) then
            if (allocated(uvs_std)) then
              call memory_monitor(-sizeof(uvs_std),'uvs_std',.true.)
              deallocate(uvs_std, stat = ierr)
              call checkerr(ierr,'uvs_std',ilog) 
            end if

            allocate(uvs_std(nngl), stat = ierr)
            uvs_std = 0.0d0
            call checkerr(ierr,'uvs_std',ilog)
            call memory_monitor(sizeof(uvs_std),'uvs_std',.true.)
          end if
                         
          !map ja array to standard sparse matrix structure, increasing column number for each row
          javs_std = javs
          do i1 = 1, njavs
              imapvs_std (i1) = i1
          end do
          !write(idbg, *) "remap javs"
          call remap_matrix_ja(nngl, iavs, njavs, javs_std, imapvs_std)
        end if                       !variably saturated flow
      end if     !  energy balance      
    end if 
#endif
    
    ! use PETSC solver
    if (i_solver_type_flow == 0 .and. (b_solver_test_petsc .or.  &
        b_solver_test_lis)) then        
      if (heat_transport) then
        if (decoupled_type_vs_heat > 1) then
          if (allocated(uheat_std)) then
            call memory_monitor(-sizeof(uheat_std),'uheat_std',.true.)
            deallocate(uheat_std, stat = ierr)
            call checkerr(ierr,'uheat_std',ilog) 
          end if

          allocate(uheat_std(nngl), stat = ierr)
          uheat_std = 0.0d0
          call checkerr(ierr,'uheat_std',ilog)
          call memory_monitor(sizeof(uheat_std),'uheat_std',.true.)
        else
          if (varsat_flow) then          !variably saturated flow              
            if (allocated(uglob_std)) then
              call memory_monitor(-sizeof(uglob_std),'uglob_std',.true.)
              deallocate(uglob_std, stat = ierr)
              call checkerr(ierr,'uglob_std',ilog) 
            end if

            allocate(uglob_std(2*nngl), stat = ierr)
            uglob_std = 0.0d0
            call checkerr(ierr,'uglob_std',ilog)
            call memory_monitor(sizeof(uglob_std),'uglob_std',.true.)
          end if
        end if
      end if
      
      if (.not.heat_transport .or. decoupled_type_vs_heat > 1) then
        if (varsat_flow) then          !variably saturated flow            
          if (allocated(uvs_std)) then
            call memory_monitor(-sizeof(uvs_std),'uvs_std',.true.)
            deallocate(uvs_std, stat = ierr)
            call checkerr(ierr,'uvs_std',ilog) 
          end if

          allocate(uvs_std(nngl), stat = ierr)
          uvs_std = 0.0d0
          call checkerr(ierr,'uvs_std',ilog)
          call memory_monitor(sizeof(uvs_std),'uvs_std',.true.)
        end if                       !variably saturated flow
      end if     !  energy balance      
    end if
        
!c  discretization information
    EdgeLenMin = 1.0d100 
    EdgeLenMax = 0.0d0
    do ivol = 1, nngl           !loop over all volumes

      istart = iavs(ivol)+1     !pointer - start of row
      iend = iavs(ivol+1)-1     !pointer - end of row

      do jtemp = istart, iend   !loop over all connections
        jvol = javs(jtemp)
        EdgeLen = (xg(ivol)-xg(jvol))**2 + (yg(ivol)-yg(jvol))**2 +  &
                  (zg(ivol)-zg(jvol))**2
        if (EdgeLen > EdgeLenMax) then
          EdgeLenMax = EdgeLen
        end if
        if (EdgeLen < EdgeLenMin) then
          EdgeLenMin = EdgeLen
        end if
      end do
    end do
    EdgeLenMin = sqrt(EdgeLenMin)
    EdgeLenMax = sqrt(EdgeLenMax)

#ifdef PETSC
    call MPI_Allreduce(EdgeLenMin, EdgeLenMin_gbl,1,MPI_REAL8,       &
                       MPI_MIN,Petsc_Comm_World,ierrcode)
    CHKERRQ(ierrcode)
    EdgeLenMin = EdgeLenMin_gbl

    call MPI_Allreduce(EdgeLenMax, EdgeLenMax_gbl,1,MPI_REAL8,       &
                       MPI_MAX,Petsc_Comm_World,ierrcode)
    CHKERRQ(ierrcode)
    EdgeLenMax = EdgeLenMax_gbl     
#endif

    if (rank == 0 .and. b_enable_output) then
      write(ilog,'(/a/,2(a,1pe15.6e3/))')                            &
        'spatial discretization information',                        &
        'spatial discretization resoltion mininum: ',EdgeLenMin,     &
        'spatial discretization resoltion maximum: ',EdgeLenMax
    end if
    
!cdbg
!c
!c  ia-ja pointers
#ifdef DEBUG
     info_debug = 0
     if (info_debug > 0) then
       do irow=1,nngl+1
         write(idbg,*) 'ia(',irow,') = ',iavs(irow)
       end do
       do irow=1,nngl
         istart = iavs(irow)
         iend = iavs(irow+1)-1
         write(idbg,*) ('ja(',i1,') = ',javs(i1),i1=istart,iend)
       end do

!c  ordering vectors
!c
       do ivol=1,nngl
         write(idbg,'(a,1x,i6,1x,a,1x,i6)')                            &
               'lordervs(',ivol,') = ',lordervs(ivol)
       end do
       write(idbg,*)
       do ivol=1,nngl
         write(idbg,'(a,1x,i6,1x,a,1x,i6)')                            &
               'invordvs(',ivol,') = ',invordvs(ivol)
       end do
!c
!c  iaf-jaf pointers
!c
       do irow=1,nngl+1
         write(idbg,*) 'iaf(',irow,') = ',iafvs(irow)
       end do
       do irow=1,nngl
         write(idbg,*) 'iafd(',irow,') = ',iafdvs(irow)
       end do

       do irow=1,nngl
         istart = iafvs(irow)
         iend = iafvs(irow+1)-1
         write(idbg,*) ('jaf(',i1,') = ',jafvs(i1),i1=istart,iend)
       end do
     end if
#endif
!c     stop
!cdbg

!    if (b_solver_test_pardiso) then
!!c  ia-ja pointers
!
!     do irow=1,nngl+1
!       write(idbg,*) 'ia(',irow,') = ',iavs(irow)
!     end do
!     do irow=1,nngl
!       istart = iavs(irow)
!       iend = iavs(irow+1)-1
!       write(idbg,*) ('ja(',i1,') = ',javs(i1),i1=istart,iend)
!     end do
!
!!c  ordering vectors
!
!     do ivol=1,nngl
!       write(idbg,'(a,1x,i6,1x,a,1x,i6)') 'lordervs(',ivol,') = ',lordervs(ivol)
!     end do
!     write(idbg,*)
!     do ivol=1,nngl
!       write(idbg,'(a,1x,i6,1x,a,1x,i6)') 'invordvs(',ivol,') = ',invordvs(ivol)
!     end do
!
!!c  iaf-jaf pointers
!
!     do irow=1,nngl+1
!       write(idbg,*) 'iaf(',irow,') = ',iafvs(irow)
!     end do
!     do irow=1,nngl
!       write(idbg,*) 'iafd(',irow,') = ',iafdvs(irow)
!     end do
!     do irow=1,nngl
!       istart = iafvs(irow)
!       iend = iafvs(irow+1)-1
!       write(idbg,*) ('jaf(',i1,') = ',jafvs(i1),i1=istart,iend)
!     end do  
!     
!    end if
      return
      end
