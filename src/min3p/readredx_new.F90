!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/readredx_new.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine readredx_new
!c -----------------------
!c
!c read database for redox couples and assign to permanent storage
!c
!c written by:      Uli Mayer - July 13, 02
!c                  based on readredx, adjusted to fit new database
!c                  format
!c
!c last modified:   -
!c                  
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   integer*4:
!c           ----------
!c           irdbs              = unit number, database for redox     + -
!c                                             couples
!c           ilog               = unit number, log book               + -
!c           idbg               = unit number, debugging file         + -
!c
!c common:
!c chem.f:   real*8:
!c           -------
!c           dhcr(nr)           = enthalpy change for redox reaction  * +
!c           eqrs(nr)           = equilibrium constants for redox     * +
!c                                couples at standard temperature
!c           xnur(nr*nc)        = stoichiometric coefficient of       * +
!c                                components in redox couple
!c                                reaction equation
!c
!c           integer*4:
!c           ----------
!c           iarc(nr+1)         = row pointer array to                * +
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           iars(nr)           = pointer array to secondary          * +
!c                                component of redox couple
!c           jarc(nr*nc)        = column pointer array to             * +
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           nc                 = number of components                + -
!c           nr                 = number of redox couples             + -
!c
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c           namer(nr)          = names of redox couples              + -
!c           namers(nr)         = names of secondary components of    + -
!c                                redox couples
!c           namet(30)          = species names (temporary)           * *
!c           rtype_hom(nr)      = reaction type of homogeneous        * +
!c                                reaction in aqueous phase
!c                                'equilibrium'
!c           
!c
!c local:    real*8:
!c           -------
!c           r10                = constant
!c           xnut(100)          = array for temporary storage of
!c                                stoichiometric coefficients
!c
!c           integer*4:
!c           ----------
!c           ic                 = counter (components)
!c           icount             = counter
!c           icur               = pointer
!c           istart             = pointer
!c           istop              = pointer
!c           ir                 = counter (redox couples)
!c           iv                 = counter
!c           nv                 = number of components with nonzero
!c                                stoichiometric coefficients in
!c                                redox couple reaction equation
!c                                (temporary)
!c
!c           logical:
!c           --------
!c           comment_line       = .true.  -> read comment line
!c           done               = .true.  -> exit search
!c           found              = .true.  -> exit search
!c           next_entry         = .true.  -> database entry for
!c                                           next redox couple
!c
!c           character:
!c           ----------
!c           junk               = dummy character variable
!c           name_rs            = name of secondary component of 
!c                                redox couple (temporary)
!c
!c external: -
!c ----------------------------------------------------------------------

      subroutine readredx_new(irdbs,ilog,idbg)
 
      use parm
      use chem
      use gen, only : rank, b_enable_output, idbs_bk, use_dbs_bk
      use file_utility, only : makelowercase, replacecharacter,        &
                               readnextline
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif 
      implicit none
      
      integer :: irdbs, ilog, idbg

      character*1 junk
      character*72 name_rs
      character*256 :: strbuffer
      dimension xnut(100)
      logical comment_line, done, found, next_entry

      real*8 :: r10
      parameter (r10 = 10.0d0)  
      
      !local variables
      integer :: i, ic, icount, icur, info_debug, ir, istart, istop,   &
                 iv, nv 
      real*8 :: xnut

!c initialize pointer arrays for sparse matrix structure
 
      iarc(1) = 1
 
!c  loop over redox couples specified for simulation
 
      do ir = 1,nr
 
!c  loop over redox couples in database, search for match 
!c  read redox couple data and store in compressed format
!c  exit when done or if end of database is reached
 
        done = .false.
 
        do while (.not.done)
 
!c  skip over comment lines in database
 
          comment_line = .true.
          do while (comment_line)
            read (irdbs,'(a1)',err=997,end=999) junk
            if (junk.ne.'!') comment_line = .false.
          end do
 
!c  backspace to start of database entry for current redox couple

          backspace(irdbs)

!c  read name of secondary component of redox couple 
 
          read(irdbs,*,err=997,end = 999) name_rs

!c  look for match, as long end of file is not reached or 
!c  match is found
 
!c  redox couple is found --> read data
 
          if (name_rs.eq.namers(ir)) then
 
            done = .true.

!c  check, if secondary component of redox couple is specified
!c  as a component, assign pointer to total aqueous component 
!c  concentration for secondary component of redox couple

            ic = 0
            found = .false.
            do while ((ic.lt.nc).and.(.not.found))
              ic = ic+1
              if (namers(ir).eq.namec(ic)) then
                found = .true.
                iars(ir) = ic
              end if
            end do

!c  exit, if secondary component of redox couple is not specified

            if (.not.found) then
              if (rank == 0) then
                write(ilog,'(72a)') ('-',i=1,72)
                write(ilog,'(3a)')                                     &
     &               'secondary component for redox couple ',          &
     &                namer(ir)(:l_namer(ir)),' is missing'
                write(ilog,'(72a)') ('-',i=1,72)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if

!c  read components involved in current redox reaction and reaction
!c  stoichiometry

            read(irdbs,*,err=997) nv,(namet(iv),xnut(iv),iv=1,nv)

!c  pointer array to row in stoichiometric reaction matrix for 
!c  next redox couple

            iarc(ir+1) = iarc(ir) + nv
 
!c  check if reactants and reaction products of current
!c  redox couple are specified as components,
!c  set up pointer array to column in stoichiometric matrix
        
            icount = 0
            ic = 0
            do while ((icount.lt.nv).and.(ic.lt.nc))
              ic = ic+1
              iv = 0
              found = .false.
              do while ((iv.lt.nv).and.(.not.found))
                iv = iv+1
                if (namet(iv).eq.namec(ic)) then
                  found = .true.
                  icount = icount+1
                  icur = iarc(ir)+iv-1
                  jarc(icur) = ic
                end if
              end do
            end do

!c  exit, if component is missing
 
            if (icount.ne.nv) then
              if (rank == 0) then
                write(ilog,'(72a)') ('-',i=1,72)
                write(ilog,'(5a)')                                      &
     &               'component for redox couple ',                     &
     &                namer(ir)(:l_namer(ir)),' is missing'             
                write(ilog,'(72a)') ('-',i=1,72)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
 
!c  all components available --> read data and assign to arrays
 
            elseif (icount.eq.nv) then
 
!c  assign stoichiometric coefficients
 
              istart = iarc(ir)
              istop = iarc(ir+1)-1
              iv = 0
              do i = istart,istop
                iv = iv+1
                xnur(i) = xnut(iv) 
              end do

!c  read log equilibrium constant and enthalpy change
 
              read(irdbs,*,err=997) rtype_hom(ir)

              if (rtype_hom(ir).eq.'equilibrium') then

!c  backspace and read log_10 of equilibrium constant and enthalpy 
!c  change

              backspace(irdbs)
              read(irdbs,*,err=997) rtype_hom(ir),eqrs(ir),dhcr(ir)

!c  convert equilibrium constant from log units 

                eqrs(ir) = r10 ** (eqrs(ir))

              else
                 if (rank == 0) then
                   write(ilog,*) 'abnormal exit from readredx_new'
                   write(ilog,*) 'reaction type in database ',         &
     &                           'not set to "equilibrium"'
                 end if
#ifdef PETSC
                 call petsc_mpi_finalize
#endif
                 stop

              end if
 
!c  rewind database for redox couples to search for next 
!c  redox couple, doing this allows the specification of redox 
!c  couples in an arbitray order
 
              rewind(irdbs)
 
            end if
 
!c  go to next redox couple, if no match was found
  
          elseif (name_rs.ne.namers(ir)) then

            next_entry = .false.
            do while (.not.next_entry)
              read (irdbs,'(a1)',err=997) junk
              if (junk.eq.'!') then
                next_entry = .true.
              end if
            end do

            backspace(irdbs)

          end if               !search for redox couples
        end do                 !end - loop over redox database
      end do                   !end - loop over specified redox couples

!cdbg ---- activate this section for purposes of debugging -----
#ifdef DEBUG
      info_debug = 0

      if (info_debug.gt.0) then
        do ir=1,nr
          write(idbg,'(a)') 'returning from readredx ...'
          write(idbg,'(a145,1x,a145)') namer(ir)
          write(idbg,'(a,1pe15.6e3)') 'eqrs  ',dlog10(eqrs(ir))
          write(idbg,'(a,1pe15.6e3)') 'dhcr  ',dhcr(ir)
          write(idbg,'(a,i10)') 'iarc    ',iarc(ir)
          write(idbg,'(a,i10,2x,a)') 'iars    ',iars(ir),namec(iars(ir))
 
!c  echo check for stoichiometric coefficients 
 
          istart = iarc(ir)
          istop = iarc(ir+1)-1
          do i = istart, istop
            icur = jarc(i)
            write(idbg,'(i5,2x,a72,a,i5,a,1pe15.6e3)') i,namec(icur),  &
     &                 ' jarc ',jarc(i),' xnur ',xnur(i)
          end do
 
          write(idbg,*) '----------------------------------------------'
        end do
      end if

      if (info_debug.gt.1) then
#ifdef PETSC
        call petsc_mpi_finalize
#endif 
        stop
      end if
#endif

!c  write backup of database items to the file
      if (rank == 0) then
        if (.not.use_dbs_bk) then
          if (redox_master.eq.'o2(aq)') then
            write(*,'(1x,a)') 'start of database backup: redox.dbs'
            write(idbs_bk, '(a)') '<------ redox.dbs: start of intra-aqueous kinetic reactions ------>'
          elseif (redox_master.eq.'h2(aq)') then
            write(*,'(1x,a)') 'start of database backup: redoxh2.dbs'
            write(idbs_bk, '(a)') '<------ redoxh2.dbs: start of intra-aqueous kinetic reactions ------>'
          elseif (redox_master.eq.'e-1') then
            write(*,'(1x,a)') 'start of database backup: redoxe.dbs'
            write(idbs_bk, '(a)') '<------ redoxe.dbs: start of intra-aqueous kinetic reactions ------>'
          end if
           
          do ir = 1,nr
            rewind(irdbs)
            do while(.true.)
              if (readnextline(irdbs, strbuffer, lowercase=.false.,        &
                  original=.true.)) then
                if (index(adjustl(strbuffer),trim(namers(ir))) == 2) then            !note, mineral name has quotes
                  write(idbs_bk,'(a)') trim(strbuffer)
                  do while(readnextline(irdbs,strbuffer,lowercase=.false., &
                           withcomment=.true.,original=.true.))
                    if (index(adjustl(strbuffer), '!') == 1 .or.           &
                        trim(adjustl(strbuffer)).eq."'end'") then
                      write(idbs_bk,'(a)') trim(strbuffer)
                      exit
                    else
                      write(idbs_bk,'(a)') trim(strbuffer)
                    end if
                  end do
                  exit
                end if
              end if
            end do
          end do
          rewind(irdbs)
          !write(idbs_bk, '(a)') "'end'"
          if (redox_master.eq.'o2(aq)') then
            write(*,'(1x,a)') 'end of database backup: redox.dbs'
            write(idbs_bk, '(a/)') '<------ redox.dbs: end of intra-aqueous kinetic reactions ------>'
          elseif (redox_master.eq.'h2(aq)') then
            write(*,'(1x,a)') 'end of database backup: redoxh2.dbs'
            write(idbs_bk, '(a/)') '<------ redoxh2.dbs: end of intra-aqueous kinetic reactions  ------>'
          elseif (redox_master.eq.'e-1') then
            write(*,'(1x,a)') 'end of database backup: redoxe.dbs'
            write(idbs_bk, '(a/)') '<------ redoxe.dbs: end of intra-aqueous kinetic reactions  ------>'
          end if
        end if
      end if

      return

!c  exit program if end of database is reached and redox couple
!c  was not found 

997   continue
      backspace(irdbs)
      read(irdbs,'(a)') strbuffer
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,'(2a)') 'error reading in redox database: ',trim(strbuffer)
        write(*,*) 'SIMULATION TERMINATED'
        write(*,'(2a)') 'error reading in redox database: ',trim(strbuffer)
        close(ilog)
      end if

#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,'(72a)') ('-',i=1,72)
        write(ilog,'(2a)') 'redox couple not in database - check',     &
     &                     ' input file' 
        write(ilog,'(72a)') ('-',i=1,72)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop
      end
  
