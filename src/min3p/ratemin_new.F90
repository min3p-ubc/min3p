!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 869 $
!> $Author: dsu $
!> $Date: 2023-08-18 09:44:21 -0700 (Fri, 18 Aug 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/ratemin_new.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine ratemin_new
!c ----------------------
!c
!c compute absolute dissolution-precipitation rates of minerals
!c based on new database format
!c
!c sign convention: dissolution -
!c                  precipitation +
!c
!c written by:      Uli Mayer - November 11, 01
!c
!c last modified:   Uli Mayer - February 3, 02
!c                  added hyperbolic and inhibition terms
!c                  for minerals
!c                  Uli Mayer - August 8, 02
!c                  added hyperbolic and inhibition terms 
!c                  for components as species in solution 
!c
!c                  Danyang Su - March 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           aream              = reactivity term                     + -
!c           c(nc)              = concentrations of free species      + -
!c                                - new time level [moles/l h2o]
!c           cx(nx)             = concentrations of secondary         + -
!c                                aqueous species
!c           gammac(nc)         = activity coefficients of free       + -
!c                                species
!c           gammax(nx)         = activity coefficient of             + -
!c                                secondary aqueous species
!c           phim               = volume fractions of minerals        + -
!c           phimold            = volume fractions of minerals        + -
!c                                - old time level
!c           ratem              = absolute dissolution-precipitation  * +
!c                                rate of mineral
!c                                [moles/(l bulk*day)
!c           totc(nc)           = total aqueous component             + -
!c                                concentrations - new time level
!c                                [moles/l h2o]
!c
!c common:
!c chem.f:   real*8:
!c           -------
!c           diffm(ndr*nm,nthreads)
!c                              = free diffusion coefficient of       + -
!c                                primary reactant in water
!c                                (transport controlled reactions)
!c           eqm(nm,nthreads)   = equilibrium constants for minerals  + -
!c           fmdi(nrc*nc)       = inhibition constants - T^a          + - 
!c           fmdm(nrc*nc)       = half saturation constants - T^a     + -
!c           fmic(nrc*nc)       = inhibition constants - C^c          + - 
!c           fmhc(nrc*nc)       = half saturation constants - C^c     + -
!c           fmdpi(nrc*nm)      = inhibition constants - phi^m        + - 
!c           fmdpm(nrc*nm)      = half saturation constants - phi^m   + -
!c           orddc(nrc*nm)      = order of free species in            + -
!c                                dissolution reaction
!c           orddcx(nrc*nm)     = order of secondary aqueous          + -
!c                                species in dissolution reaction
!c           orddt(nrc*nm)      = order of total aqueous component    + -
!c                                concentration in dissolution
!c                                reaction
!c           ordmdi(nrc*nc)     = order of inhibition terms for       + -
!c                                dissolution-precipitation reactions
!c                                - T^a
!c           ordmdm(nrc*nc)     = order of hyperbolic terms for       + -
!c                                dissolution-precipitation reactions
!c                                - T^a
!c           ordmic(nrc*nc)     = order of inhibition terms for       + -
!c                                dissolution-precipitation reactions
!c                                - C^c
!c           ordmhc(nrc*nc)     = order of hyperbolic terms for       + -
!c                                dissolution-precipitation reactions
!c                                - C^c
!c           ordmdpi(nrc*nm)    = order of inhibition terms for       + -
!c                                dissolution-precipitation reactions
!c                                - phi^m
!c           ordmdpm(nrc*nm)    = order of hyperbolic terms for       + -
!c                                dissolution-precipitation reactions
!c                                - phi^m
!c           ordm(ndr*nm)       = exponent m for reaction rate law    + -
!c           ordn(ndr*nm)       = exponent n for reaction rate law    + -
!c           rated(ndr*nm,nthreads)      
!c                              = rate constants for dissolution      + -
!c                                reactions
!c           ratemp(ndr*nm,nthreads)
!c                              = reaction rates for minerals         * +
!c                                including parallel reactions
!c           satm(nm,nthreads)  = saturation indices                  * +
!c           xnud(ndr*nm)       = stoichiometric coefficients of      + -
!c                                reacting species in transport
!c                                controlled dissolution reaction
!c           xnum(nm*nc)        = stoichiometric coefficients of      + +
!c                                components in mineral
!c
!c           integer*4:
!c           ----------
!c           iam(nm+1)          = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in mineral
!c           iamd(nm+1)         = pointer array to dissolution        + -
!c                                reactions
!c           iamdc(ndr*nm+1)    = pointer array to free species       + -
!c                                involved in dissolution reactions
!c           iamdcx(ndr*nm+1)   = pointer array to secondary aqueous  + -
!c                                species involved in dissolution
!c                                reactions
!c           iamdi(ndr*nm+1)    = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms - T^a)
!c           iamdm(ndr*nm+1)    = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms - T^a)
!c           iamic(ndr*nm+1)    = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms - C^c)
!c           iamhc(ndr*nm+1)    = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms - C^c)
!c           iamdpi(ndr*nm+1)   = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms 
!c                                - phi^m)
!c           iamdpm(ndr*nm+1)   = row pointer array to reactants      + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms 
!c                                - phi^m)
!c           iamdt(ndr*nm+1)    = pointer array to total aqueous      + -
!c                                component concentrations involved
!c                                in dissolution reactions
!c           jam(nm*nc)         = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in mineral
!c           jamd(nrc*nm)       = pointer array to parallel reactions + -
!c                                involved in dissolution reactions
!c           jamdc(nrc*nm)      = pointer array to free species       + -
!c                                involved in dissolution reactions
!c           jamdcx(nrc*nm)     = pointer array to secondary aqueous  + -
!c                                species involved in dissolution
!c                                reactions
!c           jamdi(nrc*nm)      = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms - T^a)
!c           jamdm(nrc*nm)      = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms - T^a)
!c           jamic(nrc*nm)      = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms - C^c)
!c           jamhc(nrc*nm)      = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms - C^c)
!c           jamdpi(nrc*nm)     = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms - 
!c                                phi^m)
!c           jamdpm(nrc*nm)     = column pointer array to reactants   + -
!c                                in dissolution-precipitation
!c                                reactions (hyperbolic terms - phi^m)
!c           jamdt(nrc*nm)      = pointer array to total aqueous      + -
!c                                component concentrations involved
!c                                in dissolution reactions
!c           nm                 = number of minerals specified        + -
!c           nc                 = number of components                + -
!c           nx                 = number of aqueous complexes         + -
!c
!c
!c           logical:
!c           --------
!c           far_from_equil(nm) = .true.  -> far from equilibrium     + -
!crevaff           
!c           reverse_affinity_term(nm) = .true. -> reverse affinity   + - 
!c                                                 term if IAP/K > 1                   
!crevaff
!c
!c           character:
!c           ----------
!c           rate_control(nm)   = rate controlling process for        + -
!c                                dissolution-precipitation reaction
!c                                'surface'   = surface controlled
!c                                              reaction
!c                                'transport' = transport controlled
!c                                              reaction
!c                                'mixed'     = mixed control
!c           reaction_type(nm)  = type of dissolution-precipitation   + -
!c                                reaction
!c
!c local:    real*8:
!c           -------
!c           prodrc             = product of reacting species
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter
!c           istart             = pointer (start of reaction set) 
!c           istop              = pointer (end of reaction set)
!c           ireac              = counter (number of dissolution/ 
!c                                         precipitation reactions)
!c           istart2            = pointer (start of species involved) 
!c           istop2             = pointer (end of species involved)
!c           ic                 = counter (components)
!c           im2                = counter (minerals)
!c           ix                 = counter (secondary aqueous species)
!c
!c external: raoult   = compute dissolution rate of organic compound
!c                      from organic mixture based on raoult's law
!c ----------------------------------------------------------------------
  
      subroutine ratemin_new(totc,c,cx,gammac,gammax,sw,ratem,phim,    &
                             phimold,aream,rootdens,im,tid)

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use chem
      use gen, only : idbg, rank, b_enable_output, ilog,               &
                      b_rate_satcorr, rate_satcorr
  
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      integer :: im, tid 
      integer :: i, i1, ic, ic2, i2, i3, ii, im2, icur, icount,        &
                 itemp, info_debug, ireac, istart, istop, istart2,     &
                 istop2, istart3, istop3, itop, ibottom, next, ix, im3 
      
      real*8 :: totc, c, cx, gammac, gammax, sw, ratem, phim, phimold      
      real*8 :: aream, rootdens, r1_iap_k, prodrc, prodrcinc, conc_m
      real*8 :: alphar, alphartot, alphartop, gammatemp, sumic, sumix
      real*8 :: salinity, sar
      real*8 :: a, b
      logical :: summed_species

      dimension c(*),cx(*),gammac(*),gammax(*),totc(*),phim(*)

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0
      real, parameter  :: pi = 3.141592653589793d0
      
      external :: raoult

      real*8, external :: satcorr_curve
     
      r1_iap_k = 0.0d0

!c  compute dissolution rate for organic compound based on Raoult's law

      if (reaction_type(im).eq.'raoult') then

        call raoult(c,gammac,ratem,phim(im),phimold,aream,im,tid)
        return

      end if

!c  initialize total reaction rate

      ratem = r0

!c  initialize parallel reaction rates

      istart = iamd(im)
      istop = iamd(im+1)-1

      do ireac = istart,istop
        ratemp(ireac,tid) = r0
      end do

!c  calculate saturation index for current mineral except for
!c  far from equilibrium dissolution-precipitation reactions

!c_isotope
!c calculate the saturation index for isotopes     
!c need to total isotopes to get accurate activity for the component  
      if (.not.far_from_equil(im)) then
        if (isofrac(im)) then
          satm(im,tid) = eqm(im,tid)**(-r1)          
          ireac = iamd(im)            
          istart = iam(im)
          istop = iam(im+1)-1 
                    
          do i1 = istart, istop ! loop through components in mineral
            icount = 0
            ic = jam(i1)
            next = 0
            do i = 1, nifrm(im)  ! loop through isotope sets
                istart2 = next + iamdiso(im)
                icur = iamdiso2(im) + i - 1
                istop2 = iamdiso(im) + jamdiso2(icur) - 1
                next = jamdiso2(icur)
                gammatemp = r0
                !loop through isotope compents in set
                do i2 = istart2, istop2 
                  ii = jamdiso(i2)
                  !check to see if component is an isotope
                  if (ii.eq.ic) then 
                    icount = icount + 1
                    !if so sum the isotope activities
                    do i3 = istart2, istop2 
                        ic2 = jamdiso(i3)
                        gammatemp = gammatemp + c(ic2)
                    end do 
                    gammatemp = gammac(ic)*gammatemp
                    satm(im,tid) = satm(im,tid) *(gammatemp**xnum(i1))
                  end if
                end do
            end do  !i2
          !if not calculate the saturaton index the normal way  
            if (icount.eq.0) then    
              satm(im,tid) = satm(im,tid) * (gammac(ic)*c(ic))**xnum(i1)
            end if
          end do   !i1    
        else 
          satm(im,tid) = eqm(im,tid)**(-r1)          
          istart = iam(im)
          istop = iam(im+1)-1
          do i1 = istart,istop
            ic = jam(i1)
            satm(im,tid) = satm(im,tid) * (gammac(ic)*c(ic))**xnum(i1)
          end do
        end if
      end if

!c  compute total dissolution/precipitation rate for surface controlled
!c  dissolution/precipitation reactions

      if (rate_control(im).eq.'surface' .or.                           &
          rate_control(im).eq.'root') then     !FG August 2021

!c  compute rates only for specified reaction direction

        if (reaction_type(im).eq.'reversible' .or.                     &
            reaction_type(im).eq.                                      &
             'dissolution_far_from_equilibrium' .or.                   &
            (reaction_type(im).eq.'dissolution_to_equilibrium'.and.    &
             dg_lim(im)-satm(im,tid).gt.r0) .or.                       &
            reaction_type(im).eq.                                      &
            'precipitation_far_from_equilibrium' .or.                  &
            (reaction_type(im).eq.'precipitation_to_equilibrium'.and.  &
             dg_lim(im)-satm(im,tid).lt.r0)) then

!c  loop over parallel dissolution reactions

          istart = iamd(im)
          istop = iamd(im+1)-1

          do ireac = istart,istop
  
!c  scale reaction rate depending on equilibrium condition except
!c  for far-from-equilibrium reactions 

            if (reaction_type(im).eq.                                 &
                'dissolution_far_from_equilibrium') then
                                                                       
              prodrc = -rated(ireac,tid)

              if (rate_control(im).eq.'root') then
                prodrc = prodrc*rootdens
              end if
                                                                       
            elseif (reaction_type(im).eq.                             &
                   'precipitation_far_from_equilibrium') then

              prodrc = rated(ireac,tid)

              if (rate_control(im).eq.'root') then
                prodrc = prodrc*rootdens
              end if

!culi 18/05/06 modified formulation for precipitation_to_equilibrium   !MX sept2012
!culi to avoid excessively large precipitation rates 
            elseif (reaction_type(im).eq.                             &
                   'precipitation_to_equilibrium') then                
              prodrc = rated(ireac,tid) * (r1 - satm(im,tid)**(-r1))
            else

!c  commented out to avoid NaN problems              
              ! prodrc = -rated(ireac)                                 &
              !        * (r1 - satm(im)**ordm(ireac))**ordn(ireac)
              ! 
              !if(isnan(prodrc)) then
              !    write(*,*) "prodrc is nan4: ", r1 - satm(im)**ordm(ireac),  ordn(ireac)
              !end if
              
              !Lasaga et al. (1994) equation. dsu, 2012-12-20
              
              if (b_ratelaw_exponent_n) then

                if (reverse_affinity_term(im).and.                    &
                    satm(im,tid).gt.r1) then
!crevaff
                    prodrc = rated(ireac,tid) *                       &
                             (r1 - satm(im,tid)**(-ordm(ireac)))**    &
                             ordn(ireac)
!crevaff
                else
                    
                  r1_iap_k = dg_lim(im) - satm(im,tid)**ordm(ireac)
                  if(r1_iap_k>0) then       !satm(im) < 1 as ordm(ireac) is positive
                      if (reaction_type(im) == 'precipitation_to_equilibrium') then
                          prodrc = 0.0d0
                      else
                          prodrc = -rated(ireac,tid) *                &
                                   r1_iap_k**ordn(ireac)
                      end if
                  else                      !satm(im) >= 1 as ordm(ireac) is positive 
                      if (reaction_type(im) == 'dissolution_to_equilibrium') then
                          prodrc = 0.0d0
                      else
                          prodrc = rated(ireac,tid) *                 &
                                   (abs(r1_iap_k))**ordn(ireac)
                      end if
                  end if
                  
                end if  
                  
              else
!crevaff
                if (reverse_affinity_term(im).and.                    &
                    satm(im,tid).gt.r1) then
                    
                    prodrc = rated(ireac,tid) *                       &
                             (dg_lim(im) - satm(im,tid)**(-ordm(ireac)))
                else
                    prodrc = -rated(ireac,tid) *                      &
                             (dg_lim(im) - satm(im,tid)**ordm(ireac))
                end if    
!crevaff                
              end if
              
     !--old--
     !         prodrc = -rated(ireac)                                  &
     !&               * (r1 - satm(im)**ordm(ireac))
                 
            end if

          
!c  form product of reacting components in terms of total 
!c  aqueous component concentrations

            istart2 = iamdt(ireac)
            istop2 = iamdt(ireac+1)-1

            do i1 = istart2,istop2

              ic = jamdt(i1)
              prodrc = prodrc * totc(ic)**orddt(i1)

            end do

!c  form product of reacting components as species in solution

            istart2 = iamdc(ireac)
            istop2 = iamdc(ireac+1)-1

            do i1 = istart2,istop2

              ic = jamdc(i1)
              prodrc = prodrc * (gammac(ic)*c(ic))**orddc(i1)

            end do

!c  form product of reacting complexed species

            istart2 = iamdcx(ireac)
            istop2 = iamdcx(ireac+1)-1

            do i1 = istart2,istop2

              ix = jamdcx(i1)
              prodrc = prodrc * (gammax(ix)*cx(ix))**orddcx(i1)

            end do

!c noble gas ingrowth, from product of reacting mineral's concentration

            istart2 = iamdcm(ireac)
            istop2 = iamdcm(ireac+1)-1

            do i1 = istart2,istop2

              ix = jamdcm(i1)

              !c conc_mol = phim*densm(im)/gfwm(im) => mol/cvol
              !c conver unit to mol/L bulk = phim*densm(im)/gfwm(im)*1.0e3
              !c apply first order decay based on mineral concentration in ppm

              conc_m = phim(ix)*densm(ix)/gfwm(ix)*1.0e3
              prodrc = prodrc * (conc_m**ordmdcm(i1))
            end do

!c form product of reacting minerals
            
            istart2 = iamdphm(ireac)
            istop2 = iamdphm(ireac+1)-1

            do i1 = istart2,istop2

              ix = jamdphm(i1)
              prodrc = prodrc * (phim(ix)**ordmdphm(i1))
            end do

!c_uranium
!c  form product of summed reacting complexed species

            istart2 = iamdscx(ireac)
            istop2 = iamdscx(ireac+1)-1
            summed_species = .false.
            sumix = r0

            do i1 = istart2,istop2
              ix = jamdscx(i1)
              sumix = sumix + (gammax(ix)*cx(ix)*orddscx(i1))
              summed_species = .true.
            end do

            if (summed_species) then
              prodrc = prodrc * sumix**orddsumx(im)     
            end if       

!c  hyperbolic terms - T^a

            istart2 = iamdm(ireac)
            istop2 = iamdm(ireac+1)-1
      
            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamdm(i1)

                prodrc = prodrc                                       &
     &                 * (totc(ic)/(fmdm(i1) + totc(ic)))**ordmdm(i1)

              end do

            end if
            
!c_isotopes
!c  hyperbolic terms - sum T^a

            istart2 = iamdsta2(ireac)
            istop2 = iamdsta2(ireac+1)-1
            itemp = r0
            
            do i1 = istart2, istop2                  

               istart3 = iamdsta(ireac)+itemp
               istop3 = istart3+ntsc(i1)-1
               sumic = r0
               do i2 = istart3, istop3
                 ic = jamdsta(i2)
                 sumic = sumic + totc(ic)
              end do

              prodrc = prodrc                                          &
     &              * (sumic/(fmdsta(i1) + sumic))**orddsta(i1)
               
              itemp = itemp + ntsc(i1)

            end do

!c_isotopes
!c  isotope fractionation - compute rate fractions for isotope dependent reactions
            
            !determine ratios and combine with alphas
            if ((.not.far_from_equil(im)).and.(satm(im,tid).lt.r1)) then
              next = 0 
              do i = 1, nifrm(im)  ! loop through isotope sets 
                istart2 = next + iamdiso(im)
                icur = iamdiso2(im) + i - 1
                istop2 = iamdiso(im) + jamdiso2(icur) - 1
                next = jamdiso2(icur)
                ibottom = jamdpair(istart2)
                alphartot = r1
                alphartop = r1
                !loop through isotope compents in set
                do i2 = istart2+1, istop2 
                    itop = jamdpair(i2)
                    alphar = phim(itop)/phim(ibottom)*jamdalpha(i2)
                    alphartot = alphartot + alphar
                    if (itop.eq.im) then
                      alphartop = alphar
                    end if
                end do
                
                prodrc = prodrc*alphartop/alphartot

              end do
            else
              next = 0 
              do i = 1, nifrm(im)  ! loop through isotope sets
                istart2 = next + iamdiso(im)
                icur = iamdiso2(im) + i - 1
                istop2 = iamdiso(im) + jamdiso2(icur) - 1
                next = jamdiso2(icur)
                ibottom = jamdiso(istart2)
                alphartot = r1
                alphartop = r1
                !loop through isotope compents in set
                do i2 = istart2+1, istop2 
                    itop = jamdiso(i2)
                    alphar = totc(itop)/totc(ibottom)*jamdalpha(i2)
                    alphartot = alphartot + alphar
                
                    istart = iam(im)
                    istop = iam(im+1)-1 
                    do i1 = istart, istop
                        ic = jam(i1)
                        if (ic.eq.itop) then
                           alphartop = alphar
                        end if
                    end do
                end do
                
                prodrc = prodrc*alphartop/alphartot

              end do
            end if

!c  inhibition terms - T^a

            istart2 = iamdi(ireac)
            istop2 = iamdi(ireac+1)-1

            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamdi(i1)

                prodrc = prodrc                                       &
     &                 * (fmdi(i1)/(fmdi(i1)+totc(ic)))**ordmdi(i1)

              end do

            end if

!c  hyperbolic terms - C^c

            istart2 = iamhc(ireac)
            istop2 = iamhc(ireac+1)-1
      
            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamhc(i1)

                prodrc = prodrc                                       &
     &                 * (gammac(ic)*c(ic)                            &
     &                 / (fmhc(i1) + gammac(ic)*c(ic)))**ordmhc(i1)

              end do

            end if

!c  inhibition terms - C^c

            istart2 = iamic(ireac)
            istop2 = iamic(ireac+1)-1

            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                ic = jamic(i1)

                prodrc = prodrc                                       &
     &                 * (fmic(i1)                                    &
     &                 / (fmic(i1)+gammac(ic)*c(ic)))**ordmic(i1)

              end do

            end if

!c  hyperbolic terms - phi^m

            istart2 = iamdpm(ireac)
            istop2 = iamdpm(ireac+1)-1
      
            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                im2 = jamdpm(i1)

                prodrc = prodrc * (phim(im2) /                        &
     &                   (fmdpm(i1) + phim(im2)))**ordmdpm(i1)

              end do

            end if

!c  inhibition terms - phi^m

            istart2 = iamdpi(ireac)
            istop2 = iamdpi(ireac+1)-1

            if (istop2.ge.istart2) then

              do i1 = istart2,istop2

                im2 = jamdpi(i1)

                prodrc = prodrc * (fmdpi(i1) /                        &
     &                   (fmdpi(i1) + phim(im2)))**ordmdpi(i1)

              end do

            end if

!cmx compute the influence of salinity dependent mineral dissolution 
!      on the reaction rate for the case of sulfur bacteria reaction

            im3 = jamd(ireac)

            if (salinity_dependent(im3)) then
              salinity = 0.0
              do ic = 1, nc-1
                if (namec(ic) .ne. 'o2(aq)') then
                  salinity = salinity + gfwc(ic)*totc(ic)
                end if
              end do
          
              if (sdtype(im3) .eq. 'equation') then
                sar = 0.0d0
              
                if (salinity .le. min_salinity(im3)) then
                  sar = min_sar(im3)
                else if (salinity .ge. max_salinity(im3)) then
                  sar = max_sar(im3)
                else
                  do i = 1, nfac(im3)
                    sar = sar + sfac_sdmin(im3,i)*(salinity**(i-1))
                  end do
                end if 
                   
!c The strong inhibition of salinity on the sulfur water formation can be expresssed as cosine function
!c When the level of salinity is high enough, the reaction rate is completely blocked.
!c The consine function f=f(totc(ic)) is normalized to provide a coefficient sar between 0 and 1.0.
!c the function f=(cos(a*x+b)+1)/2
!c a and b is determined by providing the x values when f=0 and 1 from the input file.


              else if (sdtype(im) .eq. 'strong inhibition by one component') then
                sar = 0.0d0
                if (totc(inamec_inhib(im3)) .le.  min_salinity(im3)) then
                  sar = 1.0d0
                else if (totc(inamec_inhib(im3)) .ge. max_salinity(im3)) then
                  sar = 0.0d0
                else
                  a=0.0d0
                  b=0.0d0
                  a = 180/(max_salinity(im3) - min_salinity(im3))
                  b = - min_salinity(im3) * a
                  sar = (cos(pi/180*(a*totc(inamec_inhib(im3))+b))+1.0d0)/2.0d0
                end if 

              end if
          
              if (sar .gt. 0.0 .and. sar .le. 1.0) then
                prodrc = prodrc*sar
              else if (sar .le. 0.0) then
                prodrc = prodrc*1.0d-10
              else
                if (rank == 0 .and. b_enable_output) then
                  write(ilog,'(3a)') 'In file ratemin_new: error calculating ',&
                        'salinity dependent factor of mineral  ',namem(im3)
                  write(ilog,'(a,1pe15.6e3)') 'sfac_sdmin(im,1) ',sfac_sdmin(im3,1)
                  write(ilog,'(a,1pe15.6e3)') 'The salinity = ',salinity
                  write(ilog,'(a,1pe15.6e3)') 'The coefficient = ',sar
                  write(ilog,*) 'It should be between 0.0 to less or equal to 1.0.'                
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if
            end if

            
!c  compute total rate for surface controlled reactions
!c  [moles/(l bulk*day)] = [m^2 mineral/l bulk]
!c                          ----------- 
!c                       * [moles/(m^2 mineral * day)]
!c                                 -----------

            ratemp(ireac,tid) = aream * prodrc

!c  sum up parallel reaction rates for surface controlled
!c  dissolution/precipitation reactions

            ratem = ratem + ratemp(ireac,tid)

          end do       !loop over parallel diss/prec reactions

        else           !reaction_type

          ratem = r0
 
        end if         !reaction_type

!c  compute total dissolution rate for transport 
!c  controlled dissolution reactions

      elseif (rate_control(im).eq.'transport') then

        if (reaction_type(im).eq.'dissolution_far_from_equilibrium'.or.&
     &      reaction_type(im).eq.'reversible'.or.                      &
     &      (reaction_type(im).eq.'dissolution_to_equilibrium'.and.    &
     &       dg_lim(im)-satm(im,tid).gt.r0)) then

!c  compute total dissolution rate 
 
          istart = iamd(im)
          istop = iamd(im+1)-1

          do ireac = istart,istop

!c  scale reaction rate, if dissolution reaction is limited by
!c  equilibrium conditions 

            if (far_from_equil(im)) then
              prodrc = r1
            else
              prodrc = dg_lim(im)-satm(im,tid) 
            end if

!c  form product of reacting components in terms of total
!c  aqueous component concentrations

            istart2 = iamdt(ireac)
            istop2 = iamdt(ireac+1)-1

            do i1 = istart2,istop2
              ic = jamdt(i1)
              prodrc = prodrc * totc(ic)**orddt(i1)
            end do

!c  form product of reacting component species for current dissolution
!c  reaction, activity coefficients are here not considered explicitely,
!c  but are by definition included in the effective diffusion coefficient
 
            istart2 = iamdc(ireac)
            istop2 = iamdc(ireac+1)-1

            do i1 = istart2,istop2
              ic = jamdc(i1)
              prodrc = prodrc * c(ic)**orddc(i1)
            end do
 
!c  include complexed species in product of reacting species for current
!c  dissolution reaction
 
            istart2 = iamdcx(ireac)
            istop2 = iamdcx(ireac+1)-1
            do i1 = istart2,istop2
              ix = jamdcx(i1)
              prodrc = prodrc * cx(ix)**orddcx(i1)
            end do
 
!cmx compute the influence of salinity dependent mineral dissolution 
!      on the reaction rate for the case of sulfur bacteria reaction

            im3 = jamd(ireac)

            if (salinity_dependent(im3)) then
              salinity = 0.0
              do ic = 1, nc-1
                if (namec(ic) .ne. 'o2(aq)') then
                  salinity = salinity + gfwc(ic)*totc(ic)
                end if
              end do
          
              if (sdtype(im3) .eq. 'equation') then
                sar = 0.0d0
              
                if (salinity .le. min_salinity(im3)) then
                  sar = min_sar(im3)
                else if (salinity .ge. max_salinity(im3)) then
                  sar = max_sar(im3)
                else
                  do i = 1, nfac(im3)
                    sar = sar + sfac_sdmin(im3,i)*(salinity**(i-1))
                  end do
                end if
                    
!c The strong inhibition of salinity on the sulfur water formation can be expresssed as cosine function
!c When the level of salinity is high enough, the reaction rate is completely blocked.
!c The consine function f=f(totc(ic)) is normalized to provide a coefficient sar between 0 and 1.0.
!c the function f=(cos(a*x+b)+1)/2
!c a and b is determined by providing the x values when f=0 and 1 from the input file.


              else if (sdtype(im) .eq. 'strong inhibition by one component') then
                sar = 0.0d0
                if (totc(inamec_inhib(im3)) .le.  min_salinity(im3)) then
                  sar = 1.0d0
                else if (totc(inamec_inhib(im3)) .ge. max_salinity(im3)) then
                  sar = 0.0d0
                else
                  a=0.0d0
                  b=0.0d0
                  a = 180/(max_salinity(im3) - min_salinity(im3))
                  b = - min_salinity(im3) * a
                  sar = (cos(pi/180*(a*totc(inamec_inhib(im3))+b))+1.0d0)/2.0d0                  
                end if                     
              end if
          
              if (sar .gt. 0.0 .and. sar .le. 1.0) then
                prodrc = prodrc*sar
              else if (sar .le. 0.0) then
                prodrc = prodrc*1.0d-10
              else
                if (rank == 0 .and. b_enable_output) then
                  write(ilog,'(3a)') 'In file ratemin_new: error calculating ', &
                        'salinity dependent factor of mineral  ',namem(im3)
                  write(ilog,'(a,1pe15.6e3)') 'sfac_sdmin(im,1) ',sfac_sdmin(im3,1)
                  write(ilog,'(a,1pe15.6e3)') 'The salinity = ',salinity
                  write(ilog,'(a,1pe15.6e3)') 'The coefficient = ',sar
                  write(ilog,*) 'It should be between 0.0 to less or equal to 1.0.'                
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop
              end if
            end if
            
!c  compute rate
!c  [moles/(l bulk*day)] = [m mineral / m^3 bulk]
!c                          ---------   ---
!c                       * [m^3 h2o/m^3 mineral * m^2 mineral/day]
!c                          --- --- -----------   -----------
!c                       * [moles/l h2o]
!c                                  ---

            ratemp(ireac,tid) = - aream * diffm(ireac,tid)/xnud(ireac)*&
                                  prodrc

!c  sum up parallel rates

            ratem = ratem + ratemp(ireac,tid)

          end do  
 
!c  set reaction rate to zero for all other conditions
 
        else

          ratem = r0
 
        end if          !(reaction_type(im))

      end if            !(rate_control(im))

!c  saturation correction
      if (b_rate_satcorr .and. satcorr_flag(im))then
        ratem  = ratem * satcorr_curve(sw)
      end if

      return
    end   

