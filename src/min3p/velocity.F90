!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/velocity.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine velocity
!c -------------------
!c
!c compute average interfacial velocities in x,y,z directions 
!c for rectangular, cartesian finite volume discretization 
!c
!c written by:      Uli Mayer - June 6, 98
!c
!c last modified:   -
!c
!c                  Danyang Su - March. 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           cinfvs(nn)         = influence coefficient               + -
!c                                (variably saturated flow) 
!c           dimcv(3,nn)        = dimension of cells in x,y,z         + -
!c                                direction
!c           hhead(nn)          = hydraulic head                      + -
!c           uvsnew(nn)         = hydraulic head                      + -
!c           relperm(nn)        = relative permeability               + -
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           iavs(nn+1)         = row pointer array for 1d-scalar     + -
!c                                matrix
!c           idbg               = output for debugging information    + -
!c           ilog               = unit number, logbook                + -
!c           ivel               = unit number, average interfacial    + -
!c                                velocities
!c           javs(njavs)        = connectivity list for 1d-scalar     + -
!c                                matrix
!c           njavs              = number of global connections        + -
!c           nn                 = total number of control volumes     + -
!c           nvx                = number of control volumes           + -
!c                                in x direction
!c           nvy                = number of control volumes           + -
!c                                in y direction
!c           nvz                = number of control volumes           + -
!c                                in z direction
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           half_cells         = .true.  -> half cells on boundary   + -
!c           upstream           = .true.  -> upstream weighting       + -
!c
!c common:   -
!c
!c local:    real*8:
!c           -------
!c           aread(3,12)        = A_ij/d_ij for current "pseudo
!c                                dispersion element" associated
!c                                with control volume ivol, up to 4
!c                                entries for each dimension
!c           areai              = interfacial area
!c           dflux              = interfacial flux
!c           eps                = constant
!c           r0                 = constant
!c           rhalf              = constant
!c           vel(3)             = average interfacial velocities
!c
!c           integer*4:
!c           ----------
!c           cvpair(3,12,2)     = pointers to connected control 
!c                                volumes in each pair for each 
!c                                dimension
!c           i1                 = pointer (connectivity list)
!c           i1sav              = pointer (connectivity list)
!c           idim               = pointer (dimensions)
!c           idim2              = pointer (dimensions)
!c           idim3              = pointer (dimensions)
!c           ipair              = counter (control volume pairs in
!c                                         dimension)
!c           ivol               = pointer (control volume i)
!c           jvol               = pointer (connected control volume j)
!c           ivol2              = counter (control volumes)
!c           ivx                = counter (number of control
!c                                volumes in x-direction)
!c           ivy                = counter (number of control
!c                                volumes in y-direction)
!c           ivz                = counter (number of control
!c                                volumes in z-direction)
!c           npair(3)           = number of control volume pairs
!c                                in dimension
!c
!c           character:
!c           ----------
!c           iups               = upstream pointer
!c
!c external: cliqdisp  = find control volume pairs for computation of 
!c                       average interfacial velocities
!c           fluxfs    = flux function for fully saturated flow 
!c           fluxvs    = flux function for variably saturated flow
!c ----------------------------------------------------------------------

      subroutine velocity(nvx, nvy, nvz, iavs, javs, cinfvs, dimcv, xg,&
                          yg, zg, uvsnew, hhead, relperm, pornew,      &
                          idbg, ilog, ivel, upstream, fully_saturated, &
                          njavs, nn, nn_loc, half_cells,               &
                          cinfrad, radial_coord, offset)

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use gen, only : rank, b_enable_output, node_idx_lg2l,            &
                      b_output_binary,realbuffer,b_output_mpiio_single,&
                      b_output_multizone, ascii_fmt,                   &
                      b_use_fixed_flow_vel, fixed_flow_vel,            &
                      mem_cur, mem_max, memory_monitor,                &
                      b_mpiarray_ivel_init,mpiarray_filetype_ivel,     &
                      mpiarray_sizes_gbl_ivel,mpiarray_sizes_sub_ivel, &
                      mpiarray_starts_sub_ivel
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      use module_binary_mpiio, only : binary_write_data,               &
                                      binary_subarray_initialize

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
      
      external cliqdisp, checkerr

!c  passed variables

      integer nvx, nvy, nvz, njavs, nn, nn_loc, iavs(nn+1),            &
              javs(njavs), idbg, ilog, ivel, ierr
                                                                       
      logical half_cells, fully_saturated, upstream, radial_coord
                                                                       
      real*8  uvsnew(nn), hhead(nn), relperm(nn), dimcv(3,nn),         &
              pornew(nn), cinfvs(njavs), xg(nn), yg(nn), zg(nn),       &
              cinfrad(njavs) 

      real*8, external :: fluxfs, fluxvs
      
#ifdef PETSC
      integer(kind=MPI_OFFSET_KIND) :: offset, offset_temp
#else
      integer*8 :: offset, offset_temp
#endif

!c  local variables

      real*8 eps, r0, rhalf
      parameter (eps = 1.0d-300, r0 = 0.0d0, rhalf = 0.5d0)

      real*8 aread(3,12),areax(3,12),vel(3), dist(3,12), areai, dflux, &
             xg_out, yg_out, zg_out

      integer ivol, ivz, ivy, ivx, i1, jvol, i1sav, idim, npair(3),   & 
     &        cvpair(3,12,2), ipair, idim2, idim3, ivol2, ivol_l

      character*1 iups
      
      if (b_output_binary) then 
        allocate(realbuffer(nn_loc*6), stat = ierr)
        call checkerr(ierr,'velocity-realbuffer',ilog)
        realbuffer = 0.0d0
        call memory_monitor(sizeof(realbuffer),'realbuffer',.true.)
      end if

!c  compute average interfacial velocities

      ivol2 = 0
      ivol_l = 0

      do ivz = 1, nvz          !increments in z-direction
        do ivy = 1, nvy        !increments in y-direction
          do ivx = 1, nvx      !increments in x-direction

            ivol2 = ivol2 + 1  !counter - control volumes
            
            !skip ghost nodes
#ifdef PETSC
            if(node_idx_lg2l(ivol2) < 0) then
                cycle
            end if
#endif
         
!c  find node pairs for interfacial velocities
            call cliqdisp (nvx, nvy, nvz, ivx, ivy, ivz,              &
     &                     cvpair, npair,aread,areax,dist,dimcv,      &
     &                     half_cells,                                &
     &                     iavs,javs,njavs,                           &
     &                     nn,idbg,cinfrad,radial_coord)
                                                                      
!c  check connections
                                                                       
            if ((nvx .gt. 1 .and. npair(1) .eq. 0) .or.               &
     &          (nvy .gt. 1 .and. npair(2) .eq. 0) .or.               &
     &          (nvz .gt. 1 .and. npair(3) .eq. 0)) goto 400
            
            ivol_l = ivol_l + 1

!c  loop over the dimensions x,y,z

            do idim = 1, 3

              idim2 = idim + 1
              idim3 = idim + 2
              if (idim2 .gt. 3) idim2 = idim2 - 3
              if (idim3 .gt. 3) idim3 = idim3 - 3

!c  zero average interfacial velocity

              vel(idim) = r0

!c  loop over the number of control volume pairs in the dimension

              do ipair = 1, npair(idim)

                ivol = cvpair(idim, ipair, 1)
                jvol = cvpair(idim, ipair, 2)

                do i1 = iavs(ivol), iavs(ivol+1)-1
                  if (javs(i1) .eq. jvol) then
                    i1sav = i1
                    go to 500
                  endif
                end do
                if (rank == 0) then
                  write(ilog,*) ' error-cannot find jvol in list'
                  write(ilog,*) ' ivol, jvol ', ivol, jvol
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop

500             continue

!c  calculate average interfacial area between nodes
                if (.not.b_use_fixed_flow_vel) then
!cprovi------------------------------------------------
!cprovi Assign the interfacial area
!cprovi------------------------------------------------                
                  areai = areax(idim, ipair)

!c  find flux between control volume pair

                  if (.not.fully_saturated) then
                    if (upstream) then
                      iups = 'i'                            !h_i >= h_j
                      if (hhead(jvol).gt.hhead(ivol)) then  !h_j > h_i
                        iups = 'j'
                      end if
                    end if
  
                    dflux = - fluxvs(upstream,hhead(ivol),             &
                                     hhead(jvol),relperm(ivol),        &
                                     relperm(jvol),iups,               &
                                     cinfvs(i1sav))
                                                                       
                  elseif (fully_saturated) then 
                                                                       
                    dflux = - fluxfs(uvsnew(ivol),uvsnew(jvol),        &
                                   cinfvs(i1sav))
                  end if


!c  velocity is the flux (m^3/day) divided
!c  by the interfacial area between the two control volumes
!c  this is darcy velocity, not the linear groundwater velocity, for the later one,
!c  the velocity should be divided by the porosity, averaged by adjacent vols (DSU, 2017-08-02)
!c  vel(idim) = vel(idim) - dflux/areai/(pornew(ivol)+pornew(jvol))*2.0d0

                  vel(idim) = vel(idim) - dflux / areai
                end if

              end do

!c  find the average interfacial velocity in the x,y,z directions
              if (.not.b_use_fixed_flow_vel) then
                vel(idim) = vel(idim)/(float( npair(idim) ) + eps)
              end if

            end do

            if (b_use_fixed_flow_vel) then
              vel(1) = fixed_flow_vel%x
              vel(2) = fixed_flow_vel%y
              vel(3) = fixed_flow_vel%z
            end if

!c  write average interfacial velocities to output file

            if (nvx.gt.1) then
              xg_out = xg(ivol2) - rhalf * dimcv(1,ivol2)
            else
              xg_out = xg(ivol2)
            end if

            if (nvy.gt.1) then
              yg_out = yg(ivol2) - rhalf * dimcv(2,ivol2)
            else
              yg_out = yg(ivol2)
            end if

            if (nvz.gt.1) then
              zg_out = zg(ivol2) - rhalf * dimcv(3,ivol2)
            else
              zg_out = zg(ivol2)
            end if
            
            if (b_output_binary) then

              realbuffer((ivol_l-1)*6+1:ivol_l*6) = (/xg_out, yg_out,  &
                         zg_out, vel(1), vel(2), vel(3)/)
              
            else
              write(ivel,ascii_fmt) xg_out,yg_out,zg_out,              &
                                     (vel(idim),idim=1,3)
            end if
            
400         continue

          end do
        end do
      end do
      
      if (b_output_binary) then 
        if (b_output_multizone .or. .not.b_output_mpiio_single) then
          call binary_write_data(ivel, ivol_l*6, realbuffer,           &
                       offset,b_output_mpiio_single)
        else
          call binary_subarray_initialize(6,b_mpiarray_ivel_init,      &
                      .true.,mpiarray_filetype_ivel,                   &
                      mpiarray_sizes_gbl_ivel,mpiarray_sizes_sub_ivel, &
                      mpiarray_starts_sub_ivel)
          call binary_write_data(ivel, ivol_l*6, realbuffer,           &
                       offset,mpiarray_filetype_ivel)
        end if
        call memory_monitor(-sizeof(realbuffer),'realbuffer',.true.)
        deallocate(realbuffer)
      end if

      return
      end

