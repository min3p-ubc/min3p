!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 879 $
!> $Author: dsu $
!> $Date: 2024-02-17 10:15:21 -0800 (Sat, 17 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/jacrt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacrt
!c ----------------
!c
!c construct Jacobian matrix and rhs-vector (reactive transport)
!c
!c modified for density dependent flow
!c
!c written by:      Uli Mayer - Aug 15, 96
!c
!c last modified:   Uli Mayer - December 5, 96
!c                  Uli Mayer - November 12, 01
!c                  added new database format
!c                  for dissolution-precipitation reactions
!c
!c                  Tom Henderson - October 22, 2002
!c                  Sergi Molins - January 20, 2003
!c                  added advective transport of (ideal) gases
!c                  Sergi Molins - May 2, 2006
!c                  added multi-component diffusion
!c                  Sergi Molins - June 12, 2006
!c                  gsatmin = 0.0 (larger values cause DGM/ MS
!c                  modules to fail under saturated conditions)
!c                  relpgij passed to dgm_dfluxdg.f
!c
!c                  Danyang Su - March 27, 2014
!c                  Add gas advection, modified from Sergi Molins's codes
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c bbls.f    real*8
!c           --------
!c   
!c           integer*4
!c           ---------
!c           ibub               = counter for inner bubble iteration loop
!c
!c           logical
!c           -------
!c           update_component(nc)    = .true.-> component is an assigned gas
!c                                    component or h+ and totcnew is updated in jacrt
!c                                    .false.-> totcnew is not updated in jacrt
!c  
!c gen.f:    real*8:
!c           -------
!c           astor(n)           = storage term (non-competitive       * +
!c                                sorption)
!c           area(nm,nn)        = specific reactive surface area of   + - 
!c                                mineral (global system)
!c           art(njart)         = jacobian matrix                     + -
!c           brt(nn*n)          = rhs vector                          + -
!c           cflux(ncon,n)      = interfacial mass fluxes             * *
!c                                (aqueous phase)
!c           cinfrt_da(njavs)   = influence coefficients              + -
!c                                (dispersion - aqueous phase)
!c           cinfrt_dg(njavs)   = influence coefficients              + -
!c                                (diffusion - gaseous phase)
!c           cinfrt_va(njavs)   = influence coefficients              + -
!c                                (advection - aqueous phase)
!c           cinfrt_g(njavs)    = influence coefficients              + -
!c                                (advection - gaseous phase)
!c           hhead(nn)          = hydraulic head                      + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c           cmnew(nm,nn)       = mineral concentrations              + -
!c                                - new time level [moles/l bulk]
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           cec_g(nn)          = cation exchange capacity (meq/100g) + -
!c                                - global system
!c           cstor(n)           = storage term (aqueous phase)        * *
!c           cvol(nn)           = nodal volumes                       + -
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           distcoff_rt(nc,nn) = sorption distribution coefficient   + -
!c                                [-], [l bulk/l bulk]
!c                                - reactive transport
!c           delt               = time step                           + -
!c           dinc_rt            = factor to compute increment for     + -
!c                                numerical differentiation
!c           dtotcflux(n)       = derivatives of total mass fluxes    * +
!c                                (aqueous phase)
!c           dtotgflux(n)       = derivatives of total mass fluxes    * +
!c                                (gaseous phase)
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + +
!c                                species
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles / l air]
!c           gflux(ncon,n)      = interfacial mass fluxes             * *
!c                                (gaseous phase)
!c           gstor(n)           = storage term (gaseous phase)        * *
!c           phi(nm,nn)         = volume fractions of minerals        + -
!c           phiold(nm,nn)      = volume fractions of minerals        + -
!c                                (old time level)
!c           pornew(nn)         = porosity                            + -
!c           por_thresh_min     = minimal porosity threshold          + -
!c           ratemdp(nm,nn)     = absolute dissolution-precipitation  * +
!c                                rates of minerals
!c           sionnew(nn)        = ionic strength of solution          + +
!c                                - new time level
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            + -
!c                                - old time level
!c           sgnew(nn)          = gaseous phase saturation            + -
!c                                - new time level
!c           sgold(nn)          = gaseous phase saturation            + -
!c                                - old time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totaold(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                non-competitive sorption 
!c                                - old time level [moles/l bulk]
!c           totanew(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                non-competitive sorption
!c                                - new time level [moles/l bulk]
!c           totcflux(n)        = total mass fluxes (water phase)     * *
!c           totcnew(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totcold(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totgflux(n)        = total mass fluxes (gaseous phase)   * *
!c           totgnew(nc,nn)      = total gaseous component             * +
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totgold(nc,nn)      = total gaseous component             + -
!c                                concentrations
!c                                - old time level [moles/l air]
!c           totmdp(n,nn)       = total source/sink term towards      * +
!c                                total aqueous component
!c                                concentrations due to mineral
!c                                dissolution-precipitation reactions
!c           totsnew(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c           totsnew_ion(n,nn)  = total sorbed component              * +
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsnew_surf(n,nn) = total sorbed component              * +
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (surface-complex)
!c           totsold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c           totsold_ion(n,nn)  = total sorbed component 
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsold_surf(n,nn) = total sorbed component 
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (surface-complex)
!c
!c           added for gas advection and multi-component diffusion
!c
!c           deltaij(njavs)     = distance between i-j                + -
!c           gmfrac(ng,nn)      = gas molar fractions at c.v. i       * +
!c           gporij(njavs)      = gas filled porosity                 + -
!c           relpermg(nn)       = relative permeability (gas phase)   * +
!c           tauij(njavs)       = tortuosity (gas phase)              + -
!c           
!c           integer*4:
!c           ----------
!c           i2up(nn)           = pointer array to second upstream    + -
!c                                point
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           idbg               = unit number - debugging file        + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           javs(njavs)        = connectivity list                   + -
!c           lart(njavs+1)      = pointer array                       + -
!c           kadbl(n,n)         = pointer array for conversion to     + -
!c                                sparse format (diagonal block
!c                                matrices)
!c           kaobl(n,n)         = pointer array for conversion        + -
!c                                to sparse format
!c                                (off-diagonal block matrices)
!c           kart(njart)        = mapping pointer                     + -
!c                                (global block -> nd-scalar)
!c           nn                 = total number of control volumes     + -
!c           n                  = number of primary unknowns          + -
!c     
!c           logical:
!c           --------
!c           analyt_deriv_rt    = .true.  -> form derivatives         + -
!c                                           analytically
!c           pore_clogging      = .true.  -> pore clogging model      + -
!c
!c
!c chem.f:   real*8:
!c           -------
!c           cinc(nc,nthreads)  = incremented free species            * *
!c                                concentrations
!c                                [moles/l water]
!c           chargesb(nsb)      = charge of sorbed species            + -
!c           chargesb_ion(nsb_ion)   = charge of sorbed species       + -
!c                                     (ion-exchange)
!c           chargesb_surf(nsb_surf) = charge of sorbed species       + -
!c                                     (surface-complex)
!c           cmcmin(nm,nthreads)= min. concentration of minerals      + -
!c                                [moles/l bulk]
!c           csb(nsb)           = concentrations of sorbed species    * *
!c                                - new time level
!c           csb_ion(nsb_ion,nthreads)
!c                              = concentrations of sorbed species    * *
!c                                - new time level (ion-exchange)
!c           csb_surf(nsb_surf,nthreads) 
!c                              = concentrations of sorbed species    * *
!c                                - new time level (surface-complex)
!c           cxinc(nx,nthreads) = secondary aqueous species           * *
!c                                concentrations dependent on
!c                                incremented free species
!c                                concentrations
!c                                [moles/l water]
!c           dcsb(nsb)          = derivatives of concentrations of    * *
!c                                sorbed species with respect to
!c                                primary species
!c           dcsb_ion(nsb_ion,nthreads)  
!c                              = derivatives of concentrations of    * *
!c                                sorbed species with respect to
!c                                primary species (ion-exchange)
!c           dcsb_surf(nsb_surf,nthreads)
!c                              = derivatives of concentrations of    * *
!c                                sorbed species with respect to
!c                                primary species (surface-complex)
!c           dratedp(nm,nthreads)        
!c                              = derivatives of absolute             * *
!c                                dissolution-precipitation
!c                                rates of minerals
!c                                [moles/(l bulk*day)]
!c           dtota(n)           = derivatives of total sorbed         * +
!c                                component concentrations
!c                                (non-competitive sorption)
!c                                [moles/l bulk]
!c           dtotaq(nc-1,nthreads)       
!c                              = derivative of total source-sink     * *
!c                                term towards total aqueous component
!c                                concentrations due to intra-aqueous
!c                                kinetic reactions
!c           totaq(nc-1,nthreads) 
!c                              = total source-sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to intra-aqueous
!c                                kinetic reactions
!c           dtotc(n,nthreads)  = derivatives of total aqueous        * *
!c                                component concentrations
!c                                [moles/l water]
!c           dtotcf(n,nthreads) = derivatives of total aqueous
!c                                component concentrations
!c                                times porosity correstion 
!c                                factors for hMCD model [moles/l h2o]
!c           dtotdp(n,nthreads) = derivatives of total source/sink    * *
!c                                term towards aqueous component
!c                                concentrations due to mineral
!c                                dissolution-precipitation reactions
!c                                [moles/(l bulk*day)]
!c           dtotor(n)          = derivatives of total source/sink    * *
!c                                term towards aqueous component
!c                                concentrations due to 
!c                                oxidation/reduction reactions
!c                                [moles/(l bulk*day)]
!c           dtotg(n)           = derivatives of total gaseous        * *
!c                                component concentrations
!c                                [moles/l air]
!c           dtotsb(n)          = derivatives of total source/sink    * *
!c                                term towards total aqueous
!c                                component concentrations due to
!c                                sorption reactions
!c                                [moles/(l bulk*day)]
!c           dtotsb_ion(n,nthreads)      
!c                              = derivatives of total source/sink    * *
!c                                term towards total aqueous
!c                                component concentrations due to
!c                                sorption reactions
!c                                [moles/(l bulk*day)]
!c                                (ion-exchange)
!c           dtotsb_surf(n,nthreads)     
!c                              = derivatives of total source/sink    * *
!c                                term towards total aqueous
!c                                component concentrations due to
!c                                sorption reactions
!c                                [moles/(l bulk*day)]
!c                                (surface-complex)
!c           eqm(nm,nthreads)   = equilibrium constants for minerals  + -
!c           eqr(nr,nthreads)   = equilibrium constant for redox      + -
!c                                couple reaction equation
!c           eqsb(nsb)          = equilibrium constants for           + -
!c                                sorbed species
!c           eqsb_ion(nsb_ion,nthreads)  
!c                              = equilibrium constants for           + -
!c                                sorbed species (ion-exchange)
!c           eqsb_surf(nsb_surf,nthreads)
!c                              = equilibrium constants for           + -
!c                                sorbed species (surface-complex)
!c           eqx(nx,nthreads)   = equilibrium constants for           + -
!c                                aqueous complexes
!c           ginc(ng,nthreads)  = gas concentrations dependent on     * *
!c                                incremented free species
!c                                concentrations
!c                                [moles/l air]
!c           rateaq(naq,nthreads) 
!c                              = reaction rates of intra-aqueous     * *
!c                                kinetic reaction
!c           rateor(nr,nthreads)= oxidation-reduction rate for        * *
!c                                redox couple [moles/(l h2o*day)
!c           rhobulk            = dry bulk density of porous medium   + -
!c           satm(nm,nthreads)  = saturation indices                  * *
!c           supsatm(nm)        = level of supersaturation required   + -
!c                                for precipitation [log cycles]
!c           tinyrate           = set reaction rates to zero,         + -
!c                                if smaller than tinyrate
!c           totcinc(n,nthreads)= total aqueous component             * +
!c                                concentrations - new time level
!c                                incremented [moles/l water]
!c           totdp(n,nthreads)  = total source/sink term towards      * *
!c                                total aqueous component 
!c                                concentrations due to mineral 
!c                                dissolution-precipitation 
!c                                reactions [moles/(l bulk*day)]
!c           totor(nc-1)        = total source/sink term towards      * *
!c                                aqueous component concentrations
!c                                due to oxidation/reduction
!c                                reactions [moles/(l bulk*day)]
!c           totrateg(nc-1)     = total rate for removal of aqueous   * *
!c                                components due to degassing
!c                                [mol L^-1 s^-1]
!c           totsb(n)           = total source/sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to sorption
!c                                reactions [moles/(l bulk*day)]
!c           totsb_ion(n)       = total source/sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to sorption
!c                                reactions [moles/(l bulk*day)]
!c                                (ion-exchange)
!c           totsb_surf(n)      = total source/sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to sorption
!c                                reactions [moles/(l bulk*day)]
!c                                (surface-complex)
!c           totgasdecay(n)     = total source/sink term towards      * *
!c                                total aqueous component
!c                                concentrations due to first
!c                                order gas decay [mol L^-1 s^-1]
!c
!c           xnug(ng*nc)        = stoichiometric coefficient matrix   + -
!c                                for formation of gases from
!c                                free species
!c           xnum(nm*nc)        = stoichiometric coefficients of      + -
!c                                components in mineral
!c           xnur(nr*nc)        = stoichiometric coefficient of       + -
!c                                component in redox couple
!c                                reaction equation
!c           xnusb(nsb*nc)      = stoichiometric coefficient matrix   + -
!c                                for formation of sorbed species
!c                                from components
!c           xnusb_ion(nsb_ion*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (ion-exchange)
!c           xnusb_surf(nsb_surf*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (surface-complex)
!c           xnux(nx*nc)        = stoichiometric coefficient matrix   + -
!c                                for formation of aqueous complexes
!c                                from components
!c
!c           integer*4:
!c           ----------
!c           iaga(ng+1)         = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                free species in gases
!c           iam(nm+1)          = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in mineral
!c           iarc(nr+1)         = row pointer array to                + -
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           iasb(nsb+1)        = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           iasb_ion(nsb_ion+1)= row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           iasb_surf(nsb_surf+1)= row pointer array to              + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           iax(nx+1)          = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in aqueous complexes
!c           jaga(ng*nc)        = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in gases
!c           jam(nm*nc)         = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in mineral
!c           jarc(nr*nc)        = column pointer array to             + -
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           jasb(nsb*nc)       = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           jasb_ion(nsb_ion*nc)= column pointer array to            + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           jasb_surf(nsb_surf*nc)= column pointer array to          + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           jax(nx*nc)         = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                components in aqueous complexes
!c           naq                = number of intra-aqueous kinetic     + -
!c                                reactions
!c           nc                 = number of components including h2o  + -
!c           ng                 = number of gases                     + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nx                 = number of aqueous complexes         + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c
!c           logical:
!c           --------
!c           far_from_equil(nm) = .true.  -> far from equilibrium     + -
!c           gas_removal        = .true.  -> degassing of dissolved   + -
!c                                           gases, if confining
!c                                           pressure exceeded
!c           new_database       = .true.  -> use new database format  + -
!c           noncompetitive_sorption = logical array for activation   + -   
!c                                     of noncompetitive sorption
!c                                     reactions
!c           redox_equil        = .true.  -> equilibrium reactions    + -
!c                                           for redox couples
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           update_activity(nthreads)    
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       + -
!c                                'surface' = surface site
!c                                'biomass' = biomass
!c           sorption_group     = 'ion-exchange'                      + -
!c                                'surface-complexation'
!c                                'undefined'
!c           sorption_type      = 'gaines-thomas'                     + -
!c                                'gapon'
!c
!c dens.f:   logical:
!c           --------
!c          density_dependence = .true.  -> density-dependent flow   + -
!c multidiff.f90
!c            real*8:
!c           -------
!c           electromignew(n,nn)   
!c                              = electromigration induced 
!c                                  concentration change (MCD)
!c           delectromignew(nn,nthreads) 
!c                              = derivative of electromigration 
!c                                  induced concentration change (MCD)
!c           totviscnew(n,nn)   = total 'dynamic viscosity' term
!c              dtotviscnew(nn,nthreads)     
!c                              = derivative of total 'dynamic viscosity' 
!c             cinfrt_mcd(njavs)    = influence coefficient of multicomponent 
!c                                  diffusion (MCD)
!c             mdiff_ic(nc)        = diffusion coefficient of free 
!c                                  aqueous species
!c             mdiff_ix(nx)        = diffusion coefficient of secondary 
!c                                aqeous complexes
!c           logical:
!c           --------
!c             multi_diff         = .true. -> multicomponent diffusion (MCD)
!c         hmulti_diff = .true. -> hybrid multicomponent diffusion (hMCD)
!c
!c local:    real*8:
!c           -------
!c           dgflux             = derivative of interfacial mass
!c                                flux (gaseous phase)
!c           dissvol            = mineral mass to be dissolved
!c           dcflux             = derivative of interfacial mass
!c                                flux (aqueous phase)
!c           drtinc             = increment for numerical 
!c                                differentiation
!c           dgstor             = derivative of storage term
!c                                (gaseous phase)
!c           dcstor             = derivative of storage term 
!c                                (water phase)
!c           r0                 = constant
!c           r1                 = constant
!c           small              = small increment
!c
!c added for gas transport:
!c
!c           densgij            = gas density at interface i-j
!c           dgm_dgflux(nc)     = derivative of diffusive flux        * +
!c                                (as computed w/ DGM)
!c           dgmfrac(ng)        = derivative of gas molar fraction    * +
!c           dgm_gflux(nc)      = diffusive flux (as computed w/DGM)  * +
!c           fmat(ng,ncon)      = right hand side DGM system          * +
!c           gacc               = gravity                             + -
!c           gdens(nn)          = gas density at control volume i     * +
!c           gij                = gas concentration at i-j            * +
!c           gmfracij           = gas molar fractions at i-j          * +
!c           gmfrac_inc(ng)     = incremented gas molar fraction      * +
!c           gpivol(nn)         = gas pressure at control volume i    * +
!c           gsatmin            = constant
!c           gvisc(ivol)        = gas viscosity at control vol i      * +
!c           ludecomp(ng,ng,ncon) = LU decomp of matrix of DGM system * +
!c           lumat2(ng-1,ng-1)  = LU decomp of matrix of Maxwell sys  * +
!c           mdens_g_inc        = incremented gas density             * +
!c           ms_dgflux(nc)      = derivative of diffusive flux        * +
!c                                (as computed w/ stefan-maxwell)     * +
!c           ms_gflux(nc)       = diffusive flux (as computed w/S-M)  * +
!c           neflux(nc)         = non-equimolar flux for multi-comp   * +
!c                                diffusion
!c           relpgij            = relative perm (gas) at i-j          * +
!c           totgij             = total gas concentrations of         * +
!c                                components at interface i-j         * +
!c           rverysmall         = constant 
!c           viscgij            = gas viscosity at interface i-j      * +
!c           wfac               = weighting factor for gas transport  * +
!c
!c           character:
!c           ----------
!c           spt_weight         = spatial weighting for gas transp    * +
!c           spwt2              = spatial weighting for gas transp    * +
!c           integer*4:
!c           ----------
!c           i1                 = counter (entries in ja, a arrays 
!c                                         for 1d-scalar matrix)
!c           i2                 = pointer (entries in ja, a arrays
!c                                         for nd-scalar matrix)
!c           iaq                = counter (intra-aqueous kinetic 
!c                                         reactions)
!c           ibl                = counter (rows of block matrix)
!c           ic                 = counter (components)
!c           icon               = pointer (off-diagonal connections)
!c           idiag              = pointer (diagonal of 1d-scalar 
!c                                         matrix)
!c           iend               = pointer (last off-diagonal entry 
!c                                         in row for 1d-scalar 
!c                                         matrix)
!c           ig                 = counter (gases)
!c           im                 = counter (minerals)
!c           ir                 = counter (redox couples)
!c           isb                = counter (sorbed species)
!c           irow               = pointer (row in rhs-vector)
!c           istart             = pointer (first off diagonal entry 
!c                                         in row for 1d-scalar 
!c                                         matrix)
!c           isym               = symmetry pointer (1d-scalar 
!c                                                  matrix)
!c           ivol               = counter (control volumes)
!c           ix                 = counter (complexed species)
!c           jbl                = counter (columns of block matrix)
!c           jvol               = pointer (column in 1d-scalar 
!c                                         matrix)
!c           ldiag              = pointer (diagonal block in global 
!c                                         block matrix)
!c           lsym               = symmetry pointer (global block 
!c                                                  matrix)
!c           info_debug         = 0 -> no debugging information
!c                              = 1 -> write debugging information to
!c                                     prefix_o.dbg
!c                              = 2 -> write debugging information to
!c                                     prefix_o.dbg and quit
!c
!c external: acoff     = compute activity coefficient
!c           bulkconc  = convert from [moles/l water] to 
!c                       [moles/l bulk]
!c           comptotc  = compress concentration vector, if number
!c                       of unknowns is reduced due to redox
!c                       equilibrium reactions
!c           drategas  = compute derivatives of degassing rates
!c           drategdd  = compute derivatives of degassing rates
!c                       density dependent flow
!c           drateint  = compute derivative of reaction rate
!c                       of intra-aqueous kinetic reaction
!c           drateint_new  = compute derivative of reaction rate
!c                       of intra-aqueous kinetic reaction (new
!c                       database format)
!c           dratemin  = compute numerical derivative of absolute 
!c                       dissolution-precipitation rates of minerals
!c           dratemin_new  = compute numerical derivative of absolute 
!c                       dissolution-precipitation rates of minerals
!c                       (new database format)
!c           aratemin  = compute analytical derivative of absolute 
!c                       dissolution- precipitation rates of minerals
!c           draterdx  = compute derivative of total oxidation/
!c                       reduction rates for redox couples in terms 
!c                       of total aqueous component concentrations
!c           dtotconc  = compute numerical derivatives of total aqueous
!c                       component concentrations
!c           atotconc  = compute analytical derivatives of total aqueous
!c                       component concentrations
!c           dtotcong  = compute derivative of total gaseous
!c                       component concentrations
!c           fluxd     = diffusive/dispersive flux
!c           fluxv     = advective flux
!c           fluxv_vl  = advective flux (Van Leer flux limiter)
!c           gasconc   = compute gas concentrations based on 
!c                       concentrations of free species
!c           molconc   = compute average molar concentration for 
!c                       organic mixture
!c           rategas   = compute degassing rates
!c           rategasd  = compute degassing rates for density
!c                       dependent flow
!c           rateint   = compute rate for intra-aqueous kinetic 
!c                       reactions
!c           rateint_new   = compute rate for intra-aqueous kinetic 
!c                       reactions (new database format)
!c           ratemin   = compute absolute dissolution-precipitation
!c                       rates of minerals
!c           ratemin_new  = compute absolute dissolution-precipitation
!c                       rates of minerals (new database format)
!c           rateredx  = compute oxidation/reduction rates for 
!c                       redox couples
!c           rhsrt     = construct rhs-vector (reactive transport)
!c           secspec   = compute aqueous complex concentration
!c                       based on concentrations of free species
!c           sorbspc   = compute concentration of sorbed species
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totcona   = compute total sorbed component
!c                       concentrations (non-competitive sorption)
!c           totconc   = compute total aqueous component
!c                       concentrations based on concentrations 
!c                       of free species and secondary aqueous 
!c                       species
!c           totconcg  = compute total gaseous component 
!c                       concentrations based on concentrations 
!c                       of gases
!c           totint    = compute total source-sink terms towards
!c                       total aqueous component concentrations
!c                       due to intra-aqueous reactions
!c           totmin    = compute total source/sink terms towards 
!c                       towards total aqueous component concentrations
!c                       due to mineral dissolution-precipitation 
!c                       reactions in [moles/(l bulk x day)]
!c           totredx   = compute total source/sink terms towards 
!c                       total aqueous component concentrations
!c                       due to oxidation/reduction reactions
!c                       in [moles/(l bulk x day)]
!c           totsorb   = compute total sorbed component concentrations
!c                       [moles/l bulk]
!c           updtsvap  = update secondary variables in aqueous 
!c                       phase
!c ----------------------------------------------------------------------
!c
!c  added for gas advection and multi-component diffusion:
!c
!c           dfluxvg     = compute derivative of gas advective fluxes
!c           dgm_dfluxdg = compute derivative of gas diffusive fluxes
!c                         with Dusty Gas Model
!c           dgm_fluxdg  = compute gas diffusive fluxes
!c                         with Dusty Gas Model
!c           fluxvg      = compute gas advective fluxes
!c           gasdiff2    = compute diffusion coefficients with LeBlancs
!c                         approximation (Ficks law)
!c           gasd_m      = compute gas density
!c           gasp_m      = compute gas pressure 
!c           gasv        = compute gas viscosity
!c           ms_dfluxdg  = compute derivative of gas diffusive fluxes
!c                         with Stefan-Maxwell
!c           ms_fluxdg   = compute gas diffusive fluxes
!c                         with Stefan-Maxwell
!c           wgprop      = calculate variables for flux calculations 
!c                         at the interface using the correspoding 
!c                         spatial weighting 
!c           wgpropd     = calculate variables for calculations of the
!c                         derivative of fluxes at the interface using
!c                         the correspoding spatial weighting 
!c
!c  added for solute uptake by root:
!c        passive_uptake = calculate passive uptate term w/rootwat and q_root  (HG)
!c ----------------------------------------------------------------------
 
      subroutine jacrt
 
      use parm
      use gen
      use chem
      use dens
      use bbls
      use dgml
      use phys, only : dens_h2o, visc_h2o, mdens_g, blanc_diff_g,      &
                       rsum_vprop, is_cell_based_relp,                 &
                       rootwateruptake_field, uptakefactor_vol
      use multidiff
      use nobleGasIngrowth
      use biol

#ifdef USG
      use math_common
      use geometry
      use mod_fluxd_usg
      use gradient_usg, only : gradient_cross_diff_rt,                 &
                               gradient_cross_diff_rt_inc,             &
                               gradient_cross_diff_md,                 &
                               gradient_cross_diff_md_inc,             &
                               gradient_cross_diff_rt_average

      use usg_mesh_data, only : num_edge_dvols,cells,                  &
                                num_nodes_per_cell,node_cells,         &
                                node_num_cells,num_edge_maxcells,      &
                                grad_method, CellsQuadTriNode
      use usg_face_utility, only : usg_face_utility_cinfvs,            &
                                   usg_face_utility_cinfrt_da,         &
                                   usg_face_utility_cinfrt_da_ic,      &
                                   usg_face_utility_cinfrt_dg,         &
                                   usg_face_utility_cinfrt_mcd
#endif

#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      
      implicit none
      
      integer :: tid, chunk
      integer :: ivol_track, ivol_gbl
      real*8 :: rtimespan
      real*8 :: dissvol, dissvol1
      real*8 :: dummy, por_diff, por_temp, ratio, over_por     
      !c root uptake variables   !HG
      real*8 :: qrootloc
     
!cdsu-------------------------------------------------------------------
!cdsu---------------------Gas transport variables-----------------------
!cdsu-------------------------------------------------------------------
      character*12 :: spt_weight
      
      real*8 ::                   &
     &       relpgij            , & 
     &       densgij            , &          
     &       viscgij            , & 
     &       gpij               , &  
     &       dgpivol            , & 
     &       dmdens_i           , & 
     &       ddens_i            , & 
     &       wfac               , &
     &       relpgi             , &
     &       relpgj

      integer :: i1, i2, iaq, ibl, icol, icon, ir, info_debug, ivol,   &
                 izn, izn_c, ig, isb, im, ic, ix, idiag, istart, iend, &
                 irow, isym, istop, im2, ldiag, lsym, jbl, jvol, i, j, &
                 ingi
      real*8 :: dcstor, dgstor, drtinc, dcflux, dgflux
                  

      real*8, external :: acoff, bulkconc, fluxd, fluxvg, fluxv_vl,    &
              dfluxvg, gasm, gasp, gasp_m, gasd_m, gasv,               &
              cputime, gasdiff2

#ifdef USG
      integer :: icell, icell2, idvol, kvol, ncell, ndvol
      real*8 :: grad_weights(num_crossdifficv_max)
      real*8 :: gasdiff_loc, cinfrt_usg(num_edge_dvols, num_edge_maxcells)

      real*8 :: flux_totcnew_hls_corr(num_edge_dvols,num_edge_maxcells),       &
                flux_dtotcnew_inc_hls_corr(num_edge_dvols,num_edge_maxcells),  &
                flux_totviscnew_hls_corr(num_edge_dvols,num_edge_maxcells),      &                
                flux_dtotviscnew_inc_hls_corr(num_edge_dvols,num_edge_maxcells), &
                flux_electro_hls_corr(num_edge_dvols,num_edge_maxcells),       &                
                flux_delectro_inc_hls_corr(num_edge_dvols,num_edge_maxcells),  &
                flux_totgnew_hls_corr(num_edge_dvols,num_edge_maxcells),       &
                flux_dtotgnew_inc_hls_corr(num_edge_dvols,num_edge_maxcells)

      type(point) :: grad_totcnew_locs(num_crossdifficv_max),                  &
                     grad_totgnew_locs(num_crossdifficv_max),                  &
                     grad_totviscnew_locs(num_crossdifficv_max),               &
                     grad_totviscnew_inc_locs(num_crossdifficv_max),           &
                     grad_electro_locs(num_crossdifficv_max),                  &
                     grad_electro_inc_locs(num_crossdifficv_max),              &
                     grad_totcnew_ivol(n), grad_totcnew_jvol(n),               &
                     grad_totgnew_ivol(n), grad_totgnew_jvol(n),               &
                     grad_totviscnew_ivol(n), grad_totviscnew_jvol(n),         &
                     grad_electro_ivol(n), grad_electro_jvol(n),               &
                     grad_totcnew_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                     grad_totgnew_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                     grad_totviscnew_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                     grad_electro_kvol(n,num_nodes_per_cell,num_edge_maxcells),&
                     grad_totcnew_mids(num_edge_dvols,num_edge_maxcells),      &
                     grad_dtotcnew_inc_mids(num_edge_dvols,num_edge_maxcells), &
                     grad_totviscnew_mids(num_edge_dvols,num_edge_maxcells),   &
                     grad_dtotviscnew_inc_mids(num_edge_dvols,num_edge_maxcells), &
                     grad_electro_mids(num_edge_dvols,num_edge_maxcells),      &
                     grad_delectro_inc_mids(num_edge_dvols,num_edge_maxcells), &
                     grad_totgnew_mids(num_edge_dvols,num_edge_maxcells),      &
                     grad_dtotgnew_inc_mids(num_edge_dvols,num_edge_maxcells), &
                     cinfrt_usg_cross(num_edge_dvols,num_edge_maxcells)
      type(grad_hls_term) :: grad_totcnew_hls_loc(n,num_edge_dvols,num_edge_maxcells),&
                             grad_totgnew_hls_loc(n,num_edge_dvols,num_edge_maxcells),&
                             grad_totviscnew_hls_loc(n,num_edge_dvols,num_edge_maxcells),&
                             grad_electro_hls_loc(n,num_edge_dvols,num_edge_maxcells)

      real*8 :: permij_usg_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfvs_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfvs_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfrt_da_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfrt_da_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfrt_da_ic_usg_loc(nc,num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfrt_da_ic_usg_cross_loc(nc,num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfrt_dg_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfrt_dg_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      real*8 :: cinfrt_mcd_usg_loc(num_edge_dvols,num_edge_maxcells)
      type(point) :: cinfrt_mcd_usg_cross_loc(num_edge_dvols,num_edge_maxcells)

      type(point) :: grad_cgg_totcnew(n,num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_cgg_totviscnew(n,num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_cgg_electro(n,num_edge_dvols,num_edge_maxcells)
      type(point) :: grad_cgg_totgnew(n,num_edge_dvols,num_edge_maxcells)
#endif
      
!c dgm variables and initialization
      integer*4 :: ipvt(ng,ncon)
      real*8    :: dgm_gflux(nc), dgm_dgflux(nc)
      real*8    :: ludecomp(ng,ng,ncon), fmat(ng,ncon)
      real*8    :: gpivol_ivol, gpivol_jvol, gdens_ivol, gdens_jvol,   &
                   gvisc_ivol, gvisc_jvol
      
!c root respiration variables:
      real*8 :: rootresp_current, rootresp_max, dresprate,      &
                rootdens, rootresp(n), drootresp(n)
      
!c ms variables    
      real*8    :: ms_gflux(nc), ms_dgflux(nc), neflux(nc),     &
                   lumat2(ng-1,ng-1) 
      real*8 :: so_av, cinfrt, mdens_g_inc, dgmfrac(ng)

     
      external comptotc, dtotcong, rateredx, rhsrt,             &
               secspec, sorbspc, totcona, totconc, totconcg,    &
               totmin, totsorb, elecmigration, totconcfac,      &
               wgprop, wgpropd, atotconc, ratemin, ratemin_new, &
               aratemin, drategas, drategdd, drateint,          &
               drateint_new, dratemin, dratemin_new, draterdx,  &
               dtotconc, gasconc, molconc, rategas,             &
               rategasd, rateint, rateint_new, tcorr, totint,   &
               totredx, updtsvap

      !c root uptake variables !HG
      real*8, external :: rootwat

      real*8, external :: pressure_melt_k   
  
      real*8 :: r0, r1, small, gsatmin, rsmallarea, rverysmall, &
                enat, conv3

      parameter (r0 = 0.0d0, r1 = 1.0d0, small = 1.0d-10,       &
                 gsatmin=0.0d0, rsmallarea = 1.0d-8,            &
                 rverysmall = 1.0d-30, conv3 = 1.0d3,           &
                 enat = 2.71828182845904509d0)

      real*8 :: rcvt
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      rcvt = visc_h2o/dens_h2o/gacc

      rtimespan = 0.0d0
      
!c    initialize spatial weighting variable for gas transport
      spt_weight = spatial_weighting      

      if(iter_rt.le.1 .and. mtime.le.1) then
        info_debug = 0
        ivol_track = -1
      else
        info_debug = 0
        ivol_track = -1
      end if
    
      if (b_prtfile) then
          prt_react_jac_part = 0.0
          prt_react_jac_part(1) = cputime() 
          prt_react_jac_part(6) = cputime()
      end if

#ifdef OPENMP
      chunk = nngl / numofthreads_matrix_react
      if(mod(nngl, numofthreads_matrix_react) > 0) then
          chunk = chunk + 1                             !This is default chunk size for static scheduling.
      end if
      if (i_chunksize_factor_react > 1) then
            if(mod(chunk, i_chunksize_factor_react) > 0) then
                chunk = chunk/i_chunksize_factor_react + 1
            else
                chunk = chunk/i_chunksize_factor_react
            end if
      end if
#endif

#ifdef SCHEDULE_DYNAMIC
      if(i_chunksize_factor_react == 0) then
        chunk = 1                                       !This is the default chunk size for dynamic scheduling.
      end if 
#endif 

!c  initialize local variables
     relpgij  = r0 
     densgij  = r0          
     viscgij  = r0 
     gpij     = r0  
     dgpivol  = r0 
     dmdens_i = r0 
     ddens_i  = r0 
     wfac     = r0
     relpgi   = r0
     relpgj   = r0

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_jacrt == 1)                      &
    !$omp num_threads(numofthreads_matrix_react)                      &
    !$omp default(shared)                                             &
    !$omp private (                                                   &
#ifdef USG
    !$omp icell, idvol, kvol, ndvol, ncell, grad_weights,             &
    !$omp flux_totcnew_hls_corr, flux_dtotcnew_inc_hls_corr,          &
    !$omp flux_totviscnew_hls_corr, flux_dtotviscnew_inc_hls_corr,    &
    !$omp flux_electro_hls_corr, flux_delectro_inc_hls_corr,          &
    !$omp flux_totgnew_hls_corr, flux_dtotgnew_inc_hls_corr,          &
    !$omp grad_totcnew_mids, grad_dtotcnew_inc_mids,                  &
    !$omp grad_totviscnew_mids, grad_dtotviscnew_inc_mids,            &
    !$omp grad_electro_mids, grad_delectro_inc_mids,                  &
    !$omp grad_totgnew_mids, grad_dtotgnew_inc_mids,                  &
    !$omp grad_totcnew_locs, grad_totgnew_locs,                       &
    !$omp grad_totviscnew_locs, grad_electro_locs,                    &
    !$omp grad_totcnew_ivol, grad_totcnew_jvol, grad_totcnew_kvol,    &
    !$omp grad_totgnew_ivol, grad_totgnew_jvol, grad_totgnew_kvol,    &
    !$omp grad_totviscnew_ivol, grad_totviscnew_jvol,                 &
    !$omp grad_totviscnew_kvol,                                       &
    !$omp grad_electro_ivol, grad_electro_jvol, grad_electro_kvol,    &
    !$omp grad_totcnew_hls_loc, grad_totgnew_hls_loc,                 &
    !$omp grad_totviscnew_hls_loc, grad_electro_hls_loc,              &
    !$omp permij_usg_loc, cinfvs_usg_loc, cinfvs_usg_cross_loc,       &
    !$omp cinfrt_usg, cinfrt_usg_cross,                               &
    !$omp cinfrt_da_usg_loc, cinfrt_da_usg_cross_loc,                 &
    !$omp cinfrt_da_ic_usg_loc, cinfrt_da_ic_usg_cross_loc,           &
    !$omp cinfrt_dg_usg_loc, cinfrt_dg_usg_cross_loc,                 &
    !$omp cinfrt_mcd_usg_loc, cinfrt_mcd_usg_cross_loc,               &
    !$omp grad_cgg_totcnew, grad_cgg_totviscnew, grad_cgg_electro,    &
    !$omp grad_cgg_totgnew,                                           &
#endif
    !$omp tid, i1, i2, iaq, ibl, ic, icon, idiag, iend,               &
    !$omp ig, im, im2, ir, irow, isb, istart, isym, ivol, ivol_gbl,   &
    !$omp istop, ix, izn, izn_c, ingi, jbl, jvol, ldiag, lsym,        &
    !$omp delta_totviscnew, delta_electromignew,                      &
    !$omp qrootloc, rootresp, rootresp_current, rootresp_max,         &   !!Root uptake and
    !$omp dresprate, drootresp, rootdens,                             &   !!respiration
    !$omp densgij, dg, dgpivol, dmdens_i, ddens_i, gij,  gmfracij,    &   !!Gas advection and dgm model
    !$omp gpivol_ivol, gpivol_jvol, gdens_ivol, gdens_jvol,           &
    !$omp gvisc_ivol, gvisc_jvol,                                     &
    !$omp gpij, totgij, relpgij, relpgi, relpgj, viscgij, wfac,       &
    !$omp cinfrt, dgm_gflux, ms_gflux, ms_dgflux, fmat, ipvt,         &
    !$omp mdens_g_inc,dgmfrac,neflux, dgm_dgflux, lumat2, ludecomp,   &   !!Gas advection and dgm model
    !$omp gasdecayrate, totgasdecay, dgasdecayrate, dtotgasdecay,     &   !!1st order gas decay
    !$omp aqdecayrate, totaqdecay, daqdecayrate, dtotaqdecay,         &   !!1st order aqueous decay
    !$omp sorptiondecayrate, totsorptiondecay,                        &   !!1st order sorbed specied decay
    !$omp astor, cflux, cstor, dcflux, dcstor, dgflux, dgstor,        &
    !$omp dissvol, drtinc, dtota, dtotcflux, dtotgflux, dtotor,       &
    !$omp gflux, gstor, totcflux, totgflux, totor, totrateg,          &
    !$omp totsb_ion, totsb_surf, por_temp, ratio,                     &
    !$omp over_por, por_diff, dissvol1)                                   !!if pore_clogging 
#endif
      
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
!cprovi Update the secondary variables
!cprovi update secondary variables and compute storage, source/sink and 
!cprovi flux terms
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
!cprovi-----------------------------------------------------------
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif  
#endif
      do ivol = 1,nngl                 !loop over control volumes
          

#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif
          
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      izn = mpropvs(ivol)
      izn_c = mpropc(ivol)

#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,*)                                                &
                "-->jacrt->ivol gnew(:,ivol) A2", ivol, gnew(:,ivol)
        end if
#endif 

!cprovi------------------------------------------------------
!cprovi temperature corrections for debye-huckel, equilibrium and 
!cprovi rate constants 
!cprovi We have added the temperature update when energy 
!cprovi balance is solved 
!cprovi------------------------------------------------------           
        if (temp_corr.or.heat_transport) then
          call tcorr(tkel(ivol),ivol,tid)
        end if

#ifdef DEBUG
        if(info_debug > 10) then
          if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
            write(idbg, *)                                           &
                  "--> check temperature corrections, ivol",         &
                  ivol_gbl
            write(idbg, *) "--> dhad, dhbd", dhad(tid),dhbd(tid)
            write(idbg, *) "--> eqx ", eqx(:,tid)
            write(idbg, *) "--> eqg ", eqg(:,tid)
            write(idbg, *) "--> eqm ", eqm(:,tid)
            write(idbg, *) "--> rated ", rated(:,tid)
            write(idbg, *) "--> eqmx ", eqmx(:,tid)
            write(idbg, *) "--> eqr ", eqr(:,tid)
            write(idbg, *) "--> eqsb_ion ", eqsb_ion(:,tid)
            write(idbg, *) "--> eqsb_surf ", eqsb_surf(:,tid)
            write(idbg, *) "--> eqaq ", eqaq(:,tid)
            write(idbg, *) "--> ratecaq ", ratecaq(:,tid)
          end if
        end if
#endif
!OPENMP Check: This part is checked via d43_density_dep_heat_solute\henry-hilleke benchmark.       


!c  constant activity coefficients
!c  -> update only concentrations of secondary aqueous species
!c     and compute ionic strength   
#ifdef DEBUG
        if(info_debug > 10) then
          if(ivol_gbl == ivol_track .or. ivol_track == 0) then   
            write(idbg, *)                                             &
                  "-->jacrt->centrations before updtsvap, ivol",       &
                  ivol_gbl, " tid ", tid
            write(idbg, *) "--> cnew ", cnew(:,ivol)
            write(idbg, *) "--> cx ", cx(:,ivol)
            write(idbg, *) "--> gamma ", gamma(:,ivol)
            write(idbg, *) "--> sionnew ",sionnew(ivol)
            write(idbg, *) "--> dhad ", dhad(tid), " dhad-all ", dhad(:)
            write(idbg, *) "--> dhbd ", dhbd(tid), " dhbd-all ", dhbd(:)
            write(idbg, *) "--> eqr ", eqr(:,tid)
            write(idbg, *) "--> eqx ", eqx(:,tid)
          end if
        end if
#endif

        call updtsvap(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),           & 
     &                gamma(nc+1,ivol),sionnew(ivol),tid)
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,*)                                                &
                "-->jacrt->ivol gnew(:,ivol) A3", ivol, gnew(:,ivol)
        end if
#endif 
        
#ifdef DEBUG
        if(info_debug > 10) then
          if(ivol_gbl == ivol_track  .or. ivol_track == 0) then   
            write(idbg, *)                                             &
                  "--> check concentrations after updtsvap, ivol",     &
                  ivol_gbl
            write(idbg, *) "--> cnew ", cnew(:,ivol)
            write(idbg, *) "--> cx ", cx(:,ivol)
            write(idbg, *) "--> gamma ", gamma(:,ivol)
            write(idbg, *) "--> sionnew ",sionnew(ivol)
            write(idbg, *) "--> dhad ", dhad(tid)
            write(idbg, *) "--> dhbd ", dhbd(tid)
            write(idbg, *) "--> eqr ", eqr(:,tid)
            write(idbg, *) "--> eqx ", eqx(:,tid)
          end if
        end if
#endif
!OPENMP Check: This part is checked via biomass\chrom-bio benchmark. 
        
!c  variable activity coefficients
!c  -> double update of secondary variables 
!c     - activitiy coefficients
!c     - concentrations of secondary aqueous species
!c     - ionic strength                                                 
 
        if (update_activity(tid).eq.'double_update') then
          call updtsvap(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),         &     
     &                  gamma(nc+1,ivol),sionnew(ivol),tid)
#ifdef DEBUG
          if(info_debug > 10) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
              write(idbg, *)                                           &
                 "--> check concentrations of secondary: double, ivol",&
                 ivol_gbl
              write(idbg, *) "--> cnew ", cnew(:,ivol)
              write(idbg, *) "--> cx ", cx(:,ivol)
              write(idbg, *) "--> gamma ", gamma(:,ivol)
              write(idbg, *) "--> sionnew ",sionnew(ivol)
              write(idbg, *) "--> dhad ", dhad(tid)
              write(idbg, *) "--> dhbd ", dhbd(tid)
              write(idbg, *) "--> eqr ", eqr(:,tid)
              write(idbg, *) "--> eqx ", eqx(:,tid)
            end if
          end if
#endif
        end if
!OPENMP Check: This part is checked via d6_rt_highly_saline\polyhal-pitz benchmark.  

#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,*)                                                &
                "-->jacrt->ivol gnew(:,ivol) A4", ivol, gnew(:,ivol)
        end if
#endif 
   
        
!c  compute total aqueous component concentrations                      

        call totconc(cnew(1,ivol),cx(1,ivol),totcnew(1,ivol)) 

!c Calculate the total concentrations times correction factors - new time level !MX
        if (hmulti_diff) then               
!c  compute total concentrations of aqueous primary and secondary
!c  species times the correction factors
                
            call totconcfac(cnew(1,ivol),cx(1,ivol),totcnewf(1,ivol),izn)

        end if
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,*)                                                &
                "-->jacrt->ivol gnew(:,ivol) A5", ivol, gnew(:,ivol)
        end if
#endif 
        
#ifdef DEBUG
        if(info_debug > 10) then
          if(ivol_gbl == ivol_track .or. ivol_track == 0) then
            write(idbg, *)                                             &
               "--> check total aqueous concentrations, ivol", ivol
            write(idbg, *) "--> cnew ", cnew(:,ivol)
            write(idbg, *) "--> cx ", cx(:,ivol)
            write(idbg, *) "--> totcnew ", totcnew(:,ivol)
          end if
        end if
#endif
        
!c  compute total sorbed component concentrations
!c  non-competitive sorption                                            

        if (noncompetitive_sorption) then
          call totcona(totanew(1,ivol),totcnew(1,ivol),                &
                       distcoff_rt(1,ivol),sanew(ivol),pornew(ivol))     
        end if
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,*)                                                &
                "-->jacrt->ivol gnew(:,ivol) A6", ivol, gnew(:,ivol)
        end if
#endif 

!OPENMP Check: This part is checked via retardation benchmark


!c  compress total aqueous and sorbed (non-competitive sorption) 
!c  component concentration vector in case of redox equilibrium 
!c  reactions                                                           

        if (redox_equil.and.nr.gt.0) then
          call comptotc(totcnew(1,ivol))
          if (noncompetitive_sorption) then
            call comptotc(totanew(1,ivol))                              
          end if
        end if
!OPENMP Check: This part is not checked   
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,*)                                                &
                "-->jacrt->ivol gnew(:,ivol) A7", ivol, gnew(:,ivol)
        end if
#endif 

#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,*)                                                &
                "-->jacrt->tid, eqg(:,tid)", tid, eqg(:,tid)
        end if
#endif 
        
!c  compute gas concentrations and total gaseous component 
!c  concentrations                                                      

        if (ng.gt.0) then

          do ig = 1,ng 
            call gasconc(cnew(1,ivol),gamma(1,ivol),gnew(ig,ivol),ig,  &
                         tkel(ivol),tid)
          end do
#ifdef DEBUG
          if(info_debug > 10) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
              write(idbg, *) "--> compute gas concentrations, ivol ",  &
                             ivol  
              write(idbg, *) "--> ivol:", ivol
              write(idbg, *) "--> cnew:", cnew(:,ivol)
              write(idbg, *) "--> gamma:", gamma(:,ivol)
              write(idbg, *) "--> gnew:", gnew(:,ivol)
              write(idbg, *) "--> tkel:", tkel(ivol)
            end if
          end if
#endif
          call totconcg(gnew(1,ivol),totgnew(1,ivol))                       

!c  compress total gaseous component concentration vector in case
!c  of redox equilibrium reactions

          if (redox_equil.and.nr.gt.0) then
            call comptotc(totgnew(1,ivol))
          end if

        end if                 !(ng.gt.0)
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,*)                                                &
                "-->jacrt->ivol gnew(:,ivol) A8", ivol, gnew(:,ivol)
        end if
#endif 
        
!c  compute sorbed concentrations and total sorbed component            
!c  concentrations                                                      

        if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
            
          if (nsb_ion.gt.0) then
            do isb = 1,nsb_ion 
                call sorbspc_m(csb_ion(isb,tid),dummy,cec_g(ivol),    &
                     cec_fraction_g(idx_nsites_ion(isb),ivol),        &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),                &
                     gamma(1,ivol),cnew(1,ivol),xnusb_ion,xnusb_surf, &
                     iasb_ion,iasb_surf,jasb_ion,jasb_surf,nsb_ion,   &
                     nsb_surf,isb,0,sorption_type_ion,                &
                     sorption_type_surf,sorption_group,isactcexch)
                                      
            end do  !isb
          end if
          
          if(nsb_surf.gt.0) then
            do isb = 1,nsb_surf 
              call sorbspc(dummy,csb_surf(isb,tid),cec_g(ivol),       &
                   eqsb_ion(:,tid),eqsb_surf(:,tid),                  &
                   gamma(1,ivol),cnew(1,ivol),xnusb_ion,xnusb_surf,   &
                   iasb_ion,iasb_surf,jasb_ion,jasb_surf,nsb_ion,     &
                   nsb_surf,0,isb,sorption_type_ion,                  &
                   sorption_type_surf,sorption_group,isactcexch)
            end do
          end if

          call totsorb(csb_ion(:,tid),csb_surf(:,tid),                &
               chargesb_ion,rhobulk_g(ivol),totsnew_ion(1,ivol),      &
               totsnew_surf(1,ivol),xnusb_ion,xnusb_surf,iasb_ion,    &
               iasb_surf,jasb_ion,jasb_surf,nc,nsb_ion,nsb_surf,      &
               namec)

!c  compress total sorbed component concentration vector in case
!c  of redox equilibrium reactions

          if (redox_equil.and.nr.gt.0.and.nsb_ion.gt.0) then
            call comptotc(totsnew_ion(1,ivol))
          end if
          
          if (redox_equil.and.nr.gt.0.and.nsb_surf.gt.0) then
            call comptotc(totsnew_surf(1,ivol))
          end if

        end if  
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,*)                                                &
                "-->jacrt->ivol gnew(:,ivol) A9", ivol, gnew(:,ivol)
        end if
#endif 
        
!c  compute total source-sink terms towards total concentrations due
!c  to dissolution-precipitation reactons   

#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            write(idbg,*)                                              &
                  "-->A ivol ratemdp",ivol, ratemdp(:,ivol)
          end if
#endif
 
        if (nm.gt.0) then        

!c  compute total molar concentration in organic mixture 
          call molconc(phiold(1,ivol),tid)   
          do im=1,nm

!c  overall dissolution-precipitation rate
!c  dissolution   -ve
!c  precipitation +ve

#ifdef DEBUG
            if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.     &
              ivol_track == 0)) then
              write(idbg,*)                                            &
                  "-->jacrt->im,pressure_approximation(im)",           &
                  im,pressure_approximation(im)
            end if  
#endif

            if (pressure_approximation(im)) then
              call rate_gasmin(ratemdp(im,ivol),im,ivol,area(im,ivol),&
                               tid)
            else if (new_database) then
              if (root_uptake) then
                rootdens = rld(ivol)
              else
                rootdens = r1
              end if
              call ratemin_new(totcnew(1,ivol),cnew(1,ivol),         &
                            cx(1,ivol),gamma(1,ivol),gamma(nc+1,ivol),&
                            sanew(ivol),ratemdp(im,ivol),             &
                            phi(1,ivol),phiold(im,ivol),area(im,ivol),&
                            rootdens,im,tid)
              
            else

              call ratemin(totcnew(1,ivol),cnew(1,ivol),cx(1,ivol),   &
                           gamma(1,ivol),gamma(nc+1,ivol),            &
                           ratemdp(im,ivol),phi(im,ivol),             &
                           phiold(im,ivol),area(im,ivol),im,tid)
            end if      
          
#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            write(idbg,*)                                              &
                  "-->jacrt->A im ratemdp", im, ratemdp(im,ivol),      &
                  "cmnew",cmnew(im,ivol)
          end if  
#endif 

!cdsu  Adjust mineral rate for intermittent reactions
          if (flag_intermittent_react) then
            if (imizn2jairm(im,izn_c) > 0) then
              ratemdp(im,ivol) = ratemdp(im,ivol)*imizn2irc(im,izn_c)
            end if
          end if

!cdsu  Assign mineral rate for freezing water
            if(b_water_freezing_ratemin) then
              if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                ratemdp(im,ivol) = water_freezing_ratemin
              end if
            end if

!c  modify computed rates in the same manner as done in the residual
!c  assembly, moving the related code into modrate function.
            call modrate(ratemdp(im,ivol),cmnew(im,ivol),              &
                         pornew(ivol),delt,im,tid)            

          end do             !loop over minerals
        
!c  total source/sink terms towards total aqueous component
!c  concentrations due to mineral dissolution precipitation 
!c  reactions                                                           
 
          call totmin(ratemdp(1,ivol),totmdp(1,ivol))
#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            write(idbg,*)                                              &
                  "-->jacrt->ivol ratemdp", ivol, ratemdp(:,ivol)
            write(idbg,*)                                              &
                  "-->jacrt->ivol totmdp", ivol, totmdp(:,ivol)
          end if
#endif 
          
!c  compress source/sink term towards total aqueous component
!c  concentrations due to mineral dissolution-precipitation reactions
!c  in case of redox equilibrium reactions                              

          if (redox_equil.and.nr.gt.0) then
            call comptotc(totmdp(1,ivol))
          end if

        end if                       !(nm.gt.0)
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg,*)                                                &
                "-->jacrt->ivol gnew(:,ivol) A10", ivol, gnew(:,ivol)
        end if
#endif 
        
!c  calculate gas properties + molar fractions
        if (ng .gt. 0 .and. (gas_advection .or. dgm .or. maxwell)) then      

          mdens_g(ivol) = gasm(ng, gnew(1,ivol))                   ! gas molar density               

          do ig=1,ng
            gmfrac(ig,ivol) = gnew(ig,ivol) / mdens_g(ivol)    ! molar fractions
          enddo                                                ! gas species
          
          do ic=1,n
            totgmfrac(ic,ivol) = totgnew(ic,ivol) / mdens_g(ivol) ! gas molar frac
          enddo                                                   ! for components
              
          gpivol (ivol) = gasp_m(mdens_g(ivol),ivol)           ! gas pressure
          gdens  (ivol) = gasd_m(mdens_g(ivol),gmfrac(:,ivol)) ! gas density
          gvisc  (ivol) = gasv(gmfrac(:,ivol))                 ! gas viscosity 
          
#ifdef DEBUG
          if(info_debug > 10 .and. (ivol_gbl == ivol_track .or.        &
              ivol_track == 0)) then    
            write(idbg, *)                                             &
               "-->jacrt->ivol gnew(:,ivol) A11", ivol, gnew(:,ivol)
            write(idbg, *) "->ivol,gmfrac(:,ivol)",ivol,gmfrac(:,ivol)
            write(idbg, *) "->ivol,totgmfrac(:,ivol)",ivol,            &
                           totgmfrac(:,ivol) 
            write(idbg, *) "->ivol,gpivol,gdens,gvisc",ivol,           &
                           gpivol(ivol),gdens(ivol),gvisc(ivol)
          end if 
#endif 
        end if
        
#ifdef DEBUG
        if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.         &
            ivol_track == 0)) then
          write(idbg, *)                                               &
                "-->jacrt->ivol gnew(:,ivol) A12", ivol, gnew(:,ivol)
        end if
#endif

      end do                         !loop over control volumes
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif

      if (b_prtfile .and. tid == 1) then 
       prt_react_jac_part(1) = cputime() - prt_react_jac_part(1)
      end if

    
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
!cprovi Build the residual and Jacobian matrix
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------------
#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic, chunk)
#elif SCHEDULE_STATIC
    !$omp do schedule(static, chunk)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif 
#endif

      do ivol = 1,nngl                   !loop over control volumes
          
#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif
          
#ifdef OPENMP    
        tid = omp_get_thread_num() + 1
#else
        tid = 1
#endif

        izn = mpropvs(ivol)
        izn_c = mpropc(ivol)

        if (b_prtfile) then
          if(tid == 1) then
            rtimespan = cputime()
          end if
        end if

!cprovi-----------------------------------------------------------------------------
!cprovi temperature corrections for debye-huckel, equilibrium and rate constants
!cprovi-----------------------------------------------------------------------------       
        if (temp_corr.or.heat_transport) then
          call tcorr(tkel(ivol),ivol,tid)
        end if
!cprovi-----------------------------------------------------------------------------
!cprovi Recompute activity coefficients
!cprovi-----------------------------------------------------------------------------
        if (update_activity(tid).eq.'double_update') then
!cprovi----------------------------------------------      
         if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andrs Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi Cuidado, las componentes pueden no ser acuosas
!cprovi preguntarle a Uli 
!cprovi---------------------------------------------- 

        call pitzer (phase,gamma(1:nc,ivol),                          &
     &               gamma(nc+1:nc+nx,ivol),                          &
     &               cnew(1:nc,ivol),cx(1:nx,ivol),                   &
     &               nc,nx,ilog)

         else 
!c  --> for free species
          do ic=1,nc
            gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),           &
     &                             sionnew(ivol),chargec(ic),         &
     &                             dhac(ic),dhbc(ic),                 &
     &                             dhad(tid),dhbd(tid),               &
     &                             adav,bdav,acth2omin,nc,            &
     &                             nx,namec(ic),namec,ic,             &
     &                             issit,asit,basit,coepsil,          &
     &                             iasit,jasit)
          end do
        

!c  --> for secondary aqueous species
          do ix=1,nx
            gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol),        &
     &                                sionnew(ivol),chargex(ix),      &
     &                                dhax(ix),dhbx(ix),              &
     &                                dhad(tid),dhbd(tid),            &
     &                                adav,bdav,acth2omin,nc,         &
     &                                nx,namex(ix),namec,             &
     &                                nc+ix,issit,asit,basit,         &
     &                                coepsil,iasit,jasit)
          end do
         end if 
        end if

!c recompute root water uptake for current control volume (HG written by DSU)
!c and correct the flux by the passive factor (HG written by DSU)

        if (passive_uptake) then
          if (rld(ivol)>rverysmall) then
            qrootloc = cvol(ivol)*rootwat(sanew,ivol,rsum_vprop)
            if (rootwateruptake_field) then
              qrootloc = qrootloc*uptakefactor_vol(ivol)
            else
              qrootloc = qrootloc*uptakefactor(mpropvs(ivol))
            end if

#ifdef DEBUG
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                write(idbg,*) '--> qrootloc->ivol sanew rsum_vprop',   &
                      ivol,sanew(ivol),rsum_vprop
              end if
            end if 
#endif                       
          end if   
        end if 

!c  get row pointers

        idiag = iavs(ivol)           !diagonal
        istart = iavs(ivol)+1        !start - off-diagonal connections
        iend = iavs(ivol+1)-1        !end   - off-diagonal connections

!cprovi----------------------------------------------------------------
!cprovi Compute storage term 
!c  compute storage terms (aqueous phase)
!c  exclude non-aqueous components (surface sites) because 
!c  total surface concentrations remain constant
!cprovi----------------------------------------------------------------
        do ic=1,n
          if (hmulti_diff) then
                
            cstor(ic) = cvol(ivol)/delt                               &
     &                * (bulkconc(totcnewf(ic,ivol),                  &
     &                            sanew(ivol),                        &
     &                            pornew(ivol))                       &
     &                -  bulkconc(totcoldf(ic,ivol),                  &
     &                            saold(ivol),                        &
     &                            porold(ivol)))

          else

            cstor(ic) = cvol(ivol)/delt                               &
     &                * (bulkconc(totcnew(ic,ivol),                   &
     &                            sanew(ivol),                        &
     &                            pornew(ivol))                       &
     &                -  bulkconc(totcold(ic,ivol),                   &
     &                            saold(ivol),                        &
     &                            porold(ivol)))
            
#ifdef DEBUG
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                write(idbg,*)                                         &
                      "totcnew(ic,ivol),sanew(ivol),pornew(ivol)",    &
                      "totcold(ic,ivol),saold(ivol),porold(ivol)",    &
                      totcnew(ic,ivol),sanew(ivol),pornew(ivol),      &   
                      totcold(ic,ivol),saold(ivol),porold(ivol)
                write(idbg,*) "ic,cvol,delt,cstor",ic,cvol(ivol),     &
                      delt,cstor(ic)

              end if
            end if 
#endif
            
          end if 

        end do
!cprovi----------------------------------------------------------------        
!cprovi compute storage terms (gaseous phase)
!cprovi----------------------------------------------------------------

        if (ng>0) then

          do ic=1,n
            gstor(ic) = cvol(ivol)/delt                               &
     &                * (bulkconc(totgnew(ic,ivol),                   &
     &                            sgnew(ivol),                        &
     &                            pornew(ivol))                       &
     &                -  bulkconc(totgold(ic,ivol),                   &
     &                            sgold(ivol),                        &
     &                            porold(ivol)))

#ifdef DEBUG
          if(info_debug > 20) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then
              write(idbg,*) 'ic',ic,'gstor',gstor(ic),'delt',delt,     &
                    'totgnew',totgnew(ic,ivol),'sgnew',sgnew(ivol),    &
                    'pornew',pornew(ivol),'totgold',totgold(ic,ivol),  &
                    'sgold',sgold(ivol),'porold',porold(ivol)
            end if
          end if
#endif 
          end do
        else
          gstor = r0  
        end if

!c  compute storage terms (non-competitive sorption)

        if (noncompetitive_sorption) then
          do ic = 1,n
            astor(ic) = cvol(ivol)/delt * (totanew(ic,ivol) - totaold(ic,ivol))
          end do
        else
          astor = r0  
        end if

!c  compute storage terms (surface complexation and ion exchange)

        if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
            
          if (sorption_group.eq.'surface-complexation'.or.(nsb_surf.gt.0.and. &
              sorption_group.eq.'surface-complex and ion-exchange')) then  
              do ic=1,n            

                  totsb_surf(ic) = cvol(ivol)/delt                            &
                           * (pornew(ivol)*sanew(ivol)*totsnew_surf(ic,ivol) -  &
                            porold(ivol)*saold(ivol)*totsold_surf(ic,ivol))

        
              end do
          else
            totsb_surf = r0
          end if
           
          if (sorption_group.eq.'ion-exchange'.or.(nsb_ion.gt.0.and. &
              sorption_group.eq.'surface-complex and ion-exchange')) then  
            do ic=1,n            
              totsb_ion(ic) = cvol(ivol)/delt * (totsnew_ion(ic,ivol) - totsold_ion(ic,ivol))
            end do
          else
            totsb_ion = r0
          end if
        else
          totsb_surf = r0
          totsb_ion = r0
        end if        
        
!c  compute total source-sink terms towards total concentrations due
!c  to intra-aqueous kinetic reactions

        if (naq>0) then

!c  reaction rates of intra-aqueous kinetic reactions

          do iaq = 1,naq
            if (new_database) then
              call rateint_new(rateaq(iaq,tid),totcnew(1,ivol),       &
                               cnew(1,ivol),cx(1,ivol),gamma(1,ivol), &
                               gamma(nc+1,ivol),phi(1,ivol),iaq,      &
                               scalfac_aq_ivol(iaq,ivol),             &
                               sanew(ivol),pornew(ivol),tid)
            else
              call rateint(rateaq(iaq,tid),totcnew(1,ivol),           &
                           cnew(1,ivol),gamma(1,ivol),phi(1,ivol),    &
                           iaq,scalfac_aq_ivol(iaq,ivol),tid)
            end if
          end do
           
!c  total source/sink terms towards total aqueous component
!c  concentrations due to intra-aqueous kinetic reactions
          call totint(totaq(:,tid),tid,idbg)
          
!c  scale total source-sink term due to intra-aqueous kinetic 
!c  reactions

          do ic = 1,n
            totaq(ic,tid) = cvol(ivol) * bulkconc(totaq(ic,tid),       &
                                         sanew(ivol),pornew(ivol))
          end do
        else
          totaq(:,tid) = r0
        end if

!c  total source/sink terms towards total aqueous component
!c  concentrations due to noble gas ingrowth
        if (b_use_ngi) then
          do ingi = 1, ngi
            ic = noble_gas_ingrowth(ingi)%idx_namec
            !totaq_ngi(ic,tid) = -cvol(ivol) * bulkconc(                &
            !                    totRateNobleGas(ingi,ivol),r1,         &
            !                    r1-pornew(ivol))
            totaq_ngi(ic,tid) = -cvol(ivol) * totRateNobleGas(ingi,ivol)
          end do
        else
          totaq_ngi(:,tid) = r0
        end if
         
!c  compute degassing rates and total rates for removal of aqueous
!c  components due to degassing [mol L^-1 h2o s^-1]
 
        if (ng.gt.0.and.gas_removal) then
          if (density_dependence) then
            call rategasd(gnew(1,ivol),tkel(ivol),uvsnew(ivol),        &
                          sgnew(ivol),tid)
          else
            call rategas(gnew(1,ivol),tkel(ivol),hhead(ivol),zg(ivol), &
                         sgnew(ivol),tid)
          end if
          call totconcg(rateg(:,tid),totrateg)

!c  scale total rates for removal af aqueous components due to 
!c  degassing [mol L^-1 bulk s^-1]

          do ic = 1,n
            totrateg(ic) = cvol(ivol) * bulkconc(totrateg(ic),        &
     &                                           sanew(ivol),         &
     &                                           pornew(ivol))
          end do

!c  compress total rates for removal of aqueous components
!c  due to degassing in case of redox equilibrium reactions

          if (redox_equil.and.nr.gt.0) then
            call comptotc(totrateg)
          end if
        else
          totrateg = r0
        end if                   !(ng.gt.0.and.gas_removal)

!c  compute total sorbed component concentrations
!c  non-competitive sorption                                            

        if (noncompetitive_sorption) then
!c  total source/sink terms towards total aqueous component
!c  concentrations due to 1st order sorbed components decay
!c  by DSU, 2020-05-19                   
          if (b_use_sorption_decay) then 
!c  compute sorbed components concentration 
!c  due to decay [mol L^-1 bulk s^-1]
            do ic = 1, n
              sorptiondecayrate(ic) = totanew(ic,ivol)/delt*           &
                      (1.0d0-enat**(-sorptiondecayconst(ic)*delt))
              totsorptiondecay(ic) = cvol(ivol)*sorptiondecayrate(ic)
            end do
          else
            totsorptiondecay = r0
          end if      
        end if


!c  total source/sink terms towards total aqueous component
!c  concentrations due to 1st order aqueous decay
!c  by DSU, 2022-03-09
        if (b_use_aq_decay) then
          do ic = 1, n
            aqdecayrate(ic) = totcnew(ic,ivol)/delt*                   &
                               (1.0d0-enat**(-aqdecayconst(ic)*delt))

            totaqdecay(ic) = cvol(ivol) * bulkconc(aqdecayrate(ic),    &
                                                   sanew(ivol),        &
                                                   pornew(ivol))
          end do
        else
          totaqdecay = r0  
        end if

!c  total source/sink terms towards total aqueous component
!c  concentrations due to 1st order gas decay
!c  by DSU, 2017-06-08
        if (ng .gt. 0 .and. b_use_gas_decay) then
          do ig = 1, ng
            gasdecayrate(ig) = gnew(ig,ivol)/delt*                    &
                               (1.0d0-enat**(-gasdecayconst(ig)*delt))
          end do
         
!c  compute gaseous components concentration 
!c  due to gas decay [mol L^-1 bulk s^-1]

          call totconcg(gasdecayrate,totgasdecay)

          do ic = 1,n
            totgasdecay(ic) = cvol(ivol) * bulkconc(totgasdecay(ic), &
                                                    sgnew(ivol),     &
                                                    pornew(ivol))
          end do
        else
          totgasdecay = r0  
        end if

!c  compute total source-sink terms towards total concentrations due
!c  to kinetically controlled oxidation/reduction reactions

        if (.not.redox_equil.and.nr.gt.0) then

!c  overall oxidation-reduction rates for redox couples

          do ir = 1,nr
            call rateredx(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),      &
     &                    gamma(nc+1,ivol),rateor(ir,tid),            &
     &                    totcnew(1,ivol),ir,tid)
          end do

!c  total source/sink terms towards total aqueous component
!c  concentrations due to oxidation-reduction reactions
          call totredx(totor,tid,idbg)
          
!c  scale total source-sink term due to oxidation/reduction reactions

          do ic = 1,n
            totor(ic) = cvol(ivol) * bulkconc(totor(ic),              &
     &                                        sanew(ivol),            &
     &                                        pornew(ivol))    
          end do
        else
          totor = r0
        end if 

!c  scale total source-sink term due to dissolution/precipitation 
!c  reactions

        if (nm.gt.0) then
          do ic=1,n
            totdp(ic,tid) = cvol(ivol)*totmdp(ic,ivol)
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                write(idbg,'(a,3(1pe15.6e3))')                         &
                      "cvol(ivol),totmdp(ic,ivol),totdp(ic)",          &
                      cvol(ivol),totmdp(ic,ivol),totdp(ic,tid)
              end if
            end if 
          end do
        else
          totdp(:,tid) = r0
        end if

!c  calculate root related respiration
        if (root_uptake) then
          do ic = 1, n
            !c absorption or exudation by root
            !c convert rld(ivol)*resprate(ic,izn) from mol/m^3 to mol/L bulk             
            if (resprate(ic,izn) < r0) then    !exudation by root
              rootresp(ic) = cvol(ivol)*rld(ivol)*resprate(ic,izn)/conv3
            else                          !respiration by root 
              rootresp_current = cvol(ivol)*rld(ivol)*resprate(ic,izn)/conv3         !mol/day
              rootresp_max = (totcnew(ic,ivol)-                        &
                              max(rverysmall,totc_uptake_min(ic,izn)))*&
                              cvol(ivol)*pornew(ivol)*sanew(ivol)/delt               !mol/day
              rootresp(ic) = min(rootresp_current,max(rootresp_max,r0))
            end if

          end do
        else
          rootresp = r0
        end if
 
!c  compute fluxes between current control volume and adjacent
!c  control volumes and total flux into current control volume

        icon = 0                   !zero counter - connections

        do ic=1,n
          totcflux(ic) = r0        !zero total influx (aqueous phase)
        end do

!c add root water uptake term 7 Feb 2019 HG (written by DSU)

        if (passive_uptake) then 
          if (rld(ivol)>rverysmall) then 
            do ic = 1,n             
              totcflux(ic) = totcflux(ic) + totcnew(ic,ivol) * qrootloc  
            end do  
          end if
        end if    
        
        if (ng.gt.0) then
          do ic=1,n
            totgflux(ic) = r0      !zero total influx (gaseous phase)
          end do
        else
          totgflux = r0
        end if

        gpivol_ivol = 0.0d0
        gdens_ivol  = 0.0d0
        gvisc_ivol  = 0.0d0

!c  calculate gas properties + molar fractions
        if (ng .gt. 0 .and. (gas_advection .or. dgm .or. maxwell)) then
          !gpivol_ivol = gasp_m(mdens_g(ivol),ivol)           ! gas pressure
          !gdens_ivol  = gasd_m(mdens_g(ivol),gmfrac(:,ivol)) ! gas density
          !gvisc_ivol  = gasv(gmfrac(:,ivol))                 ! gas viscosity
          gpivol_ivol = gpivol(ivol)                          ! gas pressure
          gdens_ivol  = gdens(ivol)                           ! gas density
          gvisc_ivol  = gvisc(ivol)                           ! gas viscosity
        end if

        do i1 = istart,iend        !off-diagonal connections

          icon = icon+1            !current connection
          jvol = javs(i1)          !column pointer
          
#ifdef USG
          if (discretization_type > 0) then
            ncell = janumcell(i1)
          end if
#endif

! cdsu -------------------------------------------------------
! cdsu gradient reconstruction for reactive transport
! cdsu -------------------------------------------------------
#ifdef USG
          if (discretization_type > 0) then
            if (b_use_cross_diffusion_react) then
              if (multi_diff) then
                call gradient_cross_diff_md(i1,ivol,jvol,              &
                     grad_totviscnew_ivol,grad_totviscnew_jvol,        &
                     grad_totviscnew_kvol,grad_electro_ivol,           &
                     grad_electro_jvol,grad_electro_kvol,              &
                     grad_totviscnew_hls_loc,grad_electro_hls_loc,     &
                     grad_cgg_totviscnew,grad_cgg_electro)
              else
                call gradient_cross_diff_rt(i1,ivol,jvol,n,totcnew,    &
                     grad_totcnew_ivol,grad_totcnew_jvol,              &
                     grad_totcnew_kvol,grad_totcnew_hls_loc,           &
                     grad_cgg_totcnew)
              end if

              if (ng > 0) then
                call gradient_cross_diff_rt(i1,ivol,jvol,n,totgnew,    &
                     grad_totgnew_ivol,grad_totgnew_jvol,              &
                     grad_totgnew_kvol,grad_totgnew_hls_loc,           &
                     grad_cgg_totgnew)
              end if
            end if

!cdsu
!cdsu calculate influence coefficient
!cdsu
            if (diff_coff) then
              call usg_face_utility_cinfrt_da_ic(ivol,jvol,i1,         &
                       cinfrt_da_ic_usg_loc,cinfrt_da_ic_usg_cross_loc)
            else
              call usg_face_utility_cinfrt_da(ivol,jvol,i1,            &
                       cinfrt_da_usg_loc,cinfrt_da_usg_cross_loc)
            end if

            if (ng > 0) then
              call usg_face_utility_cinfrt_dg(ivol,jvol,i1,            &
                       cinfrt_dg_usg_loc,cinfrt_dg_usg_cross_loc)
            end if

            if (multi_diff) then
              call usg_face_utility_cinfrt_mcd(ivol,jvol,i1,           &
                       cinfrt_mcd_usg_loc,cinfrt_mcd_usg_cross_loc)
            end if

!cdsu calculate influence coefficient for variable saturated flow
            call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,  &
                     cinfvs_usg_cross_loc,permij_usg_loc)

          end if
#endif

!cdsu -------------------------------------------------------
!cdsu                   gas advection
!cdsu--------------------------------------------------------
          relpgij = 0.0d0
          totgij = 0.0d0
          gpivol_jvol = 0.0d0
          gdens_jvol = 0.0d0
          gvisc_jvol = 0.0d0

          if (ng .gt. 0 .and. (gas_advection .or. dgm .or. maxwell)) then

            !gpivol_jvol = gasp_m(mdens_g(jvol),jvol)           ! gas pressure
            !gdens_jvol  = gasd_m(mdens_g(jvol),gmfrac(:,jvol)) ! gas density
            !gvisc_jvol  = gasv(gmfrac(:,jvol))                 ! gas viscosity

            gpivol_jvol = gpivol(jvol)                          ! gas pressure
            gdens_jvol  = gdens(jvol)                           ! gas density
            gvisc_jvol  = gvisc(jvol)                           ! gas viscosity

#ifdef DEBUG
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                write(idbg, *)                                          &
                      "--> A ivol,jvol,gvisc_ivol,gvisc_jvol",          &
                      ivol,jvol,gvisc_ivol,gvisc_jvol
              end if
            end if
#endif

!         calculate gas properties at interface according to weighting scheme
#ifdef USG
            if (discretization_type > 0 .and. is_cell_based_relp) then

              !c modify relpgij externally
              do icell = 1, node_num_cells(ivol)
                relpgij = relpgij + relpermg(node_cells(icell,ivol))
              end do
              relpgij = relpgij / node_num_cells(ivol)

              relpgi = relpgij
              relpgj = relpgij

            else
#endif
              relpgi = relpermg(ivol)
              relpgj = relpermg(jvol)
#ifdef USG
            end if
#endif

            call wgprop(totgnew(1,ivol),totgnew(1,jvol),totgij ,     &
                      gnew(1,ivol)   ,gnew(1,jvol)   ,gij      ,     &
                      gmfrac(1,ivol) ,gmfrac(1,jvol) ,gmfracij ,     &
                      relpgi         ,relpgj         ,relpgij  ,     &
                      gdens_ivol     ,gdens_jvol     ,densgij  ,     &
                      gvisc_ivol     ,gvisc_jvol     ,viscgij  ,     &
                      gpivol_ivol    ,gpivol_jvol    ,gpij     ,     &
                      zg(ivol)       ,zg(jvol)       ,               &
                      spt_weight     ,iupsg(i1)      ,               &
                      nc             ,ng             ,gacc     )

#ifdef DEBUG
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                write(idbg, *)                                          &
                      "--> B ivol,jvol,gvisc_ivol,gvisc_jvol,viscgij",  &
                      ivol,jvol,gvisc_ivol,gvisc_jvol,viscgij
              end if
            end if
#endif


!c ----- DGM module -------------------------------------------------------------
!c         solve A F = B
!c         computes fluxes F of all gas components at current c.v. interphase
!c         to be modified later, cross diffusion for gas phase using DGM model is not
!c         included yet.

            if (dgm) then

#ifdef USG
              if (discretization_type > 0) then
                call dgm_fluxdg(gnew(1,ivol)       ,gnew(1,jvol) ,    &
                                gij                ,gmfracij     ,    &
                                zg(ivol)           ,zg(jvol)     ,    &
                                densgij            ,gpij         ,    &
                                tkel(ivol)         ,                  &
                                sum(permij_usg_loc(1:num_edge_dvols  ,&
                                                   1:ncell)) ,        &
                                relpgij            ,tauij(i1)    ,    &
                                gporij(i1)         ,deltaij(i1)  ,    &
                                rverysmall         ,                  &
                                ludecomp(1,1,icon) ,                  &
                                fmat(1,icon)       ,ipvt(1,icon) ,    &
                                dgm_gflux          ,neflux       )
              else
#endif
                call dgm_fluxdg (gnew(1,ivol)       ,gnew(1,jvol) ,    &
                                 gij                ,gmfracij     ,    &
                                 zg(ivol)           ,zg(jvol)     ,    &
                                 densgij            ,gpij         ,    &
                                 tkel(ivol)         ,permij(i1)   ,    &
                                 relpgij            ,tauij(i1)    ,    &
                                 gporij(i1)         ,deltaij(i1)  ,    &
                                 rverysmall         ,                  &
                                 ludecomp(1,1,icon) ,                  &
                                 fmat(1,icon)       ,ipvt(1,icon) ,    &
                                 dgm_gflux          ,neflux       )


#ifdef DEBUG
                if(info_debug > 10) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                    write(idbg, *) "check dgm_fluxdg ivol",ivol,       &
                          "jvol",jvol,"i1",i1,                         &
                          "gnew(:,ivol)",gnew(:,ivol),                 &
                          "gnew(:,jvol)",gnew(:,jvol),"gij",gij,       &
                          "gmfracij",gmfracij,"densgij",densgij,       &
                          "gpij",gpij,"tkel(ivol)",tkel(ivol),         &
                          "permij(i1)",permij(i1),"relpgij",relpgij,   &
                          "tauij(i1)",tauij(i1),                       &
                          "gporij(i1)",gporij(i1),                     &
                          "deltaij(i1)",deltaij(i1),                   &
                          "dgm_gflux",dgm_gflux(:),"neflux",neflux(:)
                  end if
                end if
#endif

#ifdef USG
              end if
#endif

!c ------------------------------------------------------------------------------
!c ----- Maxwell Stefan module --------------------------------------------------

            else if (maxwell) then

              call ms_fluxdg (gnew(1,ivol)        ,gnew(1,jvol) ,      &
     &                        gij                 ,gmfracij     ,      &
     &                        zg(ivol)            ,zg(jvol)     ,      &
     &                        densgij             ,gpij         ,      &
     &                        tkel(ivol)          ,tauij(i1)    ,      &
     &                        gporij(i1)          ,deltaij(i1)  ,      &
     &                        rverysmall          ,                    &
     &                        ludecomp(1,1,icon)  ,                    &
     &                        fmat(1,icon)        ,                    &
     &                        ipvt(1,icon)        ,equimolar    ,      &
     &                        ms_gflux            ,neflux       )

            endif

          end if

! prc -------------------------------------------------------
! prc calculating dynamic visusity for
! prc multicomponent diffusion flux
! prc -------------------------------------------------------


          if (multi_diff) then

            call totdyvisc(ivol,jvol,cnew(:,ivol),cx(:,ivol),          &
                           cnew(:,jvol),cx(:,jvol),                    &
                           delta_totviscnew(:,tid))

            call elecmigration(ivol,jvol,cnew(:,ivol),cx(:,ivol),      &
                               cnew(:,jvol),cx(:,jvol),                &
                               delta_electromignew(:,tid))

#ifdef DEBUG
            if(info_debug > 10) then
                if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                  write(idbg, *) "check elecmigration ",             &
                    "ivol",ivol,"jvol",jvol,                         &
                    "cnew(:,ivol)",cnew(:,ivol),                     &
                    "cnew(:,jvol)",cnew(:,jvol),                     &
                    "cx(:,ivol)",cx(:,ivol),"cx(:,jvol)",cx(:,jvol)
                end if
            end if
#endif

          end if

          do ic=1,n                !loop over primary unknowns

!cprovi---------------------------------------------------------------
!cprovi Bubbles use component dependent influence coefficient if specified
!cprovi---------------------------------------------------------------
            if (diff_coff) then
             cinfrt_da(i1) = cinfrt_da_ic(ic,i1)
#ifdef USG
              if (discretization_type > 0) then
                do idvol = 1, num_edge_dvols
                  do icell = 1, ncell
                    cinfrt_da_usg_loc(idvol,icell) =                    &
                           cinfrt_da_ic_usg_loc(ic,idvol,icell)
                    cinfrt_da_usg_cross_loc(idvol,icell) =              &
                           cinfrt_da_ic_usg_cross_loc(ic,idvol,icell)
                  end do
                end do
              end if
#endif
            end if
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!cprovi---------------------------------------------------------------
!c  compute aqueous phase flux
            if (multi_diff) then      !multi diffusion
#ifdef USG
              if (discretization_type > 0) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                grad_totcnew_mids = vector_zero
                grad_totviscnew_mids = vector_zero
                grad_electro_mids = vector_zero
                flux_totcnew_hls_corr = r0
                flux_totviscnew_hls_corr = r0
                flux_electro_hls_corr = r0

                if (b_use_cross_diffusion_react) then
                  call gradient_cross_diff_rt_average(ic,n,i1,ivol,    &
                       jvol,grad_totviscnew_ivol,grad_totviscnew_jvol, &
                       grad_totviscnew_kvol,grad_totviscnew_hls_loc,   &
                       grad_weights,grad_totviscnew_locs,              &
                       grad_totviscnew_mids,flux_totviscnew_hls_corr,  &
                       grad_cgg_totviscnew)
  
                  call gradient_cross_diff_rt_average(ic,n,i1,ivol,    &
                       jvol,grad_electro_ivol,grad_electro_jvol,       &
                       grad_electro_kvol,grad_electro_hls_loc,         &
                       grad_weights,grad_electro_locs,                 &
                       grad_electro_mids,flux_electro_hls_corr,        &
                       grad_cgg_electro)
                end if

                cflux(icon,ic) =                                               &
                      fluxv_vl(totcnew(ic,ivol),totcnew(ic,jvol),ivol,jvol,    & !advective term
                               cinfrt_va_usg(i1),ic)                           &
                    - fluxd_usg(r0,delta_totviscnew(ic,tid),                   & !diffusive term
                            num_edge_dvols,ncell,                              &
                            grad_totviscnew_mids(1:num_edge_dvols,1:ncell),    &
                            flux_totviscnew_hls_corr(1:num_edge_dvols,1:ncell),&
                            cinfrt_mcd_usg_loc(1:num_edge_dvols,1:ncell),      &
                            cinfrt_mcd_usg_cross_loc(1:num_edge_dvols,1:ncell))&
                    - fluxd_usg(r0,delta_electromignew(ic,tid),                & !electromigration term
                            num_edge_dvols,ncell,                              &
                            grad_electro_mids(1:num_edge_dvols,1:ncell),       &
                            flux_electro_hls_corr(1:num_edge_dvols,1:ncell),   &
                            cinfrt_mcd_usg_loc(1:num_edge_dvols,1:ncell),      &
                            cinfrt_mcd_usg_cross_loc(1:num_edge_dvols,1:ncell))
              else
#endif

                cflux(icon,ic) = fluxv_vl(totcnew(ic,ivol),            & !advective term
                                      totcnew(ic,jvol),                &
                                      ivol,jvol,                       &
                                      cinfrt_va(i1),ic)                &
                               - fluxd(r0,delta_totviscnew(ic,tid),    & !diffusive term
                                       cinfrt_mcd(i1))                 &
                               - fluxd(r0,delta_electromignew(ic,tid), & !electromigration term
                                       cinfrt_mcd(i1))

#ifdef USG
              end if
#endif

            else                 !not multi diffusion

#ifdef USG
              if (discretization_type > 0) then
                grad_totcnew_mids = vector_zero
                flux_totcnew_hls_corr = r0

                if (b_use_cross_diffusion_react) then
                  call gradient_cross_diff_rt_average(ic,n,i1,ivol,    &
                       jvol,grad_totcnew_ivol,grad_totcnew_jvol,       &
                       grad_totcnew_kvol,grad_totcnew_hls_loc,         &
                       grad_weights,grad_totcnew_locs,                 &
                       grad_totcnew_mids,flux_totcnew_hls_corr,        &
                       grad_cgg_totcnew)
                end if

                cflux(icon,ic) = fluxv_vl(totcnew(ic,ivol),totcnew(ic,jvol),ivol,jvol,    & !advective term
                                          cinfrt_va_usg(i1),ic)                           &
                               - fluxd_usg(totcnew(ic,ivol),totcnew(ic,jvol),             & !dispersive term
                                 num_edge_dvols,ncell,                                    &
                                 grad_totcnew_mids(1:num_edge_dvols,1:ncell),             &
                                 flux_totcnew_hls_corr(1:num_edge_dvols,1:ncell),         &
                                 cinfrt_da_usg_loc(1:num_edge_dvols,1:ncell),             &
                                 cinfrt_da_usg_cross_loc(1:num_edge_dvols,1:ncell))

#ifdef DEBUG
                    if(info_debug > 10) then
                      if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                        write(idbg, *)                                                 &
                        "--> no multi_diff cflux-a0: ivol",ivol,"jvol",jvol,           &
                        "i1",i1,"num_edge_dvols",num_edge_dvols,                       &
                        "janumcell(i1)",janumcell(i1),"cinfrt_va_usg",cinfrt_va_usg(i1)

                        do icell = 1, ncell
                          do idvol = 1, num_edge_dvols
                            write(idbg,*)                                              &
                                  "--> idvol",idvol,"icell",icell,                     &
                                  "icellid",jacell(icell,i1),                          &
                                  "grad",grad_totcnew_mids(idvol,icell)%x,             &
                                  grad_totcnew_mids(idvol,icell)%y,                    &
                                  grad_totcnew_mids(idvol,icell)%z,                    &
                                  "cinfrt_da_usg_cross",                               &
                                  cinfrt_da_usg_cross_loc(idvol,icell)%x,              &
                                  cinfrt_da_usg_cross_loc(idvol,icell)%y,              &
                                  cinfrt_da_usg_cross_loc(idvol,icell)%z,              &
                                  "hls-corr",flux_totcnew_hls_corr(idvol,icell),       &
                                  "cinfrt_da_usg",cinfrt_da_usg_loc(idvol,icell),      &
                                  "cflux(icon,ic)",cflux(icon,ic)

                          end do
                        end do

                      end if
                    end if
#endif

              else
#endif
                cflux(icon,ic) = fluxv_vl(totcnew(ic,ivol),            & !advective term
                                          totcnew(ic,jvol),            &
                                          ivol,jvol,                   &
                                          cinfrt_va(i1),ic)            &
                               - fluxd(totcnew(ic,ivol),               & !dispersive term
                                       totcnew(ic,jvol),               &
                                       cinfrt_da(i1))
#ifdef USG
              end if
#endif
            end if

!cmx  Check pore clogging condition, either ivol or jvol is clogged
!cmx  no mass flux between them
!cdsu fix bug
            !if (pore_clogging) then
            !  if (pornew(ivol) <= por_thresh_min .or.                  &
            !      pornew(jvol) <= por_thresh_min)  then
            !    cflux(icon,ic) = r0
            !  end if        
            !end if
    
        
!c  total influx
            totcflux(ic) = totcflux(ic) + cflux(icon,ic)

!c  compute gaseous phase flux and total influx

            if (ng.gt.0) then
                
              gflux(icon,ic) = r0
              
              if (gas_advection) then

                if (gsatij(i1).gt.gsatmin) then
                
#ifdef USG
                  if (discretization_type > 0) then
                    gflux(icon,ic) = fluxvg(gpivol_ivol ,gpivol_jvol , &
                                            zg(ivol)    ,zg(jvol)    , &
                                            totgij(ic)  ,relpgij     , &
                                            densgij     ,viscgij     , &
                                            rcvt*sum(cinfvs_usg_loc(   &
                                                1:num_edge_dvols,      &
                                                1:ncell)),             &
                                            gas_gravity ,gacc)
                  else
#endif
                    gflux(icon,ic) = fluxvg(gpivol_ivol ,gpivol_jvol , &
                                            zg(ivol)    ,zg(jvol)    , &
                                            totgij(ic)  ,relpgij     , &
                                            densgij     ,viscgij     , &
                                            cinfvs_g(i1),              &
                                            gas_gravity ,gacc)
#ifdef USG
                  end if
#endif
 
                endif
              
              endif ! gas advection 
              
#ifdef DEBUG
              if(info_debug > 10) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                    write(idbg,*)                                      &
                      "ivol",ivol,"jvol",jvol,"ic",ic,"gflux(icon,ic)",&
                      gflux(icon,ic),"totgij(ic)",totgij(ic),          &
                      "viscgij",viscgij,                               &
                      "gpivol_ivol",gpivol_ivol,"gpivol_jvol",         &
                      gpivol_jvol,"zg(ivol)",zg(ivol),"zg(jvol)",      &
                      zg(jvol),"relpgij",relpgij,"densgij",densgij,    &
                      "cinfvs_g(i1)",cinfvs_g(i1),"gacc",gacc
                  end if
              end if    
#endif
       
!c--------ficks law, business as usual------------------------------------

              if ((.not.dgm).and.(.not.maxwell)) then

                if (blanc_diff_g) then
#ifdef USG
                  if (discretization_type > 0) then
                    gasdiff_loc = gasdiff2(gmfrac(1,ivol),gmfrac(1,jvol),    &
                                           gpivol_ivol   ,gpivol_jvol   ,    &
                                           zg(ivol)      ,zg(jvol)      ,    &
                                           gdens_ivol    ,gdens_jvol    ,    &
                                           ic            ,                   &
                                           iupsg(i1)     ,spt_weight    )
                    cinfrt_usg(:,:) = cinfrt_dg_usg_loc(:,:)*gasdiff_loc
                    cinfrt_usg_cross(:,:) = cinfrt_dg_usg_cross_loc(:,:)* &
                                                   gasdiff_loc
                  else
#endif
!c                  diffusion coefficient calc'd with LeBlanc's law
                    cinfrt = cinfrt_dg(i1) * gasdiff2                        &
                                    (gmfrac(1,ivol), gmfrac(1,jvol),         &
                                     gpivol_ivol   , gpivol_jvol   ,         &
                                     zg(ivol)      , zg(jvol)      ,         &
                                     gdens_ivol    , gdens_jvol    ,         &
                                     ic            ,                         &
                                     iupsg(i1)     , spt_weight    )
#ifdef USG
                  end if
#endif
                else
!c                single constant diffusion
#ifdef USG
                  if (discretization_type > 0) then
                    cinfrt_usg(:,:) = cinfrt_dg_usg_loc(:,:)
                    cinfrt_usg_cross(:,:) =cinfrt_dg_usg_cross_loc(:,:)
                  else
#endif
                    cinfrt = cinfrt_dg(i1)
#ifdef USG
                  end if
#endif
                endif    

!c diffusion expressed in terms of concentration gradients
#ifdef USG
                if (discretization_type > 0) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                  grad_totgnew_mids = vector_zero
                  flux_totgnew_hls_corr = r0

                  if (b_use_cross_diffusion_react) then
                    call gradient_cross_diff_rt_average(ic,n,i1,ivol,    &
                         jvol,grad_totgnew_ivol,grad_totgnew_jvol,       &
                         grad_totgnew_kvol,grad_totgnew_hls_loc,         &
                         grad_weights,grad_totgnew_locs,                 &
                         grad_totgnew_mids,flux_totgnew_hls_corr,        &
                         grad_cgg_totgnew)
                  end if

                  gflux(icon,ic) = gflux(icon,ic)                              & !advective flux
                            - fluxd_usg(totgnew(ic,ivol), totgnew(ic,jvol),    & !diffusive flux
                              num_edge_dvols,ncell,                            &
                              grad_totgnew_mids(1:num_edge_dvols,1:ncell),     &
                              flux_totgnew_hls_corr(1:num_edge_dvols,1:ncell), &
                              cinfrt_usg(1:num_edge_dvols,1:ncell),            &
                              cinfrt_usg_cross(1:num_edge_dvols,1:ncell))
                else
#endif
                  gflux(icon,ic) = gflux(icon,ic)                      & !advective flux
                                 - fluxd(totgnew(ic,ivol),             & !diffusive flux
                                         totgnew(ic,jvol),             &
                                         cinfrt)
#ifdef USG
                end if
#endif

!c ------- DGM module -----------------------------------------------------------

              else if (dgm) then
 
!c               check if there is gas phase
                if (gporij(i1).lt.rverysmall .or.                      &
                    relpgij.lt.rverysmall) then
!c               no gas phase 

                else

#ifdef USG
                  if (discretization_type > 0) then
                    gflux(icon,ic) = gflux(icon,ic)                    &
                                   + sum(cinfrt_dg_usg_loc(            &
                                         1:num_edge_dvols,             &
                                         1:ncell))                     &
                                   * deltaij(i1)                       &
                                   * dgm_gflux(ic)                     &
                                   / tauij(i1)                         &
                                   / gporij(i1)
                  else
#endif
                    gflux(icon,ic) = gflux(icon,ic)                    &
                                   + cinfrt_dg(i1)                     &
                                   * deltaij(i1)                       &
                                   * dgm_gflux(ic)                     &
                                   / tauij(i1)                         &
                                   / gporij(i1)
#ifdef USG
                  end if
#endif

#ifdef DEBUG
                  if(info_debug > 10) then
                    if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                      write(idbg, *) "ivol, ic, icon",ivol,ic,icon,    &
                            "glfux",gflux(icon,ic),"cinfrt_dg",        &
                            cinfrt_dg(i1),"deltaij",deltaij(i1),       &
                            "dgm_gflux",dgm_gflux(ic),"tauij",         &
                            tauij(i1),"gporij",gporij(i1)
                    end if
                  end if
#endif

                endif

!c ------- Maxwell Stefan module -------------------------------------------------

              else if (maxwell) then

!c               check if there is gas phase
                if (gporij(i1).lt.rverysmall) then
!c               no gas phase 

                else
#ifdef USG
                  if (discretization_type > 0) then
                    gflux(icon,ic) = gflux(icon,ic)                    &
                                   + sum(cinfrt_dg_usg_loc(            &
                                         1:num_edge_dvols,             &
                                         1:ncell))                     &
                                   * deltaij(i1)                       &
                                   * ms_gflux(ic)                      &
                                   / tauij(i1)                         &
                                   / gporij(i1)
                  else
#endif
                    gflux(icon,ic) = gflux(icon,ic)                    &
                                   + cinfrt_dg(i1)                     &
                                   * deltaij(i1)                       &
                                   * ms_gflux(ic)                      &
                                   / tauij(i1)                         &
                                   / gporij(i1)
#ifdef USG
                  end if
#endif

#ifdef DEBUG
                  if(info_debug > 10) then
                    if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                      write(idbg, *) "ivol, ic, icon",ivol,ic,icon,    &
                            "glfux",gflux(icon,ic),"cinfrt_dg",        &
                            cinfrt_dg(i1),"deltaij",deltaij(i1),       &
                            "ms_gflux",ms_gflux(ic),"tauij",           &
                            tauij(i1),"gporij",gporij(i1)
                    end if
                  end if
#endif
                endif

              end if      
 
              totgflux(ic) = totgflux(ic) + gflux(icon,ic)
#ifdef DEBUG
              if(info_debug > 10) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                    write(idbg, *) "ivol, ic, totgflux(ic)",           &
                    ivol, ic, totgflux(ic)
                  end if
              end if    
#endif
          end if

          end do                   !loop over components
          
        end do                     !off-diagonal connections

!c  construct rhs-vector
 
        do ic = 1,n

          irow = (ivol-1)*n+ic      !pointer - global rhs-vector 

          call rhsrt(naq,ng,nm,nr,nsb_ion,nsb_surf,astor(ic),         &
                     cstor(ic),gstor(ic),totaq(ic,tid),               &
                     totsb_ion(ic),totsb_surf(ic),                    &
                     totor(ic),totdp(ic,tid),                         &
                     totcflux(ic),totgflux(ic),totrateg(ic),          &
                     rootresp(ic),totgasdecay(ic),b_use_gas_decay,    &
                     totaqdecay(ic),b_use_aq_decay,                   &
                     totsorptiondecay(ic),b_use_sorption_decay,       &
                     totaq_ngi(ic,tid),b_use_ngi,           &
                     redox_equil,noncompetitive_sorption,             &
                     component_type(ic),brt(irow))
#ifdef DEBUG
          if(info_debug > 20) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                write(idbg,*) "ic",ic,"irow",irow
                write(idbg,*) "naq,ng,nm,nr,nsb_ion,nsb_surf",        &
                  naq,ng,nm,nr,nsb_ion,nsb_surf
                write(idbg,*)                                         &
                  "astor(ic),cstor(ic),gstor(ic),totaq(ic)",          &
                  astor(ic),cstor(ic),gstor(ic),totaq(ic,tid)
                write(idbg,*)                                         &
                  "totsb_ion(ic),totsb_surf(ic),totor(ic)",           &
                  totsb_ion(ic),totsb_surf(ic),totor(ic)
                write(idbg,*)                                         &
                  "totdp(ic),totcflux(ic),totgflux(ic),totrateg(ic)", &
                  totdp(ic,tid),totcflux(ic),totgflux(ic),totrateg(ic)
                write(idbg,*)                                         &
                  "redox_equil,noncompetitive_sorption",              &
                  redox_equil,noncompetitive_sorption
                write(idbg,*)                                         &
                  "irow,brt,component_type(ic)",irow,brt(irow),       &
                  component_type(ic)
              end if
          end if
#endif
        end do

 
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!cprovi-----------------------------------------------------------------
!c  compute derivatives for jacobian matrix

        do ic=1,nc
          cinc(ic,tid) = cnew(ic,ivol)  !extract free species concentrations
        end do                      !for current control volume

        
        !if(info_debug > 0 .and. ittot_rt < 5 .and. ivol == nngl) then 
        !    write(idbg, *) "Openmp test: label 6"
        !    write(idbg, *) "---> brt:"
        !    write(idbg, *) brt
        !end if
  
        if (b_prtfile) then
            if(tid == 1) then
                rtimespan = cputime() - rtimespan
                prt_react_jac_part(2) = prt_react_jac_part(2) + rtimespan
            end if     
        end if
       
        do jbl=1,n               !loop over columns of block matrix
        
          if (b_prtfile) then
              if(tid == 1) then  
                rtimespan = cputime()
              end if  
          end if

!c  compute increment for numerical differentiation

          drtinc = dinc_rt*cnew(jbl,ivol)

!c  increment free species concentration for current column
 
          cinc(jbl,tid) = cnew(jbl,ivol)+drtinc

!c  equilibrium redox reactions, compute concentrations of dependent
!c  components of redox couples with incremented free species
!c  concentrations

          if (redox_equil.and.nr.gt.0) then
            do ir=1,nr
              ic = n+ir    
              call secspec(cinc(:,tid),cinc(ic,tid),eqr(ir,tid),      &
                   gamma(1,ivol),gamma(ic,ivol),xnur,iarc,jarc,nc,ir)
            end do
          end if

!c  compute aqueous complex concentrations with incremented free species
!c  concentrations

          do ix=1,nx
            call secspec(cinc(:,tid),cxinc(ix,tid),eqx(ix,tid),       &
                 gamma(1,ivol),gamma(nc+ix,ivol),xnux,iax,jax,nc,ix)
          end do
         
!c  compute derivatives of total aqueous component concentrations
!c  to be modified later, for better performance for USG as the derivation has already been saved

          if (analyt_deriv_rt) then
            call atotconc(cnew(1,ivol),cx(1,ivol),jbl,tid)
          else
            if (hmulti_diff) then
                call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl,tid,izn)
                call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl,tid,0)
            else   
                call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl,tid,0)
            end if
          end if

!c  compute derivative of sorbed concentrations (non-competitive
!c  sorption) and scale total source and sink term 

          if (noncompetitive_sorption) then
          
            call totcona(dtota,dtotc(:,tid),distcoff_rt(1,ivol),       &
                         sanew(ivol), pornew(ivol))
            do ic = 1,n
              dtota(ic) = cvol(ivol)/delt * dtota(ic)
            end do 
            
          end if

!c  compress total aqueous and sorbed (noncompetitive sorption)
!c  component concentration vector in case of redox equilibrium 
!c  reactions

          if (redox_equil.and.nr.gt.0) then
            call comptotc(dtotc(:,tid))
            if (noncompetitive_sorption) then
              call comptotc(dtota)
            end if
          end if

!c  compute gas concentrations with incremented free species 
!c  concentrations 

          if (ng.gt.0) then

            do ig = 1,ng
              call gasconc(cinc(:,tid),gamma(1,ivol),ginc(ig,tid),     &
                   ig,tkel(ivol),tid)
            end do
            
#ifdef DEBUG
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                write(idbg, *) "--> compute gas concentrations with ", &
                               "incremented free species"  
                write(idbg, *) "--> cinc", cinc(:,tid)
                write(idbg, *) "--> gamma", gamma(:,ivol)
                write(idbg, *) "--> ginc", ginc(:,tid)
                write(idbg, *) "--> tkel", tkel(ivol)
                write(idbg, *) "--> eqg", eqg(:,tid)
              end if
            end if
#endif

!c  compute derivatives of total gaseous component concentrations 

            call dtotcong(gnew(1,ivol),ginc(:,tid),dtotg(:,tid),xnug,drtinc, &
     &                    iaga,jaga,nc,ng,jbl,namec)
            
#ifdef DEBUG
            if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                write(idbg, *) "--> compute derivatives of total ",    &
                "gaseous component concentrations"  
                write(idbg, *) "--> ivol,nc,ng,jbl", ivol,nc,ng,jbl
                write(idbg, *) "--> gnew", gnew(:,ivol)
                write(idbg, *) "--> ginc", ginc(:,tid)
                write(idbg, *) "--> dtotg", dtotg(:,tid)
                write(idbg, *) "--> xnug", xnug
                write(idbg, *) "--> drtinc", drtinc
              end if
            end if
#endif

!c  compress derivative of total gaseous component concentration 
!c  vector in case of redox equilibrium reactions

            if (redox_equil.and.nr.gt.0) then
              call comptotc(dtotg(:,tid))
            end if

!c  compute derivatives of degassing rates and derivatives of total 
!c  rates for removal of aqueous components due to degassing 
!c  [mol L^-1 h2o s^-1]

            if (gas_removal) then
              if (density_dependence) then
                call drategdd(gnew(1,ivol),tkel(ivol),uvsnew(ivol),   &
     &                        drtinc,tid)
              else
                call drategas(gnew(1,ivol),tkel(ivol),hhead(ivol),    &
     &                        zg(ivol),drtinc,tid)         
              end if
              call totconcg(rateg(:,tid),totrateg)

!c  scale derivatives of total rates for removal af aqueous components 
!c  due to degassing [mol L^-1 bulk s^-1]

              do ic = 1,n
                totrateg(ic) = cvol(ivol) * bulkconc(totrateg(ic),    &
     &                                               sanew(ivol),     &
     &                                               pornew(ivol))
              end do

!c  compress derivatives of total rates for removal of aqueous components
!c  due to degassing in case of redox equilibrium reactions

              if (redox_equil.and.nr.gt.0) then
                call comptotc(totrateg)
              end if
            else
              totrateg = r0
            end if

!c  compute derivatives of total rates for aqueous components due to 
!c  1st order aqueous decay
!c  by DSU, 2022-03-09
            if (b_use_aq_decay) then
              do ic = 1, n
                daqdecayrate(ic) = dtotc(ic,tid)/delt*                 &
                        (1.0d0-enat**(-aqdecayconst(ic)*delt))

                dtotaqdecay(ic) = cvol(ivol)*bulkconc(daqdecayrate(ic),&
                                              sanew(ivol),pornew(ivol))
              end do
            end if

!c  compute derivatives of total rates for aqueous components due to 
!c  1st order gas decay
            if (b_use_gas_decay) then
              do ig = 1, ng
                dgasdecayrate(ig) = (ginc(ig,tid)-gnew(ig,ivol))/delt*    &
                             (1.0d0-enat**(-gasdecayconst(ig)*delt))/drtinc
              end do
         
!c  compute gaseous components concentration 
!c  due to gas decay [mol L^-1 bulk s^-1]

              call totconcg(dgasdecayrate,dtotgasdecay)

              do ic = 1,n
                dtotgasdecay(ic) = cvol(ivol) * bulkconc(dtotgasdecay(ic),&
                                                sgnew(ivol),pornew(ivol))
              end do
            end if           

          end if

!c  compute partial derivatives of concentrations of sorbed species 
!c  with respect to primary unknowns

          if (nsb_ion.gt.0.or.nsb_surf.gt.0) then

            if(nsb_ion.gt.0) then
              do isb = 1,nsb_ion  
                call sorbspc_m(csb_ion(isb,tid),dummy,cec_g(ivol),    &
                     cec_fraction_g(idx_nsites_ion(isb),ivol),        &
                     eqsb_ion(:,tid), eqsb_surf(:,tid),               &
                     gamma(1,ivol),cnew(1,ivol),                      &
                     xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,         &
                     jasb_ion,jasb_surf,nsb_ion,nsb_surf,isb,0,       &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)    
                call sorbspc_m(dcsb_ion(isb,tid),dummy,cec_g(ivol),   &
                     cec_fraction_g(idx_nsites_ion(isb),ivol),        &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),                &
                     gamma(1,ivol), cinc(:,tid),                      &
                     xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,         &
                     jasb_ion,jasb_surf,nsb_ion,nsb_surf,isb,0,       &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)
                dcsb_ion(isb,tid) =                                   &
                    (dcsb_ion(isb,tid) - csb_ion(isb,tid))/drtinc 
              end do
            end if
            
            if(nsb_surf.gt.0) then
              do isb = 1,nsb_surf  
                call sorbspc(dummy,csb_surf(isb,tid),cec_g(ivol),     &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),                &
                     gamma(1,ivol),cnew(1,ivol),                      &
                     xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,         &
                     jasb_ion,jasb_surf,nsb_ion,nsb_surf,0,isb,       &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)
                call sorbspc(dummy,dcsb_surf(isb,tid),cec_g(ivol),    &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),                &
                     gamma(1,ivol), cinc(:,tid),                      &
                     xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,         &
                     jasb_ion,jasb_surf,nsb_ion,nsb_surf,0,isb,       &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)                
                dcsb_surf(isb,tid) =                                  &
                    (dcsb_surf(isb,tid) - csb_surf(isb,tid))/drtinc
              end do
            end if

!c  compute derivatives of of total sorbed component concentrations

            call totsorb(dcsb_ion(:,tid),dcsb_surf(:,tid),            &
                         chargesb_ion,rhobulk_g(ivol),                &
                         dtotsb_ion(:,tid),dtotsb_surf(:,tid),        &
                         xnusb_ion,xnusb_surf,iasb_ion,iasb_surf,     &
                         jasb_ion,jasb_surf,nc,nsb_ion,nsb_surf,      &
                         namec)

!c  compress derivative of total sorbed component concentration 
!c  vector in case of redox equilibrium reactions

            if (redox_equil.and.nr.gt.0.and.nsb_ion.gt.0) then
              call comptotc(dtotsb_ion(:,tid)) 
            end if
            
            if (redox_equil.and.nr.gt.0.and.nsb_surf.gt.0) then
              call comptotc(dtotsb_surf(:,tid)) 
            end if

!c  scale total source and sink term towards total aqueous component
!c  concentrations due to sorption reactions
      
            do ic = 1,n
              if(nsb_ion.gt.0) then  
                dtotsb_ion(ic,tid) = cvol(ivol)/delt *                &
                                     dtotsb_ion(ic,tid)
              end if
              if(nsb_surf.gt.0) then  
                dtotsb_surf(ic,tid) = cvol(ivol)/delt *               &
                                      dtotsb_surf(ic,tid)
              end if
              if (nsb_surf.gt.0.and.(sorption_group.eq.               &
                  'surface-complexation'.or. sorption_group.eq.       &
                  'surface-complex and ion-exchange')) then
                dtotsb_surf(ic,tid) = sanew(ivol)*pornew(ivol)*       &
                                      dtotsb_surf(ic,tid)
              end if
            end do

          end if

!c  compute total aqueous component concentrations (incremented),
!c  to be used for computing derivatives of dissolution-precipitation,
!c  oxidation-reduction rates and/or advective fluxes (Van Leer flux
!c  limiter)

          if ((.not.redox_equil.and.nr.gt.0).or.(nm.gt.0).or.         &
     &         naq.gt.0) then
            call totconc(cinc(:,tid),cxinc(:,tid),totcinc(:,tid))
          end if

!c  compute derivatives of intra-aqueous kinetic reactions

          if (naq.gt.0) then

            do iaq = 1,naq
              if (new_database) then
                call drateint_new(rateaq(iaq,tid),totcnew(1,ivol),    & 
                                cnew(1,ivol),cx(1,ivol),gamma(1,ivol),&
                                gamma(nc+1,ivol),phi(1,ivol),         &
                                drtinc,iaq,scalfac_aq_ivol(iaq,ivol), &
                                sanew(ivol),pornew(ivol),tid)
              else
                
                call drateint(rateaq(iaq,tid),totcnew(1,ivol),        &
                              cnew(1,ivol),gamma(1,ivol),phi(1,ivol), &
                              drtinc,iaq,scalfac_aq_ivol(iaq,ivol),   &
                              tid)
              end if
            end do

!c  derivative of total source/sink terms towards total aqueous component
!c  concentrations due to intra-aqueous kinetic reactions
            call totint(dtotaq(:,tid),tid,idbg)

!c  scale derivative of total source-sink term due to intra-aqueous 
!c  kinetic reactions

            do ic = 1,n
              dtotaq(ic,tid) = cvol(ivol) * bulkconc(dtotaq(ic,tid),  &
     &                                           sanew(ivol),         &
     &                                           pornew(ivol))        

            end do

          end if

!c  compute derivatives of oxidation-reduction rates

          if (.not.redox_equil.and.nr.gt.0) then

            do ir = 1,nr
              call draterdx(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),    &
     &                      gamma(nc+1,ivol),rateor(ir,tid),          &
     &                      totcnew(1,ivol),drtinc,ir,tid,idbg)
            end do

!c  derivative of total source/sink terms towards total aqueous 
!c  component concentrations due to derivatives of oxidation/reduction 
!c  reactions
            call totredx(dtotor,tid,idbg)
 
!c  scale derivative of total source-sink term due to 
!c  oxidation/reduction reactions

            do ic = 1,n
              dtotor(ic) = cvol(ivol) * bulkconc(dtotor(ic),          &
     &                                           sanew(ivol),         &
     &                                           pornew(ivol))
            end do

          end if

!c  compute derivatives of total source-sink terms towards total 
!c  aqueous component concentrations due to dissolution-precipitation 
!c  reactions 
 
          if (nm.gt.0) then

!c  compute total molar concentration in organic mixture 
            call molconc(phiold(1,ivol),tid)

            do im=1,nm

!c  - compute derivative of rate if:
!c     * sufficient mineral mass is available 
!c     * abs(dissolution-precipitation rate) > 0 
!c    otherwise: set derivative of rate to zero

              dissvol = ratemdp(im,ivol)*delt

              if ((cmnew(im,ivol)+dissvol).lt.                        &
     &            (r1+small)*cmcmin(im,tid).or.                       &
     &            dabs(ratemdp(im,ivol)).lt.tinyrate) then
!cmbalmin            if ((cmnew(im,ivol).le.cmcmin(im).and.
!cmbalmin     &           ratemdp(im,ivol).le.r0).or.
!cmbalmin     &          (dabs(ratemdp(im,ivol)).lt.tinyrate)) then
                
                dratedp(im,tid) = r0
 
              else

                if (analyt_deriv_rt) then

                  call aratemin(totcnew(1,ivol),cnew(1,ivol),         &
                                cx(1,ivol),gamma(1,ivol),             &
                                gamma(nc+1,ivol),dratedp(im,tid),     &
                                phi(im,ivol),phiold(im,ivol),         &
                                area(im,ivol),im,jbl,ivol,tid)

                else
                  if (pressure_approximation(im)) then
                    call drate_gasmin(dratedp(im,tid),im,ivol,        &
                                      area(im,ivol),drtinc,tid)
                
                  else if (new_database) then
                    if (root_uptake) then
                      rootdens = rld(ivol)
                    else
                      rootdens = r1
                    end if
                    call dratemin_new(totcnew(1,ivol),cnew(1,ivol),   &  
                                    cx(1,ivol),gamma(1,ivol),         &
                                    gamma(nc+1,ivol),sanew(ivol),     &
                                    dratedp(im,tid),                  &
                                    phi(1,ivol),phiold(im,ivol),      &
                                    area(im,ivol),drtinc,rootdens,    &
                                    im,ivol,tid)
                  else

                    call dratemin(totcnew(1,ivol),cnew(1,ivol),       &  
                                cx(1,ivol),gamma(1,ivol),             &
                                gamma(nc+1,ivol),dratedp(im,tid),     &
                                phi(im,ivol),phiold(im,ivol),         &
                                area(im,ivol),drtinc,im,ivol,tid)
                
                 end if
                end if

              end if

!c  set derivative of rate to zero, if solution supersaturated,
!c  but precipitation does not occur 

              if (.not.far_from_equil(im)) then
                if (dlog10(satm(im,tid)).lt.supsatm(im) .and.         &
     &              ratemdp(im,ivol).gt.r0) then

                  dratedp(im,tid) = r0

                end if
              end if
              
!cmx  set mineral reaction rate to 0.0 in clogged control volume
              if (pore_clogging) then
                if (pornew(ivol) <= por_thresh_min) then
                    dratedp(im,tid) = r0
                end if
              end if

!cdsu  Adjust mineral rate for intermittent reactions
              if (flag_intermittent_react) then
                if (imizn2jairm(im,izn_c) > 0) then
                  dratedp(im,tid) = dratedp(im,tid)*imizn2irc(im,izn_c)
                end if                 
              end if

!cdsu  Assign mineral rate for freezing water
              if(b_water_freezing_ratemin) then
                if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                  dratedp(im,tid) = r0
                end if
              end if              

            end do

!c  derivatives of total source/sink terms due to dissolution/
!c  precipitation reactions
 
            call totmin(dratedp(:,tid),dtotdp(:,tid))

!c  compress  derivatives of source/sink term towards total aqueous
!c  component concentrations due to mineral dissolution-precipitation
!c  reactions in case of redox equilibrium reactions

            if (redox_equil.and.nr.gt.0) then
              call comptotc(dtotdp(:,tid)) 
            end if

!c  scale derivative of total source-sink term due to 
!c  dissolution/precipitation reactions

            do ic=1,n
              dtotdp(ic,tid) = cvol(ivol)*dtotdp(ic,tid)
            end do

          end if                  !(nm.gt.0)

!c  construct current column of jacobian matrix

          icon = 0                     !zero counter (connections)

          do ic=1,n
            dtotcflux(ic) = r0         !zero derivative of total
          end do                       !influx (aqueous phase)

!c calculate derivative of respiration (HG)
          if (root_uptake) then 
            !c derivative of respiration depends on the formula
            !c if respiration rate is not related to solute concentration, 
            !c as shown below, then derivative is zero
            !c rootresp(ic) = cvol(ivol)*rld(ivol)*resprate(ic,izn)/conv3
            !c drootresp(ic) = d(rootresp)/d(cnew) = r0
            drootresp = r0
          else
            drootresp = r0
          end if 
              
!croot - add derivative of root water uptake term (HG)

          if (passive_uptake) then
            if (rld(ivol)>rverysmall) then
              do ic = 1,n     
                dtotcflux(ic) = dtotcflux(ic) - dtotc(ic,tid) * qrootloc 
              end do 
            end if
          end if 

#ifdef DEBUG
          if(info_debug > 20) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
              write(idbg, *) "--> dtotcflux -> dtotc(:), qrootloc: ",      &
                    dtotc(:,tid),qrootloc
            end if
          end if 
#endif

          if (ng.gt.0) then
            do ic=1,n
              dtotgflux(ic) = r0       !zero derivative of total
            end do                     !influx (gaseous phase)
          end if
          
!c  compute numerical derivatives for each gas wrt primary unknown incremented
          if (ng.gt.0 .and. (gas_advection .or. dgm .or. maxwell)) then
            
              do ig = 1,ng
                dg(ig) = (ginc(ig,tid) - gnew(ig,ivol)) / drtinc
              end do
              
              dgpivol  = gasp(ng,dg,ivol)          
              dmdens_i = gasm(ng,dg)
              ddens_i  = gasd_m(dmdens_i,gmfrac(:,ivol)) 
              
!c  for dgm module calculations:
!c  calculate gas molar densities and mole fractions
              mdens_g_inc = gasm(ng,ginc(:,tid))                    !gas molar density              
              do ig=1,ng
                dgmfrac(ig) = (ginc(ig,tid)/mdens_g_inc-gmfrac(ig,ivol)) / &
                               drtinc
              enddo
!c  end dgm
              
          end if    

          if (b_prtfile) then
              if(tid == 1) then
                rtimespan = cputime() - rtimespan
                prt_react_jac_part(3) = prt_react_jac_part(3) + rtimespan
                rtimespan = cputime()
              end if
          end if
          
          do i1 = istart,iend          !off-diagonal connections

            icon = icon+1              !pointer - connection
            jvol = javs(i1)            !pointer - column
            isym = isymvs(i1)          !symmetry pointer - 1d - scalar
            lsym = lart(isym)          !symmetry pointer - global block

#ifdef USG
            if (discretization_type > 0) then
              ncell = janumcell(i1)
            end if
#endif

            if (ng.gt.0 .and. (gas_advection.or.dgm.or.maxwell)) then 

              !gpivol_jvol = gasp_m(mdens_g(jvol),jvol)           ! gas pressure
              !gdens_jvol  = gasd_m(mdens_g(jvol),gmfrac(:,jvol)) ! gas density
              !gvisc_jvol  = gasv(gmfrac(:,jvol))                 ! gas viscosity
              gpivol_jvol = gpivol(jvol)                          ! gas pressure
              gdens_jvol  = gdens(jvol)                           ! gas density
              gvisc_jvol  = gvisc(jvol)                           ! gas viscosity
#ifdef USG
              if (discretization_type > 0 .and. is_cell_based_relp) then

                !c modify relpgij externally
                relpgij = 0.0d0
                do icell = 1, node_num_cells(ivol)
                  relpgij = relpgij + relpermg(node_cells(icell,ivol))
                end do
                relpgij = relpgij / node_num_cells(ivol)

                relpgi = relpgij
                relpgj = relpgij

              else
#endif
                relpgi = relpermg(ivol)
                relpgj = relpermg(jvol)
#ifdef USG
              end if
#endif

!c        calculate gas properties at interface according to weighting scheme
              call wgpropd( totgnew(1,ivol),totgnew(1,jvol),totgij   , &
     &                      relpgi         ,relpgj         ,relpgij  , &
     &                      gdens_ivol     ,gdens_jvol     ,densgij  , &
     &                      gvisc_ivol     ,gvisc_jvol     ,viscgij  , &
     &                      gpivol_ivol    ,gpivol_jvol    ,gpij     , &
     &                      zg(ivol)       ,zg(jvol)       ,           &
     &                      spt_weight     ,iupsg(i1)      ,wfac     , &
     &                      nc             ,ng             ,gacc     )
               
!c ----- DGM module -------------------------------------------------------------
!c           solve A dF/dy = dB/dy - dA/dy F
!c           calculates derivatives of fluxes for current c.v. interphase
          
              if (dgm) then
              
                call dgm_dfluxdg (gnew(1,ivol)  ,gnew(1,jvol)  ,       &
     &                            dg            ,dgmfrac       ,       &
     &                            zg(ivol)      ,zg(jvol)      ,       &
     &                            densgij       ,gpij          ,       &
     &                            tkel(ivol)    ,relpgij       ,       &
     &                            tauij(i1)     ,gporij(i1)    ,       &
     &                            deltaij(i1)   ,rverysmall    ,       &
     &                            wfac          ,ipvt(1,icon)  ,       &
     &                            ludecomp(1,1,icon)           ,       &
     &                            fmat(1,icon)  ,dgm_dgflux    )
            
              endif

!c ------------------------------------------------------------------------------
!c ----- Maxwell Stefan module --------------------------------------------------
!c           solve A dF/dy = dB/dy - dA/dy F
!c           calculates derivatives of fluxes for current c.v. interphase
          
              if (maxwell) then
              
                do i=1,ng-1
                  do j=1,ng-1
                    lumat2(i,j)=ludecomp(i,j,icon)
                  enddo
                enddo
                
                call ms_dfluxdg  (gnew(1,ivol)    ,gnew(1,jvol)    ,   &
     &                            dg              ,dgmfrac         ,   &
     &                            zg(ivol)        ,zg(jvol)        ,   &
     &                            densgij         ,gpij            ,   &
     &                            tkel(ivol)      ,tauij(i1)       ,   &
     &                            gporij(i1)      ,deltaij(i1)     ,   &
     &                            rverysmall      ,wfac            ,   &
     &                            ipvt(1,icon)    ,equimolar       ,   &
     &                            lumat2          ,fmat(1,icon)    ,   &
     &                            ms_gflux        ,ms_dgflux   )
              
              endif

            end if 
            

!c  compute derivatives of fluxes between current control volume 
!c  and adjacent control volumes and derivatives of total fluxes into 
!c  current control volume

! prc -------------------------------------------------------
! prc calculating derivatives dynamic visusity for 
! prc multicomponent diffusion flux 
! prc -------------------------------------------------------
        
            if (multi_diff) then

              call totdyvisc(ivol,jvol,cinc(:,tid),cxinc(:,tid),       &
                             cnew(:,ivol),cx(:,ivol),                  &
                             delta_totviscnew(:,tid))

              call elecmigration(ivol,jvol,cinc(:,tid),cxinc(:,tid),   &
                                 cnew(:,ivol),cx(:,ivol),              &
                                 delta_electromignew(:,tid))

#ifdef DEBUG
              if(info_debug > 10) then
                if(ivol_gbl == ivol_track .or. ivol_track == 0) then
#ifdef PETSC
                 write(idbg, *)                                        &
                   "--> multi_diff delecmigrationnew: global ivol",    &
                   node_idx_lg2g(ivol),"global jvol",node_idx_lg2g(jvol)
#else
                 write(idbg, *)                                        &
                   "--> multi_diff delecmigrationnew: ivol",ivol,      &
                   "jvol",jvol
#endif

                 do ibl=1,nc-1
                     write(idbg,*)                                     &
                     "ibl",ibl,                                        &
                     "cnew(ibl,ivol)",cnew(ibl,ivol),                  &
                     "cx(ibl,ivol)",cx(ibl,ivol),                      &
                     "cnew(ibl,jvol)",cnew(ibl,jvol),                  &
                     "cx(ibl,jvol)",cx(ibl,jvol),                      &
                     "cinc(ibl,tid)",cinc(ibl,tid),                    &
                     "cxinc(ibl,tid)",cxinc(ibl,tid)
                 end do

                end if
              end if
#endif
            end if


! cdsu -------------------------------------------------------
! cdsu gradient reconstruction for reactive transport
! cdsu -------------------------------------------------------
#ifdef USG
            if (discretization_type > 0) then
              if (b_use_cross_diffusion_react) then
                if (multi_diff) then
                  call gradient_cross_diff_md_inc(tid,i1,ivol,jvol,    &
                       grad_totviscnew_ivol,grad_totviscnew_jvol,      &
                       grad_totviscnew_kvol,grad_electro_ivol,         &
                       grad_electro_jvol,grad_electro_kvol,            &
                       grad_totviscnew_hls_loc,grad_electro_hls_loc,   &
                       grad_cgg_totviscnew,grad_cgg_electro)
                else
                  call gradient_cross_diff_rt_inc(tid,i1,ivol,jvol,    &
                       totcnew,dtotc,grad_totcnew_ivol,                &
                       grad_totcnew_jvol,grad_totcnew_kvol,            &
                       grad_totcnew_hls_loc,grad_cgg_totcnew)
                end if
  
                if (ng > 0) then
                  call gradient_cross_diff_rt_inc(tid,i1,ivol,jvol,    &
                       totgnew,dtotg,grad_totgnew_ivol,                &
                       grad_totgnew_jvol,grad_totgnew_kvol,            &
                       grad_totgnew_hls_loc,grad_cgg_totgnew)
                end if
              end if
!cdsu
!cdsu calculate influence coefficient
!cdsu
              if (diff_coff) then
                call usg_face_utility_cinfrt_da_ic(ivol,jvol,i1,       &
                         cinfrt_da_ic_usg_loc,cinfrt_da_ic_usg_cross_loc)
              else
                call usg_face_utility_cinfrt_da(ivol,jvol,i1,          &
                         cinfrt_da_usg_loc,cinfrt_da_usg_cross_loc)
              end if

              if (ng > 0) then
                call usg_face_utility_cinfrt_dg(ivol,jvol,i1,          &
                         cinfrt_dg_usg_loc,cinfrt_dg_usg_cross_loc)
              end if

              if (multi_diff) then
                call usg_face_utility_cinfrt_mcd(ivol,jvol,i1,         &
                         cinfrt_mcd_usg_loc,cinfrt_mcd_usg_cross_loc)
              end if

!cdsu calculate influence coefficient for variable saturated flow
              call usg_face_utility_cinfvs(ivol,jvol,i1,cinfvs_usg_loc,&
                       cinfvs_usg_cross_loc,permij_usg_loc)

            end if
#endif

            do ibl=1,n                !loop over rows (block matrix)
                
              if(sparse_blocks .and. kblsorb(ibl,jbl) == 1) then
                  cycle
              end if

              if (kaobl(ibl,jbl).ne.0) then          !skip zero entries
              
!cprovi----------------------------------------------------------------
!cprovi Bubbles use component dependent influence coefficient if specified
!cprovi----------------------------------------------------------------
                if (diff_coff) then
                 cinfrt_da(i1) = cinfrt_da_ic(ibl,i1)
#ifdef USG
                 if (discretization_type > 0) then
                   do idvol = 1, num_edge_dvols
                     do icell = 1, ncell
                       cinfrt_da_usg_loc(idvol,icell) =                &
                              cinfrt_da_ic_usg_loc(ibl,idvol,icell)
                       cinfrt_da_usg_cross_loc(idvol,icell) =          &
                              cinfrt_da_ic_usg_cross_loc(ibl,idvol,icell)
                     end do
                   end do
                 end if
#endif
                end if
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
!c  compute derivative of flux and derivative of total influx 
!c  (aqueous phase)

                if (multi_diff) then
#ifdef USG
                  if (discretization_type > 0) then
!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                    grad_dtotcnew_inc_mids = vector_zero
                    grad_dtotviscnew_inc_mids = vector_zero
                    grad_delectro_inc_mids = vector_zero
                    flux_dtotcnew_inc_hls_corr = r0
                    flux_dtotviscnew_inc_hls_corr = r0
                    flux_delectro_inc_hls_corr = r0

                    if (b_use_cross_diffusion_react) then
                      call gradient_cross_diff_rt_average(ibl,n,i1,ivol,     &
                           jvol,grad_totviscnew_ivol,grad_totviscnew_jvol,   &
                           grad_totviscnew_kvol,grad_totviscnew_hls_loc,     &
                           grad_weights,grad_totviscnew_locs,                &
                           grad_dtotviscnew_inc_mids,                        &
                           flux_dtotviscnew_inc_hls_corr,                    &
                           grad_cgg_totviscnew)
      
                      call gradient_cross_diff_rt_average(ibl,n,i1,ivol,     &
                           jvol,grad_electro_ivol,grad_electro_jvol,         &
                           grad_electro_kvol,grad_electro_hls_loc,           &
                           grad_weights,grad_electro_locs,                   &
                           grad_delectro_inc_mids,                           &
                           flux_delectro_inc_hls_corr,                       &
                           grad_cgg_electro)
                    end if

                    dcflux =                                                           &
                        fluxv_vl(dtotc(ibl,tid),r0,ivol,jvol,cinfrt_va_usg(i1),ibl)    & !advective term
                        - fluxd_usg(r0,delta_totviscnew(ibl,tid),                      & !diffusive term
                          num_edge_dvols,ncell,                                        &
                          grad_dtotviscnew_inc_mids(1:num_edge_dvols,1:ncell),         &
                          flux_dtotviscnew_inc_hls_corr(1:num_edge_dvols,1:ncell),     &
                          cinfrt_mcd_usg_loc(1:num_edge_dvols,1:ncell),                &
                          cinfrt_mcd_usg_cross_loc(1:num_edge_dvols,1:ncell))/drtinc   &
                        - fluxd_usg(r0,delta_electromignew(ibl,tid),                   & !electromigration term
                          num_edge_dvols,ncell,                                        &
                          grad_delectro_inc_mids(1:num_edge_dvols,1:ncell),            &
                          flux_delectro_inc_hls_corr(1:num_edge_dvols,1:ncell),        &
                          cinfrt_mcd_usg_loc(1:num_edge_dvols,1:ncell),                &
                          cinfrt_mcd_usg_cross_loc(1:num_edge_dvols,1:ncell))/drtinc

                  else
#endif
                    dcflux = fluxv_vl(dtotc(ibl,tid),r0,               & !advective term
                                      ivol,jvol,                       &
                                      cinfrt_va(i1),ibl)               &
                           - fluxd(r0,delta_totviscnew(ibl,tid),       & !diffusive term
                                   cinfrt_mcd(i1))/drtinc              &
                           - fluxd(r0,delta_electromignew(ibl,tid),    & !electromigration term
                                   cinfrt_mcd(i1))/drtinc
            
#ifdef USG
                  end if
#endif

                else
#ifdef USG
                  if (discretization_type > 0) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                    grad_dtotcnew_inc_mids = vector_zero
                    flux_dtotcnew_inc_hls_corr = r0

                    if (b_use_cross_diffusion_react) then
                      call gradient_cross_diff_rt_average(ibl,n,i1,ivol,   &
                           jvol,grad_totcnew_ivol,grad_totcnew_jvol,       &
                           grad_totcnew_kvol,grad_totcnew_hls_loc,         &
                           grad_weights,grad_totcnew_locs,                 &
                           grad_dtotcnew_inc_mids,                         &
                           flux_dtotcnew_inc_hls_corr,                     &
                           grad_cgg_totcnew)
                    end if

                    dcflux =                                                           &
                        fluxv_vl(dtotc(ibl,tid),r0,ivol,jvol, cinfrt_va_usg(i1),ibl)   & !advective term
                        - fluxd_usg(dtotc(ibl,tid),r0,                                 & !dispersive term
                          num_edge_dvols,ncell,                                        &
                          grad_dtotcnew_inc_mids(1:num_edge_dvols,1:ncell),            &
                          flux_dtotcnew_inc_hls_corr(1:num_edge_dvols,1:ncell),        &
                          cinfrt_da_usg_loc(1:num_edge_dvols,1:ncell),                 &
                          cinfrt_da_usg_cross_loc(1:num_edge_dvols,1:ncell))

#ifdef DEBUG
                    if(info_debug > 10) then
                      if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                        write(idbg, *)                                                 &
                        "--> no multi_diff dcflux-b: ivol",ivol,"jvol",jvol,           &
                        "ibl",ibl,"i1",i1,"num_edge_dvols",num_edge_dvols,             &
                        "janumcell(i1)",janumcell(i1),"cinfrt_va_usg",cinfrt_va_usg(i1)

                        do icell = 1, ncell
                          do idvol = 1, num_edge_dvols
                            write(idbg,*)                                              &
                                  "--> idvol",idvol,"icell",icell,                     &
                                  "icellid",jacell(icell,i1),                          &
                                  "grad",grad_dtotcnew_inc_mids(idvol,icell)%x,        &
                                  grad_dtotcnew_inc_mids(idvol,icell)%y,               &
                                  grad_dtotcnew_inc_mids(idvol,icell)%z,               &
                                  "cinfrt_da_usg_cross",                               &
                                  cinfrt_da_usg_cross_loc(idvol,icell)%x,              &
                                  cinfrt_da_usg_cross_loc(idvol,icell)%y,              &
                                  cinfrt_da_usg_cross_loc(idvol,icell)%z,              &
                                  "dtotc",dtotc(ibl,tid),                              &
                                  "hls-corr",flux_dtotcnew_inc_hls_corr(idvol,icell),  &
                                  "cinfrt_da_usg_loc",cinfrt_da_usg_loc(idvol,icell),  &
                                  "dcflux",dcflux

                          end do
                        end do

                      end if
                    end if
#endif

                  else
#endif
                    dcflux = fluxv_vl(dtotc(ibl,tid),r0,               & !advective term
                                      ivol,jvol,                       &
                                      cinfrt_va(i1),ibl)               &
                           - fluxd(dtotc(ibl,tid),r0,                  & !dispersive term
                                   cinfrt_da(i1))
#ifdef DEBUG
                    if(info_debug > 10) then
                      if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                        write(idbg, *)                                           &
                        "--> no multi_diff dcflux-b: ivol",ivol,"jvol",jvol,     &
                        "ibl",ibl,"i1",i1,"dtotc(ibl,tid)",dtotc(ibl,tid),       &
                        "cinfrt_va(i1)",cinfrt_va(i1),"cinfrt_da(i1)",           &
                        cinfrt_da(i1),"dcflux",dcflux
                      end if
                    end if
#endif

#ifdef USG
                  end if
#endif

                end if
    
!cmx  Check pore clogging condition, either ivol or jvol is clogged
!cmx  no mass flux between them
!cdsu fix bug
                !if (pore_clogging) then
                !  if (pornew(ibl) <= por_thresh_min .or.               &
                !      pornew(jvol) <= por_thresh_min)  then
                !    dcflux = r0
                !  end if        
                !end if
    
!c  derivative of total influx

                dtotcflux(ibl) = dtotcflux(ibl) + dcflux

#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *) "--> dtotcflux -> ibl dcflux: ",    &
                          ibl,dcflux
                  end if
                end if 
#endif                

!c  compute derivative of flux and derivative of total influx 
!c  (gaseous phase)

                if (ng.gt.0) then

                  dgflux = r0

                  if (gas_advection) then

                    if (gsatij(i1).gt.gsatmin) then

                      dgflux = dfluxvg(totgij(ibl)  ,dtotg(ibl,tid),   &
                                       !c bug in the old code ?
                                       !c gpivol_ivol  ,gpivol_ivol  ,    &
                                       gpivol_ivol  ,gpivol_jvol  ,    &
                                       dgpivol      ,                  &
                                       zg(ivol)     ,zg(jvol)     ,    &
                                       densgij      ,ddens_i      ,    &
                                       viscgij      ,relpgij      ,    &
                                       cinfvs_g(i1)   ,wfac       ,    &
                                       gas_gravity, gacc          )
#ifdef DEBUG
                      if(info_debug > 10) then
                        if(ivol_gbl == ivol_track .or.                 &
                            ivol_track == 0) then
                          write(idbg, *)                               &
                                "--> compute derivative dgflux 1:, ",  &
                                "ivol, dgflux", ivol, dgflux
                        end if
                      end if
#endif
                    endif

                  endif ! gas advection


!c--------ficks law, business as usual------------------------------------

                  if ((.not.dgm).and.(.not.maxwell)) then

                    if (blanc_diff_g) then
#ifdef USG
                      if (discretization_type > 0) then
                        gasdiff_loc = gasdiff2(gmfrac(1,ivol),gmfrac(1,jvol),  &
                                           gpivol_ivol   ,gpivol_jvol   ,      &
                                           zg(ivol)      ,zg(jvol)      ,      &
                                           gdens_ivol    ,gdens_jvol    ,      &
                                           ic            ,                     &
                                           iupsg(i1)     ,spt_weight    )
                        cinfrt_usg(:,:) = cinfrt_dg_usg_loc(:,:)*gasdiff_loc
                        cinfrt_usg_cross(:,:) = cinfrt_dg_usg_cross_loc(:,:) * &
                                                   gasdiff_loc
                      else
#endif
!c                      diffusion coefficient calc'd with LeBlanc's law
                        cinfrt = cinfrt_dg(i1) * gasdiff2                      &
                                        (gmfrac(1,ivol), gmfrac(1,jvol),       &
                                         gpivol_ivol   , gpivol_jvol   ,       &
                                         zg(ivol)      , zg(jvol)      ,       &
                                         gdens_ivol    , gdens_jvol    ,       &
                                         ic            ,                       &
                                         iupsg(i1)     , spt_weight    )
#ifdef USG
                      end if
#endif
                    else
!c                    single constant diffusion
#ifdef USG
                      if (discretization_type > 0) then
                        cinfrt_usg(:,:) = cinfrt_dg_usg_loc(:,:)
                        cinfrt_usg_cross(:,:) =cinfrt_dg_usg_cross_loc(:,:)
                      else
#endif
                        cinfrt = cinfrt_dg(i1)
#ifdef USG
                      end if
#endif
                    endif

!c diffusive as function of concentration gradients
#ifdef USG
                    if (discretization_type > 0) then

!c calculate gradient at the middle of edge and along the control volume face,
!c this part can be further improved for better representation for a boundary volume
                      grad_dtotgnew_inc_mids = vector_zero
                      flux_dtotgnew_inc_hls_corr = r0

                      if (b_use_cross_diffusion_react) then
                        call gradient_cross_diff_rt_average(ibl,n,i1,ivol,   &
                             jvol,grad_totgnew_ivol,grad_totgnew_jvol,       &
                             grad_totgnew_kvol,grad_totgnew_hls_loc,         &
                             grad_weights,grad_totgnew_locs,                 &
                             grad_dtotgnew_inc_mids,                         &
                             flux_dtotgnew_inc_hls_corr,                     &
                             grad_cgg_totgnew)
                      end if

                      dgflux = dgflux - fluxd_usg(                               &
                            dtotg(ibl,tid),r0,num_edge_dvols,ncell,              &
                            grad_dtotgnew_inc_mids(1:num_edge_dvols,1:ncell),    &
                            flux_dtotgnew_inc_hls_corr(1:num_edge_dvols,1:ncell),&
                            cinfrt_usg(1:num_edge_dvols,1:ncell),                &
                            cinfrt_usg_cross(1:num_edge_dvols,1:ncell))
                    else
#endif
                      dgflux = dgflux - fluxd(dtotg(ibl,tid),r0,cinfrt)
#ifdef USG
                    end if
#endif

!c ----- DGM module -------------------------------------------------------------
                
                  else if (dgm) then

!c                   check if there is gas phase
                    if (gporij(i1).lt.rverysmall                             &
     &                  .or.relpgij.lt.rverysmall) then
!c                   no gas phase

                    else
#ifdef USG
                      if (discretization_type > 0) then
                        dgflux = dgflux                                      &
                               + sum(cinfrt_dg_usg_loc(1:num_edge_dvols,     &
                                                       1:ncell))             &
                               * deltaij(i1)                                 &
                               * dgm_dgflux(ibl)                             &
                               / tauij(i1)                                   &
                               / gporij(i1)
                      else
#endif
                        dgflux = dgflux                                      &
                               + cinfrt_dg(i1)                               &
                               * deltaij(i1)                                 &
                               * dgm_dgflux(ibl)                             &
                               / tauij(i1)                                   &
                               / gporij(i1)
#ifdef USG
                      end if
#endif
                    endif
!c ------------------------------------------------------------------------------
!c ----- Maxwell Stefan module --------------------------------------------------

                  else if (maxwell) then

!c                   check if there is gas phase
                    if (gporij(i1).lt.rverysmall) then
!c                   no gas phase
                    else
#ifdef USG
                      if (discretization_type > 0) then
                        dgflux = dgflux                                      &
                               + sum(cinfrt_dg_usg_loc(1:num_edge_dvols,     &
                                                       1:ncell))             &
                               * deltaij(i1)                                 &
                               * ms_dgflux(ibl)                              &
                               / tauij(i1)                                   &
                               / gporij(i1)
                      else
#endif
                        dgflux = dgflux                                      &
                               + cinfrt_dg(i1)                               &
                               * deltaij(i1)                                 &
                               * ms_dgflux(ibl)                              &
                               / tauij(i1)                                   &
                               / gporij(i1)
#ifdef USG
                      end if
#endif
                    endif

!c ------------------------------------------------------------------------------
                  end if
                    
                  dtotgflux(ibl) = dtotgflux(ibl) + dgflux
#ifdef DEBUG
                  if(info_debug > 10) then
                    if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                      write(idbg, *)                                   &
                        "--> compute derivative dgflux 2:, ivol, ",    &
                        "i1, ibl, dtotg, cinfrt_dg, dgflux, dtotgflux",&
                        ivol, i1, ibl, dtotg(ibl,tid),cinfrt_dg(i1),   &
                        dgflux, dtotgflux(ibl)
                    end if
                  end if
#endif
                end if

!c  get pointer for assembly in global scalar jacobian matrix

                i2 = kart(lsym+kaobl(ibl,jbl)-1)

!c  allocate entries of column of off-diagonal block 
!c  in global scalar jacobian matrix

                if (component_type(ibl).eq.'aqueous') then
                    
                  art(i2) = art(i2) - cnew(jbl,ivol) * dcflux  !aqueous phase
#ifdef DEBUG
                  if(info_debug > 20) then
                    if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                      write(idbg, *)                                   &
                        "--> aqueous i2, jbl, ivol, dcflux, cnew, art",&
                        i2, jbl, ivol, dcflux, cnew(jbl, ivol), art(i2)
                    end if
                  end if
#endif
                end if

                if (ng.gt.0) then
                  art(i2) = art(i2) - cnew(jbl,ivol) * dgflux  !gaseous phase
#ifdef DEBUG
                  if(info_debug > 20) then
                    if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                      write(idbg, *)                                   &
                        "--> gas i2, jbl, ivol, dgflux, cnew, art",    & 
                        i2, jbl, ivol, dgflux, cnew(jbl, ivol), art(i2)
                    end if
                  end if
#endif
                end if
                
              end if              !skip zero entries
            end do                !loop over rows of block matrix
          end do                  !off-diagonal connections
          
          if (b_prtfile) then
              if(tid == 1) then
                rtimespan = cputime() - rtimespan
                prt_react_jac_part(4) = prt_react_jac_part(4) + rtimespan
                rtimespan = cputime()
              end if  
          end if

!c  entries in diagonal block of global scalar jacobian matrix

          ldiag = lart(idiag)     !diagonal pointer - global block matrix
          do ibl = 1,n            !loop over rows of block matrix

            if (kadbl(ibl,jbl).ne.0) then          !skip zero entries
!c  compute derivatives of storage terms for aqueous phase

!c      Porosity correction factors has to be used to modify the effective porosity
!c      of each species for the hybrid multicomponent diffusion model, which is
!c      included in dtotcf as calculated in dtotconc.
              if (hmulti_diff) then
                dcstor = cvol(ivol)/delt                              &
     &                          * bulkconc(dtotcf(ibl,tid),           &
     &                          sanew(ivol),                          &
     &                          pornew(ivol))
              else
     
                dcstor = cvol(ivol)/delt                              &
     &               * bulkconc(dtotc(ibl,tid),                       &
     &                          sanew(ivol),                          &
     &                          pornew(ivol))
              end if
    
!cprovi------------------------------------------------------------------------
!cprovi------------------------------------------------------------------------
!cprovi------------------------------------------------------------------------

!c  compute derivatives of storage terms for gaseous phase

              if (ng.gt.0) then

                dgstor = cvol(ivol)/delt                              &
     &                 * bulkconc(dtotg(ibl,tid),                     &
     &                            sgnew(ivol),                        &
     &                            pornew(ivol))
              else
                dgstor = r0
              end if

!c  get pointer for assembly in global scalar jacobian matrix

              i2 = kart(ldiag+kadbl(ibl,jbl)-1)

!c  allocate entries of column of diagonal block 
!c  in global scalar jacobian matrix

!c  aqueous phase
!c  --------------------------------------------------------------------

!c  - storage and flux terms
              if (component_type(ibl).eq.'aqueous') then
                art(i2) = art(i2) + cnew(jbl,ivol) * dcstor           &
     &                            + cnew(jbl,ivol) * dtotcflux(ibl)


#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &        
                      "--> aqueous2 i2, ibl, jbl, ivol, dcstor, ",     &
                      "dtotcflux, cnew, art",                          &
                      i2, ibl, jbl, ivol, dcstor,                      &
                      dtotcflux(ibl), cnew(jbl,ivol), art(i2)
                  end if
                end if 
#endif
              else
                art(i2) = art(i2) + cnew(jbl,ivol) * dcstor
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &
                    "--> not aqueous i2, jbl, ivol, dcstor, cnew, art",&
                    i2, jbl, ivol, dcstor, cnew(jbl,ivol), art(i2)
                  end if
                end if  
#endif
              end if

!c  - kinetically-controlled redox reactions

              if (.not.redox_equil.and.nr.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtotor(ibl)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                  write(idbg, *)                                      &
                  "--> kinetic i2, ibl, jbl, ivol, dtotor, cnew, art",&
                  i2, ibl, jbl, ivol, dtotor(ibl),                    &
                  cnew(jbl,ivol), art(i2)
                  end if
                end if 
#endif
              end if

!c  - intra-aqueous kinetic reactions

              if (naq.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtotaq(ibl,tid)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                  write(idbg, *)                                      &
                  "--> intra i2, ibl, jbl, ivol, dtotaq, cnew, art",  &
                  i2, ibl, jbl, ivol, dtotaq(ibl,tid),                &
                  cnew(jbl,ivol), art(i2)
                  end if
                end if
#endif
              end if

!c  - degassing

              if (gas_removal) then
                art(i2) = art(i2) + cnew(jbl,ivol) * totrateg(ibl)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                  write(idbg, *)                                      &
                  "--> gas removal i2, ibl, jbl, ivol, ",             &
                  "totrateg, cnew, art",                              &
                  i2, ibl, jbl, ivol,                                 &
                  totrateg(ibl), cnew(jbl,ivol), art(i2)
                  end if
                end if
#endif
              end if

!c  - first-order aqueous decay
!c  by DSU, 2022-03-09
              if (b_use_aq_decay) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtotaqdecay(ibl)
              end if

!c  - first-order gas decay
              if (ng .gt. 0 .and. b_use_gas_decay) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtotgasdecay(ibl)
              end if

!c  --------------------------------------------------------------------
!c  set derivative of respiration to Jacobian matrix (HG)
              if (root_uptake) then
                art(i2) = art(i2) + cnew(jbl,ivol) * drootresp(ibl) 
              end if 
              
!c  gaseous phase
!c  --------------------------------------------------------------------

              if (ng.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dgstor           &
     &                            + cnew(jbl,ivol) * dtotgflux(ibl)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                  write(idbg, *)                                      &
                  "--> gas2 i2, ibl, jbl, ivol, dgstor, ",            &
                  "dtotgflux, cnew, art",                             &
                  i2, ibl, jbl, ivol, dgstor,                         &
                  dtotgflux(ibl), cnew(jbl,ivol), art(i2)
                  end if
                end if 
#endif
              end if


!c  sorbed phase (non-competitive sorption)
!c  --------------------------------------------------------------------

              if (noncompetitive_sorption) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtota(ibl)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &
                    "--> noncompe sorp i2, ibl, jbl, ivol, ",          &
                    "dtota, cnew, art",                                &
                    i2, ibl, jbl, ivol,                                &
                    dtota(ibl), cnew(jbl,ivol), art(i2)
                  end if
                end if
#endif
              end if

!c  sorbed phase
!c  --------------------------------------------------------------------

              if (nsb_ion.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtotsb_ion(ibl,tid)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &
                    "--> nsb_ion i2, ibl, jbl, ivol, dtotsb_ion, ",    &
                    "cnew, art",                                       &
                    i2, ibl, jbl, ivol, dtotsb_ion(ibl,tid),           &
                    cnew(jbl,ivol), art(i2)
                  end if
                end if 
#endif
              end if
              
              if (nsb_surf.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) *                  &
                          dtotsb_surf(ibl,tid)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &
                    "--> nsb_surf i2, ibl, jbl, ivol, ",               &
                    "dtotsb_surf, cnew, art",                          &
                    i2, ibl, jbl, ivol,                                &
                    dtotsb_surf(ibl,tid), cnew(jbl,ivol), art(i2)
                  end if
                end if  
#endif
              end if

!c  mineral phase
!c  --------------------------------------------------------------------

              if (nm.gt.0) then
                art(i2) = art(i2) + cnew(jbl,ivol) * dtotdp(ibl,tid)
#ifdef DEBUG
                if(info_debug > 20) then
                  if(ivol_gbl == ivol_track .or. ivol_track == 0) then  
                    write(idbg, *)                                     &
                    "-->mineral i2, ibl, jbl, ivol, dtotdp, cnew, art",&
                    i2, ibl, jbl, ivol, dtotdp(ibl,tid),               &
                    cnew(jbl,ivol), art(i2)
                  end if
                end if  
#endif
              end if
              
            end if                !skip zero entries
            
          end do                  !loop over rows of block matrix

          cinc(jbl,tid) = cnew(jbl,ivol)  !"unshift" free species concentration
          
          if (b_prtfile) then
              if(tid == 1) then
                rtimespan = cputime() - rtimespan
                prt_react_jac_part(5) = prt_react_jac_part(5) + rtimespan
              end if
          end if

        end do                    !loop over columns of block matrix
        
      end do                      !loop over control volumes
      
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif

#ifdef OPENMP
    !$omp end parallel
#endif 

#ifdef DEBUG
      if (info_debug > 10) then
        if(ivol_gbl == ivol_track .or. ivol_track == 0) then
          write(idbg, *) "--> totgflux", totgflux
          write(idbg,*) "-->jacrt->gnew(:,ivol_track) C", gnew(:,ivol_track)
        end if
      end if
#endif

      if (b_prtfile) then
          prt_react_jac_part(6) = cputime() - prt_react_jac_part(6)
      end if

      continue
!cdbg
#ifdef DEBUG
      info_debug = 0
      if (info_debug.gt.0) then
        irow = 0
        do ivol=1,nngl 
          do ic=1,n
            irow = irow+1
            write(idbg, *)                                             &
     &            namec(ic),'b(',ivol,ic,') = ',brt(irow)/cvol(ivol)
          end do
        end do
        do ivol=1,nngl
          do ic = 1,n
            irow=(ivol-1)*n+ic
            istart = iart(irow)
            iend   = iart(irow+1)-1
            write(idbg,*) iart(irow)
            i2 = 0
            do i1 = istart,iend
              i2 = i2+1
              if (i2.gt.n) then
                i2 = i2-n
              end if
              icol = jart(i1)
              write(idbg, *)           &
     &              namec(ic),namec(i2),'a(',irow,icol,') = ',        &
     &                           art(i1)/cvol(ivol)
            end do
          end do
        end do
      end if

      if (info_debug.gt.1) then
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
      
#endif
!cdbg

      return
      end
