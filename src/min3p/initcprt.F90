!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initcprt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcprt
!c -------------------
!c
!c control parameters for reactive transport
!c
!c written by:      Uli Mayer - May 12, 96
!c
!c last modified:   Uli Mayer - November 22, 96
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           dinc_rt            = factor to compute increment for     * +
!c                                numerical differentiation
!c           srelfac_rt         = underrelaxation factor              * +
!c                                (reactive transport)
!c           tol_rt             = convergence tolerance               * +
!c                                (reactive transport)
!c           por_thresh_max     = maximum porosity threshold          * +
!c                                avoid division by 0 in 
!c                                Kozeny-Carman equation
!c           por_thresh_min     = minimum porosity threshold          * +
!c           permfac_thresh_max = maximum permeability factor threshold  * +
!c           permfac_thresh_min = minimum permeability factor threshold  * +
!c
!c           integer*4:
!c           ----------
!c           idat               = unit number, run specific input     * +
!c                                             file
!c           igen               = unit number, generic output file    * +
!c           ilog               = unit number, log file               * +
!c           itmp               = unit number, temporary storage      * +
!c           maxit_rt           = max. number of iterations           * +
!c                                (reactive transport)
!c           level_rt           = incomplete factorization level      * +
!c
!c           logical:
!c           --------
!c           mass_balance_rt    = .true.  -> compute mass balance     * +
!c                                           (reactive tramsport)
!c           rcm_ordering_rt    = .true.  -> rcm ordering for         * +
!c                                           n-d scalar matrix
!c           redox_equil_rt     = .true,  -> equilibrium redox        * +
!c                                           reactions
!c           sparse_blocks      = .true.  -> make use of sparsity     * +
!c                                           of block matrices
!c           tortuosity_corr    = .true.  -> Millington-Quirk         * +
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c           under_relax_rt     = .true.  -> underrelaxation          * +
!c           update_activity_rt = 'no_update' -> unity activity       * +
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c                                 (reactive transport)
!c           update_porosity    = .true.  -> update porosity as       * +
!c                                           a result of dissolution-
!c                                           precipitation reactions
!c           update_permeability= .true.  -> update permeability as   * +
!c                                           a function of porosity
!c           gas_advection      = .true.  -> include gas advection    * +
!c           cum_molfrac        = .true.  -> .gs2 outout in terms     * +
!c                                           of cummulative molar fr 
!c           gas_gravity        = .true.  -> enable gas gravity term  * +
!c                                           in gas transport
!c
!c           character:
!c           ----------
!c           section_header     = section header                      * +
!c           spatial_weighting  = 'upstream' -> upstream weigthing    * +
!c                                'centered' -> centered weighting
!c                                'vanleer' -> Van Leer flux limiter
!c                                              (upstream-downstream)
!c                                'vanleer2' -> Van Leer flux limiter
!c                                              (upstream-centered)
!c
!c chem.f:   real*8:
!c           -------
!c           degas_rate         = rate constant for degassing         * +
!c
!c                                [mol L^-^1 h2o s^-^1]
!c           integer*4:
!c           ----------
!c           nr                 = number of redox couples             + -
!c
!c           logical:
!c           --------
!c           gas_removal        = .true.  -> degassing occurs, if     * +
!c                                           gas pressure above
!c                                           confining pressure
!c
!c           character:
!c           ----------
!c           update_activity(nthreads)    
!c                              = 'no_update' -> unity activity       * +
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c           update_activity_lc = 'no_update' -> unity activity       * +
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c                                 (local chemistry)
!c
!c dual.f:   logical:
!c           --------
!c           dual_porosity      = .true.  -> dual porosity            * + 
!c                                           simulation 
!c
!c
!c bbls.f:      logical
!c           --------
!c             gas_bubbles        =.true. -> gas phase saturation       * -
!c                                   is calculated below the water table
!c
!c multidiff.f90
!c            character:
!c           -------
!c           type_averaging_De   = types of diffusion coefficient averaging 
!c                'harmonic' - harmonic averaging  
!c                'arithmetic' - arithmetic averaging  
!c                'no averaging' - no averaging  
!c           logical:
!c           --------
!c         averaging_diffusion = .true. -> averaging diffusion coefficient

!c local:    real*8:
!c           -------
!c           r86400             = conversion factor
!c
!c           integer*4:
!c           ----------
!c           l_string           = length of text string
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file
!c           readbloc  = read section of input file and write to 
!c                       temporary file
!c ----------------------------------------------------------------------
 
      subroutine initcprt
 
      use parm
      use gen
      use chem
      use dual
      use bbls
      use mip_bubble, only : mip_mt_enable
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use solver_snes_common, only : stencil_width
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
      
      integer :: i, im, l_string, ierrcd
      
      real*8 :: value_tau, rsat, rsatcorr, rdeltsat, rtempk, rcorr
      real*8, external :: satcorr_curve
      
      integer :: tid

      external findstrg, readbloc

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, r86400 = 8.64d4

      logical :: found_section, found_subsection
      character*72 :: subsection
      character*72 :: strbuffer
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      ierrcd = 0
 
!c  read control parameters for reactive transport
!c  and write to temporary file
   
      section_header = 'control parameters - reactive transport'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  define defaults for control parameters for reactive transport

!c  general control parameters

      dual_porosity = .false.
      redox_equil_rt = .true.
      mass_balance_rt = .true.
      b_check_div_rt = .false.
      spatial_weighting = 'upstream'
      update_activity(:) = 'time_lagged'
      if (update_activity(tid).eq.'time_lagged') then
        update_activity_rt = 'time_lagged'
        update_activity_lc = 'double_update'
      end if
      tortuosity_corr = .true.
      gas_tortuosity = 'same as aqueous'
      gas_removal = .false.
      pore_clogging = .false.
      update_porosity = .false.
      update_permeability = .false.
      por_thresh_max = 1.0d200
      por_thresh_min = 0.0d0
      permfac_thresh_max = 1.0d200
      permfac_thresh_min = 0.0d0
      tau_fac = 1.0d0

!c  Newton iteration

      dinc_rt = 1.0d-4
      iter_rt_ant = 12
      maxit_rt = 15 
      urtant_log = 0.5d0
      urtlim_log = 1.0d0
      tol_rt = 1.0d-6

!c  underrelaxation

      under_relax_rt = .false.
      under_relax_range_rt = .false.
      srelfac_rt = 1.0d0

!c  sparse block matrices

      sparse_blocks = .true.

!c  solver settings

      level_rt = 0
      msolvit_rt = 100
      idetail_rt = 1
      restol_rt = 0.1d0 * tol_rt
      deltol_rt = 0.1d0 * tol_rt
      if(i_solver_type_react == 0) then
        rcm_ordering_rt = .true.
        metis_ordering_rt = .true.
      else
        rcm_ordering_rt = .false.
        metis_ordering_rt = .false.
      end if

!c  extimated fractorization coefficient for linear solver, default value is 3 before
      coeff_fac_conn_rt = 4

!c  read in control parameters for reactive transport

      if (found_section) then

!c  read control parameters for reactive transport

!c  general control parameters

!c  dual porosity simulation

        subsection = 'dual porosity'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          dual_porosity = .true.
        end if

!c  type of redox reactions

        subsection = 'redox reactions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nr.gt.0) then
            ierrcd = 1
            read(itmp,*,err=999,end=999) redox_equil_rt
          end if
        end if

!c  mass balance settings - new definition

        subsection = 'mass balance'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          mass_balance_rt = .true.
        else
          mass_balance_rt = .false.
        end if
        
!c  mass balance settings - old definition

        subsection = 'mass balance settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 2
          read(itmp,*,err=999,end=999) mass_balance_rt
        end if

!c  Shannon entropy of the concentration distribution - dilution index
!c  Ref: Kitanidis, 1994, WRR

        subsection = 'calculate dilution index'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          b_dilution_index = .true.
        else
          b_dilution_index = .false.
        end if


!c  spatial moment, accordingly to Goltz and Huang, 1987, WRR; Oware and Moysey 2014, Journal of Hydrology
        subsection = 'calculate spatial moment'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          b_spatial_moment = .true.
        else
          b_spatial_moment = .false.
        end if

!c  stpatial averaging type for canculation diffusion coefficients

        subsection = 'averaging diffusion'
        averaging_diffusion=.false. 
        no_average=.false.
        type_averaging_De='' 
        call findstrg(subsection,itmp,found_subsection)
        
        if (.not. found_subsection) then
          subsection = 'spatial averaging - diffusion'
          call findstrg(subsection,itmp,found_subsection)
        end if

        if (found_subsection) then
          ierrcd = 3
          read(itmp,*,err=999,end=999) subsection
          if (subsection.eq.'harmonic') then
            averaging_diffusion = .true.
            type_averaging_De='harmonic'
          elseif (subsection.eq.'arithmetic') then  ! De averaging done with por_av
            averaging_diffusion = .true.
            type_averaging_De='arithmetic'
          elseif (subsection.eq.'arithmetic De') then ! De averaging done with De_av
            averaging_diffusion = .true.
            type_averaging_De='arithmetic De'            
          elseif (subsection.eq.'no averaging') then
            averaging_diffusion = .false.
            type_averaging_De='no averaging'
            no_average=.true.
          else
            if (rank == 0 .and. b_enable_output) then
              write(ilog,*) 'Sapatial averaging type of diffusion coefficient not recognized'
              write(*,*) 'Sapatial averaging type of diffusion coefficient not recognized'
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 
          end if
        end if

        if (multi_diff .and. type_averaging_De.eq.'') then
          if (rank == 0 .and. b_enable_output) then
            write(ilog,*) 'Warning: sapatial averaging for MCD is not specified and harmonic is assigned'
            write(*,*) 'Warning: sapatial averaging for MCD is not specified and harmonic is assigned'            
          end if
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,*) 'Warning: sapatial averaging for MCD is not specified and harmonic is assigned'
          end if
          
          averaging_diffusion = .true.
          type_averaging_De='harmonic'
        end if
        
!c  added by Danyang Su, 2014
        gas_advection=.false.
        subsection = 'gas advection'
        call findstrg(subsection,itmp,found_subsection)
      
        if (found_subsection) then
          gas_advection=.true.
          if (rank == 0 .and. b_enable_output) then              
            write(ilog,'(a)') 'gas advection is included'
          end if
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(a)') 'gas advection is included'
          end if
        else 
          gas_advection=.false.
          if (rank == 0 .and. b_enable_output) then
            write(ilog,'(a)') 'gas advection is ignored'
          end if
          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(a)') 'gas advection is ignored'
          end if
        end if
      
!c  added by Danyang Su, 2014
        subsection = 'cumulative mole fractions'
           
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          cum_molfrac = .true.
        else 
          cum_molfrac = .false.
        end if
      
!c  added by Danyang Su, 2014
        gas_gravity=.false.
        subsection = 'enable gravity for gas phase'           
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          gas_gravity=.true.
        else 
          gas_gravity=.false.
        end if

!c  write fluxes in output files

        subsection = 'output fluxes'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          flux_out = .true.
        else
          flux_out = .false.
        end if
        
!c  type of spatial weighting

        subsection = 'spatial weighting'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 4        
          read(itmp,*,err=999,end=999) spatial_weighting
            
          if (spatial_weighting.eq.'van leer') then
            spatial_weighting = 'vanleer'
          else if (spatial_weighting.eq.'van leer 2') then
            spatial_weighting = 'vanleer2'
          end if
          

          if (spatial_weighting.eq.'vanleer' .or.         &
              spatial_weighting.eq.'vanleer2') then
#ifdef PETSC
            if (nprcs > 1 .and. stencil_width < 2) then
              if (rank == 0) then
                write(*,'(2a)')"Error: van leer spatial weighting ",   &
                      "requires stencil width 2 or larger"
                write(ilog,'(2a)')"Error: van leer spatial weighting ",&
                      "requires stencil width 2 or larger"
                close(ilog)
              end if
              call petsc_mpi_finalize
              stop
            end if
#endif
          end if


          if (spatial_weighting.ne.'upstream'.and.        &
     &        spatial_weighting.ne.'centered'.and.        &
     &        spatial_weighting.ne.'vanleer'.and.         &
     &        spatial_weighting.ne.'vanleer2') then
            if (rank == 0) then  
              write(ilog,'(a)')                           &
     &        'error reading subsection "spatial weighting"'
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if
        end if

!cprovi----------------------------------------------------------
!c  compute harmonic average in porosity
!cprovi----------------------------------------------------------

        subsection = 'harmonic average in porosity'
        harmonic_porosity=.false.
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          harmonic_porosity=.true.
        end if
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------
!cprovi----------------------------------------------------------

!c  update porosity

        subsection = 'update porosity'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            update_porosity = .true.
          end if

!cdsu Porosity threshold by minimum factor ratio.
!cdsu This value is set to avoid division by 0 in Kozeny-Carman equation  
!cdsu This threshold is included in flow part but not in reactive transport part before. 
!cdsu 2020-09-14, DSU
          if (facpormin <= 1.0d-10) then
            ierrcd = 5
            read(itmp,*,err=990,end=999) facpormin
990         continue
            if (facpormin < 1.0d-10) then
              facpormin = 1.0d-10
            end if
          end if
        end if
        
!c  Porosity threshold value is set to avoid division by 0 in Kozeny-Carman equation.

        subsection = 'porosity threshold'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 6
          read(itmp,*,err=999,end=999) por_thresh_min, por_thresh_max
        end if
        
!c  maximum porosity threshold, this value is set to avoid division by 0 in Kozeny-Carman equation

        subsection = 'porosity threshold maximum'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 7
          read(itmp,*,err=999,end=999) por_thresh_max
        end if 
        
!c  minimum porosity threshold, this value is set to avoid division by 0 in Kozeny-Carman equation

        subsection = 'porosity threshold minimum'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 8
          read(itmp,*,err=999,end=999) por_thresh_min
        end if        

!c  update permeability

       subsection = 'update permeability'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            update_permeability = .true.
            
!c if permeabilities are updated, switch to transient flow
          
            if (update_permeability) then
              steady_flow = .false.
              transient_flow = .true.
            end if
            
            if (.not.update_porosity) then

!c  need porosity update for permeability update
 
              update_porosity = .true.

            end if
          end if
        end if
        
!c  activate clogging function due to mineral precipitation
!c   needs to activate porosity and permeability functions,
!c   and needs to provide 'porosity threshold minimum' value,
!c   which will be used as the clogging creteria

        subsection = 'pore clogging'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            pore_clogging = .true.
        
!c  need porosity and permeability for pore clogging model
            if (.not.update_porosity) then                
              update_porosity = .true.           
              if (rank == 0 .and. b_enable_output) then
                write(ilog,*) '!!!Warning:pore clogging model '
                write(ilog,*) ' works only when update porosity'
                write(ilog,*) ' is activated. Check input file '
                write(ilog,*)  ' under block 7!'
              end if
            end if
              
            if (.not.update_permeability) then
                update_permeability = .true.
              if (rank == 0 .and. b_enable_output) then
                write(ilog,*) '!!!Warning:pore clogging model '
                write(ilog,*) ' works only when update permeability'
                write(ilog,*) ' is activated. Check input file '
                write(ilog,*)  ' under block 7!'
              end if
            end if
              
            if (por_thresh_min .eq. r0) then
                por_thresh_min = 1.0d-6
              if (rank == 0 .and. b_enable_output) then
                write(ilog,*) '!!!Warning:pore clogging model '
                write(ilog,*) ' is activated. But no minimum '
                write(ilog,*) ' porosity threshold is provided.'
                write(ilog,*)  ' defalut val 1e-6 is used.'
              end if
            end if                         
          end if
      end if
        
!c  maximum permeability factor

        subsection = 'permeability scaling factor threshold maximum'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            ierrcd = 9
            read(itmp,*,err=999,end=999) permfac_thresh_max
          end if
        end if 
        
!c  minimum permeability factor

        subsection ='permeability scaling factor threshold minimum'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (nm.gt.0) then
            ierrcd = 10
            read(itmp,*,err=999,end=999) permfac_thresh_min
          end if
        end if

!c  type of activity update

        subsection = 'activity update settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 11
          read(itmp,*,err=999,end=999) update_activity(tid)
          update_activity(:) = update_activity(tid)
        end if

        if (update_activity(tid).eq.'no_update'.or.                &
     &      update_activity(tid).eq.'no update'.or.                &
     &      update_activity(tid).eq.'no-update') then
          update_activity_rt = 'no_update'
          update_activity_lc = 'no_update'
          update_activity(:) = 'no_update'
        elseif (update_activity(tid).eq.'double_update'.or.        &
     &          update_activity(tid).eq.'double update'.or.        &
     &          update_activity(tid).eq.'double-update') then
          update_activity_rt = 'double_update'
          update_activity_lc = 'double_update'
          update_activity(:) = 'double_update'
        elseif (update_activity(tid).eq.'time_lagged'.or.          &
     &          update_activity(tid).eq.'time lagged'.or.          &
     &          update_activity(tid).eq.'time-lagged') then
          update_activity_rt = 'time_lagged'
          update_activity_lc = 'time_lagged'
          update_activity(:) = 'time_lagged'
        end if

!c  tortuosity corrections - new definition

        subsection = 'tortuosity correction'
        tortuosity_corr=.false. 
        assigned_tau=.false.
        value_tau=1.0d0
        marchie=1.0d0
        marchies = 1.0d0
        assign_marchies = .false.
        update_tortuosity = .false.
        type_tortuosity=' ' 
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 12
          read(itmp,*,err=999,end=999) subsection
          if (subsection.eq.'millington') then
            tortuosity_corr = .true.
            type_tortuosity='millington'
          elseif (subsection.eq.'millington-quirk experimental') then
            tortuosity_corr = .true.
            type_tortuosity='millington-quirk experimental'
            ierrcd = 13
            read(itmp,*,err=999,end=999) tor_corr_a_mq
            read(itmp,*,err=999,end=999) tor_corr_b_mq
          elseif (subsection.eq.'millington-quirk adjustable') then
            tortuosity_corr = .true.
            type_tortuosity='millington-quirk adjustable'
            ierrcd = 13
            read(itmp,*,err=999,end=999) tor_corr_a_mq
            read(itmp,*,err=999,end=999) tor_corr_b_mq
          elseif (subsection.eq.'archie') then
            tortuosity_corr = .true.
            type_tortuosity='archie'
            assign_marchies = .true.
            ierrcd = 14
            !read(itmp,*,err=999,end=999) marchie
            !marchies = marchie
          elseif (subsection.eq.'no correction') then
            tortuosity_corr = .false.
          elseif (subsection.eq.'assigned tau') then  
            tortuosity_corr = .true.
            assigned_tau=.true.
            if (update_tortuosity) then
                assign_marchies = .true.
            end if
          elseif (subsection.eq.'fix diffusion') then  
            tortuosity_corr = .true.
            type_tortuosity='fix diffusion'
          else
            if (rank == 0) then
              write(ilog,*) 'Tortuosity correction not recognized'
              write(*,*) 'Tortuosity correction not recognized'
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop 
          end if
        end if
        
!c  tortuosity corrections - old definition

        subsection = 'tortuosity corrections'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 15
          read(itmp,*,err=999,end=999) tortuosity_corr
          if (tortuosity_corr) then  
           type_tortuosity='millington'
          end if
        end if
        
!c  tortuosity corrections in the gas phase - new - sergi
        assigned_tau_gas=.false.
        subsection = 'gas tortuosity correction'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 16
          read(itmp,*,err=999,end=999) gas_tortuosity
          if ((gas_tortuosity.eq.'millington').or.                     &
              (gas_tortuosity.eq.'no correction').or.                  &
                (gas_tortuosity.eq.'moldrup repacked').or.               &
              (gas_tortuosity.eq.'millington-2').or.                   &
              (gas_tortuosity.eq.'same as aqueous').or.                &
              (gas_tortuosity.eq.'manual')) then
          else if (gas_tortuosity.eq.'assigned tau') then
            assigned_tau_gas=.true.
          else            
            write(ilog,'(a)')                                          &
                  'error reading subsection "gas tortuosity correction"'
            stop
          end if
        else 
          gas_tortuosity = 'same as aqueous'      
        end if

        if (gas_tortuosity == 'same as aqueous' .and. assigned_tau) then
          assigned_tau_gas=.true.
        end if
        
!c  update tortuosity

        subsection = 'update tortuosity'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
            update_tortuosity = .true.
            if(assigned_tau) then
                assign_marchies = .true.
            end if
        end if  
        
!cdsu  mineral input unit, either volume fraction of bulk (default) 
!cdsu  or volume fraction of solid phase
        phiUnitSolid = .false.
        subsection = 'input units of mineral volume fractions'        
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 17
          read(itmp,*,err=999,end=999) strbuffer
          if (strbuffer .eq. 'volume fraction of solid phase') then
            phiUnitSolid = .true.
          end if
        end if

!c  degassing of dissolved gases
!c_bubbles if 'bubble formation' and 'degassing' are both true then
!c_bubbles display an error message

        subsection = 'degassing'

        call findstrg(subsection,itmp,found_subsection)
!c_bub_degas
        if (found_subsection) then
          gas_removal = .true.
          ierrcd = 18
          read(itmp,*,err=999,end=999) degas_rate
          degas_rate = degas_rate * r86400
          if(gas_bubbles .or. mip_mt_enable) then
            ierrcd = 19
            read(itmp,*,err=999,end=999) max_sg_degas  
          end if
        end if
        
!cdsu----------------------------------------------------
!cdsu Correction temperature for solution update
!cdsu----------------------------------------------------
        urtlim_conc_min = -1.0d300
        urtlim_conc_max = 1.0d300
        subsection = 'concentration correction for solution'        
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 20
          read(itmp,*,err=999,end=999) urtlim_conc_min, urtlim_conc_max
        end if


!cdsu  concentration limiter for very small concentration
!cdsu  Important: It can make a difference, esp. in the context of redox chemistry.
!cdsu  Redox couples are related to each other via an equilibrium constant. 
!cdsu  C1/C2 = K, or C1 = K x C2, if a concentration of a redox couple is changes, 
!cdsu  it might cause problems. Less an issue for all other reactions.
!cdsu  DSU, 2020-12-17
        subsection = 'minimum component concentration'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 21
          read(itmp,*,err=999,end=999) conc_corr_min       
        end if    

        subsection = 'maximum component concentration'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 21
          read(itmp,*,err=999,end=999) conc_corr_max       
        end if    

!cdsu  water freezing parameters
        b_water_freezing_ratemin = .false.
        if (b_water_freezing) then
          subsection = 'water freezing reaction rate'
          water_freezing_ratemin = 1.0d-20
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            b_water_freezing_ratemin = .true.
            ierrcd = 22
            read(itmp,*,err=999,end=999) water_freezing_ratemin
            if (water_freezing_ratemin <= 0.0d0) then
              water_freezing_ratemin = 1.0d-20
            end if
          end if
        end if

!c saturation correction for gas source
        b_rate_satcorr = .false.
        subsection = 'saturation correction'
        rate_satcorr = 0.9d0
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_rate_satcorr = .true.
          ierrcd = 23
          read(itmp,*,err=999,end=999)         &
               rate_satcorr_a,       &
               rate_satcorr_b,       &
               rate_satcorr_c,       &
               rate_satcorr_d
          ierrcd = 24
          read(itmp,*,err=999,end=999)         &
               rate_satcorr_satmin,  &
               rate_satcorr_satmax,  &
               rate_satcorr_min,     &
               rate_satcorr_max
        end if

!c temperature inhibition for vhoff equation
        subsection ='inhibition temperature'
        temperature_inhibition = tempks
        temperature_inhibition_coef = 80.0d0
        b_temperature_inhibition = .false.
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ierrcd = 25
          read(itmp,*,err=999,end=999) temperature_inhibition
          read(itmp,*,err=999,end=999) temperature_inhibition_coef
          temperature_inhibition = temperature_inhibition + tconv
          b_temperature_inhibition = .true.
        end if       
        
!c  check divergence for newton iteration
        subsection = 'enable divergence check'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          b_check_div_rt = .true.
        end if

!c  settings for Newton iteration

        subsection = 'newton iteration settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 26
          read(itmp,*,err=999,end=999) dinc_rt
          read(itmp,*,err=999,end=999) iter_rt_ant
          read(itmp,*,err=999,end=999) maxit_rt 
          read(itmp,*,err=999,end=999) urtant_log
          read(itmp,*,err=999,end=999) urtlim_log
          read(itmp,*,err=999,end=999) tol_rt 
        end if

!c  underrelaxation

        subsection = 'user specified underrelaxation factor'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          under_relax_rt = .true.
          ierrcd = 27
          read(itmp,*,err=999,end=999) srelfac_rt
        end if
        
        if (under_relax_rt) then
          srelrange_rt_min = -1.0d100
          srelrange_rt_max = 1.0d100
          subsection = 'user specified underrelaxation range'
          call findstrg(subsection,itmp,found_subsection)  
          if (found_subsection) then
            under_relax_range_rt = .true.
            ierrcd = 28
            read(itmp,*,err=999,end=999) srelrange_rt_min,srelrange_rt_max
          end if
        end if
        
!c  dense block matrices

        subsection = 'dense block matrices'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          sparse_blocks = .false.
        end if      


!c  sparse block matrices

        subsection = 'sparse block matrices'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          sparse_blocks = .true.
        end if

        subsection = 'coefficient of factored connections'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 29
          read(itmp,*,err=999,end=999) coeff_fac_conn_rt 
        end if        

!c  solver

        subsection = 'solver settings'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 29
          read(itmp,*,err=999,end=999) level_rt
          read(itmp,*,err=999,end=999) msolvit_rt
          read(itmp,*,err=999,end=999) idetail_rt
          read(itmp,*,err=999,end=999) restol_rt
          read(itmp,*,err=999,end=999) deltol_rt
          read(itmp,*,err=998,end=998) rcm_ordering_rt     !old
        end if

 998    subsection = 'natural ordering'

        call findstrg(subsection,itmp,found_subsection)    !new

        if (found_subsection) then
          rcm_ordering_rt = .false.
        end if
        
        subsection = 'rcm ordering'

        call findstrg(subsection,itmp,found_subsection)    !new

        if (found_subsection) then
          rcm_ordering_rt = .true.
        end if

#ifdef METIS
        subsection = 'metis ordering'

        call findstrg(subsection,itmp,found_subsection)     !new

        if (found_subsection) then
          metis_ordering_rt = .true.
          rcm_ordering_rt = .false.
        else
          metis_ordering_rt = .false.
        end if
#endif

      end if                 !(found_section)
      
      if (b_enable_output .and. b_enable_output_gen) then

!c  write control parameters for reactive transport
!c  to generic output file
      write(igen,'(/72a)')('-',i=1,72)
      write(igen,'(a)') section_header(:l_string)
      write(igen,'(72a/)')('-',i=1,72)

!c  general control parameters

      if (update_activity(tid).eq.'no_update') then
        write(igen,'(a)') 'unity activity coefficients'
      elseif (update_activity(tid).eq.'time_lagged') then
        write(igen,'(a)')                                 &
     &  'activity coefficients updated each time step'
      elseif (update_activity(tid).eq.'double_update') then
        write(igen,'(a)')                                 &
     &  'activity coefficients updated twice during Newton iteration'
      end if
      if ((nr.gt.0).and.(redox_equil_rt)) then
        write(igen,'(a)') 'equilibrium controlled redox reactions'
      elseif ((nr.gt.0).and.(.not.redox_equil_rt)) then
        write(igen,'(a)') 'kinetically controlled redox reactions'
      end if
      if (dual_porosity) then
        write(igen,'(a)') 'perform dual porosity calculations'
      end if
      if (tortuosity_corr) then
        write(igen,'(a)') 'Millington-Quirk tortuosity correction'
      else
        write(igen,'(a)') 'no tortuosity correction'
      end if
      write(igen,'(2a)') 'tortuosity correction in the gas phase: ',   &
                          gas_tortuosity
      if (update_porosity.and..not.update_permeability) then
        write(igen,'(a)') 'update of porosity'
      elseif (update_permeability) then
        write(igen,'(a)') 'update of porosity and permeability'
      else
        write(igen,'(a)') 'constant porosity and permeability'
      end if
      if (gas_removal) then
        write(igen,'(a)') 'degassing of dissolved gases'
        write(igen,'(a,1pe15.6e3)')                         &
        'rate constant [mol L-1 h2o s-1]                 = ',degas_rate 
      end if
      if (mass_balance_rt) then
        write(igen,'(a)') 'detailed mass balance output'
        if (b_dilution_index) then
          write(igen,'(a)') 'dilution index output'
        end if
        if (b_spatial_moment) then
          write(igen,'(a)') 'spatial moment output'
        end if
      end if
      if (spatial_weighting.eq.'centered') then
        write(igen,'(a)') 'centered weighting'
      elseif (spatial_weighting.eq.'upstream') then
        write(igen,'(a)') 'upstream weighting'
      elseif (spatial_weighting.eq.'vanleer') then
        write(igen,'(a)') 'Van Leer flux limiter'
      end if

!c  Newton iteration

      write(igen,'(a,1pe15.6e3)')                                      &
     &'factor for numerical differentiation            = ',dinc_rt
      write(igen,'(a,i10)')                                            &
     &'ant. number of iterations per time step         = ',iter_rt_ant
      write(igen,'(a,i10)')                                            &
     &'max. number of iterations per time step         = ',maxit_rt
      write(igen,'(a,1pe15.6e3)')                                      &
     &'ant. update in log cycles                       = ',urtant_log
      write(igen,'(a,1pe15.6e3)')                                      &
     &'max. tolerable update in log cycles             = ',urtlim_log
      write(igen,'(a,1pe15.6e3)')                                      &
     &'convergence tolerance                           = ',tol_rt
      if (under_relax_rt) then
        write(igen,'(a)')'underrelaxation'
        write(igen,'(a,1pe15.6e3)')                                    &
     &  'underrelaxation factor                          = ',srelfac_rt
      end if

!c  sparse block matrices

      if (sparse_blocks) then
        write(igen,'(a)')'sparse block matrices'
      else
        write(igen,'(a)')'dense block matrices'
      end if

!c  solver

      write(igen,'(a,i10)')                               &
     &'incomplete factorization level                  = ',level_rt
      write(igen,'(a,i10)')                               &
     &'max. number of solver iterations                = ',msolvit_rt
      write(igen,'(a,i10)')                               &
     &'solver information level                        = ',idetail_rt
      write(igen,'(a,1pe15.6e3)')                         &
     &'solver residual tolerance                       = ',restol_rt
      write(igen,'(a,1pe15.6e3)')                         &
     &'solver update tolerance                         = ',deltol_rt
      if (rcm_ordering_rt) then
        write(igen,'(a)')'reverse Cuthill McKee ordering'
#ifdef METIS
      else if (metis_ordering_rt) then
        write(igen,'(a)')'metis fill-reducing ordering'
#endif
      else
        write(igen,'(a)')'natural ordering'
      end if

      if(b_rate_satcorr) then
        write(igen,'(/a)') 'saturation correction curve'
        write(igen,'(72a)')('-',i=1,72)
        write(igen,'(a,10x,a)') 'saturation','relative reaction rate of o2source'
        
        rsat = rate_satcorr_satmin
        rsatcorr = rate_satcorr_max
        write(igen,'(1pe15.6e3,6x,1pe15.6e3)') rsat, rsatcorr
        
        rdeltsat = (rate_satcorr_satmax -       &
                    rate_satcorr_satmin)/20.0
        do i = 1, 19
          rsat = rate_satcorr_satmin + rdeltsat * i
          rsatcorr = satcorr_curve(rsat)
          write(igen,'(1pe15.6e3,6x,1pe15.6e3)') rsat, rsatcorr
        end do
        
      end if
      
      if(b_temperature_inhibition) then
        
        write(igen,'(/2a)') 'reaction rate correction for minerals ',  &
                           '(temperature inhibition and correction)'
        write(igen,'(72a)')('-',i=1,72)

        do im = 1, nm 
          write(igen,'(/a,1x,a)') 'mineral:', trim(namem(im))
          write(igen,'(a,11x,a)') 'temperature [Â°C]','relative reaction rate coefficient'

          do i = 1, 20
            rtempk = -15.0 + 5.0 * i + tconv
            rcorr = exp(dgcm(im)/rgascal * (r1/tempks - r1/rtempk))    &
                    /(r1 + exp(temperature_inhibition_coef *           &
                    (rtempk - temperature_inhibition)/                 &
                    temperature_inhibition))
      
            if(b_water_freezing_ratemin) then
              if (rtempk < water_freezing_tempkel) then
                rcorr=water_freezing_ratemin
              end if      
            end if 
          
            write(igen,'(1pe15.6e3,10x,1pe15.6e3)') rtempk-tconv, rcorr
          end do
        end do
        
      end if
      
      end if

      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,'(a)') 'error reading input file, error code ', ierrcd
        write(ilog,'(a)') 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
