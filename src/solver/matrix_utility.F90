!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/solver/matrix_utility.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c
!c module matrix_utility
!c
!c This module includes functions that deal with matrix and rhs export and mapping.
!c used for test purpose only, do not use it for general simulation.
!c
!c written by:      Danyang Su
!c
!c last modified:   Danyang Su - Mar. 08, 2018
!c

module matrix_utility

  use file_unit, only : lun_get, lun_free

  implicit none

    integer, parameter :: dp = kind(1.0d0)
    

    contains
    
    !> 
    !> Export matrix to Matrix Market (MM) exchange format.
    !> For formats, please look into http://math.nist.gov/MatrixMarket/formats.html
    subroutine export_mmformat_pattern(n, nnz, ia_in, ja_in, strsuffix, ilorder)
        use gen, only : str_rank
        implicit none
        integer, intent(in) :: n
        integer, intent(in) :: nnz
        integer, intent(in) :: ia_in(n + 1)
        integer, intent(in) :: ja_in(nnz)
        character(len=*), intent(in) :: strsuffix
        character(256) :: strpathsurfix
        integer, optional :: ilorder(n)

        integer :: iunit
        integer :: i, i2, j

        strpathsurfix = trim(adjustl(strsuffix))//trim(str_rank)

        !iunit = 93
        iunit = lun_get()

        !Export matrix a

        open (unit = iunit, file = "a_"//trim(strpathsurfix)//"_pattern.mtx")

        !Write head
        write(iunit, '(a)') "%%MatrixMarket matrix coordinate real general                                     "
        write(iunit, '(a)') "%================================================================================="
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% This ASCII file represents a sparse MxN matrix with L                           "
        write(iunit, '(a)') "% nonzeros in the following Matrix Market format:                                 "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% +----------------------------------------------+                                "
        write(iunit, '(a)') "% |%%MatrixMarket matrix coordinate real general | <--- header line               "
        write(iunit, '(a)') "% |%                                             | <--+                           "
        write(iunit, '(a)') "% |% comments                                    |    |-- 0 or more comment lines "
        write(iunit, '(a)') "% |%                                             | <--+                           "
        write(iunit, '(a)') "% |    M  N  L                                   | <--- rows, columns, entries    "
        write(iunit, '(a)') "% |    I1  J1  A(I1, J1)                         | <--+                           "
        write(iunit, '(a)') "% |    I2  J2  A(I2, J2)                         |    |                           "
        write(iunit, '(a)') "% |    I3  J3  A(I3, J3)                         |    |-- L lines                 "
        write(iunit, '(a)') "% |        . . .                                 |    |                           "
        write(iunit, '(a)') "% |    IL JL  A(IL, JL)                          | <--+                           "
        write(iunit, '(a)') "% +----------------------------------------------+                                "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% Indices are 1-based, i.e. A(1,1) is the first element.                          "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "%================================================================================="

        !Write value
        write(iunit, '(3(i10, 1x))') n, n, nnz

        if(present(ilorder)) then
          do i = 1, n
            do j = ia_in(i), ia_in(i+1)-1
              write(iunit, *) ilorder(i), ilorder(ja_in(j)), 1.0
            end do
          end do
        else
          do i = 1, n
            do j = ia_in(i), ia_in(i+1)-1
              write(iunit, *) i, ja_in(j), 1.0
            end do
          end do
        end if

        close(iunit)


        call lun_free(iunit)

    end subroutine export_mmformat_pattern

    !>
    !> Export matrix to Matrix Market (MM) exchange format.
    !> For formats, please look into http://math.nist.gov/MatrixMarket/formats.html
    subroutine export_mmformat(n, nnz, ia_in, ja_in, a_in, b_in, x_in, &
                               flag_a, flag_b, flag_x, strsuffix, inum)
        use gen, only : str_rank, node_idx_lg2g
        implicit none
        integer, intent(in) :: n
        integer, intent(in) :: nnz
        integer, intent(in) :: ia_in(n + 1)
        integer, intent(in) :: ja_in(nnz)
        real(kind = dp), intent(in) :: a_in(nnz)
        real(kind = dp), intent(in) :: b_in(n)
        real(kind = dp), intent(in) :: x_in(n)
        logical, intent(in) :: flag_a
        logical, intent(in) :: flag_b
        logical, intent(in) :: flag_x
        character(len=*), intent(in) :: strsuffix
        integer, optional :: inum
        character(72) :: strinum
        character(256) :: strpathsurfix
        integer :: iunit
        integer :: i, j
        
        if(present(inum)) then
            write(strinum, *) inum
            strinum = "_"//trim(adjustl(strinum))
        else
            strinum = ""
        end if
        
        strpathsurfix = trim(adjustl(strsuffix))//trim(strinum)//trim(str_rank)
        
        !iunit = 93
        iunit = lun_get()
        
        !Export matrix a
        if(flag_a) then
        
        open (unit = iunit, file = "a_"//trim(strpathsurfix)//".mtx")
        
        !Write head
        write(iunit, '(a)') "%%MatrixMarket matrix coordinate real general                                     "
        write(iunit, '(a)') "%================================================================================="
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% This ASCII file represents a sparse MxN matrix with L                           "
        write(iunit, '(a)') "% nonzeros in the following Matrix Market format:                                 "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% +----------------------------------------------+                                "
        write(iunit, '(a)') "% |%%MatrixMarket matrix coordinate real general | <--- header line               "
        write(iunit, '(a)') "% |%                                             | <--+                           "
        write(iunit, '(a)') "% |% comments                                    |    |-- 0 or more comment lines "
        write(iunit, '(a)') "% |%                                             | <--+                           "
        write(iunit, '(a)') "% |    M  N  L                                   | <--- rows, columns, entries    "
        write(iunit, '(a)') "% |    I1  J1  A(I1, J1)                         | <--+                           "
        write(iunit, '(a)') "% |    I2  J2  A(I2, J2)                         |    |                           "
        write(iunit, '(a)') "% |    I3  J3  A(I3, J3)                         |    |-- L lines                 "
        write(iunit, '(a)') "% |        . . .                                 |    |                           "
        write(iunit, '(a)') "% |    IL JL  A(IL, JL)                          | <--+                           "
        write(iunit, '(a)') "% +----------------------------------------------+                                "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% Indices are 1-based, i.e. A(1,1) is the first element.                          "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "%================================================================================="        
        
        !Write value
        write(iunit, '(3(i10, 1x))') n, n, nnz
        
        do i = 1, n
            do j = ia_in(i), ia_in(i+1)-1
                write(iunit, *) i, ja_in(j), a_in(j)
            end do
        end do        
        
        close(iunit)

        end if  !end of export matrix a
        
        
        !Export right hand side b
        if(flag_b) then        
            open (unit = iunit, file = "b_"//trim(strpathsurfix)//".txt")
            write(iunit, *) n 
            do i = 1, n
                write(iunit, *) b_in(i)
            end do
            close(iunit)
        end if  !end of exprot right hand side b
        
        !Export solution x        
        if(flag_x) then        
            open (unit = iunit, file = "x_"//trim(strpathsurfix)//".txt")
            write(iunit, *) n 
            do i = 1, n
                write(iunit, *) x_in(i)
            end do
            close(iunit)
        end if  !end of export solution x

        call lun_free(iunit)

    end subroutine export_mmformat

    !>
    !> Export matrix to Matrix Market (MM) exchange format.
    !> For formats, please look into http://math.nist.gov/MatrixMarket/formats.html
    subroutine export_mmformat_gbl(nloc, n, nnz, ia_in, ja_in, a_in,   &
                                   b_in, x_in, flag_a, flag_b, flag_x, &
                                   strsuffix, nvols, nvols_gbl,        &
                                   isreact, inum)

#ifdef PETSC
        use gen, only : str_rank, node_idx_lg2l, node_idx_lg2g
#else
        use gen, only : str_rank
#endif

        implicit none
        integer, intent(in) :: nloc                  !number of local nodes (total degrees of freedoms) without ghost nodes
        integer, intent(in) :: n                     !number of nodes (total degrees of freedoms) with ghost nodes
        integer, intent(in) :: nnz
        integer, intent(in) :: ia_in(n + 1)
        integer, intent(in) :: ja_in(nnz)
        real(kind = dp), intent(in) :: a_in(nnz)
        real(kind = dp), intent(in) :: b_in(n)
        real(kind = dp), intent(in) :: x_in(n)
        logical, intent(in) :: flag_a
        logical, intent(in) :: flag_b
        logical, intent(in) :: flag_x
        character(len=*), intent(in) :: strsuffix
        integer, intent(in) :: nvols
        integer, intent(in) :: nvols_gbl
        logical, intent(in) :: isreact
        integer, optional :: inum
        character(72) :: strinum
        character(256) :: strpathsurfix
        integer :: iunit
        integer :: i, j, ivol, jvol, k, dof, row_offset, col_offset

        if(present(inum)) then
            write(strinum, *) inum
            strinum = "_"//trim(adjustl(strinum))
        else
            strinum = ""
        end if



        strpathsurfix = trim(adjustl(strsuffix))//trim(strinum)//trim(str_rank)

        dof = n/nvols

        !iunit = 93
        iunit = lun_get()
        
        !Export matrix a
        if(flag_a) then
        
        open (unit = iunit, file = "a_"//trim(strpathsurfix)//"_natgbl.mtx")    !Export in natural global ordering

        !Write head
        write(iunit, '(a)') "%%MatrixMarket matrix coordinate real general                                     "
        write(iunit, '(a)') "%================================================================================="
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% This ASCII file represents a sparse MxN matrix with L                           "
        write(iunit, '(a)') "% nonzeros in the following Matrix Market format:                                 "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% +----------------------------------------------+                                "
        write(iunit, '(a)') "% |%%MatrixMarket matrix coordinate real general | <--- header line               "
        write(iunit, '(a)') "% |%                                             | <--+                           "
        write(iunit, '(a)') "% |% comments                                    |    |-- 0 or more comment lines "
        write(iunit, '(a)') "% |%                                             | <--+                           "
        write(iunit, '(a)') "% |    M  N  L                                   | <--- rows, columns, entries    "
        write(iunit, '(a)') "% |    I1  J1  A(I1, J1)                         | <--+                           "
        write(iunit, '(a)') "% |    I2  J2  A(I2, J2)                         |    |                           "
        write(iunit, '(a)') "% |    I3  J3  A(I3, J3)                         |    |-- L lines                 "
        write(iunit, '(a)') "% |        . . .                                 |    |                           "
        write(iunit, '(a)') "% |    IL JL  A(IL, JL)                          | <--+                           "
        write(iunit, '(a)') "% +----------------------------------------------+                                "
        write(iunit, '(a)') "%                                                                                 "
        write(iunit, '(a)') "% Indices are 1-based, i.e. A(1,1) is the first element.                          "
        write(iunit, '(a)') "% The indices are in global mode                                                  "
        write(iunit, '(a)') "%================================================================================="

        !Write value
        write(iunit, '(3(i10, 1x))') nloc, nloc, nnz

        row_offset = 0
        col_offset = 0

        do i = 1, n
          if (dof > 1) then
            if (isreact) then
              ivol = ceiling(i*1.0/dof)
              row_offset = i -ivol*dof
            else
              if (i <= nvols) then
                ivol = i
                row_offset = 0
              else
                ivol = i - nvols
                row_offset = nvols_gbl
              end if
            end if
          else
            ivol = i
            row_offset = 0
          end if

#ifdef PETSC
          if (node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif


          do j = ia_in(i), ia_in(i+1)-1

            if (dof > 1) then
              if (isreact) then
                jvol = ceiling(ja_in(j)*1.0/dof)
                col_offset = ja_in(j) -jvol*dof
              else
                if (ja_in(j) <= nvols) then
                  jvol = ja_in(j)
                  col_offset = 0
                else
                  jvol = ja_in(j) - nvols
                  col_offset = nvols_gbl
                end if
              end if
            else
              jvol = ja_in(j)
              col_offset = 0
            end if

#ifdef PETSC
            if (isreact) then
              write(iunit,*) node_idx_lg2g(ivol)*dof+row_offset, &
                    node_idx_lg2g(jvol)*dof+col_offset, a_in(j)
            else
              write(iunit,*) node_idx_lg2g(ivol)+row_offset, &
                    node_idx_lg2g(jvol)+col_offset, a_in(j)
            end if
#else
            if (isreact) then
              write(iunit,*) ivol*dof+row_offset, &
                    jvol*dof+col_offset, a_in(j)
            else
              write(iunit,*) ivol+row_offset, &
                    jvol+col_offset, a_in(j)
            end if
#endif

          end do
        end do

        close(iunit)
        
        end if  !end of export matrix a
        
        
        !Export right hand side b
        if(flag_b) then        

            open (unit = iunit, file = "b_"//trim(strpathsurfix)//"_natgbl.txt")

            write(iunit, *) nloc

            do i = 1, n
              if (dof > 1) then
                if (isreact) then
                  ivol = ceiling(i*1.0/dof)
                  row_offset = i -ivol*dof
                else
                  if (i <= nvols) then
                    ivol = i
                    row_offset = 0
                  else
                    ivol = i - nvols
                    row_offset = nvols_gbl
                  end if
                end if
              else
                ivol = i
                row_offset = 0
              end if

#ifdef PETSC
              if (node_idx_lg2l(ivol) < 0) then
                cycle
              end if
#endif

#ifdef PETSC
              if (isreact) then
                write(iunit, *) node_idx_lg2g(ivol)*dof+row_offset, b_in(i)
              else
                write(iunit, *) node_idx_lg2g(ivol)+row_offset, b_in(i)
              end if
#else
              if (isreact) then
                write(iunit, *) ivol*dof+row_offset, b_in(i)
              else
                write(iunit, *) ivol+row_offset, b_in(i)
              end if
#endif

            end do

            close(iunit)

        end if  !end of exprot right hand side b
        
        !Export solution x        
        if(flag_x) then

            open (unit = iunit, file = "x_"//trim(strpathsurfix)//"_natgbl.txt")
            write(iunit, *) nloc

            do i = 1, n
              if (dof > 1) then
                if (isreact) then
                  ivol = ceiling(i*1.0/dof)
                  row_offset = i -ivol*dof
                else
                  if (i <= nvols) then
                    ivol = i
                    row_offset = 0
                  else
                    ivol = i - nvols
                    row_offset = nvols_gbl
                  end if
                end if
              else
                ivol = i
                row_offset = 0
              end if

#ifdef PETSC
              if (node_idx_lg2l(ivol) < 0) then
                cycle
              end if
#endif

#ifdef PETSC
              if (isreact) then
                write(iunit, *) node_idx_lg2g(ivol)*dof+row_offset, x_in(i)
              else
                write(iunit, *) node_idx_lg2g(ivol)+row_offset, x_in(i)
              end if
#else
              if (isreact) then
                write(iunit, *) ivol*dof+row_offset, x_in(i)
              else
                write(iunit, *) ivol+row_offset, x_in(i)
              end if
#endif

            end do

            close(iunit)

        end if  !end of export solution x

        call lun_free(iunit)
        
    end subroutine  export_mmformat_gbl
    
    !export 1d array data to file
    subroutine export_arrays1d(n, nnz, ia_in, ja_in, a_in, b_in, x_in, &
                               flag_a, flag_b, flag_x, strsuffix, inum)
        use gen, only : str_rank    
        implicit none
        integer, intent(in) :: n
        integer, intent(in) :: nnz
        integer, intent(in) :: ia_in(n + 1)
        integer, intent(in) :: ja_in(nnz)
        real(kind = dp), intent(in) :: a_in(nnz)
        real(kind = dp), intent(in) :: b_in(n)
        real(kind = dp), intent(in) :: x_in(n)
        logical, intent(in) :: flag_a
        logical, intent(in) :: flag_b
        logical, intent(in) :: flag_x
        character(len=*), intent(in) :: strsuffix
        character(256) :: strpathsurfix
        integer, optional :: inum
        
        character(72) :: strinum
        integer :: iunit
        integer :: i
        
        if(present(inum)) then
            write(strinum, *) inum
            strinum = "_"//trim(adjustl(strinum))
        else
            strinum = ""
        end if
        
        strpathsurfix = trim(adjustl(strsuffix))//trim(strinum)//trim(str_rank)//".txt"
        
        !iunit = 93 
        iunit = lun_get()
        
        !Export matrix a
        if(flag_a) then        
            open (unit = iunit, file = "ia_"//trim(strpathsurfix))
            write(iunit, *) n + 1 
            do i = 1, n + 1
                write(iunit, *) ia_in(i)
            end do
            close(iunit)        

            open (unit = iunit, file = "ja_"//trim(strpathsurfix))

            write(iunit, *) nnz
            do i = 1, nnz
                write(iunit, *) ja_in(i)
            end do
            close(iunit)
            
            open (unit = iunit, file = "a_"//trim(strpathsurfix))

            write(iunit, *) nnz
            do i = 1, nnz
                write(iunit, *) a_in(i)
            end do
            close(iunit)
        end if  !end of export matrix a
        
        
        !Export right hand side b
        if(flag_b) then            
            open (unit = iunit, file = "b_"//trim(strpathsurfix))
            write(iunit, *) n 
            do i = 1, n
                write(iunit, *) b_in(i)
            end do
            close(iunit)        
        end if  !end of exprot right hand side b
        
        !Export solution x        
        if(flag_x) then
            open (unit = iunit, file = "x_"//trim(strpathsurfix))
            write(iunit, *) n 
            do i = 1, n
                write(iunit, *) x_in(i)
            end do
            close(iunit)        
        end if  !end of export solution x
        
        call lun_free(iunit)
    
    end subroutine export_arrays1d
    
    !export sparse matrix to 2d format, just for a easier view
    subroutine export_matrix2d_1(iunit, n, nnz,ia_in, ja_in, a_in, b_in)

        use gen, only : ascii_fmt
    
        implicit none
        
        integer, intent(in) :: iunit
        integer, intent(in) :: n
        integer, intent(in) :: nnz
        integer, intent(in) :: ia_in(n + 1)
        integer, intent(in) :: ja_in(nnz)
        real(kind = dp), intent(in) :: a_in(nnz)
        real(kind = dp), intent(in) :: b_in(n)
        real(kind = dp), allocatable :: mat2d(:)
        integer :: i, j, k, istart, iend
        
        allocate(mat2d(n*(n+1)))
        
        !set value
        mat2d = 0.0d0        
        do i = 1, n
            istart = ia_in(i)
            iend = ia_in(i+1)-1
            do j = istart, iend
                k = (i-1)*n + ja_in(j)
                mat2d(k) = a_in(j)
            end do
        end do
        
        mat2d(n*n + 1:) = b_in(1:)
        
        !write data
        do i = 1, n
          write(iunit,ascii_fmt) (mat2d(j), j = (i-1)*n+1, i*n), mat2d(n*n + i)
        end do
        
        deallocate(mat2d)
        
    end subroutine export_matrix2d_1
    
    
    !export sparse matrix to 2d format, just for a easier view
    subroutine export_matrix2d_2(strsuffix, n, nnz,ia_in, ja_in, a_in, b_in)
    
        implicit none
        
        character(len=*), intent(in) :: strsuffix
        integer, intent(in) :: n
        integer, intent(in) :: nnz
        integer, intent(in) :: ia_in(n + 1)
        integer, intent(in) :: ja_in(nnz)
        real(kind = dp), intent(in) :: a_in(nnz)
        real(kind = dp), intent(in) :: b_in(n)        
        integer :: iunit
        
        !iunit = 93
        iunit = lun_get()
        
        open (unit = iunit, file = "matrix_"//trim(adjustl(strsuffix))//".txt", position = 'append')
            write(iunit, *)"matrix: ", n, " x ", n 
            call export_matrix2d_1(iunit, n, nnz,ia_in, ja_in, a_in, b_in)
        close(iunit)
        
        call lun_free(iunit)
        
    end subroutine export_matrix2d_2
    
    !> remap matrix ja locations and values of a 
    subroutine remap_matrix_a_ja (n, ia, nja, ja, a)
#ifdef OPENMP   
        use gen, only : numofthreads_global, numofloops_thred_matrix_uti_1
#endif
    
        implicit none
        
        integer, intent(in) :: n
        integer, intent(in) :: ia(n+1)
        integer, intent(in) :: nja
        integer, intent(inout) :: ja(nja)
        real(kind = dp), intent(inout) :: a(nja)
        integer :: i
                
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (n > numofloops_thred_matrix_uti_1)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)                  
    !$omp do schedule(static)
#endif
        do i = 1, n
            call qsort(ja(ia(i):ia(i+1)-1),a(ia(i):ia(i+1)-1))
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 
 
    end subroutine remap_matrix_a_ja
    
    
    !> remap matrix structure to generate standard sparse matrix pointer array
    subroutine remap_matrix_ja(n, ia, nja, ja, imap)
#ifdef OPENMP    
        use gen, only : numofthreads_global, numofloops_thred_matrix_uti_1
#endif
    
        implicit none
        
        integer, intent(in) :: n
        integer, intent(in) :: ia(n+1)
        integer, intent(in) :: nja
        integer, intent(inout) :: ja(nja)
        integer, intent(inout) :: imap(nja)
        
        integer :: i
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (n > numofloops_thred_matrix_uti_1)                      &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)                  
    !$omp do schedule(static)
#endif
        do i = 1, n
            call qsort2(ja(ia(i):ia(i+1)-1),imap(ia(i):ia(i+1)-1))
        end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 
        
        write(*,*) "Remapping matrix structure completed ... "
    
    end subroutine remap_matrix_ja
    
    !> quick sort ja in each row to make column indices ja should in increasing order per row
    recursive subroutine qsort(ja, a)
        
        implicit none
        
        integer, intent(inout), dimension(:) :: ja
        real(kind = dp), intent(inout), dimension(:) :: a
        integer :: iq

        if(size(ja,1) > 1) then
            call partition(ja, a, iq)
            call qsort(ja(:iq-1),a(:iq-1))
            call qsort(ja(iq:),a(iq:))
        endif
        
    end subroutine qsort

    !> subroutine for quicksort
    subroutine partition(ja,a, marker)
    
        implicit none
      
        integer, intent(inout), dimension(:) :: ja
        real(kind = dp), intent(inout), dimension(:) :: a
        integer, intent(out) :: marker
        integer :: i, j
        integer :: tempi
        integer :: x      ! pivot point
        real(kind = dp) :: tempr
        x = ja(1)
        i= 0
        j= size(ja, 1) + 1

        do
            j = j-1
            do
            if (ja(j) <= x) exit
            j = j-1
            end do
            i = i+1
            do
            if (ja(i) >= x) exit
            i = i+1
            end do
            if (i < j) then
            ! exchange ja_in(i), ja_in(j) and a_in(i), a_in(j)
            
            tempr = a(i)
            a(i) = a(j)
            a(j) = tempr
            
            tempi = ja(i)            
            ja(i) = ja(j)
            ja(j) = tempi            
            
            elseif (i == j) then
            marker = i+1
            return
            else
            marker = i
            return
            endif
        end do
        
    end subroutine partition   
    
    !> quick sort ja in each row to make column indices ja in increasing order per row
    recursive subroutine qsort2(ja, imap)
        
        implicit none
        
        integer, intent(inout), dimension(:) :: ja
        integer, intent(inout), dimension(:) :: imap
        integer :: iq

        if(size(ja,1) > 1) then
            call partition2(ja, imap, iq)
            call qsort2(ja(:iq-1),imap(:iq-1))
            call qsort2(ja(iq:),imap(iq:))
        endif
        
    end subroutine qsort2

    !> subroutine for quicksort
    subroutine partition2(ja, imap, marker)
    
        implicit none
      
        integer, intent(inout), dimension(:) :: ja
        integer, intent(inout), dimension(:) :: imap
        integer, intent(out) :: marker
        integer :: i, j
        integer :: tempi
        integer :: x      ! pivot point
        real(kind = dp) :: tempr
        x = ja(1)
        i= 0
        j= size(ja, 1) + 1

        do
            j = j-1
            do
                if (ja(j) <= x) exit
                j = j-1
            end do
            i = i+1
            do
                if (ja(i) >= x) exit
                i = i+1
            end do
            if (i < j) then
                tempi = imap(i)
                imap(i) = imap(j)
                imap(j) = tempi
                
                tempi = ja(i)            
                ja(i) = ja(j)
                ja(j) = tempi
            elseif (i == j) then
                marker = i+1
                return
            else
                marker = i
                return
            endif
            
        end do
        
    end subroutine partition2  

end module matrix_utility
