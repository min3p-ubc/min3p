!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 877 $
!> $Author: dsu $
!> $Date: 2024-02-08 21:51:08 -0800 (Thu, 08 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/nexttime.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine nexttime
!c -------------------
!c
!c prepare for next time step
!c
!c written by:      Uli Mayer - November 26, 96
!c
!c last modified:   Tom Henderson - February 9, 2004
!c                  - corrected update of porosity when using 
!c                    'combine mineralogical parameters' option
!c                  - added TDS update for density dependent flow
!c                  - drop NAPL phases from porosity update 
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  - Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c
!c bbls.f:      logical
!c           --------
!c             gas_bubbles         =.true. -> gas phase saturation       + -
!c                                        is calculated
!c                                         below the water table
!c
!c gen.f:    real*8:
!c           -------
!c           uvsold(nn)         = solution vector (old time level)    * +
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            * +
!c                                - old time level
!c           sgnew(nn)          = gaseous phase saturation            * +
!c                                - new time level
!c           sgold(nn)          = gaseous phase saturation            * +
!c                                - old time level
!c           c(nc,nn)           = concentrations of free species      * +
!c                                - old time level [moles/l water]
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           cec_g(nn)          = cation exchange capacity [meq/100g] + -
!c                                - global system
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           distcoff_rt(nc,nn) = sorption distribution coefficient   + -
!c                                [-], [l bulk/l bulk]
!c                                - reactive transport
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + -
!c                                species [-]
!c           phi(nm,nn)         = mineral volume fractions            + -
!c           phiold(nm,nn)      = mineral volume fractions            + -
!c                                - old time level
!c           sionold(nn)        = ionic strength of solution          * +
!c                                - old time level
!c           sionnew(nn)        = ionic strength of solution          + -
!c                                - new time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totaold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                non-competitive sorption 
!c                                - old time level [moles/l bulk]
!c           totanew(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                non-competitive sorption
!c                                - new time level [moles/l bulk]
!c           totcold(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totcnew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totgold(nc,nn)      = total gaseous component            * +
!c                                concentrations
!c                                - old time level [moles/l air]
!c           totgnew(nc,nn)      = total gaseous component            + -
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totsold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c           totsold_ion(n,nn)  = total sorbed component              * +
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsold_surf(n,nn) = total sorbed component              * +
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (surface-complex)
!c           totsnew(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c           totsnew_ion(n,nn)  = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsnew_surf(n,nn) = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (surface-complex)
!c           cmold(nm,nn)       = mineral concentrations              * +
!c                                - old time level [moles/l bulk]]
!c           cmnew(nm,nn)       = mineral concentrations              + -
!c                                - new time level [moles/l bulk]
!c           gold(ng,nn)        = gas concentrations                  * +
!c                                - old time level [moles / l air]    
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles / l air]
!c           perm_fac(nn)       = scaling factor for permeability     + +
!c                                as a function of porosity changes
!c           pornew(nn)         = porosity                            + +
!c           por_thresh_max     = maximum porosity threshold          * +
!c                                avoid division by 0 in 
!c                                Kozeny-Carman equation
!c           por_thresh_min     = minimum porosity threshold          * +
!c           permfac_thresh_max = maximum permeability factor threshold  * +
!c           permfac_thresh_min = minimum permeability factor threshold  * +
!c           tau_fac(nn)        = updated tortuosity as the function
!c                                of changed porosity
!c                                tau = tau_0 * por^alpha / por_0^alpha
!c                                tauupdate_fac = por^alpha / por_0^alpha
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number - debugging information + -
!c           n                  = number of components excluding h2o  + -
!c                                equals number of unknowns per
!c                                control volume
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           reactive_transport = .true.  -> perform reactive         + -
!c                                           transport simulation
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           update_porosity    = .true.  -> update porosity as       + -
!c                                           a result of dissolution-
!c                                           precipitation reactions
!c           update_permeability= .true.  -> update permeability as   + -
!c                                           a function of porosity
!c           varsat_flow        = .true.  -> perform flow simulation  + -
!c                                           simulation
!c
!c chem.f:   real*8:
!c           -------
!c           csb(nsb)           = concentrations of sorbed species    * *
!c                                - new time level
!c           chargesb(nsb)      = charge of sorbed species            + -
!c           chargesb_ion(nsb_ion)   = charge of sorbed species       + -
!c                                     (ion-exchange)
!c           chargesb_surf(nsb_surf) = charge of sorbed species       + -
!c                                     (surface-complex)
!c           eqsb(nsb)          = equilibrium constants for           + -
!c                                sorbed species
!c           eqsb_ion(nsb_ion,nthreads)  
!c                              = equilibrium constants for           + -
!c                                sorbed species (ion-exchange)
!c           eqsb_surf(nsb_surf,nthreads)
!c                              = equilibrium constants for           + -
!c                                sorbed species (surface-complex)
!c           rhobulk            = dry bulk density of porous medium   + -
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           xnusb(nsb*nc)      = stoichiometric coefficient matrix   + -
!c                                for formation of sorbed species
!c                                from components
!c           xnusb_ion(nsb_ion*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (ion-exchange)
!c           xnusb_surf(nsb_surf*nc)= stoichiometric coefficient matrix   + -
!c                                for formation of sorbed species
!c                                from components (surface-complex)
!c
!c           integer*4:
!c           ----------
!c           iamp(nm+1)         = pointer array for distribution      + -
!c                                and combination of mineralogical
!c                                parameters
!c           iasb(nsb+1)        = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           iasb_ion(nsb_ion+1)= row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           iasb_surf(nsb_surf+1)= row pointer array to              + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           jamp(nm)           = pointer array for distribution      + -
!c                                and combination of mineralogical
!c                                parameters
!c           jasb(nsb*nc)       = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           jasb_ion(nsb_ion*nc)= column pointer array to            + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           jasb_surf(nsb_surf*nc)= column pointer array to          + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           nc                 = number of components                + -
!c                                (including h2o)
!c           ng                 = number of gases                     + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c
!c           logical:
!c           --------
!c           noncompetitive_sorption = logical array for activation   + -   
!c                                     of noncompetitive sorption
!c                                     reactions
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c           sorption_group     = 'ion-exchange'                      + -
!c                                'surface-complexation'
!c                                'undefined'
!c           sorption_type      = 'gaines-thomas'                     + -
!c                                'gapon'
!c           update_activity(nthreads)    
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c
!c dens.f:   integer*4:
!c           ----------
!c           ianpl(nnpl)        = pointer for napl components         * -
!c           inpl               = counter for napl components         * +
!c           nnpl               = total number of napl components     * -
!c
!c local:    real*8:
!c           -------
!c           por_diff           = porosity difference between time 
!c                                steps
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter
!c           ic                 = counter (components)
!c           ig                 = counter (gases)
!c           im                 = counter (minerals)
!c           im2                = counter (minerals)
!c           isb                = counter (sorbed species)
!c           ivol               = counter (control volumes)
!c
!c external: infcvs    = compute influence coefficients (variably
!c                       saturated flow)
!c           sorbspc   = compute concentrations of sorbed species
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totcona   = compute total sorbed component
!c                       concentrations (non-competitive sorption)
!c           totconc   = compute total aqueous component
!c                       concentrations based on concentrations
!c                       of free species and secondary aqueous
!c                       species
!c           totconcg  = compute total gaseous component
!c                       concentrations based on concentrations
!c                       of gases
!c           totsorb   = compute total sorbed component 
!c                       concentrations [moles/l bulk]
!c ----------------------------------------------------------------------

      subroutine nexttime
 
      use parm
      use gen
      use chem
      use dens
      use phys
      use bbls
      use nobleGasIngrowth
      use mip_bubble, only : mip_mt_enable, mip_adjust_bubble_cond
#ifdef OPENMP      
      use omp_lib
#endif

#ifdef USG
      use usg_mesh_data, only : nodes, is_boundary_node,               &
          node_to_layer_node, layer_nodes_bottom, num_nodes_per_layer
      use usg_ice_sheet, only : ice_basal_temperature_type,            &
                                layer_nodes_bottom_temp,               &
                                layer_nodes_bottom_temp_gbl
#endif

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      implicit none
      
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC
      PetscErrorCode :: ierrcode
#endif
      
      integer :: tid
      
      real*8 :: actw, dummy1, dummy2, dummy3

      external infcvs, sorbspc, totconc, totconcg, totsorb

      real*8 :: dummy, pormin, por_diff, sum_entalchg, aentry_loc
      real*8, external :: acoff
      integer :: i1, iaq, ic, im, im2, ivol, ix, izn, ig, isb,inpl,    &
                 nclog, nclog_gbl, ivol_bottom, ivol_gbl, ivol_track,  &
                 info_debug
      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rsmall = 1.0d-10,   &
                           enat = 2.71828182845904509d0
      external :: tcorr
      
    
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      if(mtime.le.2) then
        info_debug = 0
        ivol_track = -1
      else
        info_debug = 0
        ivol_track = -1
      end if

      im = 0
!c  prepare for next time step

!c  variably saturated flow
!c  note: in parallel environment, section runs in arbitrary order. DSU
      if (varsat_flow.and.transient_flow) then
          uvsold(1:nngl) = uvsnew(1:nngl)

          saold(1:nngl) = sanew(1:nngl) 
 
          if (zero_storage) then
            sgnew(1:nngl)=r1-sanew(1:nngl)
            sgold(1:nngl) = sgnew(1:nngl)
          else
            sgold(1:nngl) = sgnew(1:nngl)
            sgnew(1:nngl)=r1-sanew(1:nngl)
          end if

          if (gas_bubbles) then
            sa_min_old(1:nngl) = sa_min(1:nngl)
          end if

!cdsu--------------------------------------------------------------
!cdsu note: for density dependent flow, densold2, tds_old2 and saold2 mean the value in the 
!cdsu previous timestep while densold, tds_old and saold means the value in the previous picard iteration.
!cdsu--------------------------------------------------------------
          if (density_dependence) then
            densold(1:nngl) = density(1:nngl)
            densold2(1:nngl) = density(1:nngl)
          
            tds_old(1:nngl) = tds_new(1:nngl)
            tds_old2(1:nngl) = tds_new(1:nngl)
          
            saold(1:nngl) = sanew(1:nngl)
            saold2(1:nngl) = sanew(1:nngl)
          end if

          if (heat_transport .and. ispitzerdens) then
            densold_pitzer(1:nngl) = density_pitzer(1:nngl)
            densold2_pitzer(1:nngl) = density_pitzer(1:nngl)
          end if

!          if (density_dependence) then
!            densold1(1:nngl) = density(1:nngl)     
!          end if
    
          if (heat_transport) then
            tempold(1:nngl) = tempnew(1:nngl)
          end if

#ifdef USG
          !c temperature at the bottom of layered simualtion domain
          if (heat_transport .and. ice_basal_temperature_type == 2) then
            !c reset value to a very small one
            layer_nodes_bottom_temp = -1.0d300
            
            do ivol = 1, nngl
              if (is_boundary_node(ivol)) then
                ivol_bottom = node_to_layer_node(ivol)
                if (abs(nodes(ivol)%z - layer_nodes_bottom(ivol_bottom)%z) < rsmall) then
                  layer_nodes_bottom_temp(ivol_bottom) = tempnew(ivol)
                end if
              end if
            end do

#ifdef PETSC
            call MPI_Allreduce(layer_nodes_bottom_temp,                &
                               layer_nodes_bottom_temp_gbl,            &
                               num_nodes_per_layer,MPI_REAL8,MPI_MAX,  &
                               Petsc_Comm_World,ierrcode)
            CHKERRQ(ierrcode)
            layer_nodes_bottom_temp = layer_nodes_bottom_temp_gbl
#endif
          end if
#endif
             
          if (heat_transport .and. update_viscosity_temp) then  
            viscoold(1:nngl) = viscosity(1:nngl)
          end if      
           
          if (heat_transport .and. variably_saturated.and.evaporation) then
            densvold(1:nngl) = densvnew(1:nngl)
            latvapold(1:nngl) = latvapnew(1:nngl)             
          end if
          
          if (napl_permeability) then 
            sgnew(1:nngl) = r1-sanew(1:nngl)-snnew(1:nngl)
          else
            sgnew(1:nngl) = r1-sanew(1:nngl)
          end if

      end if
      
!c_trap reset variables for bubble entrapment
      if (gas_bubbles) then
        do ivol=1,nngl
          if (soilhydrfunc_field) then
            aentry_loc = aentry_vol(ivol)
          else
            izn = mpropvs(ivol)
            aentry_loc = aentry(izn)
          end if

          if (uvsnew(ivol).lt.aentry_loc) then
            unsaturated(ivol) = .true.
          else
            unsaturated(ivol) = .false.
          end if
          if (trap_bubbles) then
            sgt_old(ivol) = sgt(ivol)
            big_bub_old(ivol) = big_bubble(ivol)
          end if
        end do
      end if
 
!c  reactive transport 
      nclog = 0
      if (reactive_transport .and. .not.tran_steady_flow) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_nexttime_1)                     &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(tid, i1, iaq, ic, ig, im, im2, inpl, isb, ivol, ix, &
    !$omp ivol_gbl, napl_match, por_diff, pormin, sum_entalchg)       &
    !$omp reduction(+:nclog)
    !$omp do schedule(static)
#endif
        do ivol = 1,nngl
            
#ifdef OPENMP
          tid = omp_get_thread_num() + 1
#else
          tid = 1
#endif

#ifdef PETSC
          ivol_gbl = node_idx_lg2g(ivol)
#else
          ivol_gbl = ivol
#endif

!c  recompute activity coefficients

#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            write(idbg,*) "-->nexttime->ivol gamma-a", ivol, gamma(:,ivol)
          end if
#endif

          if (update_activity(tid).eq.'time_lagged') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

            if (temp_corr.or.heat_transport) then
              call tcorr(tkel(ivol),ivol,tid)
            end if
!cprovi----------------------------------------------      
            if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andrï¿½s Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi Cuidado, las componentes pueden no ser acuosas
!cprovi preguntarle a Uli 
!cprovi---------------------------------------------- 
              call pitzer (phase,gamma(1:nc,ivol),                    &
                           gamma(nc+1:nc+nx,ivol),                    &
                           cnew(1:nc,ivol),cx(1:nx,ivol),             &
                           nc,nx,ilog)                                
            else 
!c  --> for free species

              do ic=1,nc
                gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),       &
                                       sionnew(ivol),chargec(ic),     &
                                       dhac(ic),dhbc(ic),             &
                                       dhad(tid), dhbd(tid),          &
                                       adav,bdav,acth2omin,nc,        &
                                       nx,namec(ic),namec,ic,         &
     &                                 issit,asit,basit,coepsil,      &
     &                                 iasit,jasit)
              end do

!c  --> for secondary aqueous species

              do ix=1,nx
                gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol),    &
                                          sionnew(ivol),chargex(ix),  &
                                          dhax(ix),dhbx(ix),          &
                                          dhad(tid),dhbd(tid),        &     
                                          adav,bdav,acth2omin,nc,     &
                                          nx,namex(ix),namec,         &
     &                                    nc+ix,issit,asit,basit,     &
     &                                    coepsil,iasit,jasit)
              end do
            end if 
          end if

#ifdef DEBUG
          if (info_debug > 10 .and. (ivol_gbl == ivol_track .or.       &
              ivol_track == 0)) then
            write(idbg,*) "-->nexttime->ivol gamma-b", ivol, gamma(:,ivol)
          end if
#endif
 
!c  aqueous phase
!c  -------------
!c  reassign ionic strengtih for next time level 

          sionold(ivol) = sionnew(ivol)

!c  reassign free species concentrations for next time level

          do ic = 1,n
            c(ic,ivol) = cnew(ic,ivol)
          end do
          
!c  reassign secondary species concentrations for next time level   !MX May2014
          if (hmulti_diff) then
                do ix = 1,nx
                  cxold(ix,ivol) = cx(ix,ivol)
                end do
          end if
          
!c  redox equilibrium reactions

          if ((redox_equil_rt.and.nr.gt.0) .or. gas_bubbles .or.       &
                mip_mt_enable) then

!c  recompute total aqueous component concentrations

            call totconc(cnew(1,ivol),cx(1,ivol),totcnew(1,ivol))

!c Calculate the secondary species concentrations cxold - old time level
            if (hmulti_diff) then
                izn = mpropvs(ivol)
                    
!c  compute total concentrations of aqueous primary and secondary
!c  species times the correction factors
                
                call totconcfac(cnew(1,ivol),cx(1,ivol),totcnewf(1,ivol),izn)
                call totconcfac(c(1,ivol),cxold(1,ivol),totcoldf(1,ivol),izn)
            
            end if

!c  recompute total sorbed component concentrations (non-competitive
!c  sorption)
            
            if (noncompetitive_sorption) then
              call totcona(totanew(1,ivol),totcnew(1,ivol),           &
                            distcoff_rt(1,ivol),sanew(ivol),pornew(ivol))
            end if
            
          end if
          
          if (redox_equil_rt.and.nr.gt.0) then

!c  compress total aqueous and sorbed (noncompetitive sorption)
!c  component concentration vector

            call comptotc(totcnew(1,ivol))
            if (noncompetitive_sorption) then
              call comptotc(totanew(1,ivol))
            end if

          end if

!c  reassign total aqueous and sorbed (non-competitive sorpton)
!c  component concentrations for next time level

          do ic = 1,n
            totcold(ic,ivol) = totcnew(ic,ivol)
            
            if (hmulti_diff) then
                totcoldf(ic,ivol) = totcnewf(ic,ivol)
            end if
            
            if (noncompetitive_sorption) then
              totaold(ic,ivol) = totanew(ic,ivol)
              !c to be checked later, decay
              if (b_use_sorption_decay) then
                totaold(ic,ivol) = totaold(ic,ivol)*enat**(-sorptiondecayconst(ic)*delt)
              end if
            end if
          end do

!c  gaseous phase
!c  -------------
!c  redox equilibrium reactions

          if (ng.gt.0) then

            if ((redox_equil_rt.and.nr.gt.0) .or. gas_bubbles .or.     &
                 mip_mt_enable) then

!c  recompute total gaseous component concentrations

              call totconcg(gnew(1,ivol),totgnew(1,ivol))
              
            end if
            
            if (redox_equil_rt.and.nr.gt.0) then

!c  compress total gaseous component concentrations

              call comptotc(totgnew(1,ivol))

            end if

!c  reassign total gaseous component concentrations for next time level

            do ic = 1,n
              totgold(ic,ivol) = totgnew(ic,ivol)
            end do

!c  reassign gas concentrations for next time level

            do ig = 1,ng
              gold(ig,ivol) = gnew(ig,ivol)
            end do

          end if

!c  sorbed phase
!c  ------------
!c  redox equilibrium reactions

          if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
 
            if (redox_equil_rt.and.nr.gt.0) then

!c  recompute sorbed species concentrations

              do isb = 1,nsb_ion
                call sorbspc(csb_ion(isb,tid),dummy,cec_g(ivol),      &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),gamma(1,ivol),  &
                     cnew(1,ivol),xnusb_ion,xnusb_surf,               &
                     iasb_ion,iasb_surf,jasb_ion,                     &
                     jasb_surf,nsb_ion,nsb_surf,isb,0,                &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)
              end do
              
              do isb = 1,nsb_surf
                call sorbspc(dummy,csb_surf(isb,tid),cec_g(ivol),     &
                     eqsb_ion(:,tid),eqsb_surf(:,tid),gamma(1,ivol),  &
                     cnew(1,ivol),xnusb_ion,xnusb_surf,               &
                     iasb_ion,iasb_surf,jasb_ion,                     &
                     jasb_surf,nsb_ion,nsb_surf,0,isb,                &
                     sorption_type_ion,sorption_type_surf,            &
                     sorption_group,isactcexch)
              end do

!c  recompute total sorbed component concentrations

              call totsorb(csb_ion(:,tid),csb_surf(:,tid),            &
                   chargesb_ion,rhobulk_g(ivol),                      &
                   totsnew_ion(1,ivol),totsnew_surf(1,ivol),          &
                   xnusb_ion,xnusb_surf,                              &
                   iasb_ion,iasb_surf,jasb_ion,jasb_surf,nc,          &
                   nsb_ion,nsb_surf,namec)
                                                                      
!c  compress total sorbed component concentration vector
              if(nsb_ion.gt.0) then
                call comptotc(totsnew_ion(1,ivol))
              end if
              
              if(nsb_surf.gt.0) then
                call comptotc(totsnew_surf(1,ivol))
              end if

            end if

!c  reassign total sorbed component concentrations for next time level

            if(nsb_ion.gt.0) then
                do ic = 1,n
                  totsold_ion(ic,ivol) = totsnew_ion(ic,ivol)
                end do
            end if
            
            if(nsb_surf.gt.0) then
                do ic = 1,n
                  totsold_surf(ic,ivol) = totsnew_surf(ic,ivol)
                end do
            end if

          end if 

!c  mineral phase and porosity-permeability changes
!c  -----------------------------------------------
!c  reassign mineral concentrations for next time level and update
!c  porosity and permeability, if required

          if (nm.gt.0) then

            por_diff = r0

!c update mineral porosity, screening out the napl phases

            do im=1,nm
              cmold(im,ivol) = cmnew(im,ivol)
              if (update_porosity) then

                napl_match = .false.
                if (napl_permeability) then
                  do inpl = 1,nnpl
                    if (im .eq. ianpl(inpl)) then
                      napl_match = .true.
                    end if
                  end do
                end if !napl_permeability

                i1 = iamp(im)
!c sung-wook's (Dec. 17/2004)
                if (i1.lt.iamp(im+1)) then
                !if (i1.le.nm) then                
                  im2 = jamp(i1)
                  if (.not. napl_match) then
                    por_diff = por_diff -     &
                              (phi(im2,ivol)-phiold(im2,ivol))
                  end if
                end if
              end if
              phiold(im,ivol) = phi(im,ivol)
            end do

            if (update_porosity) then 
              porold(ivol) = pornew(ivol)
              pornew(ivol) = pornew(ivol)+por_diff
              pormin=por_init(ivol)*facpormin              
              if (pornew(ivol)<pormin) then
                pornew(ivol) = pormin 
              elseif (pornew(ivol).gt.r1) then
                pornew(ivol) = r1-1.0d-20
              end if
              
              if (pornew(ivol) > por_thresh_max) then
                  pornew(ivol) = por_thresh_max
              else if (pornew(ivol) < por_thresh_min) then                
                !if (rank == 0 .and. b_enable_output) then
                !  write(*,*) '***Warning: Clogging in ivol  ', ivol 
                !  write(*,*) '  por= ', pornew(ivol)
                !  write(*,*) '  is <min threshold por=',por_thresh_min
                !  write(*,*) '  reset por=',por_thresh_min
                !end if
                pornew(ivol) = por_thresh_min
                nclog = nclog + 1
              end if
            end if
            
!c  update permeability based on linear relationship, if required
!c  can include here more appropiate relationships when available

            if (update_permeability) then

!c  linear correction term

!cfff          perm_fac(ivol) = perm_fac(ivol)
!cfff &                       * pornew(ivol)/(pornew(ivol)-por_diff)

!c  correction after Kozeny-Carman (normalized to initial permeability
!c  multiplied over time steps)

              if (pornew(ivol) <= min(por_thresh_max,r1-rsmall) .and.  &
                  pornew(ivol) >= max(por_thresh_min,rsmall) .and.     &
                  porold(ivol) <= min(por_thresh_max,r1-rsmall) .and.  &
                  porold(ivol) >= max(por_thresh_min,rsmall)) then

                !perm_fac(ivol) = perm_fac(ivol)                        &
                !      * pornew(ivol)**3.0d0 / (r1-pornew(ivol))**2.0d0 &
                !      * (r1-porold(ivol))**2.0d0 / porold(ivol)**3.0d0

                !cdsu the following format is less in roundoff error compared to 
                !cdsu the above one when porosity is close to zero or one

                perm_fac(ivol) = perm_fac(ivol)                        &
                      * (pornew(ivol)/porold(ivol))**3.0d0             &
                      * ((r1-porold(ivol))/(r1-pornew(ivol)))**2.0d0
                
                if (perm_fac(ivol) > permfac_thresh_max) then
                  perm_fac(ivol) = permfac_thresh_max
                else if (perm_fac(ivol) < permfac_thresh_min) then
                  perm_fac(ivol) = permfac_thresh_min
                end if                    

              end if

            end if
            
            
            
!c  tortuosity update factor: tau = tau_0 * por^alpha / pro_0^alpha
!c                            tau_fac = por^alpha / pro_0^alpha
!c  used in the benchmark decalcification-of-concrete
!c  DSU, 2013-2-25
            if (assigned_tau .and. update_tortuosity) then
                if (pornew(ivol) >= por_thresh_min) then
                    tau_fac(ivol) = (pornew(ivol)/porold(ivol))**marchies(ivol)
                end if                
            end if

          end if
          
!c Copy the new porosities in the old vector 
!c this is after update for dissolution/precipitation 
          if (update_porosity.or.update_porosity_flow) then
             porold(ivol) = pornew(ivol)
          end if 
          
          if (heat_transport.and.entalphy_change) then
              !sum_entalchg=r0
              !do ix=1,nx
              !  sum_entalchg=sum_entalchg+dhcx(ix)*cx(ix,ivol)
              !end do
            
              !entalchg(ivol)=sum_entalchg
            
              sum_entalchg=r0
              do iaq=1,naq
                sum_entalchg=sum_entalchg+dhaq(im)*rateaqtot(iaq)
              end do
              entalchg(ivol)=entalchg(ivol)+sum_entalchg
              
              sum_entalchg=r0
              do im=1,nm
                sum_entalchg=sum_entalchg+dhcm(im)*ratemdp(im,ivol)
              end do
              entalchg(ivol)=entalchg(ivol)+sum_entalchg
              
           !   sum_entalchg=r0           !   do isb=1,nsb
           !     sum_entalchg=sum_entalchg+dhsb(isb)*csb(isb)
           !   end do
           !   entalchg(ivol)=entalchg(ivol)+sum_entalchg
          end if          

        end do           !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

#ifdef PETSC
        if (pore_clogging) then
          call MPI_Allreduce(nclog, nclog_gbl,1,MPI_INTEGER4,MPI_SUM,    &
                         Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          nclog = nclog_gbl
        end if
#endif
        if (pore_clogging .and. rank == 0 .and. b_enable_output) then
          !cdsu Write to log file only works for master thread/rank as only one 
          !cdsu log file is specified. Avoid writing to log files by multi-threads
          !cdsu or processors. Only use for debug purpose or output to different files
          !cdsu if it is really necessary.
          !do ivol = 1, nngl
          !  if (pornew(ivol) <= por_thresh_min) then
          !    write(ilog,*) '***Warning: Clogging in ivol ', ivol
          !  end if
          !end do
          if (nclog > 0) then
            write(*,*) '***Warning: number of clogged volumes ', nclog
            write(ilog,*) '***Warning: number of clogged volumes ', nclog   
          end if
        end if
       
       
        !cprovi------------------------------------------------------------
        !cprovi Compute the drhov/dT and drhov/dPl as a function of
        !cprovi state variables, for the next time
        !cprovi They are used for influence coefficients of vapor
        !cprovi diffussion
        !cprovi Only if vapor density derivatives must be updated in
        !cprovi each time increment
        !cprovi------------------------------------------------------------
        if (heat_transport.and.evaporation.and.update_ddensv) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_nexttime_2)                     &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, izn, actw, dummy1, dummy2, dummy3, aentry_loc)
    !$omp do schedule(static)
#endif
          do ivol=1,nngl
            if (reactive_transport) then
             actw=gamma(nc,ivol)
            else
             actw=r1
            end if

            if (soilhydrfunc_field) then
              aentry_loc = aentry_vol(ivol)
            else
              izn = mpropvs(ivol)
              aentry_loc = aentry(izn)
            end if

            call vapor_prop (dummy1,dummy2,ddensvdpa(ivol),            &
                             ddensvdt(ivol),dummy3,                    &
                             tempnew(ivol),aentry_loc,                 &
                             uvsnew(ivol),actw,                        &
                             density(ivol),ivol)
            call surf_tens_prop (dummy1,dsurftensdt(ivol),             &
                                   tempnew(ivol))

          end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif        
        end if


!c  recalculate influence coefficients for variably-saturated flow,
!c  if permeability is updated
!c  Parallelized, OpenMP, DSU

        if (update_permeability.or.update_permeability_flow .or.    &
            (mip_mt_enable .and. mip_adjust_bubble_cond) .or.       &
            b_water_freezing) then
          if(discretization_type == 0) then
            call infcvs
#ifdef USG
          else
            call infcvs_usg
#endif
          end if
        end if

      end if             !reactive_transport

      return
      end
