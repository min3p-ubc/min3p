!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 826 $
!> $Author: dsu $
!> $Date: 2022-03-24 10:10:16 -0700 (Thu, 24 Mar 2022) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/readredx.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine readredx
!c -------------------
!c
!c read database for redox couples and assign to permanent storage
!c
!c written by:      Uli Mayer - May 27, 97
!c
!c last modified:   Uli Mayer - February 3, 98
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   integer*4:
!c           ----------
!c           irdbs              = unit number, database for redox     + -
!c                                             couples
!c           ilog               = unit number, log book               + -
!c           idbg               = unit number, debugging file         + -
!c
!c common:
!c chem.f:   real*8:
!c           -------
!c           bcatfac(nr*nor)    = bacterial catalysis factor          * +
!c           chomc(nr*nor*nc)   = cutoff concentrations for reacting  * +
!c                                species (components as species
!c                                in solution)
!c           chomt(nr*nor*nc)   = cutoff concentration for reacting   * +
!c                                species (total aqueous component
!c                                concentrations)
!c           chomx(nr*nor*nx)   = cutoff concentration for reacting   * +
!c                                species (aqueous complexes)
!c           dhcr(nr)           = enthalpy change for redox reaction  * +
!c           eqrs(nr)           = equilibrium constants for redox     * +
!c                                couples at standard temperature
!c           ordorc(nr*nor*nc)  = order of oxidation-reduction        * +
!c                                reaction with respect to components
!c                                as species in solution
!c           ordort(nr*nor*nc)  = order of oxidation-reduction        * +
!c                                reaction with respect to total 
!c                                aqueous component concentrations
!c           ordorx(nr*nor*nx)  = order of oxidation-reduction        * +
!c                                reaction with respect to
!c                                secondary aqueous species
!c           rateox(nr*nor)     = log of oxidation-reduction rate     * +
!c                                constant
!c                                (units: liter -  moles - seconds)
!c           xnur(nr*nc)        = stoichiometric coefficient of       * +
!c                                components in redox couple
!c                                reaction equation
!c
!c           integer*4:
!c           ----------
!c           iarc(nr+1)         = row pointer array to                * +
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           iaor(nr+1)         = pointer array to parallel           * +
!c                                oxidation-reduction reactions
!c           iaorc(nr*nor+1)    = row pointer array to reactants      * +
!c                                in parallel oxidation-reduction
!c                                reactions (components as species
!c                                in solution)
!c           iaort(nr*nor+1)    = row pointer array to reactants      * +
!c                                in parallel oxidation-reduction
!c                                reactions (total aqueous component
!c                                concentrations)
!c           iaorx(nr*nor+1)    = row pointer array to reactants      * +
!c                                in parallel oxidation-reduction
!c                                reactions (secondary aqueous
!c                                species)
!c           iars(nr)           = pointer array to secondary          * +
!c                                component of redox couple
!c           jarc(nr*nc)        = column pointer array to             * +
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           jaorc(nr*nor*nc)   = column pointer array to reactants   * +
!c                                in parallel oxidation-reduction
!c                                reactions (components as species
!c                                in solution)
!c           jaort(nr*nor*nc)   = column pointer array to reactants   * +
!c                                in parallel oxidation-reduction
!c                                reactions (total aqueous component
!c                                concentrations)
!c           jaorx(nr*nor*nx)   = column pointer array to reactants   * +
!c                                in parallel oxidation-reduction
!c                                reactions (secondary aqueous
!c                                species)
!c           nc                 = number of components                + -
!c           ncrc               = number of components with nonzero   * *
!c                                stoichiometric coefficients in
!c                                redox couple reaction equation
!c           nor                = number of parallel                  * *
!c                                oxidation-reduction reactions
!c                                for current redox couple
!c           norc               = number of reactants in current      * *
!c                                oxidation-reduction reaction,
!c                                (components as species in
!c                                solution)
!c           nort               = number of reactants in current      * *
!c                                oxidation-reduction reaction,
!c                                (total aqueous component
!c                                concentrations)
!c           norx               = number of reactants in current      * *
!c                                oxidation-reduction reaction,
!c                                (secondary aqueous species)
!c           nr                 = number of redox couples             + -
!c           nx                 = number of secondary aqueous species + -
!c
!c           logical:
!c           --------
!c           temp_corr          = .true.  -> specify constant         + -
!c                                           temperature
!c                                .false. -> use standard
!c                                           temperature
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c           namer(nr)          = names of redox couples              + -
!c           namers(nr)         = names of secondary components of    + -
!c                                redox couples
!c           namex(nx)          = names of secondary aqueous species  + -
!c           namet(30)          = species names (temporary)           * *
!c           rtype_hom(nr)      = reaction type of homogeneous        * +
!c                                reaction in aqueous phase
!c                                'forward'
!c                                'backward'
!c                                'forward-to-equilibrium'
!c                                'backward-to-equilibrium'
!c                                'reversible'
!c                                'equilibrium'
!c           
!c
!c local:    real*8:
!c           -------
!c           ctmp(100)          = array for temporary storage of
!c                                cutoff concentrations
!c           ordt(100)          = array for temporary storage of
!c                                reaction orders
!c           r10                = constant
!c           r86400             = constant
!c           xnut(100)          = array for temporary storage of
!c                                stoichiometric coefficients
!c
!c           integer*4:
!c           ----------
!c           ic                 = counter (components)
!c           icount             = counter
!c           icur               = pointer
!c           ior                = counter
!c           iorc               = counter
!c           iort               = counter
!c           iorx               = counter
!c           istart             = pointer
!c           istop              = pointer
!c           ir                 = counter (redox couples)
!c           iv                 = counter
!c           ix                 = counter
!c           nv                 = number of components with nonzero
!c                                stoichiometric coefficients in
!c                                redox couple reaction equation
!c                                (temporary)
!c
!c           logical:
!c           --------
!c           comment_line       = .true.  -> read comment line
!c           done               = .true.  -> exit search
!c           found              = .true.  -> exit search
!c           next_entry         = .true.  -> database entry for
!c                                           next redox couple
!c
!c           character:
!c           ----------
!c           junk               = dummy character variable
!c           name_rs            = name of secondary component of 
!c                                redox couple (temporary)
!c
!c external: -
!c ----------------------------------------------------------------------

      subroutine readredx(irdbs,ilog,idbg)
 
      use parm
      use chem
      use gen, only : rank, b_enable_output
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif 
      implicit none
      
      integer :: irdbs, ilog, idbg

      character*1 junk
      character*72 name_rs
      character*256 :: strbuffer
      dimension ctmp(100), xnut(100), ordt(100)
      logical comment_line, done, found, next_entry

      real*8, parameter :: r10 = 10.0d0, r86400 = 8.64d4  
      
      integer :: i, i2, ic, icount, icur, ir, iv, ior, iorc, iorx,     &
                 iort, ix, nv, istart, istop, istart2, istop2,         &
                 info_debug
      real*8 :: xnut, ordt, ctmp

!c initialize pointer arrays for sparse matrix structure
 
      iarc(1) = 1
      iaor(1) = 1
      iaorc(1) = 1
      iaort(1) = 1
      iaorx(1) = 1
 
!c  loop over redox couples specified for simulation
 
      do ir = 1,nr
 
!c  loop over redox couples in database, search for match 
!c  read redox couple data and store in compressed format
!c  exit when done or if end of database is reached
 
        done = .false.
 
        do while (.not.done)
 
!c  skip over comment lines in database
 
          comment_line = .true.
          do while (comment_line)
            read (irdbs,'(a1)',err=997,end = 999) junk
            if (junk.ne.'!') comment_line = .false.
          end do
 
!c  backspace to start of database entry for current redox couple

          backspace(irdbs)

!c  read name of secondary component of redox couple 
!c  and type of reaction
 
          read(irdbs,*,err=997,end = 999) name_rs, rtype_hom(ir)

!c  look for match, as long end of file is not reached or 
!c  match is found
 
!c  redox couple is found --> read data
 
          if (name_rs.eq.namers(ir)) then
 
            done = .true.

!c  check, if secondary component of redox couple is specified
!c  as a component, assign pointer to total aqueous component 
!c  concentration for secondary component of redox couple

            ic = 0
            found = .false.
            do while ((ic.lt.nc).and.(.not.found))
              ic = ic+1
              if (namers(ir).eq.namec(ic)) then
                found = .true.
                iars(ir) = ic
              end if
            end do

!c  exit, if secondary component of redox couple is not specified

            if (.not.found) then
              if (rank == 0) then
                write(ilog,'(72a)') ('-',i=1,72)
                write(ilog,'(3a)')                                     &
     &               'secondary component for redox couple ',          &
     &                namer(ir)(:l_namer(ir)),' is missing'
                write(ilog,'(72a)') ('-',i=1,72)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if

!c  read components involved in current redox reaction and reaction
!c  stoichiometry

            read(irdbs,*,err=997) nv,(namet(iv),xnut(iv),iv=1,nv)

!c  pointer array to row in stoichiometric reaction matrix for 
!c  next redox couple

            iarc(ir+1) = iarc(ir) + nv
 
!c  check if reactants and reaction products of current
!c  redox couple are specified as components,
!c  set up pointer array to column in stoichiometric matrix
        
            icount = 0
            ic = 0
            do while ((icount.lt.nv).and.(ic.lt.nc))
              ic = ic+1
              iv = 0
              found = .false.
              do while ((iv.lt.nv).and.(.not.found))
                iv = iv+1
                if (namet(iv).eq.namec(ic)) then
                  found = .true.
                  icount = icount+1
                  icur = iarc(ir)+iv-1
                  jarc(icur) = ic
                end if
              end do
            end do

!c  exit, if component is missing
 
            if (icount.ne.nv) then
              if (rank == 0) then
                write(ilog,'(72a)') ('-',i=1,72)
                write(ilog,'(5a)')                                     &
     &               'component for redox couple ',                    &
     &                namer(ir)(:l_namer(ir)),' is missing'
                write(ilog,'(72a)') ('-',i=1,72)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
 
!c  all components available --> read data and assign to arrays
 
            elseif (icount.eq.nv) then
 
!c  assign stoichiometric coefficients
 
              istart = iarc(ir)
              istop = iarc(ir+1)-1
              iv = 0
              do i = istart,istop
                iv = iv+1
                xnur(i) = xnut(iv) 
              end do

!c  read log equilibrium constant
 
              if (temp_corr) then
                read(irdbs,*,err=997) eqrs(ir),dhcr(ir)
              else
                read(irdbs,*,err=997) eqrs(ir)
              end if

!c  convert equilibrium constant 

              eqrs(ir) = r10 ** (eqrs(ir))
 
!c  number of parallel oxidation-reduction reactions
 
              read(irdbs,*,err=997) nor

!c  assign pointer to oxidation-reduction reactions for next 
!c  redox couple
  
              iaor(ir+1) = iaor(ir) + nor

!c  loop over number of parallel oxidation-reduction reactions for 
!c  redox couple ir and read data
 
              istart = iaor(ir)
              istop = iaor(ir+1)-1 

              do ior = istart,istop

!c  number of reactants involved in reaction
!c  (components as total aqueous component concentrations)
!c  (components as species in solution), reaction rate
!c  and biological catalysis factor

                read(irdbs,*,err=997) nort,norc,norx,rateox(ior),bcatfac(ior)

!c  convert log rate to absolute rate

                rateox(ior) = r10**rateox(ior)
                bcatfac(ior) = r10**bcatfac(ior)

!c  convert reaction rate time units from database units [seconds] to 
!c  internal time units [days] and volume units from [m^3] to [L]

                rateox(ior) = r86400 * rateox(ior)
 
!c  assign row pointer for reactants for next oxidation-
!c  reduction reaction

                iaort(ior+1) = iaort(ior) + nort
                iaorc(ior+1) = iaorc(ior) + norc
                iaorx(ior+1) = iaorx(ior) + norx

!c  read names of reacting species and order of reaction from
!c  database and store in temporary array, skip for zero order reactions
 
                if (nort+norc+norx.gt.0) then

                  if (rtype_hom(ir).eq.'forward'.or.                  &
     &                rtype_hom(ir).eq.'backward') then                
                    read(irdbs,*,err=997) (namet(i),ordt(i),ctmp(i),  &
     &                             i=1,nort+norc+norx)                 
                  else                                                 
                    read(irdbs,*,err=997) (namet(i),ordt(i),          &
     &                             i=1,nort+norc+norx)
                  end if
 
!c  check if all reactants involved in reaction are specified 
!c  as components
!c  assign pointer to species and order of reaction
 
!c  components - total aqueous component concentrations

                  icount = 0
                  ic = 0
                  do while ((icount.lt.nort).and.(ic.lt.nc))
                    found = .false.
                    iort = 0
                    ic = ic+1
                    do while ((iort.lt.nort).and.(.not.found))
                      iort = iort+1
                      if (namet(iort).eq.namec(ic)) then
                        found = .true.
                        icount = icount+1
                        icur = iaort(ior)+iort-1
                        jaort(icur) = ic
                        ordort(icur) = ordt(iort)
                        if (rtype_hom(ir).eq.'forward'.or.            &
     &                      rtype_hom(ir).eq.'backward') then
                          chomt(icur) = ctmp(iort)
                        end if
                      end if
                    end do
                  end do
 
!c  if component is missing --> exit
 
                  if (icount.ne.nort) then
                    if (rank == 0) then
                      write(ilog,'(72a)') ('-',i=1,72)
                      write(ilog,'(5a)')                               &
     &                      'component for redox couple ',             &
     &                       namer(ir)(:l_namer(ir)),' is missing'
                      write(ilog,'(72a)') ('-',i=1,72)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if

!c  components as species in solution
 
                  icount = 0
                  ic = 0
                  do while ((icount.lt.norc).and.(ic.lt.nc))
                    found = .false.
                    iorc = 0
                    ic = ic+1
                    do while ((iorc.lt.norc).and.(.not.found))
                      iorc = iorc+1
                      if (namet(nort+iorc).eq.namec(ic)) then
                        found = .true.
                        icount = icount+1
                        icur = iaorc(ior)+iorc-1
                        jaorc(icur) = ic
                        ordorc(icur) = ordt(nort+iorc)
                        if (rtype_hom(ir).eq.'forward'.or.            &
     &                      rtype_hom(ir).eq.'backward') then
                          chomc(icur) = ctmp(nort+iorc)
                        end if
                      end if
                    end do
                  end do

!c  if component is missing --> exit

                  if (icount.ne.norc) then
                    if (rank == 0) then
                      write(ilog,'(72a)') ('-',i=1,72)
                      write(ilog,'(5a)')                               &
     &                      'component for redox couple ',             &
     &                       namer(ir)(:l_namer(ir)),' is missing'
                      write(ilog,'(72a)') ('-',i=1,72)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if

!c  secondary aqueous species

                  icount = 0
                  ix = 0
                  do while ((icount.lt.norx).and.(ix.lt.nx))
                    found = .false.
                    iorx = 0
                    ix = ix+1
                    do while ((iorx.lt.norx).and.(.not.found))
                      iorx = iorx+1
                      if (namet(nort+norc+iorx).eq.namex(ix)) then
                        found = .true.
                        icount = icount+1
                        icur = iaorx(ior)+iorx-1
                        jaorx(icur) = ix
                        ordorx(icur) = ordt(nort+norc+iorx)
                        if (rtype_hom(ir).eq.'forward'.or.            &
     &                      rtype_hom(ir).eq.'backward') then
                          chomx(icur) = ctmp(nort+norc+iorx)
                        end if
                      end if
                    end do
                  end do

!c  if component is missing --> exit

                  if (icount.ne.norx) then
                    if (rank == 0) then
                      write(ilog,'(72a)') ('-',i=1,72)
                      write(ilog,'(5a)')                               &
     &                   'secondary aqueous species for redox couple ',&
     &                    namer(ir)(:l_namer(ir)),' is missing'
                      write(ilog,'(72a)') ('-',i=1,72)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if

                end if      !(nort+norc+norx.gt.0)
 
              end do        !number of parallel redox reactions
 
!c  rewind database for redox couples to search for next 
!c  redox couple, doing this allows the specification of redox 
!c  couples in an arbitray order
 
              rewind(irdbs)
 
            end if
 
!c  go to next redox couple, if no match was found
  
          elseif (name_rs.ne.namers(ir)) then

            next_entry = .false.
            do while (.not.next_entry)
              read (irdbs,'(a1)',err=997) junk
              if (junk.eq.'!') then
                next_entry = .true.
              end if
            end do

            backspace(irdbs)

          end if               !search for redox couples
        end do                 !end - loop over redox database
      end do                   !end - loop over specified redox couples

!cdbg ---- activate this section for purposes of debugging -----
#ifdef DEBUG
      info_debug = 0

      if (info_debug.gt.0) then
        do ir=1,nr
          write(idbg,'(a)') 'returning from readredx ...'
          write(idbg,'(a145,1x,a145)') namer(ir)
          write(idbg,'(a,1pe15.6e3)') 'eqrs  ',dlog10(eqrs(ir))
          write(idbg,'(a,1pe15.6e3)') 'dhcr  ',dhcr(ir)
          write(idbg,'(a,i10)') 'iarc    ',iarc(ir)
          write(idbg,'(a,i10,2x,a)') 'iars    ',iars(ir),namec(iars(ir))
 
!c  echo check for stoichiometric coefficients 
 
          istart = iarc(ir)
          istop = iarc(ir+1)-1
          do i = istart, istop
            icur = jarc(i)
            write(idbg,'(i5,2x,a72,a,i5,a,1pe15.6e3)') i,namec(icur),  &
     &                 ' jarc ',jarc(i),' xnur ',xnur(i)
          end do
 
!c  echo check reactions
 
          write(idbg,'(a,i10)') 'iaor   ',iaor(ir)
          istart = iaor(ir)
          istop = iaor(ir+1)-1
          do i = istart, istop
            write(idbg,'(a,i5)') 'reaction',i 
            write(idbg,'(2(a,1pe15.6e3,1x))') 'bcatfac ',              &
                  dlog10(bcatfac(i)), ' rateox ', dlog10(rateox(i))

!c  components as total aqueous component concentrations

            write(idbg,'(a,1x,i10,1x)') 'iaort   ',iaort(i)
            istart2 = iaort(i)
            istop2 = iaort(i+1)-1
            do i2 = istart2,istop2
              icur = jaort(i2)
              write(idbg,'(i5,2x,a72,a,i5,a,1pe15.6e3)') i2,namec(icur), &
                    ' jaort ',jaort(i2), ' ordort ',ordort(i2)
            end do

!c  components as species in solution

            write(idbg,'(a,1x,i10,1x)') 'iaorc   ',iaorc(i)
            istart2 = iaorc(i)
            istop2 = iaorc(i+1)-1
            do i2 = istart2,istop2
              icur = jaorc(i2)
              write(idbg,'(i5,2x,a72,a,i5,a,1pe15.6e3)') i2,namec(icur), &
                    ' jaorc ',jaorc(i2), ' ordorc ',ordorc(i2)
            end do

!c  secondary aqueous species

            write(idbg,'(a,1x,i10,1x)') 'iaorx   ',iaorx(i)
            istart2 = iaorx(i)
            istop2 = iaorx(i+1)-1
            do i2 = istart2,istop2
              icur = jaorx(i2)
              write(idbg,'(i5,2x,a72,a,i5,a,1pe15.6e3)') i2,namex(icur), &
                    ' jaorx ',jaorx(i2), ' ordorx ',ordorx(i2)
            end do

          end do
 
          write(idbg,*) '----------------------------------------------'
        end do
      end if

      if (info_debug.gt.1) then
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
#endif
!cdbg

      return

997   continue
      backspace(irdbs)
      read(irdbs,'(a)') strbuffer
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,'(2a)') 'error reading in redox database: ',trim(strbuffer)
        write(*,*) 'SIMULATION TERMINATED'
        write(*,'(2a)') 'error reading in redox database: ',trim(strbuffer)
        close(ilog)
      end if

#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

!c  exit program if end of database is reached and redox couple
!c  was not found 

999   continue
      if (rank == 0) then
        write(ilog,'(72a)') ('-',i=1,72)
        write(ilog,'(2a)') 'redox couple not in database - check',      &
     &                     ' input file'                                
        write(ilog,'(72a)') ('-',i=1,72)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif

      stop
      end
  
