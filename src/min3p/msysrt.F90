!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 869 $
!> $Author: dsu $
!> $Date: 2023-08-18 09:44:21 -0700 (Fri, 18 Aug 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/msysrt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c -----------------------------------------------------------------------
!c subroutine msysrt
!c -----------------
!c total system mass (reactive transport)
!c
!c written by:      Uli Mayer - April 25, 96
!c
!c last modified:   Uli Mayer - December 5, 96
!c                  Sergi Molins - May 2, 2006 
!c                  added skip, nskip variables
!c
!c                  Danyang Su - March 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   - 
!c
!c common:
!c gen.f:    real*8:
!c           -------
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           cmnew(nm,nn)       = mineral concentrations              + -
!c                                - new time level [moles/l bulk]
!c           cec_g(nn)          = cation exchange capacity [meq/100g] + -
!c                                - global system
!c           csbmass(nsb)       = total sorbed mass in system         * *
!c                                [moles]
!c           csbmass_ion(nsb_ion) = total sorbed mass in system       * *
!c                                  [moles] (ion-exchange)
!c           csbmass_surf(nsb_surf) = total sorbed mass in system     * *
!c                                    [moles] (surface-complex)
!c           csbmass_c(nsites)  = total sorbed mass in system         * *
!c                                - non-aqueous components [moles]
!c           cvol(nn)           = nodal volumes                       + -
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           distcoff_rt(nc,nn) = sorption distribution coefficient   + -
!c                                [-], [l bulk/l bulk]
!c                                - reactive transport
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles / l air]
!c           pornew(nn)         = porosity                            + -
!c           sgnew(nn)          = gaseous phase saturation            + -
!c                                - new time level
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           time_io            = current solution time (I/O units)   + -
!c           tmass(n)           = total mass in aqueous and gaseous   * +
!c                                phase in terms of total component
!c                                concentrations [moles]
!c           totanew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                non-competitive sorption
!c                                - new time level [moles/l bulk]
!c           amass(n)           = total adsorbed mass -               * *
!c                                non-competitive sorption [moles]
!c           cmass(n)           = total mass in water phase in        * *
!c                                terms of total aqueous component
!c                                concentrations [moles]
!c           cmmass(nm)         = total mineral mass in system        * *
!c                                [moles]
!c           gmass(ng)          = total mass in air phase in terms    * *
!c                                of gas concentrations [moles]
!c           smass(nmb)         = total mass of selected species in   * *
!c                                aqueous phase [moles]
!c
!c           integer*4:
!c           ----------
!c           iamb(nmb)          = pointer array for selected          + -
!c                                species to species concentration
!c                                arrays
!c           imrt               = unit number, mass balance -         + -
!c                                             reactive transport
!c           imrt_first         = pointer - first unit number for     + -
!c                                mass balance - reactive transport
!c           jabrt(nbrt)        = pointer array - boundary conditions + -
!c                                (reactive transport)
!c           nbrt               = number of specified boundary        + -
!c                                control volumes
!c           nn                 = total number of control volumes     + -
!c           nmb                = number of selected species          + -
!c
!c           skip               = number of skipped timesteps in logf + -
!c           nskip              = counter of skipped timesteps        + -
!c
!c           character:
!c           ----------
!c           btypert(nn)        = type of boundary control volumes    + -
!c                                'first'  = Dirichlet
!c                                           (specified
!c                                            concentration)
!c                                'second' = Neumann
!c                                           (specified dispersive flux, 
!c                                            free mass outflux for aqueous
!c                                            phase, free exit)
!c                                'third'  = Cauchy
!c                                           (specified dispersive and advective flux, 
!c                                            for aqueous phase)
!c                                'third-evap'
!c                                         = Cauchy
!c                                           (specified advective
!c                                            mass influx for
!c                                            aqueous phase, for outflux,
!c                                            use closed boundary for transport,
!c                                            like evaporation)
!c                                'mixed'  = mixed
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and free
!c                                            diffusive mass influx
!c                                            for gaseous phase)
!c          logic:
!c          ----------
!            flux_out           = .true.  -> output of flux data (MCD)
!c
!c chem.f:   real*8:
!c           -------
!c           csb(nsb)           = concentrations of sorbed species    * *
!c                                - new time level
!c           csb_ion(nsb_ion,nthreads)
!c                              = concentrations of sorbed species    * *
!c                                - new time level (ion-exchange)
!c           csb_surf(nsb_surf,nthreads) 
!c                              = concentrations of sorbed species    * *
!c                                - new time level (surface-complex)
!c           chargesb(nsb)      = charge of sorbed species            + -
!c           chargesb_ion(nsb_ion)   = charge of sorbed species       + -
!c                                     (ion-exchange)
!c           chargesb_surf(nsb_surf) = charge of sorbed species       + -
!c                                     (surface-complex)
!c           eqsb(nsb)          = equilibrium constants for           + -
!c                                sorbed species
!c           eqsb_ion(nsb_ion,nthreads)  
!c                              = equilibrium constants for           + -
!c                                sorbed species (ion-exchange)
!c           eqsb_surf(nsb_surf,nthreads)
!c                              = equilibrium constants for           + -
!c                                sorbed species (surface-complex)
!c           rhobulk            = dry bulk density of porous medium   + -
!c           totcn(nc-1,nthreads)
!c                              = total aqueous component             * +
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totgn(nc-1,nthreads)
!c                              = total gaseous component             * +
!c                                concentrations
!c                                - new time level [moles/l air]
!c           xnusb(nsb*nc)      = stoichiometric coefficient matrix   + -
!c                                for formation of sorbed species
!c                                from components
!c           xnusb_ion(nsb_ion*nc)= stoichiometric coefficient matrix  + -
!c                                for formation of sorbed species
!c                                from components (ion-exchange)
!c           xnusb_surf(nsb_surf*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (surface-complex)
!c
!c           integer*4:
!c           ----------
!c           iaic(nsites)       = pointer array for compressed        + -
!c                                storage of surface site data
!c           iasb(nsb+1)        = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           iasb_ion(nsb_ion+1)= row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           iasb_surf(nsb_surf+1)= row pointer array to              + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           jasb(nsb*nc)       = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           jasb_ion(nsb_ion*nc)= column pointer array to            + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           jasb_surf(nsb_surf*nc)= column pointer array to          + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           nanc               = number of sorbed species            + -
!c                                non-competitive sorption
!c           nc                 = number of components including h2o  + -
!c           ng                 = number of gases                     + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c           nsites             = number of surface sites             + -
!c
!c           logical:
!c           --------
!c           noncompetitive_sorption = logical array for activation   + -  
!c                                     of noncompetitive sorption
!c                                     reactions
!c           redox_equil        = .true.  -> equilibrium reactions    + -
!c                                           for redox couples
!c
!c           character:
!c           ----------
!c           isotherm_type(nc)  = definition of sorption isotherm     + -   
!c                                'none' = no sorption
!c                                'linear' = linear adsorption
!c                                'freundlich' = Freundlich isotherm
!c                                'langmuir' = Langmuir isotherm
!c           namec(nc)          = component names                     + -
!c           nameg(ng)          = gas names                           + -
!c           namem(nm)          = mineral names                       + -
!c           namesb(nsb)        = names of sorbed species             + -
!c           namesb_ion(nsb_ion)= names of sorbed species             + -
!c                                (ion-exchange)
!c           namesb_surf(nsb_surf) = names of sorbed species          + -
!c                                   (surface-complex)
!c           sorption_group     = 'ion-exchange'                      + -
!c                                'surface-complexation'
!c                                'undefined'
!c           sorption_type      = 'gaines-thomas'                     + -
!c                                'gapon'
!c
!c local:    real*8:
!c           -------
!c           conv3              = conversion factor [l/m^3]
!c           r0                 = constant
!c           r100               = conversion factor 
!c                                1/([cm^3 bulk/l bulk] * [100g/g] *
!c                                   [mol/mmol]) = 
!c                                1/(1.0d3 * 1.0d-2 * 1.0d-3)
!c
!c           integer*4:
!c           ----------
!c           ibrt               = counter (control volumes on 
!c                                         boundary)
!c           ianc               = counter (non-competitive
!c                                         sorption reactions)
!c           ic                 = counter (components)
!c           ig                 = counter (gases)
!c           im                 = counter (minerals)
!c           imb                = counter (selected species)
!c           isb                = counter (sorbed species)
!c           isites             = counter (number of surface sites)
!c           isp                = pointer (species)
!c           ivol               = counter (control volumes)
!c
!c external: comptotc  = compress concentration vector, if number
!c                       of unknowns is reduced due to redox
!c                       equilibrium reactions
!c           sorbspc   = compute sorbed species concentrations
!c           totcona   = compute total sorbed component
!c                       concentrations (non-competitive
!c                       sorption)
!c           totconc   = compute total aqueous component 
!c                       concentrations
!c           totconcg  = compute total gaseous component 
!c                       concentrations
!c ----------------------------------------------------------------------
  
      subroutine msysrt

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use chem
      use file_utility, only : reposition_file
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      use module_binary_mpiio, only : binary_write_data
      
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      integer :: ianc, ibrt, ic, ig, im, imb, isb, isp, isites, ivol
      
#ifdef PETSC
      PetscErrorCode :: ierrcode
#endif
      
      integer :: tid
      
      real*8 dummy
      real*8 :: rtmass  !temporary local variable

      external comptotc, sorbspc, totcona, totconc, totconcg
 
      real*8, parameter :: r0 = 0.0d0, conv3 = 1.0d3, r100 = 1.0d2
      
      integer :: nvarsimrt, irecord
 
!c  assign pointer for first mass balance file

      imrt = imrt_first
 
      if (flux_out) then
        imcd = imcd_first
      endif
      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_msysrt_1)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(tid, ivol)                                          
#endif 

!c  Note: the parallel loops are put into the inner loops as the number of 
!c        the outer loops are usually smaller than the number of threads
      
!c  compute total mass in aqueous phase in terms of total 
!c  aqueous component concentrations [moles] and total system
!c  mass in terms of total component concentrations [moles]
      do ic=1,nc-1
#ifdef OPENMP
    !$omp single
#endif
        cmass(ic) = r0  
        tmass(ic) = r0
#ifdef OPENMP
    !$omp end single
#endif 

#ifdef OPENMP
    !$omp do schedule(static) reduction(+:cmass, tmass)
#endif
        do ivol = 1,nngl
!#ifdef PETSC
!          if(node_idx_lg2l(ivol) < 0) then
!              cycle
!          end if
!#endif
            
#ifdef OPENMP    
          tid = omp_get_thread_num() + 1
#else
          tid = 1
#endif

!c  recompute total aqueous component concentrations and
!c  total gaseous component concentrations

          call totconc(cnew(1,ivol),cx(1,ivol),totcn(:,tid))
          call totconcg(cnew(1,ivol),totgn(:,tid))

!c  compute total system mass
#ifdef PETSC
          if(node_idx_lg2l(ivol) > 0) then
#endif
            cmass(ic)  = cmass(ic) + conv3 * cvol(ivol)                &
     &                 * sanew(ivol) * pornew(ivol) * totcn(ic,tid)
            tmass(ic)  = tmass(ic) + conv3 * cvol(ivol) *              &
     &                 ( sanew(ivol) * pornew(ivol) * totcn(ic,tid)    &
     &                 + sgnew(ivol) * pornew(ivol) * totgn(ic,tid))
#ifdef PETSC
          end if
#endif        
        end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
      end do
#ifdef OPENMP
    !$omp end parallel
#endif    

#ifdef PETSC
      call MPI_Allreduce(cmass, cmass_gbl,nc-1,MPI_REAL8,MPI_SUM,   &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      cmass(1:nc-1) = cmass_gbl(1:nc-1)
      
      call MPI_Allreduce(tmass, tmass_gbl,nc-1,MPI_REAL8,MPI_SUM,   &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      tmass(1:nc-1) = tmass_gbl(1:nc-1)     
#endif

!c  compute total for equilibrium redox reactions for actual primary
!c  unknowns

      if (redox_equil_rt.and.nr.gt.0) then
        call comptotc(tmass)
      end if
 
!c  write total system mass in aqueous phase to file
      if(rank == 0 .and. b_enable_output .and.                       &
         .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
        if (b_output_trans_binary) then
          nvarsimrt = nc
          realbuffer_gb(1:nvarsimrt) = (/time_io,(cmass(ic),ic=1,nc-1)/)
          call binary_write_data(imrt_mpi(imrt), 1,            &
                       (/mtime/),offset_imrt_ijk(imrt),.true.)
          call binary_write_data(imrt_mpi(imrt), nvarsimrt,    &
                       realbuffer_gb,offset_imrt(imrt),.true.) 

          offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit

        else 
          if (mtime == mtime_append .and. i_append_sim >= 1) then
            call reposition_file(imrt,irecord)
          end if

          if (i_append_sim < 1 .or.                                    &
             (mtime >= mtime_append .and. i_append_sim >= 1)) then
            write(imrt,ascii_fmt) time_io,(cmass(ic),ic=1,nc-1)
          end if

        end if
      end if

!c  compute total mass in aqueous phase for selected species 
!c  concentrations [moles]

      if (nmb.gt.0) then

        imrt = imrt + 1
        
        if (flux_out) then
          imcd = imcd + 1
        endif
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_msysrt_2)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol)                         
#endif 
        do imb=1,nmb
#ifdef OPENMP
    !$omp single
#endif
          smass(imb) = r0
 
          isp = iamb(imb) 
#ifdef OPENMP
    !$omp end single
#endif          

!c  selected species is free species

          if (isp.le.nc) then
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:smass)
#endif
            do ivol = 1,nngl
#ifdef PETSC
              if(node_idx_lg2l(ivol) < 0) then
                  cycle
              end if
#endif
              smass(imb) = smass(imb) + conv3 * cvol(ivol)            &
                         * sanew(ivol) * pornew(ivol) * cnew(isp,ivol)

            end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
!c  selected species is aqueous complex

          else
#ifdef OPENMP
    !$omp single
#endif
            isp = isp - nc
#ifdef OPENMP
    !$omp end single
#endif

#ifdef OPENMP
    !$omp do schedule(static) reduction(+:smass)
#endif
            do ivol = 1,nngl
#ifdef PETSC
              if(node_idx_lg2l(ivol) < 0) then
                  cycle
              end if
#endif
              smass(imb) = smass(imb) + conv3 * cvol(ivol)            &
     &                   * sanew(ivol) * pornew(ivol) * cx(isp,ivol)

            end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
          end if

        end do
#ifdef OPENMP
    !$omp end parallel
#endif 

#ifdef PETSC
      call MPI_Allreduce(smass, smass_gbl,nmb,MPI_REAL8,MPI_SUM,       &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      smass(1:nmb) = smass_gbl(1:nmb)     
#endif

!c  write total system mass in aqueous phase to file
      if(rank == 0 .and. b_enable_output .and.                         &
         .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
        if (b_output_trans_binary) then
          nvarsimrt = nmb+1
          realbuffer_gb(1:nvarsimrt)=(/time_io,(smass(imb),imb=1,nmb)/)
          call binary_write_data(imrt_mpi(imrt), 1,            &
                       (/mtime/),offset_imrt_ijk(imrt),.true.)
          call binary_write_data(imrt_mpi(imrt), nvarsimrt,    &
                       realbuffer_gb,offset_imrt(imrt),.true.) 

          offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit

        else 
          if (mtime == mtime_append .and. i_append_sim >= 1) then
            call reposition_file(imrt,irecord)
          end if

          if (i_append_sim < 1 .or.                                    &
             (mtime >= mtime_append .and. i_append_sim >= 1)) then
            write(imrt,ascii_fmt) time_io,(smass(imb),imb=1,nmb)
          end if
        end if
      end if
      
      end if              !(nmb.gt.0)           

!c  compute total mass in gaseous phase in terms of gas concentrations 
!c  [moles] (only if gases are specified)

      if (ng.gt.0) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_msysrt_3)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol)                         
#endif           
        do ig=1,ng
#ifdef OPENMP
    !$omp single
#endif            
          gmass(ig) = r0 
#ifdef OPENMP
    !$omp end single
#endif          
          
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:gmass)
#endif          
          do ivol = 1,nngl
#ifdef PETSC 
            if(node_idx_lg2l(ivol) < 0) then
                cycle
            end if
#endif
            gmass(ig) = gmass(ig) + conv3 * cvol(ivol)                &
                      * sgnew(ivol) * pornew(ivol) * gnew(ig,ivol)
          end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
        end do
#ifdef OPENMP
    !$omp end parallel
#endif 

#ifdef PETSC
        call MPI_Allreduce(gmass,gmass_gbl,ng,MPI_REAL8,MPI_SUM,       &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        gmass(1:ng) = gmass_gbl(1:ng)     
#endif

!c  write total system mass in gaseous phase to file

        imrt = imrt+1
        
        if (flux_out) then
          imcd = imcd+1
        endif
        
        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
          if (b_output_trans_binary) then
            nvarsimrt = ng+1
            realbuffer_gb(1:nvarsimrt) = (/time_io,(gmass(ig),ig=1,ng)/)
            call binary_write_data(imrt_mpi(imrt), 1,          &
                         (/mtime/),offset_imrt_ijk(imrt),.true.)
            call binary_write_data(imrt_mpi(imrt), nvarsimrt,  &
                         realbuffer_gb,offset_imrt(imrt),.true.) 

            offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
   
          else
            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imrt,irecord)
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imrt,ascii_fmt) time_io,(gmass(ig),ig=1,ng)
            end if
          end if
        end if

      end if

!c  compute total sorbed mass - non-competitive sorption [moles]
      
    if (noncompetitive_sorption) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_msysrt_4)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(tid, ivol)                                          
#endif  
        
!c  recompute total sorbed component concentrations
#ifdef OPENMP
    !$omp do schedule(static)
#endif  
      do ivol =1,nngl
#ifdef OPENMP    
          tid = omp_get_thread_num() + 1
#else
          tid = 1
#endif 
          call totconc(cnew(1,ivol),cx(1,ivol),totcn(:,tid))
          call totcona(totanew(1,ivol),totcn(:,tid),                  &
                       distcoff_rt(1,ivol),sanew(ivol),               &
                       pornew(ivol))         
      end do  
#ifdef OPENMP
    !$omp end do
#endif  

#ifdef OPENMP
    !$omp barrier
#endif

!c total sorbed mass

      do ic = 1,nc-1
#ifdef OPENMP
    !$omp single
#endif          
        amass(ic) = r0
#ifdef OPENMP
    !$omp end single
#endif

#ifdef OPENMP
    !$omp do schedule(static) reduction(+:amass)
#endif         
        do ivol = 1,nngl
#ifdef PETSC
          if(node_idx_lg2l(ivol) < 0) then
              cycle
          end if
#endif
          amass(ic) = amass(ic) + conv3 * cvol(ivol) * totanew(ic,ivol)
        end do
#ifdef OPENMP
    !$omp end do
#endif 

#ifdef OPENMP
    !$omp barrier
#endif
      end do
      
#ifdef OPENMP
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(amass,amass_gbl,nc-1,MPI_REAL8,MPI_SUM,       &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      amass(1:nc-1) = amass_gbl(1:nc-1)     
#endif

!c  compress total sorbed mass vector for output 
      ianc = 0
      do ic = 1,nc-1
        if (isotherm_type(ic).ne.'none') then
          ianc = ianc+1
          amass(ianc) = amass(ic)
        end if
      end do
    
    end if

!c  compute total sorbed mass - competitive sorption [moles]
!c something wrong here, NAN in .mss file
      if (nsb_ion.gt.0.or.nsb_surf.gt.0) then        
!c  compute total sorbed mass - ion-exchange
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_msysrt_5)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(tid, ivol)                                          
#endif 
        do isb = 1,nsb_ion
#ifdef OPENMP
    !$omp single
#endif
          csbmass_ion(isb) = r0
#ifdef OPENMP
    !$omp end single
#endif

#ifdef OPENMP                       
    !$omp do schedule(static) reduction(+:csbmass_ion)
#endif 
          do ivol = 1,nngl
!#ifdef PETSC
!            if(node_idx_lg2l(ivol) < 0) then
!                cycle
!            end if
!#endif
              
#ifdef OPENMP    
            tid = omp_get_thread_num() + 1
#else
            tid = 1
#endif      

!c  compute sorbed mass for each control volume and each sorbed species
!c  exclude contributions from first type boundary nodes

            if (btypert(ivol).ne.'first') then

                    call sorbspc_m(csb_ion(isb,tid),dummy,cec_g(ivol),&
                         cec_fraction_g(idx_nsites_ion(isb),ivol),    &
                         eqsb_ion(:,tid),eqsb_surf(:,tid),            &
                         gamma(1,ivol),                               &
                         cnew(1,ivol),xnusb_ion,xnusb_surf,           &
                         iasb_ion,iasb_surf,jasb_ion,jasb_surf,       &
                         nsb_ion,nsb_surf,isb,0,sorption_type_ion,    &
                         sorption_type_surf,sorption_group,isactcexch)
#ifdef PETSC
                    if(node_idx_lg2l(ivol) > 0) then
#endif
                      csbmass_ion(isb) = csbmass_ion(isb) +            &
                          cvol(ivol) * csb_ion(isb,tid)*rhobulk_g(ivol)
#ifdef PETSC
                    end if
#endif
            end if

          end do
#ifdef OPENMP
    !$omp end do
#endif 

#ifdef OPENMP
    !$omp barrier
#endif

#ifdef OPENMP
    !$omp single
#endif
          csbmass_ion(isb) = conv3 * csbmass_ion(isb) / (r100 * chargesb_ion(isb))
!CMX            csbmass(isb) = conv3 * rhobulk * csbmass(isb) /           & 
!CMX     &                     (r100 * chargesb(isb))
#ifdef OPENMP
    !$omp end single
#endif

        end do

       
!c  compute total sorbed mass - surface-complex
        do isb = 1,nsb_surf

#ifdef OPENMP
    !$omp single
#endif
          csbmass_surf(isb) = r0
#ifdef OPENMP
    !$omp end single
#endif          
          
#ifdef OPENMP                     
    !$omp do schedule(static) reduction(+:csbmass_surf)
#endif
          do ivol = 1,nngl
              
#ifdef OPENMP    
            tid = omp_get_thread_num() + 1
#else
            tid = 1
#endif 

!c  compute sorbed mass for each control volume and each sorbed species
!c  exclude contributions from first type boundary nodes

            if (btypert(ivol).ne.'first') then

              call sorbspc(dummy,csb_surf(isb,tid),cec_g(ivol),       &
                   eqsb_ion(:,tid),eqsb_surf(:,tid),gamma(1,ivol),    &
                   cnew(1,ivol),xnusb_ion,xnusb_surf,                 &
                   iasb_ion,iasb_surf,jasb_ion,                       &
                   jasb_surf,nsb_ion,nsb_surf,0,isb,                  &
                   sorption_type_ion,sorption_type_surf,              &
                   sorption_group,isactcexch)
#ifdef PETSC
              if(node_idx_lg2l(ivol) > 0) then
#endif
                csbmass_surf(isb) = csbmass_surf(isb) +                &
                     cvol(ivol) * sanew(ivol) *                        &
                     pornew(ivol) * csb_surf(isb,tid)
#ifdef PETSC
              end if
#endif
            end if
          end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif

#ifdef OPENMP
    !$omp single
#endif
          csbmass_surf(isb) = conv3 * csbmass_surf(isb)
#ifdef OPENMP
    !$omp end single
#endif

        end do 

!c  compute sorbed mass for each control volume - non-aqueous components

        if (sorption_group.eq.'surface-complexation' .or.         &
            (sorption_group.eq.'surface-complex and ion-exchange' &
            .and. nsb_surf.gt.0)) then
#ifdef OPENMP
    !$omp single
#endif
          do isites = 1,nsites
            csbmass_c(isites) = r0
          end do
#ifdef OPENMP
    !$omp end single
#endif          
          
#ifdef OPENMP
                       
    !$omp do schedule(static) reduction(+:csbmass_c)
#endif
          do ivol = 1,nngl
#ifdef PETSC
            if(node_idx_lg2l(ivol) < 0) then
                cycle
            end if
#endif  
            if (btypert(ivol).ne.'first') then
              do isites = 1,nsites
                  csbmass_c(isites) = csbmass_c(isites)                 &
                                      + conv3 * cvol(ivol) * sanew(ivol)&
                                      * pornew(ivol)                    &
                                      * cnew(iaic(isites),ivol)             
              end do
            end if
          end do
#ifdef OPENMP
    !$omp end do
#endif  

#ifdef OPENMP
    !$omp barrier
#endif
        end if
#ifdef OPENMP
    !$omp end parallel
#endif   

#ifdef PETSC
        if(nsb_ion > 0) then
          call MPI_Allreduce(csbmass_ion,csbmass_ion_gbl,nsb_ion,      &
                    MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          csbmass_ion(1:nsb_ion) = csbmass_ion_gbl(1:nsb_ion)
        end if
        
        if(nsb_surf > 0) then
          call MPI_Allreduce(csbmass_surf,csbmass_surf_gbl,nsb_surf,   &
                    MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          csbmass_surf(1:nsb_surf) = csbmass_surf_gbl(1:nsb_surf)
        end if 
        
        if (sorption_group.eq.'surface-complexation' .or.              &
            (sorption_group.eq.'surface-complex and ion-exchange'      &
            .and. nsb_surf.gt.0)) then
          call MPI_Allreduce(csbmass_c,csbmass_c_gbl,nsites,           &
                    MPI_REAL8,MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          csbmass_c(1:nsites) = csbmass_c_gbl(1:nsites)
        end if
#endif

      end if                     !(nsb.gt.0)

!c  write total sorbed mass in system to file

      if (nsb_ion.gt.0.or.nsb_surf.gt.0.or.noncompetitive_sorption) then

        imrt = imrt+1

        if (flux_out) then
          imcd = imcd+1
        endif

!c  only competitive sorption

      if(rank == 0 .and. b_enable_output .and.                       &
         .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
      
      if (.not.noncompetitive_sorption) then
        
        if (sorption_group.eq.'ion-exchange') then 
          if (b_output_trans_binary) then
            nvarsimrt = nsb_ion+1
            realbuffer_gb(1:nvarsimrt) = (/time_io, (csbmass_ion(isb), &
                                                     isb=1,nsb_ion)/)
            call binary_write_data(imrt_mpi(imrt), 1,          &
                         (/mtime/),offset_imrt_ijk(imrt),.true.)
            call binary_write_data(imrt_mpi(imrt), nvarsimrt,  &
                         realbuffer_gb,offset_imrt(imrt),.true.) 

            offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
  
          else
            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imrt,irecord)
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imrt,ascii_fmt) time_io,                           &
                   (csbmass_ion(isb),isb=1,nsb_ion)
            end if
          end if
       
        elseif (sorption_group.eq.'surface-complexation') then
          if (b_output_trans_binary) then
            nvarsimrt = nsites+nsb_surf+1
            realbuffer_gb(1:nvarsimrt) = (/time_io,(csbmass_c(isites), &
                                                   isites = 1,nsites), &
                                                   (csbmass_surf(isb), &
                                                      isb=1,nsb_surf)/)
            call binary_write_data(imrt_mpi(imrt), 1,          &
                         (/mtime/),offset_imrt_ijk(imrt),.true.)
            call binary_write_data(imrt_mpi(imrt), nvarsimrt,  &
                         realbuffer_gb,offset_imrt(imrt),.true.) 

            offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
  
          else
            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imrt,irecord)
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imrt,ascii_fmt)                                    &
                    time_io,(csbmass_c(isites),isites = 1,nsites),     &
                    (csbmass_surf(isb),isb=1,nsb_surf)
            end if
          end if

        elseif (sorption_group.eq.'surface-complex and ion-exchange') then
          if (b_output_trans_binary) then
            nvarsimrt = nsites+nsb_ion+nsb_surf+1
            realbuffer_gb(1:nvarsimrt) = (/                            & 
                       time_io, (csbmass_ion(isb),isb=1,nsb_ion),      & 
                       (csbmass_c(isites),isites = 1,nsites),          &
                       (csbmass_surf(isb),isb=1,nsb_surf)/)
            call binary_write_data(imrt_mpi(imrt), 1,          &
                         (/mtime/),offset_imrt_ijk(imrt),.true.)
            call binary_write_data(imrt_mpi(imrt), nvarsimrt,  &
                         realbuffer_gb,offset_imrt(imrt),.true.) 

            offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
 
          else
            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imrt,irecord)
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imrt,ascii_fmt)                                    &
                    time_io, (csbmass_ion(isb),isb=1,nsb_ion),         &
                    (csbmass_c(isites),isites = 1,nsites),             &
                    (csbmass_surf(isb),isb=1,nsb_surf)
            end if
          end if

        end if

!c  only non-competitive sorption

      elseif(nsb_ion.eq.0 .and. nsb_surf.eq.0) then
        if (b_output_trans_binary) then
          nvarsimrt = nanc+1
          realbuffer_gb(1:nvarsimrt) = (/time_io,(amass(ianc),         &
                                                  ianc=1,nanc)/)
          call binary_write_data(imrt_mpi(imrt), 1,            &
                       (/mtime/),offset_imrt_ijk(imrt),.true.)
          call binary_write_data(imrt_mpi(imrt), nvarsimrt,    &
                       realbuffer_gb,offset_imrt(imrt),.true.) 

          offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit

        else
          if (mtime == mtime_append .and. i_append_sim >= 1) then
            call reposition_file(imrt,irecord)
          end if

          if (i_append_sim < 1 .or.                                    &
             (mtime >= mtime_append .and. i_append_sim >= 1)) then
            write(imrt,ascii_fmt) time_io,(amass(ianc),ianc=1,nanc)
          end if
        end if

!c  competitive and non-competitive sorption

      else

        if (sorption_group.eq.'ion-exchange') then 
          if (b_output_trans_binary) then
            nvarsimrt = nanc+nsb_ion+1
            realbuffer_gb(1:nvarsimrt) = (/time_io,                    &
                       (amass(ianc),ianc=1,nanc),                      &
                       (csbmass_ion(isb),isb=1,nsb_ion)/)
            call binary_write_data(imrt_mpi(imrt), 1,          &
                         (/mtime/),offset_imrt_ijk(imrt),.true.)
            call binary_write_data(imrt_mpi(imrt), nvarsimrt,  &
                         realbuffer_gb,offset_imrt(imrt),.true.) 

            offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
 
          else
            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imrt,irecord)
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imrt,ascii_fmt) time_io,                           &
                                        (amass(ianc),ianc=1,nanc),     &
                                        (csbmass_ion(isb),isb=1,nsb_ion)
            end if
          end if  
        
        elseif (sorption_group.eq.'surface-complexation') then

          if (b_output_trans_binary) then
            nvarsimrt = nanc+nsites+nsb_surf+1
            realbuffer_gb(1:nvarsimrt) = (/time_io,                    &
                        (amass(ianc),ianc=1,nanc),                     &
                        (csbmass_c(isites),isites = 1,nsites),         &
                        (csbmass_surf(isb),isb=1,nsb_surf)/)
            call binary_write_data(imrt_mpi(imrt), 1,          &
                         (/mtime/),offset_imrt_ijk(imrt),.true.)
            call binary_write_data(imrt_mpi(imrt), nvarsimrt,  &
                         realbuffer_gb,offset_imrt(imrt),.true.) 

            offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
  
          else
            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imrt,irecord)
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imrt,ascii_fmt) time_io,                           &
                        (amass(ianc),ianc=1,nanc),                     &
                        (csbmass_c(isites),isites = 1,nsites),         &
                        (csbmass_surf(isb),isb=1,nsb_surf)
            end if
          end if  
        elseif (sorption_group.eq.'surface-complex and ion-exchange') then
            
          if (b_output_trans_binary) then
            nvarsimrt = nanc+nsb_ion+nsb_surf+nsites+1
            realbuffer_gb(1:nvarsimrt) = (/time_io,                    &
                        (amass(ianc),ianc=1,nanc),                     &
                        (csbmass_ion(isb),isb=1,nsb_ion),              &
                        (csbmass_c(isites),isites = 1,nsites),         &
                        (csbmass_surf(isb),isb=1,nsb_surf)/)
            call binary_write_data(imrt_mpi(imrt), 1,          &
                         (/mtime/),offset_imrt_ijk(imrt),.true.)
            call binary_write_data(imrt_mpi(imrt), nvarsimrt,  &
                         realbuffer_gb,offset_imrt(imrt),.true.) 

            offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
   
          else
            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imrt,irecord)
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imrt,ascii_fmt) time_io,                           &
                        (amass(ianc),ianc=1,nanc),                     &
                        (csbmass_ion(isb),isb=1,nsb_ion),              &
                        (csbmass_c(isites),isites = 1,nsites),         &
                        (csbmass_surf(isb),isb=1,nsb_surf) 
            end if
          end if
        end if
      
      end if
      
      end if                    !Output by rank 0

      end if

!c  compute total mineral mass [moles]
!c  (only if minerals are specified)
 
      if (nm.gt.0) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_msysrt_6)                       &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol)                         
#endif  
        do im=1,nm
#ifdef OPENMP
    !$omp single
#endif            
          cmmass(im) = r0
#ifdef OPENMP
    !$omp end single
#endif          
          
#ifdef OPENMP
    !$omp do schedule(static) reduction(+:cmmass)
#endif          
          do ivol = 1,nngl
#ifdef PETSC
            if(node_idx_lg2l(ivol) < 0) then
                cycle
            end if
#endif
            cmmass(im) = cmmass(im) + conv3 * cvol(ivol) * cmnew(im,ivol)          
          end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif

!c  first type control volumes do not contribute to total mineral mass
!c  fix up some time
#ifdef OPENMP
    !$omp single
#endif
          rtmass = r0
#ifdef OPENMP
    !$omp end single
#endif

#ifdef OPENMP
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic) reduction(+:rtmass)
#elif SCHEDULE_STATIC
    !$omp do schedule(static) reduction(+:rtmass)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) reduction(+:rtmass) 
#else
    !$omp do schedule(auto) reduction(+:rtmass)
#endif
#endif 
          do ibrt=1,nbrt
              
            ivol = jabrt(ibrt)             !pointer to control volume
            if (ivol < 0) then
              cycle
            end if

            if (compute_ice_sheet_loading) then
              if (.not. b_jabrt_ice(ibrt)) then
                cycle
              end if
            end if

#ifdef PETSC
            if(node_idx_lg2l(ivol) < 0) then
                cycle
            end if
#endif
            
            if (btypert(ivol).eq.'first') then
              !cmmass(im) = cmmass(im)  - conv3 * cvol(ivol) * cmnew(im,ivol)
              rtmass = rtmass + conv3 * cvol(ivol) * cmnew(im,ivol)
            end if
          end do 
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif

#ifdef OPENMP
    !$omp single
#endif
          cmmass(im) = cmmass(im) - rtmass
#ifdef OPENMP
    !$omp end single
#endif          
          
        end do
#ifdef OPENMP
    !$omp end parallel
#endif 

#ifdef PETSC
        call MPI_Allreduce(cmmass,cmmass_gbl,nm,MPI_REAL8,MPI_SUM,       &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        cmmass(1:nm) = cmmass_gbl(1:nm)     
#endif

        
!c  write total mineral mass in system to file

        imrt = imrt+1
        
        if (flux_out) then
          imcd = imcd+1
        endif
        
        if(rank == 0 .and. b_enable_output .and.                       &
           .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
          if (b_output_trans_binary) then
            nvarsimrt = nm+1
            realbuffer_gb(1:nvarsimrt) = (/time_io,(cmmass(im),        &
                                                    im=1,nm)/)
            call binary_write_data(imrt_mpi(imrt), 1,          &
                         (/mtime/),offset_imrt_ijk(imrt),.true.)
            call binary_write_data(imrt_mpi(imrt), nvarsimrt,  &
                         realbuffer_gb,offset_imrt(imrt),.true.) 

            offset_imrt(imrt) = offset_imrt(imrt) + nvarsimrt*nfloatbit
   
          else 
            if (mtime == mtime_append .and. i_append_sim >= 1) then
              call reposition_file(imrt,irecord)
            end if

            if (i_append_sim < 1 .or.                                  &
               (mtime >= mtime_append .and. i_append_sim >= 1)) then
              write(imrt,ascii_fmt) time_io,(cmmass(im),im=1,nm)
            end if
          end if
        end if

      end if

!c  check total surface site mass
      if (mtime == 0) then
        do isites = 1, nsites
          if (csbmass_c(isites) > site_mass_tot(isites)) then
            if (rank == 0 .and. b_enable_output) then
              write(*,*) 'SIMULATION TERMINATED'
              write(*,*) 'Error: Total sorbed mass in system exceeds total sites.'
              write(*,*) 'Total sorbed mass in moles: ',csbmass_c(isites)
              write(*,*) 'Total sites mass in moles: : ',site_mass_tot(isites)
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'Error: Total sorbed mass in system exceeds total sites.'
              write(ilog,*) 'Total sorbed mass in moles: ',csbmass_c(isites)
              write(ilog,*) 'Total sites mass in moles: ',site_mass_tot(isites)
              close(ilog)
            end if            
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if
        end do
      end if

      return

      end
