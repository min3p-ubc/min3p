!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 786 $
!> $Author: dsu $
!> $Date: 2021-01-06 21:41:32 -0800 (Wed, 06 Jan 2021) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/tsteprt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine tsteprt
!c ------------------
!c
!c estimate magnitude of next time step based on change of 
!c concentrations of components as species in solution
!c and based on anticipated number of Newton iterations
!c (reactive transport)
!c
!c Note:
!c -----
!c if delta_c_max(n) would be stored for several time steps, 
!c it would also be possible to develop a higher order scheme for
!c estimating the new time step, a second order scheme would
!c probably perform even better
!c
!c written by:      Uli Mayer - November 26, 96
!c
!c last modified:   Uli Mayer - August 15, 1997
!c                  applied to all components, not only pH and O_2(aq)
!c                  Uli Mayer - September 18, 1997
!c                  included timestep estimate based on number
!c                  of Newton iterations
!c
!c                  Danyang Su - March. 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c gen.f:    real*8:
!c           ------- 
!c           c(nc,nn)           = concentrations of free species      + -
!c                                - old time level [moles/l water]   
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           urtant_log         = anticipated update in log cycles    * +
!c           delta_c(n)         = actual update in log cycles         * *
!c           delta_c_max(n)     = maximum update in log cycles        * *
!c           delt               = time step                           + -
!c           delt_rt            = estimated time step                 * +
!c                                (reactive transport)
!c           deltmax            = maximum time step                   + -
!c           deltmin            = minimum time step                   + -
!c
!c           integer*4:
!c           ----------
!c           iter_rt            = number of Newton iteartions         + -
!c                                (reactive transport)
!c           iter_rt_ant        = anticipated number of Newton        + -
!c                                iterations (reactive transport)
!c           n                  = number of primary unknowns          + -
!c           nn                 = total number of control volumes     + -
!c
!c chem.f:   real*8:
!c           -------
!c
!c           integer*4:
!c           ----------
!c           
!c           character:
!c           ----------
!c 
!c  
!c
!c local:    real*8:
!c           -------
!c           delt_rt_inc        = factor for maximum increase of 
!c                                time step
!c           delt_rt_iter       = factor for increase or decrease
!c                                of timestep based on number of
!c                                Newton iterations
!c           delt_rt_red        = factor for maximum reduction of 
!c                                time step
!c           r0                 = constant
!c           r5                 = constant
!c           r_20               = constant 
!c
!c           integer*4:
!c           ----------
!c           ic                 = counter (components)
!c           ivol               = counter (control volumes)
!c
!c external: -
!c ----------------------------------------------------------------------

      subroutine tsteprt

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use chem
#ifdef OPENMP
      use omp_lib 
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      integer :: ic, im, ivol
      real*8 :: delt_rt_red, delt_rt_inc, delt_rt_iter, delta_phi_max, &
                delta_phi_ant, delta_phi
      
#ifdef PETSC
      real*8 :: delta_phi_max_gbl
      PetscErrorCode :: ierrcode
#endif
      
      integer :: info_debug
      
      external zero_r8_parallel

      real*8, parameter :: r0 = 0.0d0, r_20 = 0.05d0, r5 = 5.0d0,      &
                           rverysmall = 1.0d-30
      
      info_debug = 0

!c  hardwired - could pass values through

      delt_rt_red = r_20 !maximum reduction of timestep
      delt_rt_inc = r5   !maximum increase of timestep

!c  initialize maximum change 

      call zero_r8_parallel(delta_c_max, n, 1, 1)

!c  set new time step estimate to old time step, as a first guess

      delt_rt = deltmax

!c  compute actual maximum updates

#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         & 
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ic, ivol, delta_c)                                  &
    !$omp reduction(max:delta_c_max)
    !$omp do schedule(static)
#endif
      do ivol = 1,nngl
!#ifdef PETSC 
!        if(node_idx_lg2l(ivol) < 0) then
!            cycle
!        end if
!#ifdef PETSC
          
        do ic=1,n 
          delta_c(ic) = dabs(dlog10(cnew(ic,ivol))-dlog10(c(ic,ivol)))
          delta_c_max(ic) = max(delta_c_max(ic),delta_c(ic))
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(delta_c_max, mpireduce_n,n,MPI_REAL8,           & 
                 MPI_MAX, Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      delta_c_max(1:n) = mpireduce_n(1:n)
#endif

!c  set new time step, based on anticipated maximum update 
!c  and actual update of current time step 

#ifdef DEBUG
      if(rank == 0) then
        if(info_debug > 10) then
          write(idbg,'(a, 50(1x, (1pe15.6e3)))')                         &
                "delt_rt,  urtant_log, delt, delta_c_max(nc)",           &
                delt_rt, urtant_log, delt, delta_c_max
        end if
      end if
#endif

      !cdsu for some simulation, delta_c_max may be big enough to keep timestep
      !cdsu very small, in this case, increase urtant_log or using constant 
      !cdsu abs(urtant_log) if urtant_log is negative.
      
      if (urtant_log > r0) then
        do ic = 1,n 
          if(delta_c_max(ic) > rverysmall) then
            delt_rt = min(delt_rt,urtant_log/delta_c_max(ic)*delt)
          end if
        end do
      else if (urtant_log < r0) then
        delt_rt = min(delt_rt,abs(urtant_log)*delt)
      else
        delt_rt = delt
      end if
      
#ifdef DEBUG
      if(rank == 0) then
        if(info_debug > 10) then
          write(idbg,'(a, 1x, 1pe15.6e3)') "delt_rt-1: ", delt_rt
        end if
      end if
#endif

!c  compute factor based on anticipated number of Newton iterations
!c  assume linear relationship for now
!c  could also use some power-stuff here
      
      delt_rt_iter = float(iter_rt_ant)/float(iter_rt)
      
#ifdef DEBUG
      if(rank == 0) then
        if(info_debug > 10) then
          write(idbg,'(a, 1x, 1pe15.6e3, 2(1x, i6))')                &
                "delt_rt_iter, iter_rt_ant, iter_rt ",               &
                delt_rt_iter, iter_rt_ant, iter_rt
        end if
      end if
#endif

!c  use more aggressive strategy to push the upper limit of
!c  iter_rt_ant, time step increase must be larger than time
!c  step decrease, if iter_rt = iter_rt_ant+1

      if (iter_rt.le.iter_rt_ant) then
        delt_rt_iter = float(iter_rt_ant+2)/float(iter_rt_ant)        &
     &               * delt_rt_iter
      end if

!c  take square root of factor for smoother changes

      delt_rt_iter = dsqrt(delt_rt_iter)
      
#ifdef DEBUG
      if(rank == 0) then
        if(info_debug > 10) then
          write(idbg,'(a, 1x, 1pe15.6e3)')                             &
                "final delt_rt_iter after sqrt ", delt_rt_iter
        end if
      end if
#endif

!c  set new time step, based on anticipated number of Newton
!c  iterations

      delt_rt = min(delt_rt,delt_rt_iter*delt)
      
#ifdef DEBUG
      if(rank == 0) then
        if(info_debug > 10) then
          write(idbg,'(a, 1x, 1pe15.6e3)') "delt_rt-2: ", delt_rt
        end if
      end if
#endif

!c  compute maximum decrease in mineral volume fractions

      delta_phi_max = 1.d-300    
      delta_phi_ant = 0.2d0     !maximum anticipated change: 20%
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         & 
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol, delta_phi)                                    &
    !$omp reduction(max:delta_phi_max)
#endif
      do im=1,nm  
        if (reaction_type(im).eq.'raoult') then
#ifdef OPENMP
    !$omp do schedule(static)
#endif            
          do ivol = 1,nngl
!#ifdef PETSC 
!            if(node_idx_lg2l(ivol) < 0) then
!                cycle
!            end if
!#endif
            delta_phi = (phiold(im,ivol)-phi(im,ivol))/phiold(im,ivol)
            delta_phi_max = max(delta_phi,delta_phi_max)
          end do
#ifdef OPENMP
    !$omp end do
#endif 

#ifdef OPENMP
    !$omp barrier
#endif
        end if
      end do
#ifdef OPENMP
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(delta_phi_max, delta_phi_max_gbl,1,MPI_REAL8,           & 
                 MPI_MAX, Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      delta_phi_max = delta_phi_max_gbl
#endif

!c  set new time step based on anticipated change in mineral 
!c  volume fractions

#ifdef DEBUG
      if(rank == 0) then
        if(info_debug > 10) then 
          write(idbg,'(a, 3(1x, 1pe15.6e3))')                          &
                "delt_rt, delta_phi_ant, delta_phi_max: ",             &
                delt_rt, delta_phi_ant, delta_phi_max
        end if
      end if
#endif

      delt_rt = min(delt_rt,delta_phi_ant/delta_phi_max*delt_rt)
      
#ifdef DEBUG
      if(rank == 0) then
        if(info_debug > 10) then
          write(idbg,'(a, 1x, 1pe15.6e3)') "delt_rt-3: ", delt_rt
        end if  
      end if
#endif

!c  apply upper and lower bounds for new time step

#ifdef DEBUG
      if(rank == 0) then
        if(info_debug > 10) then
          write(idbg,'(a, 4(1x, 1pe15.6e3))')                          &
               "delt_rt, delt_rt_inc, deltmax, delt_rt_red, deltmin: ",& 
               delt_rt, delt_rt_inc, deltmax, delt_rt_red
        end if  
      end if
#endif

      delt_rt = min(delt_rt, delt_rt_inc*delt) !upr bound - max. increase
      delt_rt = min(delt_rt, deltmax)          !upr bound - max. time step
      delt_rt = max(delt_rt, delt_rt_red*delt) !lwr bound - max. decrease
      delt_rt = max(delt_rt, deltmin)          !lwr bound - min. time step
      
#ifdef DEBUG
      if(rank == 0) then
        if(info_debug > 10) then
          write(idbg,'(a, 1x, 1pe15.6e3)') "delt_rt-4: ", delt_rt
        end if
      end if
#endif

      return
      end
