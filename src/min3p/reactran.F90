!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/reactran.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine reactran
!c -------------------
!c
!c driver subroutine for reactive transport
!c
!c modified for density dependent flow
!c
!c written by:      Uli Mayer - August 15, 96
!c
!c last modified:   Tom Henderson - June 1, 2006
!c                  Sergi Molins - May 2, 2006
!c                  added skip, nskip
!c                  added giups -> upstream node
!c                  Sergi Molins - June 7, 2006
!c                  added chemical_water, rateh2o
!c                  Sergi Molins - Feb 18, 2007
!c                  tortuosity corrected due to oil presence
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c bbls.f    logical
!c           -------
!c          gas_bubbles         =.true. -> gas phase saturation       + -
!c                                        is calculated
!c                                         below the water table
!c gen.f:    real*8:
!c           -------
!c           area(nm,nn)        = reactivity term                     + +
!c           art(njart)         = jacobian matrix                     * *    
!c           afrt(njafrt)       = incomplete factorization            * *
!c           brt(nn*n)          = rhs vector                          * *
!c           c(nc,nn)           = concentrations of free species      + +
!c                                - old time level [moles/l water]
!c           cinfvs(njavs)      = influence coefficients              + -
!c                                (variably saturated flow)
!c           cnew(nc,nn)        = concentrations of free species      + +
!c                                - new time level [moles/l water]
!c           cmnew(nm,nn)       = mineral concentrations              + +
!c                                - new time level [moles/l bulk]
!c           cmold(nm,nn)       = mineral concentrations              + +
!c                                - old time level [moles/l bulk]]
!c           cx(nx,nn)          = concentrations of secondary aqueous + +
!c                                species [moles/l water]
!c           delt               = time step                           + -
!c           deltol_rt          = solver update tolerance             + -
!c           dimcv(3,nn)        = dimension of control volumes        + -
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + -
!c                                species
!c           phi(nm,nn)         = volume fractions of minerals        + +
!c           pornew(nn)         = porosity                            + -
!c           resrt(nn*n)        = residual                            * *
!c           restol_rt          = solver residual tolerance           + -
!c           rmupdate           = maximum solution update (solver)    * +
!c           rnorm              = residual 2-norm                     * +
!c           rwork(8*nn*n)      = real*8 work array                   * *
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                (new time level)
!c           sgnew(nn)          = gaseous phase saturation            + -
!c                                (new time level)
!c           sionnew(nn)        = ionic strength of solution          + +
!c                                - new time level
!c           sionold(nn)        = ionic strength of solution          + -
!c                                - old time level
!c           tfinal             = final solution time                 + -
!c           time               = current solution time               + -
!c           time_io            = current solution time (I/O units)   + -
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           tsrc(ntsrc)        = target read times - transient       + -
!c                                source chemistry
!c                                (reactive transport)
!c           urt(nn*n)          = update towards solution-vector      * +
!c
!c           integer*4:
!c           ----------
!c           iavs(nn+1)         = row pointer array for 1d-scalar     + -
!c                                matrix
!c           iart(nn*n+1)       = row pointer array for art           + -
!c           iafdrt(nn*n)       = diagonal pointer array for afrt     + -
!c           iafrt(nn*n+1)      = row pointer array for afrt          + -
!c           idbg               = unit number, debugging file         + -
!c           ilog               = unit number, log book               + -
!c           idetail_rt         = information level                   + -
!c           invordrt(nn*n)     = array containing inverse ordering   + -
!c           isymvs(njavs)      = symmetry pointer array              + -
!c           iter_rt            = iteration counter                   * +
!c                                (reactive transport)
!c           itsrc              = pointer to target read time for     + +
!c                                transient source chemistry
!c                                (reactive transport)
!c           ittot_rt           = total number of iterations          + +
!c                                (reactive transport)
!c           iwork(*)           = integer work array                  * *
!c           javs(njavs)        = connectivity list for 1d-scalar     + -
!c                                matrix
!c           jart(njart)        = connectivity list                   + -
!c           jafrt(njafrt)      = column pointer array for afrt       + -
!c           lorderrt(nn*n)     = array containing ordering           + -
!c           msolvit_rt         = max. number of solver iterations    + -
!c           mpropvs(nn)        = pointer array for allocation of     + -
!c                                material properties
!c           mtime              = current time step                   + +
!c           n                  = number of components excluding h2o  + -
!c                                equals number of unknowns per
!c                                control volume
!c           nn                 = total number of control volume      + -
!c           njart              = number of global connections        + -
!c           njafrt             = number of factored connections      + -
!c           ntsrc              = pointer to target read times for    + -
!c                                transient source chemistry
!c           nvx                = number of control volumes in        + -
!c                                x-direction
!c           nvy                = number of control volumes in        + -
!c                                y-direction
!c           nvz                = number of control volumes in        + -
!c                                z-direction
!c           itsolv             = actual number of solver iterations  * +
!c           itsolvtot_rt       = total number of solver              + +
!c                                iterations
!c                                (reactive transport)
!c           skip               = number of skipped timesteps in logf + -
!c           nskip              = counter of skipped timesteps        + -
!c           
!c           
!c
!c           logical:
!c           --------
!c           half_cells         = .true.  -> half cells on boundary   + -
!c           mass_balance_rt    = .true.  -> compute mass balance     + -
!c                                           (reactive transport)
!c           not_converged      = .true.  -> continue Newton          + -
!c                                           iteration 
!c           reduce_timestep    = .true.  -> restart with reduced     + -
!c                                           timestep
!c           steady_flow        = .true.  -> steady state flow        + -
!c           tortuosity_corr    = .true.  -> Millington-Quirk         + -
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           transient_source   = .true.  -> transient source         + -
!c                                           chemistry
!c                                .false. -> constant source
!c                                           chemistry
!c           chemical_water     = .true.  -> account for production   + -
!c                                           or consumption of water
!c                                           due to geochemical 
!c                                           reactions in flow eq.
!c
!c           character:
!c           ----------
!c           btypert(nbrt)      = type of boundary control volumes    + -
!c                                'first'  = Dirichlet
!c                                           (specified
!c                                            concentration)
!c                                'second' = Neumann
!c                                           (specified dispersive flux, 
!c                                            free mass outflux for aqueous
!c                                            phase, free exit)
!c                                'third'  = Cauchy
!c                                           (specified dispersive and advective flux, 
!c                                            for aqueous phase)
!c                                'third-evap'
!c                                         = Cauchy
!c                                           (specified advective
!c                                            mass influx for
!c                                            aqueous phase, for outflux,
!c                                            use closed boundary for transport,
!c                                            like evaporation)
!c                                'mixed'  = mixed
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and free
!c                                            diffusive mass influx
!c                                            for gaseous phase)
!c           spatial_weighting  = 'upstream' -> upstream weigthing    + -
!c                                'centered' -> centered weighting
!c                                'vanleer' -> Van Leer flux limiter
!c                                              (upstream-downstream)
!c                                'vanleer2' -> Van Leer flux limiter
!c                                              (upstream-centered)
!c           time_unit          = time unit for output -> 'years'     + -
!c                                                        'days'
!c                                                        'hours'
!c                                                        'seconds'
!c           update_activity_rt = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c                                 (reactive transport)
!c
!c chem.f:   integer*4:
!c           ----------
!c           nm                 = number of minerals                  + -
!c
!c           logical:
!c           --------
!c           redox_equil        = .true.  -> equilibrium reactions    * +
!c                                           for redox couples
!c
!c           character:
!c           ----------
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           update_activity(nthreads)
!c                              = 'no_update' -> unity activity       + +
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c phys.f:   real*8:
!c           -------
!c           diff_a             = diffusion coefficient in aqueous    + -
!c                                phase (equal for all species)
!c           diff_g             = diffusion coefficient in gaseous    + -
!c                                phase (equal for all species)
!c           disx               = longitudinal dispersivity           + -
!c           disy               = transverse horizontal dispersivity  + -
!c           disz               = transverse vertical dispersivity    + -
!c
!c           integer*4:
!c           ----------
!c           nzn                = number of material property zones   + -
!c
!c dens.f:   integer*4:
!c           ----------
!c           ianpl(nnpl)        = pointer for napl components         * -
!c           inpl               = counter for napl components         * +
!c           nnpl               = total number of napl components     * -
!c
!c           logical:
!c           --------
!c          density_dependence = .true.  -> density-dependent flow   + -
!c
!c local:    real*8:
!c           -------
!c
!c           integer*4:
!c           ----------
!c           ic                 = counter (components)
!c           ierr               = 0 -> memory allocation successful
!c           im                 = counter (minerals)
!c           ivol               = counter (number of control volumes)
!c
!c           logical:
!c           --------
!c           over_flow          = .true.  -> ||r||_2 norm -> infinity
!c
!c external: checkerr = check for error during memory allocation
!c           zero_r8  = clear real*8 array 
!c           i2upfind = assign pointers to second upstream point 
!c                      for flux limiter
!c           infcrt_a = influence coefficients for reactive
!c                      transport (aqueous phase)
!c           infcrtdd = influence coefficients for reactive
!c                      transport (density dependent aqueous)
!c           infcrt_g = influence coefficients for gas phase
!c           jacrt    = construct jacobian matrix and rhs vector 
!c                      (reactive transport)
!c           jacbrt   = incorporate dirichlet and cauchy type
!c                      boundary condition in Jacobian matrix and 
!c                      rhs-vector (reactive transport)
!c           updatert = update free species concentrations and 
!c                      check for convergence
!c           updtsvap = update secondary variables in aqueous phase
!c           updtsvmp = update secondary variables in mineral phase
!c           mbalrt   = compute mass balance (reactive transport)
!c           tcorr    = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           tsteprt  = estimate of time step (reactive transport)
!c           incompletefactorization = incomplete lu-decomposition of
!c                                     stiffness matrix
!c           ws209    = iterative solution of matrix equation
!c           giups    = choose upstream node
!c           rateh2o  = compute water production/consumption due
!c                      geochemical reactions
!c           diffcoff_mcd = compute  averaged diffusion coefficients 
!c                          for free and secondary aqueous species 
!c           mbal_mcd  =  compute mass balance (MCD - 
!c                         multicomponent diffusion)
!c           infcrt_mcd = influence coefficients for MCD - 
!c                         multicomponent diffusion
!c ----------------------------------------------------------------------

      subroutine reactran
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use chem
      use phys
      use dens
      use bbls
      use biol
      use nobleGasIngrowth
      use mip_bubble, only : mip_mt_enable
      use multidiff, only : mdiff_ic_tensor, mdiff_ix_tensor,          &
                            type_mdiff_ic_coeff, type_mdiff_ix_coeff,  &
                            cinfrt_mcd
      use file_unit, only : lun_get, lun_set, lun_free
      use solver_results, only : solver_results_check_output,          &
                                 solver_results_readin
      
#ifdef PARDISO
      use solver_pardiso, only : pardiso_symbolicfactorization,        &
                                 pardiso_numfactorization,             &
                                 pardiso_substitution, ptrt, iparm_rt
#endif 

#ifdef PETSC
      use solver_dd, only : solver_dd_snes_solve_react
      use petsc_mpi_common, only : petsc_mpi_finalize, petsc_mpi_barrier
#endif

#ifdef LIS
      use solver_lis, only : solver_lis_solve_react
#endif

#ifdef OPENMP
      use omp_lib 
#endif

      use matrix_utility, only : export_mmformat, export_arrays1d,     &
                                 export_mmformat_gbl                    !for test, dsu

      implicit none
      
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef PETSC
      DOUBLE PRECISION :: mpireduce_in(2), mpireduce_out(2)
      integer :: nexvol_gbl, mpireduce_irank
      PetscErrorCode :: ierrcode
#endif

      integer :: i, i1, ic, ilist, info_debug, ipest, ierr, ivol,      &
                 i2, i3, ii, ireac, istart, istop, istart2, istop2,    &
                 ic2, icur, icount, next, ivolume, nexvol, maxvol,     &
                 n_unknown_rt, iunit, im, izn, inpl
      real*8 :: sia_abs, ups_flow_loc, uuu, gammatemp
      real*8, external :: satindex, cputime
      
      integer :: ifile, idummy, iskip, nskip
      character*256 :: strdummy, strfile
      
      integer :: tid, istatus

      external checkerr, zero_r8, infcrt_a, infcrtdd, infcrt_g,        &
               jacrt, jacbrt, updatert, mbalrt,                        &
               tsteprt, incompletefactorization, ws209,                &
               diffcoff_mcd,mbal_mcd,infcrt_mcd, giups,                &
               tcorr, updtsvap, updtsvmp

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, conv3 = 1.0d3,      &
                           rverysmall = 1.0d-30
      
      !mole water to liter water, 1mole water = 0.018L
      real*8, parameter :: rwater_mole2liter =  0.018d0  

      logical over_flow, b_redo_symbfac
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      
      info_debug = 0
      
      napl_tol = 1.0d-10 ! defined real*8 in dens.f

      if(rank == 0) then      !if MPI rank 0

      if (idetail_rt.gt.0 .and. rank == 0 .and. b_enable_output .and.  &
          .not.((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then
        write(ilog,'(a)') 'enter reactive transport'
        write(ilog,'(72a/)')('-',i=1,72)
      end if
  
      end if                  !end if MPI rank 0

!c  calculate influence coefficients and pointer array to second 
!c  upstream point
      b_mpi_process_flag = .false.

      if (transient_flow .or. update_disprt .or.                       &
         (steady_flow.and.mtime.eq.1)) then
        
        if (density_dependence) then
          
          if (heat_transport .and. decoupled_type_vs_heat <= 1) then
            ups_flow_loc=ups_heat
          else
            ups_flow_loc=ups_flow
          end if
          
          if(discretization_type == 0) then
            !infcrtdd Parallelized , OpenMP, DSU
            call infcrtdd (nvxgls, nvxgle, nvxgbl,                    &
                       nvygls, nvygle, nvygbl,                        &
                       nvzgls, nvzgle, nvzgbl,                        &
                       nvxgl, nvygl, nvzgl, iavs, javs, isymvs,       &
                       cinfvs_a, cinfrt_va, cinfrt_da, dimcv,         &
                       mpropvs, nzn, diff_a, diff_a_tensor,           &
                       type_diff_coeff, frozen_diff_a, tkel,          &
                       disx, disy, disz, pornew, sanew, uvsnew,       &
                       density, zg, viscosity, relperm,               &
                       idbg, ilog, fully_saturated,                   &
                       variably_saturated, njavs, nngl,               &
                       tortuosity_corr, half_cells,time,tfinal,       &
                       cinfrt_da_ic,diff_coff, nc,                    &
                       diff_ic, diff_ic_tensor, type_diff_ic_coeff,   &
                       assigned_tau,tau,type_tortuosity,marchies,     &
                       harmonic_porosity,delx,dely,delz,av_dens_z,    &
                       ups_flow_loc,gacc,cinfrad,radial_coord,tau_fac,&
                       sonew) 
#ifdef USG
          else
            call infcrtdd_usg
#endif
          end if
        else
          if(discretization_type == 0) then
            !infcrt_a Parallelized , OpenMP, DSU
            call infcrt_a (nvxgls, nvxgle, nvxgbl,                    &
                         nvygls, nvygle, nvygbl,                      &
                         nvzgls, nvzgle, nvzgbl,                      &
                         nvxgl, nvygl, nvzgl, iavs, javs, isymvs,     &
                         cinfvs_a, cinfrt_va, cinfrt_da, dimcv,       &
                         mpropvs, nzn, diff_a, diff_a_tensor,         &
                         type_diff_coeff, frozen_diff_a,              &
                         tkel, disx, disy, disz,                      &
                         pornew, sanew, uvsnew, hhead, relperm,       &
                         idbg, ilog, upstream, fully_saturated,       &
                         variably_saturated, njavs, nngl,             &
                         tortuosity_corr, half_cells,cinfrt_da_ic,    &
                         diff_coff, nc, diff_ic,                      &
                         diff_ic_tensor, type_diff_ic_coeff,          &
                         assigned_tau,tau,type_tortuosity,marchies,   &
                         cinfrad,radial_coord,multi_diff,tau_fac,     &
                         harmonic_porosity, delx,dely,delz,           &
                         type_averaging_De, xg,                       &
                         sonew,oil_saturation)
#ifdef USG
          else
            call infcrt_a_usg
#endif
          end if
        end if
        
!c_read_tau
        if (mtime .eq. 1) then
          if (gas_tortuosity.eq.'manual' .and.                         &
              .not. tortuosity_field_gas .and. .not. assigned_tau_gas) then
            call read_tau
          end if
        endif

!cdbg
        if(info_debug .eq.1) then
          iunit = lun_get()  
          open(iunit,file='sg-dbg'//trim(str_rank)//'.out',            &
               status='unknown',form='formatted')
          do i1=1,nngl
            write(iunit,'(15es15.7)') sgnew(i1)
          end do
          close(iunit)
          call lun_free(iunit)
          
          if(rank == 0) then
            write(*,*) 'debug stop in reactran'
            !pause            
            write(*,*) "stop signal in sg-dbg"//trim(str_rank)//".out"
          end if
          
          b_mpi_process_flag = .true.
        end if     
        
        if(.not.b_mpi_process_flag) then
            
!c_trap if trap bubbles then exclude trapped gas in calculation of diffusion coefficients
          if (gas_bubbles) then
            if (soilhydrfunc_field) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol)
    !$omp do schedule(static)
#endif
              do ivol=1,nngl
                 sg_temp(ivol)=sgnew(ivol)
                 if ((uvsnew(ivol).ge.aentry_vol(ivol)).and.           &
                     (.not.unsaturated(ivol))) then
                   sgnew(ivol)=r0
                 else
                   sgnew(ivol)=dmax1(r0,sgold(ivol)-sgt_old(ivol)*(r1-swr_vol(ivol)))
                 end if
              end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
            else
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol,izn)
    !$omp do schedule(static)
#endif
              do ivol=1,nngl
                 izn = mpropvs(ivol)
                 sg_temp(ivol)=sgnew(ivol)
                 if ((uvsnew(ivol).ge.aentry(izn)).and.                &
                     (.not.unsaturated(ivol))) then
                   sgnew(ivol)=r0
                 else
                   sgnew(ivol)=dmax1(r0,sgold(ivol)-sgt_old(ivol)*(r1-swr(izn)))
                 end if
              end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
            end if
          end if

          if (ng > 0) then
            if(discretization_type == 0) then
              !infcrt_g Parallelized , OpenMP, DSU
              call infcrt_g (nvxgl, nvygl, nvzgl, iavs, javs, isymvs,  &
                           cinfrt_dg, dimcv, diff_g, frozen_diff_g,    &
                           tkel, pornew, sgnew,                        &
                           idbg, ilog, njavs, nngl, tortuosity_corr,   &
                           half_cells,assigned_tau_gas,taugas,         &
                           type_tortuosity,marchies,                   &
                           cinfrad,radial_coord,tau_fac,               &
                           gsatij,gporij,deltaij,tauij,                &
                           gas_tortuosity,sonew,oil_saturation)
#ifdef USG
            else
              call infcrt_g_usg
#endif
            end if
        
!c_trap reset sgnew for other calculations
            if (gas_bubbles) then
              sgnew = sg_temp
            end if
        
          end if

          if (multi_diff) then
            !diffcoff_mcd Parallelized , OpenMP, DSU
            call diffcoff_mcd
                                                                          
            if(discretization_type == 0) then
              !infcrt_mcd Parallelized , OpenMP, DSU
              call infcrt_mcd (nvxgl,nvygl,nvzgl,iavs,javs,isymvs,         &
                               cinfrt_mcd, dimcv, pornew, sanew,           &
                               idbg, ilog, njavs, nngl, tortuosity_corr,   &
                               half_cells, deltaij, tauij,                 &
                               porij,satij,type_averaging_De,assigned_tau, &
                               tau,type_tortuosity,marchies,cinfrad,       &
                               radial_coord, multi_diff,tau_fac, sonew)

#ifdef USG
            else
              call infcrt_mcd_usg
#endif
            end if
            
          end if 
          if (spatial_weighting.eq.'vanleer'.or.                       &
              spatial_weighting.eq.'vanleer2') then
            !Parallelized , OpenMP, DSU
            call i2upfind
          end if

        end if
        
      end if

!cdsu -------------------------------------------------------------
!cdsu  calculate rate of neutron production and noble gas ingrowth
!cdsu -------------------------------------------------------------
      if (b_use_ngi) then
        call update_rate_neutron_product
        call update_rate_noble_gas
      end if


      if(info_debug .eq.1) then
          
        if(b_mpi_process_flag) then
            if(rank == 0) then
              write(*,*) "b_mpi_process_flag reactran A: ", b_mpi_process_flag
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
        end if
      end if  

!c  start newton iteration
 
      iter_rt = 0
      not_converged = .true.

!c option look for file pest.stp, which will cause simulation to abort
      ipest = 0 !(0/1) -> 1 = activate PEST termination function

      do while (not_converged)              !newton iteration loop
          
        prt_react_tot = cputime()
        
        b_mpi_process_flag = .false.

        if(rank == 0) then      !if MPI rank 0

          if(ipest .eq. 1) then
              iunit = lun_get()
              open (iunit,file='../pest.stp',status='old',iostat=istatus)
              if(istatus .eq. 0) then
                write(ilog,'(a)')'execution halted due to pest.stp'
                close(iunit)
                open (iunit,file='pslave.fin',status='unknown') ! terminate slave
                write(iunit,'(a)') 'F'
                close(iunit)
                b_mpi_process_flag = .true.
                write(*,*) "stop signal in ../pest.stp"
              end if
              call lun_free(iunit)
          end if                  !end if MPI rank 0

        end if
       
#ifdef PETSC
        call MPI_BCAST(b_mpi_process_flag, 1, MPI_LOGICAL, 0,        &
                       Petsc_Comm_World, ierrcode)
        CHKERRQ(ierrcode)
#endif  
        
        if(b_mpi_process_flag) then
            if(rank == 0) then
              write(*,*) "b_mpi_process_flag reactran B: ", b_mpi_process_flag
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
        end if
        
        iter_rt = iter_rt + 1               !iteration counter (current)
        ittot_rt = ittot_rt + 1             !iteration counter (total)

        if(rank == 0 .and. b_enable_output .and.                       &
           .not. ((skip_time.gt.0).and.(nskip_time.lt.skip_time))) then      !if MPI rank 0
            if (idetail_rt.eq.2) then
              write(ilog,'(/a,i3,a)') 'Newton iteration ',iter_rt,':'
              write(ilog,'(a)') '---------------------'
            end if
        end if                  !end if MPI rank 0

!c  allocate memory for solver       
        if (.not. allocated(art)) then
            allocate (art(njart), stat = ierr)
            art=r0 
            call checkerr(ierr,'art',ilog)
            call memory_monitor(sizeof(art),'art',.true.)
        end if 
        
        if (i_solver_type_react == 0) then
            if (.not. allocated(afrt)) then
                allocate (afrt(njafrt), stat = ierr)
                afrt=r0
                call checkerr(ierr,'afrt',ilog)
                call memory_monitor(sizeof(afrt),'afrt',.true.)
            end if
        end if

!c  clear arrays 
        call zero_r8(art,njart,1,1)
 
        call zero_r8(brt,n*nngl,1,1)
 
        call zero_r8(urt,n*nngl,1,1)

        prt_react_jac = cputime()
  
!c  construct jacobian matrix and rhs vector
        call jacrt
        
        if((b_output_matrix.or.itimestep_output_matrix==mtime) .and.   &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(n*nngl, njart, iart, jart, art,   &
                brt, urt, .true., .true., .false., "reactran_rt_exb",  &
                ittot_rt)
            else if(itype_matrix_format == 1) then
                call export_mmformat(n*nngl, njart, iart, jart, art,   &
                brt, urt, .true., .true., .false., "reactran_rt_exb",  &
                ittot_rt)
#ifdef PETSC
                call export_mmformat_gbl(n*nn,n*nngl,njart,iart,jart,  &
                     art,brt,urt,.true.,.true.,.false.,                &
                     "reactran_rt_exb",nngl,nngbl,.true.,ittot_rt)
#endif
            end if
        end if
 
!c  incorporate boundary terms  
        call jacbrt

        !Export sparse matrix dataset and right hand side. For test only, dsu.
        if((b_output_matrix.or.itimestep_output_matrix==mtime) .and.   &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(n*nngl, njart, iart, jart, art,   &
                brt, urt, .true., .true., .false., "reactran_rt",      &
                ittot_rt)
            else if(itype_matrix_format == 1) then
                call export_mmformat(n*nngl, njart, iart, jart, art,   &
                brt, urt, .true., .true., .false., "reactran_rt",      &
                ittot_rt)
#ifdef PETSC
                call export_mmformat_gbl(n*nn,n*nngl,njart,iart,jart,  &
                     art,brt,urt,.true.,.true.,.false.,                &
                     "reactran_rt",nngl,nngbl,.true.,ittot_rt)
#endif
            end if
        end if

!#ifdef DEBUG
!        if(rank == 0) then
!          write(*,*) "force stop after jacbrt"
!        end if
!        close(idbg)
!#ifdef PETSC
!        call petsc_mpi_finalize
!#endif
!        stop
!#endif
        
!        b_mpi_process_flag = .true.        
!        if(b_mpi_process_flag) then
!            write(*,*) "b_mpi_process_flag reactran B: ", b_mpi_process_flag
!#ifdef PETSC
!            call petsc_mpi_finalize
!#endif
!            stop
!        end if

!cdsu  debug part, use external solution (written in sequential order) to test
!        if (mtime == 1 .or. mtime == 7 .or. mtime == 13) then
!                call export_mmformat_gbl(n*nn,n*nngl,njart,iart,jart, &
!                     art,brt,urt,.true.,.true.,.false.,               &
!                     "reactran_rt_check",nngl,nngbl,.true.,ittot_rt)
!        end if
!cdsu  debug part, use external solution (written in sequential order) to test, end
        
        prt_react_jac = cputime() - prt_react_jac
        
!cprovi--------------------------------------------------------------------
!cprovi Estimate condition number for the current matrix. 
!cprovi This is used for testing when newton iteration failed.
!cprovi--------------------------------------------------------------------
#ifdef CONDITION_NUMBER
         if(b_output_condition_number) then
            call cond_num_cal(n*nngl, njart, iart, jart, art,          &
                              condition_number, condition_number_info)
            
            if (rank == 0 .and. b_enable_output) then
            
            if (condition_number_info(1) .ge. 0) then
              write(*,"(2(a, 1pe15.6e3, 1x))")                         &
                    " classical cond. num. ", condition_number(1),     &
                    " skeel cond. num. ", condition_number(2)
              write(ilog,"(2(a, 1pe15.6e3, 1x))")                      &
                    " classical cond. num. ", condition_number(1),     &
                    " skeel cond. num. ", condition_number(2)
            else
              write(*,*) ' error in estimating condition number, info(1) ', &
                         condition_number_info(1)
              write(ilog,*) ' error in estimating condition number, info(1) ', &
                            condition_number_info(1)
            endif 
            
            if(i_solver_type_react == 1) then
              if(condition_number(1) > 1.0e10 .and. condition_number(2) > 1.0e10) then
                  write(*,"(a)")    " Warning: matrix is ill-conditioned."
                  write(ilog,"(a)") " Warning: matrix is ill-conditioned."
              end if
            end if
            
            end if
            
         end if
#endif         
        prt_react_solver = 0.0d0 
        !! use ws209 solver
        if (i_solver_type_react == 0) then
#ifdef PARDISO  
         if (b_solver_test_pardiso) then
    !$omp parallel                                                    &
    !$omp if (njart > numofloops_thred_global)                        &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)  
    !$omp do schedule(static)
            do i = 1, njart
              art_std(i) = art(imaprt_std(i))
            end do
    !$omp end do
    !$omp end parallel
            
            b_redo_symbfac = .true.
100         prt_react_symbfac_comp = cputime() 
            if(bsymbolicfactor_rt  .or. i_symfactor_type_react == 1) then
                call pardiso_symbolicfactorization(iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std)
                n_unknown_rt = n*nngl
                bsymbolicfactor_rt = .false.
            end if    
            prt_react_symbfac_comp = cputime() - prt_react_symbfac_comp
            
            prt_react_fac_comp = cputime() 
            call pardiso_numfactorization(iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std)
            prt_react_fac_comp = cputime() - prt_react_fac_comp

            prt_react_sub_comp = cputime() 
            call pardiso_substitution(ilog, msolvit_rt, itsolv, idetail_rt, resrt,          &
                                        restol_rt, deltol_rt, over_flow, rnorm, rmupdate,   &
                                        iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std, brt, urt_std)           
            prt_react_sub_comp = cputime() - prt_react_sub_comp
            
            if (b_redo_symbfac .and. (itsolv > n_max_iteration_react .or. rnorm > r_max_residual_react .or. over_flow)) then
                bsymbolicfactor_rt = .true.   
                b_redo_symbfac = .false.
                goto 100
            end if
            
         end if
#endif

#ifdef PETSC
        if(b_solver_test_petsc) then
            !only solver the local part, update the ghost value
            call solver_dd_snes_solve_react(ilog,idetail_rt,art,brt,    &
                    urt_std,iart,jart,nngl*n,itsolv,over_flow,rnorm,    &
                    row_idx_l2pg_rt,col_idx_l2pg_rt,.false.)
            over_flow_rt = over_flow
#ifdef DEBUG
             if(rank == 0) then
                write(*,'(a, 3(1x, i5), 1x, l1, 1x, 1pe15.6e3)')       &
                "reactran-A: rank, new_iter_rt, iteration, over_flow, rnorm ",&
                rank, iter_rt, itsolv, over_flow, rnorm 
             end if
#endif
        end if
#endif

#ifdef LIS 
        if(b_solver_test_lis) then
          !only solver the local part, update the ghost value
          call solver_lis_solve_react(ilog,idetail_rt,art,brt,           &
                      urt_std,iart,jart,nngl*n,nn*n,n,itsolv,over_flow,  &
                      rnorm,row_idx_l2pg_rt,col_idx_l2pg_rt,.false.)
          over_flow_rt = over_flow            
#ifdef DEBUG
          if(rank == 0 .and. b_enable_output) then
            write(*,'(a, 3(1x, i5), 1x, l1, 1x, 1pe15.6e3)')             &
                  "reactran-A2: rank, new_iter_rt, iteration, over_flow, rnorm ",&
                  rank, iter_rt, itsolv, over_flow, rnorm  

          end if
#endif
        end if
#endif

!c  Scale [art] and {brt} to produce unit diagonal
!c  Generate re-ordered preconditioner [af]
  
        ilist = 1
        prt_react_fac = cputime()

        call incompletefactorization (n*nngl,njart,njafrt,brt,art,afrt,   &
                                      rwork_max,iart,jart,iafrt,iafdrt,   &
                                      jafrt,iwork_max(ilist),lorderrt,    &
                                      invordrt,numofthreads_ws209)

        prt_react_fac = cputime() - prt_react_fac
                                                                      
!c  solve [art] * {urt} = {brt}   
        prt_react_sub = cputime() 
        call ws209(ilog,n*nngl,msolvit_rt,itsolv,idetail_rt,iart,jart, &
                   iafrt,iafdrt,jafrt,lorderrt,art,afrt,urt,brt,       &
                   resrt,rwork_max,restol_rt,deltol_rt,njart,njafrt,   &
                   over_flow,rnorm,rmupdate,numofthreads_ws209,        &
                   rank,b_enable_output)

        prt_react_sub = cputime() - prt_react_sub
#ifdef PARDISO  
        if (b_solver_test_pardiso) then        
          call solver_results_check_output(ittot_rt, nngl*n, urt, urt_std, "reactran_rt") 
        end if
#endif    

#ifdef PETSC 
        if (b_solver_test_petsc) then        
            call solver_results_check_output(ittot_rt, nngl*n, urt, urt_std, "reactran_rt_petsc") 
        end if
#endif

#ifdef LIS 
        if (b_solver_test_lis) then        
            call solver_results_check_output(ittot_rt, nngl*n, urt, urt_std, "reactran_rt_lis") 
        end if
#endif

        prt_react_solver = prt_react_symbfac + prt_react_fac + prt_react_sub

        !! use pardiso solver
        else if (i_solver_type_react == 1) then
#ifdef PARDISO
    !$omp parallel                                                    &
    !$omp if (njart > numofloops_thred_global)                        &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (i)  
    !$omp do schedule(static)
            do i = 1, njart
              art_std(i) = art(imaprt_std(i))
            end do
    !$omp end do
    !$omp end parallel
            
            b_redo_symbfac = .true.
200         prt_react_symbfac = cputime() 
            if(bsymbolicfactor_rt  .or. i_symfactor_type_react == 1) then
                !write(idbg, *) "pardiso symbolic factorization for reactive transport line 474"
                call pardiso_symbolicfactorization(iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std)
                n_unknown_rt = n*nngl
                bsymbolicfactor_rt = .false.
            end if    
            prt_react_symbfac = cputime() - prt_react_symbfac
            
            !write(idbg, *) "pardiso numerical factorization for reactive transport line 479"
            prt_react_fac = cputime()
            call pardiso_numfactorization(iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std)
            prt_react_fac = cputime() - prt_react_fac
            
            !write(idbg, *) "pardiso substitution for reactive transport line 482"
            prt_react_sub = cputime()  
            call pardiso_substitution(ilog, msolvit_rt, itsolv, idetail_rt, resrt,          &
                                        restol_rt, deltol_rt, over_flow, rnorm, rmupdate,   &
                                        iparm_rt, ptrt, n*nngl, njart, iart, jart_std, art_std, brt, urt) 
            prt_react_sub = cputime() - prt_react_sub
            
            if (b_redo_symbfac .and. (itsolv > n_max_iteration_react .or. rnorm > r_max_residual_react .or. over_flow)) then
                bsymbolicfactor_rt = .true.    
                b_redo_symbfac = .false.
                goto 200
            end if
#endif
            prt_react_solver = prt_react_symbfac + prt_react_fac + prt_react_sub         
        !! use PETSc solver
        else if (i_solver_type_react == 2) then            
#ifdef PETSC
            prt_react_solver = cputime()
            
            !only solver the local part, update the ghost value
            call solver_dd_snes_solve_react(ilog,idetail_rt,art,brt,    &
                    urt,iart,jart,nngl*n,itsolv,over_flow,rnorm,        &
                    row_idx_l2pg_rt,col_idx_l2pg_rt,.false.)
            over_flow_rt = over_flow
            
            prt_react_solver = cputime() - prt_react_solver
#ifdef DEBUG
             if(rank == 0 .and. b_enable_output) then

                write(*,'(a, 3(1x, i5), 1x, l1, 1x, 1pe15.6e3)')       &
                "reactran-B: rank, new_iter_rt, iteration, over_flow, rnorm ",&
                rank, iter_rt, itsolv, over_flow, rnorm  

             end if
#endif
#endif        
        !! use LIS solver
        else if (i_solver_type_react == 3) then            
#ifdef LIS
          prt_react_solver = cputime()          
          !only solver the local part, update the ghost value
          call solver_lis_solve_react(ilog,idetail_rt,art,brt,           &
                      urt,iart,jart,nngl*n,nn*n,n,itsolv,over_flow,rnorm,&
                      row_idx_l2pg_rt,col_idx_l2pg_rt,.false.)
          over_flow_rt = over_flow            
          prt_react_solver = cputime() - prt_react_solver
#ifdef DEBUG
          if(rank == 0 .and. b_enable_output) then
            write(*,'(a, 3(1x, i5), 1x, l1, 1x, 1pe15.6e3)')             &
                  "reactran-B2: rank, new_iter_rt, iteration, over_flow, rnorm ",&
                  rank, iter_rt, itsolv, over_flow, rnorm  

          end if
#endif
#endif        

        end if
        
        !Check residual of the solver
        !b_doublecheck_residual = .true.
        !if(rank == 0) then
        !    if(b_doublecheck_residual) then
        !        rnorm_check = 0.0d0            
        !        call mkl_dcsrgemv('N', n*nngl, art, iart, jart, urt, resrt_check) 
        !        resrt_check = resrt_check-brt
        !        rnorm_check = sqrt(sum(resrt_check**2))
        !    end if
        !end if
  
        
        !Export sparse matrix dataset and right hand side. For test only, dsu.
        if((b_output_matrix.or.itimestep_output_matrix == mtime) .and. &
            b_enable_output) then
            if(itype_matrix_format == 0) then
                call export_arrays1d(n*nngl, njart, iart, jart, art,   &
                brt, urt, .false., .false., .true., "reactran_rt",     &
                ittot_rt)
            else if(itype_matrix_format == 1) then
                call export_mmformat(n*nngl, njart, iart, jart, art,   &
                brt, urt, .false., .false., .true., "reactran_rt",     &
                ittot_rt)
#ifdef PETSC
                call export_mmformat_gbl(n*nn,n*nngl,njart,iart,jart,  &
                     art,brt,urt,.false.,.false.,.true.,               &
                     "reactran_rt",nngl,nngbl,.true.,ittot_rt)
#endif
            end if
        end if
        
            
!cdsu  debug part, use external solution (written in sequential order) to test
!        if (mtime >= 1 .and. mtime <= 5) then
!          call export_mmformat_gbl(n*nn,n*nngl,njart,iart,jart, &
!               art,brt,urt,.true.,.true.,.false.,              &
!               "reactran_rt",nngl,nngbl,.true.,ittot_rt)
!
!          if (rank == 0) then
!            write(*,*) "-->read concentration change from external file"
!          end if
!
!          ifile = lun_get()
!          write(strfile, *) ittot_rt
!          strfile = "x_reactran_rt_"//trim(adjustl(strfile))//"_natgbl.txt"
!          open(ifile,file=trim(strfile),status='old',form='formatted')
!          urt = 0.0d0
!          nskip = 0
!          read(ifile,*) strdummy
!          do ivol = 1, nngl
!#ifdef PETSC
!            do iskip = 1, node_idx_lg2g(ivol) - nskip -1
!              do i =1, n
!                read(ifile,*) idummy
!              end do
!            end do
!            nskip = node_idx_lg2g(ivol)
!#endif
!            do i = 1, n
!              read(ifile,*) idummy,urt((ivol-1)*n+i)
!            end do
!          end do
!          call lun_free(ifile)
!        end if
!cdsu  debug part, use external solution (written in sequential order) to test, end

       
!c  deallocate memory for solver
       
        if (b_dynamic_memory) then
            call memory_monitor(-sizeof(art),'art',.true.)
            deallocate (art, stat = ierr)
            call checkerr(ierr,'art',ilog)
            
            if (i_solver_type_react == 0) then
                call memory_monitor(-sizeof(afrt),'afrt',.true.)
                deallocate (afrt, stat = ierr)
                call checkerr(ierr,'afrt',ilog)
            end if
        end if


!c  total number of solver iterations

        itsolvtot_rt = itsolvtot_rt + itsolv
 
!c  update solution after new iteration, check for global convergence
!c  and reduce time step if necessary
!c  Parallelized , OpenMP, DSU 

        call updatert

#ifdef DEBUG
        if(rank == 0) then

        if(info_debug > 10) then
            write(*,'(a, 2(1x, i4) ,2(1x, l1))')                       &
            "reactran: rank, iter_rt, not_converged, reduce_timestep", &
            rank, iter_rt, not_converged, reduce_timestep
        end if

        end if
#endif
        
        prt_react_tot = cputime() - prt_react_tot
        
!c  write runtime to file

        if(rank == 0 .and. b_prtfile) then      !if MPI rank 0
          write(iprt_react,"(i8,1x,2(i3,1x),i8,1x,8(1pe15.6e3,2x))")   &
                mtime, iter_sia, iter_rt,ittot_rt, prt_react_jac,      &
                prt_react_symbfac, prt_react_fac, prt_react_sub,       &
                prt_react_solver,                                      &
                (prt_react_tot - prt_react_jac - prt_react_solver),    &
                prt_react_tot

          write(iprt_react_jac,"(i8,1x,2(i3,1x),i8,1x,6(1pe15.6e3,2x))") &
                mtime, iter_sia, iter_rt, ittot_rt, prt_react_jac_part

          if(b_solver_test_pardiso) then
            write(iprt_react_comp,"(i8,1x,2(i3,1x),i8,1x,5(1pe15.6e3,2x))")&
                  mtime, iter_sia, iter_rt, ittot_rt, prt_react_fac,     &
                  prt_react_sub, prt_react_symbfac_comp,                 &
                  prt_react_fac_comp, prt_react_sub_comp
          end if
        end if                  !end if MPI rank 0 


!c  reset primary unknowns for reduced time step
!c  need ionic strength to compute reasonable activity coefficients
!c  during restart
        if (reduce_timestep) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol, ic, im)  
    !$omp do schedule(static)
#endif
          do ivol=1,nngl
            sionnew(ivol) = sionold(ivol)
!c_bubbles reset saturations to old time level
            if (gas_bubbles)then
              sanew(ivol) = saold(ivol)
              if(zero_storage) then
                sgnew(ivol)=sgold(ivol)
              else
                sgnew(ivol) = r1-saold(ivol)
              end if
              uvsnew(ivol) = uvsold(ivol)
              hhead(ivol) = uvsold(ivol)+zg(ivol)
              if (trap_bubbles) then
                sa_min(ivol) = sa_min_old(ivol)
                big_bubble(ivol) = big_bub_old(ivol)
                sgt(ivol) = sgt_old(ivol)
              end if
!c_bubbles reset flow variables also
            end if 
            do ic=1,n
              cnew(ic,ivol) = c(ic,ivol)
            end do
            if (nm.gt.r0)then
              do im=1,nm
                phi(im,ivol)=phiold(im,ivol)
                cmnew(im,ivol)=cmold(im,ivol)
              end do
            end if
          end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!c  return and start over with reduced time step

          return
       
        end if            ! reduce_timestep
        
      end do            ! newton loop
      
!cdbg
      b_mpi_process_flag = .false.

#ifdef DEBUG
      if (info_debug.gt.0) then
        write(idbg,'(/a,i3)')  'Reactran Newton iterations ',         &
     &                          iter_rt
                                                                       
        write(idbg,'(/a,3a/)') 'ivol   ',                             &
     &                         'conc. update        ',                &
     &                         'c old               ',                &
     &                         'c new               '

        do ivol = 1,nngl
          uuu = cnew(1,ivol) - c(1,ivol)
          write(idbg,'(I3,3es20.10)') ivol,uuu,c(1,ivol),cnew(1,ivol)
        end do
      end if
#endif
      
      if (info_debug.gt.1) then
        b_mpi_process_flag = .true.
        
        if(rank == 0) then
          write(*,*) "stop signal in info_debug.gt.1"
        end if
      end if 

      if (info_debug.gt.1) then

        if(b_mpi_process_flag) then
            if(rank == 0) then
              write(*,*) "b_mpi_process_flag reactran C: ", b_mpi_process_flag
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
        end if
      end if  

!cdsu update gas bubble connected to the bubble source
      !if (mip_mt_enable .and. mtime > 1) then
      !  call mip_bdcluster_update  
      !end if      
      
!cprovi---------------------------------------------------------------------
!cprovi This is necessary because we need to update the last Newton
!cprovi Raphson solution 
!cprovi---------------------------------------------------------------------         
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol,tid)                                              
    !$omp do schedule(static)
#endif
      do ivol=1,nngl

#ifdef OPENMP
        tid = omp_get_thread_num() + 1
#else
        tid = 1
#endif
!c  exclude first type boundary control volumes

        if (btypert(ivol).ne.'first') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

          if (temp_corr.or.heat_transport) then
            call tcorr(tkel(ivol),ivol,tid)           
          end if
  
          call updtsvap(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),         &
                        gamma(nc+1,ivol),sionnew(ivol),tid)
          if (hmulti_diff) then
                call updtsvap(c(1,ivol),cxold(1,ivol),gammaold(1,ivol),&        !MX June 2014
                              gammaold(nc+1,ivol),sionold(ivol),tid)
          end if

        end if

!c  recompute total concentrations vectors
      
        if (redox_equil_rt.and.nr.gt.0) then
          call totconc(cnew(1,ivol),cx(1,ivol),totcnew(1,ivol))

          if (ng.gt.0) then
              call totconcg(gnew(1,ivol),totgnew(1,ivol))
          end if  
        end if

      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif   


!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
!cprovi--------------------------------------------------------------------
!c check for Picard iteration convergence
!c variable density simulations only

      if (density_dependence) then 


!c update TDS and densities
!cprovi Here the densities are computed 
!cprovi----------------------------------------------
!cprovi----------------------------------------------
!cprovi----------------------------------------------

!cprovi-----------------------------------------------
!cprovi Store densities density = f (cit+1,tempit+1)
!cprovi Parallelized , OpenMP, DSU
!cprovi-----------------------------------------------
        if (.not. tran_steady_drho_0) then
          if (.not.flow_verification) then
            if (heat_transport) then
               call ddtds_energybal(.false.)
            else
               call ddtds
            end if
          end if
        end if
!cprovi----------------------------------------------
!cprovi----------------------------------------------
!cprovi----------------------------------------------        
!cprovi Here the densities are computed 

!c evaluate convergence using fluid densities

        sia_max = r0
        nexvol = 0
        maxvol = 0 
#ifdef OPENMP
        maxval_omp = r0
#endif        
        
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (tid, ivol, sia_abs)                                &
    !$omp reduction(+:nexvol)
    !$omp do schedule(static)
#endif
        do ivol = 1,nngl    
!#ifdef PETSC 
!          if(node_idx_lg2l(ivol) < 0) then
!              cycle
!          end if
!#endif
            
#ifdef OPENMP    
          tid = omp_get_thread_num()+1
#else
          tid = 1
#endif            

          !sia_abs  = dabs(density(ivol) - densold1(ivol))
          sia_abs  = dabs(density(ivol) - densold(ivol))
          
#ifdef OPENMP
          if (sia_abs>maxval_omp(tid)) then
            maxval_omp(tid) = sia_abs             !max solution update
            maxvol_omp(tid) = ivol                 !location of max update
          endif
#else
          if (sia_abs>sia_max) then
            sia_max = sia_abs                      !max solution update
            maxvol = ivol                          !location of max update
          endif
#endif          
          
          if (sia_abs>tol_sia) then                !number of volumes
#ifdef PETSC
            if(node_idx_lg2l(ivol) > 0) then
              nexvol = nexvol + 1
            end if
#else
            nexvol = nexvol + 1                    !exceeding convergence
#endif
          end if                                   !tolerance

        end do        !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!c  store iteration results into matrix for printing at the end of the timestep
#ifdef OPENMP
       i1 = maxloc(maxval_omp,1)
       sia_max = maxval_omp(i1)
       maxvol = maxvol_omp(i1)
#endif

#ifdef PETSC
      mpireduce_in(1) = sia_max      !returns the reduced value
      mpireduce_in(2) = rank        !returns the rank of process that owns it
      call MPI_Allreduce(mpireduce_in, mpireduce_out, 1,               &
                         MPI_2DOUBLE_PRECISION,MPI_MAXLOC,             &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      sia_max = mpireduce_out(1)
      mpireduce_irank = int(mpireduce_out(2))
      
      call MPI_BCAST(maxvol, 1, MPI_INTEGER4, mpireduce_irank,         &
                     Petsc_Comm_World, ierrcode) 
      CHKERRQ(ierrcode)
      call MPI_Allreduce(nexvol, nexvol_gbl,1,MPI_INTEGER4,MPI_SUM,    &
                         Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      nexvol = nexvol_gbl
#endif

        sia_dens(iter_sia) = sia_max
        sia_maxvol(iter_sia) = maxvol
        sia_nexvol(iter_sia) = nexvol

!c  coupling convergence check
        if (sia_max<tol_sia) then
          not_converged_sia = .false.
        else
          !c in some circumstances, sia_max may be large at the first timestep 
          !c when the initial condition is not good.
          !c The variable allow_sia_max_t1 (true) will consider this as converged.
          if (mtime == 1 .and. allow_sia_max_t1) then
            not_converged_sia = .false.
          else
            return
          end if
        end if

      end if !(density_dependence)

!c  update concentrations of minerals, mineral volumes and
!c  reactivity term 
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_global)                         &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ivol,tid,inpl,i,i1,i2,i3,ii,im,ireac,istart,istop, &
    !$omp istart2,istop2,ic,ic2,icur,icount,next,gammatemp)
#endif

#ifdef OPENMP
    !$omp do schedule(static)
#endif
      do ivol=1,nngl

#ifdef OPENMP
        tid = omp_get_thread_num() + 1
#else
        tid = 1
#endif
          
!c  exclude first type boundary control volumes

        if (btypert(ivol).ne.'first') then

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

          if (temp_corr.or.heat_transport) then
            call tcorr(tkel(ivol),ivol,tid)           
          end if
   
          call updtsvap(cnew(1,ivol),cx(1,ivol),gamma(1,ivol),         & 
                        gamma(nc+1,ivol),sionnew(ivol),tid)
          if (hmulti_diff) then
             call updtsvap(c(1,ivol),cxold(1,ivol),gammaold(1,ivol),   &        !MX June 2014
                         gammaold(nc+1,ivol),sionold(ivol),tid)
          end if

!c         THH edit: pass ivol # to updtsvmp to use in updating surface areas
!c         needed for initial volume fraction in phi-init matrix
          if (.not.gas_bubbles)then
            if (nm.gt.0) then

              !c calculate saturation index (without log10) used in 'twothird-mix' update type
              do im = 1,nm
                if (update_type(im).eq.'twothird-mix') then
                  if (.not.far_from_equil(im)) then
!c_isotope
                    if (isofrac(im)) then
                      satm(im,tid) = eqm(im,tid)**(-r1)
                      ireac = iamd(im)
                      istart = iam(im)
                      istop = iam(im+1)-1

                      do i1 = istart, istop ! loop through components in mineral
                        icount = 0
                        ic = jam(i1)
                        next = 0
                        do i = 1, nifrm(im)  ! loop through isotope sets
                          istart2 = next + iamdiso(im)
                          icur = iamdiso2(im) + i - 1
                          istop2 = iamdiso(im) + jamdiso2(icur) - 1
                          next = jamdiso2(icur)
                          gammatemp = r0
                          !loop through isotope compents in set
                          do i2 = istart2, istop2
                            ii = jamdiso(i2)
                            !check to see if component is an isotope
                            if (ii.eq.ic) then
                              icount = icount + 1
                              !if so sum the isotope activities
                              do i3 = istart2, istop2
                                  ic2 = jamdiso(i3)
                                  gammatemp = gammatemp+gamma(ic2,ivol)*cnew(ic2,ivol)
                              end do
                              satm(im,tid) = satm(im,tid) *gammatemp**xnum(i1)
                            end if
                          end do
                        end do
                        !if not calculate the saturaton index the normal way
                        if (icount.eq.0) then
                          satm(im,tid) = satm(im,tid)*(gamma(ic,ivol)*cnew(ic,ivol))**xnum(i1)
                        end if
                      end do   !i1
                    else
                      satm(im,tid) = satindex(cnew(1,ivol),eqm(im,tid),&
                                        gamma(1,ivol),xnum,iam,jam,im)
                    end if
                  end if
                end if
              end do

              call updtsvmp(cmnew(1,ivol),cmold(1,ivol),phi(1,ivol),   &
                            area(1,ivol),ratemdp(1,ivol),satm(1,tid),  &
                            delt,ivol,tid)
              
!c         added by Anna H Jan 24, 2014 to remove water during hydrate carb pptn
!c         included artinite Anna H Feb 11 2014
              if (water_removal) then
                do im = 1,nm
                  qh2o(ivol) = rwaterremovalcoeff(im)*ratemdp(im,ivol)* &
                               delt*rwater_mole2liter
                end do
              end if
             
            end if
          end if
        end if

      end do
#ifdef OPENMP
    !$omp end do
#endif 

#ifdef OPENMP
    !$omp barrier
#endif

!c update napl saturations

      if (napl_permeability) then
#ifdef OPENMP
    !$omp do schedule(static)
#endif        
        do ivol = 1,nngl             !loop over control volumes
          snnew(ivol) = r0
          do inpl = 1, nnpl
            i1 = ianpl(inpl)
            snnew(ivol) = snnew(ivol) + phi(i1,ivol)/pornew(ivol)
          end do
          if (snnew(ivol) .lt. napl_tol) then
            snnew(ivol) = r0
          end if
        end do
#ifdef OPENMP
    !$omp end do
#endif   

#ifdef OPENMP
    !$omp barrier
#endif
      end if   

!c  recompute total concentrations vectors
!c  c_bubbles 
      if ((redox_equil_rt.and.nr.gt.0) .or. gas_bubbles .or.           &
          mip_mt_enable) then
#ifdef OPENMP
    !$omp do schedule(static)
#endif 
        do ivol = 1,nngl
#ifdef OPENMP
          tid = omp_get_thread_num() + 1
#else
          tid = 1
#endif

          call totconc(cnew(1,ivol),cx(1,ivol),totcnew(1,ivol))

          if (hmulti_diff) then
            call totconc(c(1,ivol),cxold(1,ivol),totcold(1,ivol))
          end if
          if (ng.gt.0) then
            call totconcg(gnew(1,ivol),totgnew(1,ivol))
          end if
        end do
#ifdef OPENMP
    !$omp end do
#endif

#ifdef OPENMP
    !$omp barrier
#endif
      end if 
#ifdef OPENMP
    !$omp end parallel
#endif

      if(gas_bubbles .or. mip_mt_enable) then
        return
      end if

!c  mass balance computation for reactive transport
!c  Parallelized , OpenMP, DSU

      if (mass_balance_rt .and. ngb_step == ngb_step_bk) then
        call mbalrt
      end if

!c  smr: decide upstream weighting for gases in the next time step

      if (spatial_weighting.eq.'upstream' .and. ng .gt. 0) then
        call giups
      endif
      
      if (flux_out .and. ngb_step == ngb_step_bk) then
        call mbal_mcd
      end if
      
!c  smr: calculate the production/consumption rate of water

      if (chemical_water) then
        call rateh2o
      endif


!c  estimate time increment size for next time step
!c  Parallelized , OpenMP, DSU

      call tsteprt
  
      return

!c  update source chemistry at specified target read times
!c  this part is never called
!      if (transient_source) then
!        if (itsrc.le.ntsrc.and.abs(tsrc(itsrc)-time).le.tinytime_global) then
!
!         if(rank == 0 .and. b_enable_output) then   
!!c  report to log file
!
!          write(ilog,'(/a,1pe15.6e3,1x,a)')                           &
!     &         'update source chemistry - reactive transport, T = ',  &
!     &          time_io, time_unit                                     
!          write(ilog,'(72a/)')('-',i=1,72)
!                                                                      
!!c  report to screen
!                                                                       
!          write(*,'(/1x,a,1pe15.6e3,1x,a)')                           &
!     &         'update source chemistry - reactive transport, T = ',  &
!     &          time_io, time_unit
!          write(*,'(1x,72a/)')('-',i=1,72)
!          
!          end if
!
!!c  update boundary conditions
!
!          call tranbcrt(tid)
!
!!c  set index for next target read time
!
!          itsrc = itsrc+1
!
!!c  set target read time to time larger than final solution time after
!!c  last update of boundary conditions
!
!          if (itsrc.gt.ntsrc) then
!            tsrc(itsrc) = tfinal+tinytime_global
!          end if
!
!!c  redefine activity update technique for reactive transport
!
!          if (update_activity_rt.eq.'no_update') then
!           update_activity(tid) = 'no_update'
!          elseif (update_activity_rt.eq.'time_lagged') then
!            update_activity(tid) = 'time_lagged'
!          elseif (update_activity_rt.eq.'double_update') then
!            update_activity(tid) = 'double_update'
!          endif
!
!        end if
!      end if

      return
      end
