!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/icesheet/m_ice_sheet.F90 $
!---------------------------------------------------------------------
!********************************************************************!

module m_ice_sheet

implicit none

!-------------------------------------------------------------------------
!
!   $Description: 
!
!   $Use:  
!
!   $Author: Sergio Andrï¿½s Bea Jofr?
!
!   $License: UBC
!
!-------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------

!%------------------------------------------------------------------------
!% Public services 
!%------------------------------------------------------------------------
public:: &
 create_  &        ! Create ice sheet object 
,destroy_ &        ! Destroy ice sheet object
,set_ &
,set_components_ &
,compute_pice_ &
,compute_pw_ &
,compute_dpicedt_ &
,get_new_bc_ &
,get_components_ &
,read_ice_sheet_block_ &
,modify_for_permafrost_ &
,write_
!%------------------------------------------------------------------------
!% Private services 
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!% Type variable definition 
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
type, public::t_ice_sheet
 
!private                              :: 
 
character(len=100)                   :: name          ! Name of the species 
  
real*8                               :: a             ! Ice sheet constant 

real*8                               :: b             ! Ice sheet constant 

real*8                               :: logkxx        

real*8                               :: logkyy        

real*8                               :: logkzz 

real*8                               :: temp         

real*8                               :: lsource 

real*8                               :: zsource 

real*8                               :: densice

real*8                               :: densfresh

integer                              :: nstages 

integer                              :: ncomp 

logical                              :: istotbc

logical                              :: isconstant

integer                              :: linearType

logical, pointer, dimension(:)       :: isbc

real*8, pointer, dimension(:,:)      :: timestages

real*8, pointer, dimension(:,:)      :: hstages

real*8, pointer, dimension(:,:)      :: lstages

real*8, pointer, dimension(:,:)      :: thickpermstages

real*8, pointer, dimension(:,:)      :: l1permstages

real*8, pointer, dimension(:,:)      :: l2permstages

real*8, pointer, dimension(:)        :: hslope

real*8, pointer, dimension(:)        :: lslope

real*8, pointer, dimension(:,:)      :: facpw              ! Factor in order to scale the hydraulic head

real*8, pointer, dimension(:,:)      :: facpice            ! Factor in order to scale the ice sheet pressure

real*8, pointer, dimension(:,:)      :: facpp              ! Factor in order to scale the boundary pore pressure

real*8, pointer, dimension(:)        :: l1permslope

real*8, pointer, dimension(:)        :: l2permslope

real*8, pointer, dimension(:)        :: thickpermslope

real*8, pointer, dimension(:)        :: totbc              ! Water composition bc [ncomp]

character(len=12), pointer, dimension(:)   :: typetotbc

end type t_ice_sheet
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface create_
 
module procedure create_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface destroy_
 
module procedure destroy_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface set_
 
module procedure set_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface set_components_
 
module procedure set_totbc_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface compute_pice_
 
module procedure compute_pice_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface compute_pw_
 
module procedure compute_pw_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface compute_dpicedt_
 
module procedure compute_dpicedt_ice_sheet
 
end interface

!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface read_ice_sheet_block_
 
module procedure read_ice_sheet_block_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface get_new_bc_
 
module procedure get_new_bc_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface get_components_
 
module procedure get_components_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface modify_for_permafrost_
 
module procedure modify_for_permafrost_k_ice_sheet 
module procedure modify_for_permafrost_temp_ice_sheet  

end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface write_
 
module procedure write_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface give_stage_
 
module procedure give_stage_ice_sheet
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
interface check_pointer_ice_sheet_
 
module procedure check_pointer_vr
module procedure check_pointer_ar 
module procedure check_pointer_vi 
module procedure check_pointer_vlogical 
module procedure check_pointer_vch
 
end interface
!%------------------------------------------------------------------------
!%------------------------------------------------------------------------
contains
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine create_ice_sheet &
  (this)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Create  
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(inout) :: this ! Type 
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
real*8, parameter             :: &
 r0=0.0d0, &
 r1000=1.0d3, &
 r1=1.0d0  
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
this%name=' '
this%a=r0
this%b=r0
this%densice=r1000
this%densfresh=r1000
this%lsource=r0
this%zsource=r0
this%nstages=0
this%temp=r0
this%logkxx=r0
this%logkyy=r0
this%logkzz=r0
this%isconstant=.false. 
this%istotbc=.false. 
this%ncomp=0
this%linearType=0 
!%------------------------------------------------------------
!% Nullify pointers 
!%------------------------------------------------------------
this%thickpermstages => null ()
this%l1permstages => null ()
this%l2permstages => null () 
this%l1permslope => null ()
this%l2permslope => null ()
this%thickpermslope => null ()
this%timestages => null ()
this%lstages => null ()
this%hstages => null ()
this%lslope => null ()
this%hslope => null ()
this%facpw => null ()
this%facpice => null ()
this%facpp => null ()
this%isbc => null ()
this%totbc => null ()
this%typetotbc => null ()
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine set_totbc_ice_sheet &
  (this, &
   totbc, &
   typetotbc, &
   ncomp, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(inout) :: this                     

integer, intent(in)              :: ncomp

real*8, intent(in)               :: totbc(ncomp)

character(len=*), intent(in)     :: typetotbc(ncomp)

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i
real*8, parameter             :: &
 r0=0.0d0  
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
if (ncomp<=0) return
if(this%istotbc) then
     if (ncomp/=this%ncomp) then
        this%ncomp=ncomp
        call check_pointer_ice_sheet_ (this%totbc,1,.false.)
        call check_pointer_ice_sheet_ (this%typetotbc,1,.false.)
        call check_pointer_ice_sheet_ (this%totbc,ncomp,.true.)
        call check_pointer_ice_sheet_ (this%typetotbc,ncomp,.true.)
      end if
else 
     this%ncomp=ncomp
     call check_pointer_ice_sheet_ (this%totbc,ncomp,.true.)
     call check_pointer_ice_sheet_ (this%typetotbc,ncomp,.true.)
end if

this%totbc=totbc
this%typetotbc=typetotbc

return
end subroutine  
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine set_ice_sheet &
  (this, &
   name, &
   lsource, &
   zsource, &
   a, &
   b, &
   logkxx, &
   logkyy, &
   logkzz, &
   temp, &
   densice, &
   densfresh, &
   nstages, &
   ncomp, &
   totbc, &
   typetotbc, &
   isbc, &
   istotbc, &
   linearType,&
   timestages, &
   hstages, &
   lstages, &
   facpw, &
   facpice, &
   facpp, &
   l1permstages, &
   l2permstages, &
   thickpermstages, &
   isconstant, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(inout) :: this                     ! Type 

character(len=*), intent(in)     :: name

integer, intent(in)              :: nstages

integer, intent(in)              :: ncomp

real*8, intent(in)               :: a

real*8, intent(in)               :: b

real*8, intent(in)               :: logkxx

real*8, intent(in)               :: logkyy

real*8, intent(in)               :: logkzz

real*8, intent(in)               :: temp

real*8, intent(in)               :: lsource

real*8, intent(in)               :: zsource

real*8, intent(in)               :: densice

real*8, intent(in)               :: densfresh

real*8, intent(in)               :: timestages(2,nstages)

real*8, intent(in)               :: hstages(2,nstages)

real*8, intent(in)               :: lstages(2,nstages)

real*8, intent(in)               :: facpw(2,nstages)

real*8, intent(in)               :: facpice(2,nstages)

real*8, intent(in)               :: facpp(2,nstages)

real*8, intent(in)               :: l1permstages(2,nstages)

real*8, intent(in)               :: l2permstages(2,nstages)

real*8, intent(in)               :: thickpermstages(2,nstages)

real*8, intent(in)               :: totbc(ncomp)

character(len=*), intent(in)     :: typetotbc(ncomp)

logical, intent(in)              :: isconstant

logical, intent(in)              :: isbc(nstages)

logical, intent(in)              :: istotbc

integer, intent(in)              :: linearType

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i
real*8, parameter             :: &
 r0=0.0d0  
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
this%name=name
this%a=a
this%b=b
this%lsource=lsource
this%zsource=zsource
this%densice=densice
this%densfresh=densfresh
this%nstages=nstages
this%logkxx=logkxx
this%logkyy=logkyy
this%logkzz=logkzz
this%temp=temp 
this%isconstant=isconstant
this%linearType=linearType 
this%ncomp=ncomp
!%------------------------------------------------------------
call check_pointer_ice_sheet_ (this%timestages,2,nstages,.true.)
this%timestages = timestages
call check_pointer_ice_sheet_ (this%hstages,2,nstages,.true.)
this%hstages = hstages
call check_pointer_ice_sheet_ (this%lstages,2,nstages,.true.)
this%lstages = lstages
call check_pointer_ice_sheet_ (this%l1permstages,2,nstages,.true.)
this%l1permstages = l1permstages
call check_pointer_ice_sheet_ (this%l2permstages,2,nstages,.true.)
this%l2permstages = l2permstages
call check_pointer_ice_sheet_ (this%thickpermstages,2,nstages,.true.)
this%thickpermstages = thickpermstages
call check_pointer_ice_sheet_ (this%facpw,2,nstages,.true.)
this%facpw = facpw
call check_pointer_ice_sheet_ (this%facpice,2,nstages,.true.)
this%facpice = facpice
call check_pointer_ice_sheet_ (this%facpp,2,nstages,.true.)
this%facpp = facpp
call check_pointer_ice_sheet_ (this%hslope,nstages,.true.)
call check_pointer_ice_sheet_ (this%lslope,nstages,.true.)
call check_pointer_ice_sheet_ (this%l1permslope,nstages,.true.)
call check_pointer_ice_sheet_ (this%l2permslope,nstages,.true.)
call check_pointer_ice_sheet_ (this%thickpermslope,nstages,.true.)
call check_pointer_ice_sheet_ (this%isbc,nstages,.true.)
this%isbc = isbc
call check_pointer_ice_sheet_ (this%totbc,ncomp,.true.)
this%totbc=totbc
call check_pointer_ice_sheet_ (this%typetotbc,ncomp,.true.)
!c to be further checked
!c The following line this%typetotbc=typetotbc may cause some access violation on old Windows platform  
!c though the variables are associated/allocated.
this%typetotbc=typetotbc
this%istotbc=istotbc

!%------------------------------------------------------------
!% Compute slopes 
!%------------------------------------------------------------
do i=1,this%nstages

 this%hslope(i)=this%hstages(2,i)-this%hstages(1,i)
 this%hslope(i)=this%hslope(i)/(this%timestages(2,i)-this%timestages(1,i))
 
 this%lslope(i)=this%lstages(2,i)-this%lstages(1,i)
 this%lslope(i)=this%lslope(i)/(this%timestages(2,i)-this%timestages(1,i))
 
 this%l1permslope(i)=this%l1permstages(2,i)-this%l1permstages(1,i)
 this%l1permslope(i)=this%l1permslope(i)/(this%timestages(2,i)-this%timestages(1,i))
 
 this%l2permslope(i)=this%l2permstages(2,i)-this%l2permstages(1,i)
 this%l2permslope(i)=this%l2permslope(i)/(this%timestages(2,i)-this%timestages(1,i))
 
 this%thickpermslope(i)=this%thickpermstages(2,i)-this%thickpermstages(1,i)
 this%thickpermslope(i)=this%thickpermslope(i)/(this%timestages(2,i)-this%timestages(1,i))

end do
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine compute_pice_ice_sheet &
  (this, &
   pice, &
   time, &
   l, &
   typedata, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)    :: this                     ! Type 

character(len=*), intent(in)     :: typedata

real*8, intent(in)               :: l

real*8, intent(in)               :: time

real*8, intent(out)              :: pice

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 istage
real*8                        :: &
 htime, &
 ltime, &
 time1, &
 time2, &
 l1, &
 facpice
real*8, parameter             :: &
 r0=0.0d0, &
 r1=1.0d0, &
 g=9.81d0
character(len=100), parameter :: &
 pressure='pressure' 
real*8, parameter             :: &
 small=1.0d-10 
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
!%  
!%------------------------------------------------------------
istage=0
pice=r0
do i=1,this%nstages

 if (time>=this%timestages(1,i).and.time<= this%timestages(2,i)) then
   istage=i
   exit
 end if

end do
!%------------------------------------------------------------
if (istage==0) return
!%------------------------------------------------------------
time1=time-this%timestages(1,istage)
time2=this%timestages(2,istage)-this%timestages(1,istage)
htime=this%hslope(istage)*time1 + this%hstages(1,istage)
ltime=this%lslope(istage)*time1 + this%lstages(1,istage)
if (this%linearType == 1) then
  facpice=this%facpice(1,istage) + time1/time2*                        &
          (this%facpice(2,istage)-this%facpice(1,istage))
else
  facpice=this%facpice(1,istage)
end if
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
l1=dabs(l-this%lsource)
if (l1<=ltime) then
    
    if (this%isconstant .or. ltime < small) then
       pice = htime
    else
       pice = htime * (r1 - (l1/ltime)**this%a )**(r1/this%b) 
    end if 
    

    pice = facpice * pice
    
    if (typedata==pressure) then
        pice=pice*this%densice*g
    end if

end if
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!% linear interpolation of pore pressure change at ground surface when
!% ice sheet stage changes from advance (or static) to retreat.
!% Modified by DSU, 2023-05-03
!%************************************************************
!%************************************************************
subroutine compute_pw_ice_sheet &
  (this, &
   pw, &
   pp, &
   time, &
   l, &
   z, &
   bcond_start, &
   bcond_end, &
   typedata, &
   iserror)

implicit none
!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object
!
!   $Arguments:
!

type(t_ice_sheet), intent(in)    :: this                     ! Type

character(len=*), intent(in)     :: typedata

real*8, intent(in)               :: l

real*8, intent(in)               :: z

real*8, intent(in)               :: bcond_start

real*8, intent(in)               :: bcond_end

real*8, intent(in)               :: time

real*8, intent(out)              :: pw

real*8, intent(out)              :: pp

logical, intent(out)             :: iserror

!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 istage
real*8                        :: &
 htime, &
 ltime, &
 time1, &
 time2, &
 l1, &
 z1, &
 facpw, &
 facpp
logical                       :: &
 isbestage
real*8, parameter             :: &
 r0=0.0d0, &
 r1=1.0d0, &
 g=9.81d0, &
 small=1.0d-10
character(len=100), parameter :: &
 pressure='pressure'
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false.
!%------------------------------------------------------------
pw = r0
pp = bcond_end

facpw = r1
facpp = r0
!%------------------------------------------------------------
!% Check if the cell is corresponding to boundary
!%------------------------------------------------------------
z1=dabs(z-this%zsource)
if (z1>small) return
!%------------------------------------------------------------
!%
!%------------------------------------------------------------
call give_stage_ (this,istage,time,isbestage)
!%------------------------------------------------------------
if (.not.isbestage) return
!%------------------------------------------------------------
time1=time-this%timestages(1,istage)
time2=this%timestages(2,istage)-this%timestages(1,istage)
htime=this%hslope(istage)*time1 + this%hstages(1,istage)
ltime=this%lslope(istage)*time1 + this%lstages(1,istage)
if (this%linearType == 1) then
  facpw=this%facpw(1,istage) + time1/time2*                            &
        (this%facpw(2,istage)-this%facpw(1,istage))
else if (this%linearType == 2) then
  facpw=this%facpw(1,istage) + time1/time2*                            &
        (this%facpw(2,istage)-this%facpw(1,istage))
  facpp=this%facpp(1,istage) + time1/time2*                            &
        (this%facpp(2,istage)-this%facpp(1,istage))
else
  facpw=this%facpw(1,istage)
end if
!%------------------------------------------------------------
l1=dabs(l-this%lsource)
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
if (l1<=ltime) then

    if (this%isconstant) then
      pw = (this%densice/this%densfresh)*htime
    else
      pw = (this%densice/this%densfresh)*htime * (r1 - (l1/ltime)**this%a )**(r1/this%b)
    end if
    pw = facpw * pw
    if (typedata==pressure) then
      !pw = pw * this%densice * g
      !cdsu bug here, pw has already been converted to freshwater head
      pw = pw * this%densfresh * g
    end if

    pp = bcond_start*facpp + bcond_end*(r1-facpp)

end if
!%------------------------------------------------------------
return
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine get_new_bc_ice_sheet &
  (this, &
   ivolbc, &
   nvolbc, &
   b_ivolbc_ice, &
   xvol, &
   zvol, &
   nvol, &
   time, &
   iserror, &
   totbc)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description:  
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)    :: this                     

integer, intent(in)              :: nvol

integer, intent(in)              :: nvolbc

integer, intent(in)              :: ivolbc(nvolbc)

logical, intent(inout)           :: b_ivolbc_ice(nvolbc)      !indicator for those volumes affected

real*8, intent(in)               :: xvol(nvol)

real*8, intent(in)               :: zvol(nvol)

real*8, intent(in)               :: time

logical, intent(out)             :: iserror

! Important note: the array should be in the same size as passed in, otherwise,
! the array returned after this function is shifted. No compilation error is given
! here even if you pass different size. 
! The modified code will not change the boundary array, instead, it returns an indicator
! b_ivolbc_ice to check if this boundary volume is affected by ice. DSU, 2017-07-30.

real*8, optional    :: totbc(this%ncomp+1,nvolbc)
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 istage, &
 ivol, &
 ibc
real*8                        :: &
 ltime, &
 time1, &
 l1, &
 z1
logical                       :: &
 isbestage, &
 hastotbc
!integer, pointer              :: &
! ivolbc1(:) => null()
!real*8, pointer               :: &
! totbc1(:,:) => null ()
real*8, parameter             :: &
 small=1.0d-10 
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------

iserror=.false. 
b_ivolbc_ice = .true.

hastotbc=present(totbc)
!%------------------------------------------------------------
!% If the number of boundary conditions is equal to zero, 
!% return 
!%------------------------------------------------------------
if (nvolbc==0) return
!%------------------------------------------------------------
!% Determine the stage  
!%------------------------------------------------------------
call give_stage_ (this,istage,time,isbestage)
!%------------------------------------------------------------
!% If the satge is not found return 
!%------------------------------------------------------------
if (.not.isbestage) return
!%------------------------------------------------------------

!% initial boundary volume mask
b_ivolbc_ice = .false.

time1=time-this%timestages(1,istage) 
ltime=this%lslope(istage)*time1 + this%lstages(1,istage)
!%------------------------------------------------------------
!call check_pointer_ice_sheet_ (ivolbc1,nvolbc,.true.)
!if (hastotbc) then
!    call check_pointer_ice_sheet_ (totbc1,this%ncomp,nvolbc,.true.)
!end if
!ibc=0

do i=1,nvolbc
  ivol=abs(ivolbc(i))              !boundary condition can be duplicated, use negative value for those overwritten boundary condition, by DSU, 2018-02-02   
  l1=dabs(xvol(ivol)-this%lsource)
  z1=dabs(zvol(ivol)-this%zsource)
  if (z1<small) then               !top surface node
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
    if (l1>ltime.or.(l1<=ltime.and.this%isbc(istage))) then
      !ibc = ibc + 1
      !ivolbc1(ibc)=ivol
      b_ivolbc_ice(i) = .true.
      if (hastotbc) then
        if (l1<=ltime) then
          !totbc1(1:this%ncomp,ibc)=this%totbc
          if (this%istotbc) then
            totbc(1:this%ncomp,i) = this%totbc(1:this%ncomp)
          end if
        else 
          !totbc1(1:this%ncomp,ibc)=totbc(1:this%ncomp,i)
        end if        
      end if
    end if
  else                             !internal node
    !ibc = ibc + 1
    !ivolbc1(ibc)=ivol  
    b_ivolbc_ice(i) = .true.
    !if (hastotbc) then
    !     totbc1(1:this%ncomp,ibc)=totbc(1:this%ncomp,i)      
    !end if
  end if
end do
!%------------------------------------------------------------
!% Set the new number of boundary conditions 
!%------------------------------------------------------------
!nvolbc=ibc
!ivolbc=0
!%------------------------------------------------------------
!% Be carefully, number of boundary conditions could be zero!!
!%------------------------------------------------------------

!if (nvolbc>0) then
!   ivolbc(1:nvolbc)=ivolbc1(1:nvolbc)
!   if (hastotbc) then
!      totbc(1:this%ncomp,1:nvolbc)=totbc1(1:this%ncomp,1:nvolbc)       
!   end if
!end if

!%------------------------------------------------------------
!% Deallocate local pointers
!%------------------------------------------------------------
!call check_pointer_ice_sheet_ (ivolbc1,1,.false.)
!if (hastotbc) then
!   call check_pointer_ice_sheet_ (totbc1,1,1,.false.)   
!end if

!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine get_components_ice_sheet &
  (this, &
   totbc, &
   typetotbc, &
   ncomp, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description:  
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)    :: this

integer, intent(in)              :: ncomp

real*8, intent(out)              :: totbc(ncomp)

character(len=*), intent(out)    :: typetotbc(ncomp)

logical, intent(out)             :: iserror
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
if(ncomp/=this%ncomp) then
    iserror=.true. 
    return
end if
iserror=.false. 
totbc=this%totbc
typetotbc=this%typetotbc
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine read_ice_sheet_block_ice_sheet &
  (this, &
   idat, &
   ncomp, &
   ncorder, &
   component_type, &
   istemp, &
   icetimeline, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(inout) :: this                     ! Type 

integer, intent(in)              :: idat

integer, intent(in)              :: ncomp

integer, intent(in)              :: ncorder(ncomp)

character(len=*), intent(in)     :: component_type(ncomp)

logical, intent(in)              :: istemp 

real*8, allocatable              :: icetimeline(:,:)

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 nstages, &
 istage, &
 itemp, &
 linearType
real*8                        :: &
 a, &
 b, &
 densice, &
 densfresh, &
 logkxx, &
 logkyy, &
 logkzz, &
 lsource, &
 zsource, &
 temp
logical, pointer              :: &
 isbc(:) => null () 
real*8, pointer               :: &
 time(:,:) => null (), &
 h(:,:) => null (), &
 l(:,:) => null (), &
 l1perm(:,:) => null (), &
 l2perm(:,:) => null (), &
 thickperm(:,:) => null (), &
 facpw(:,:) => null (), & 
 facpice(:,:) => null (), &
 facpp(:,:) => null (), &
 totbc(:) => null ()
!cdsu fix bug of typetotbc length, should be same length of component type
character(len=12), pointer   ::  &
 typetotbc(:) => null ()
character(len=100)            :: &
 header 
character(len=100)            :: &
 subsection 

logical                       :: &
 found,                          & 
 b_react_bc,                     &
 isconstant,                     &
 istotbc
real*8, parameter             :: &
 r0=0.0d0  
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false.
temp=r0 
linearType = 0
!%------------------------------------------------------------

!%------------------------------------------------------------
!% Check if linear interpolation is used for factor for pw and pice
!%------------------------------------------------------------
 subsection = 'linear interpolation of factor for pw and pice'
 call findstrg(subsection,idat,found)
 if (found) then
   linearType = 1
 else
   subsection = 'linear interpolation of ice sheet factors'
   call findstrg(subsection,idat,found)
   if (found) then
     linearType = 2
   end if
 end if

 if (linearType == 0) then
   rewind(idat)
 end if

 read(idat,*,err=10) isconstant
 read(idat,*,err=10) lsource
 read(idat,*,err=10) zsource
 read(idat,*,err=10) a
 read(idat,*,err=10) b
 read(idat,*,err=10) logkxx
 read(idat,*,err=10) logkyy
 read(idat,*,err=10) logkzz
 if (istemp) then
  read(idat,*,err=10) temp
 end if
 read(idat,*,err=10) densice
 read(idat,*,err=10) densfresh
 read(idat,*,err=10) nstages
!%------------------------------------------------------------
!% Allocate local pointers 
!%------------------------------------------------------------ 
 call check_pointer_ice_sheet_ (time,2,nstages,.true.)
 call check_pointer_ice_sheet_ (h,2,nstages,.true.)
 call check_pointer_ice_sheet_ (l,2,nstages,.true.)
 call check_pointer_ice_sheet_ (l1perm,2,nstages,.true.)
 call check_pointer_ice_sheet_ (l2perm,2,nstages,.true.)
 call check_pointer_ice_sheet_ (thickperm,2,nstages,.true.)
 call check_pointer_ice_sheet_ (facpw,2,nstages,.true.)
 call check_pointer_ice_sheet_ (facpice,2,nstages,.true.)
 call check_pointer_ice_sheet_ (facpp,2,nstages,.true.)
 call check_pointer_ice_sheet_ (isbc,nstages,.true.)
 
!%------------------------------------------------------------
!% Get the timeline of ice loading/unloading, modify timestep when
!% this timeline is met. DSU, 2015-12-09
!%------------------------------------------------------------
if (allocated(icetimeline)) then
  deallocate(icetimeline)
end if
allocate(icetimeline(2,nstages))

 !%------------------------------------------------------------
 !% Read ice loading/unloading stages
 !%------------------------------------------------------------ 

 do i=1,nstages
   read(idat,*,err=10) istage
   read(idat,*,err=10) isbc(i)
   if (linearType == 1) then
     read(idat,*,err=10) facpw(1,i),facpw(2,i)
     read(idat,*,err=10) facpice(1,i),facpice(2,i)
   else if (linearType == 2) then
     read(idat,*,err=10) facpw(1,i),facpw(2,i)
     read(idat,*,err=10) facpice(1,i),facpice(2,i)
     read(idat,*,err=10) facpp(1,i),facpp(2,i)
   else
     read(idat,*,err=10) facpw(1,i)
     read(idat,*,err=10) facpice(1,i)
   end if
   read(idat,*,err=10) time(1,i),time(2,i)
   read(idat,*,err=10) l(1,i),l(2,i)
   read(idat,*,err=10) h(1,i),h(2,i) 
   read(idat,*,err=10) l1perm(1,i),l1perm(2,i) 
   read(idat,*,err=10) l2perm(1,i),l2perm(2,i) 
   read(idat,*,err=10) thickperm(1,i),thickperm(2,i) 
!% Set the value for ice timeline
   icetimeline(1,i) = time(1,i)
   icetimeline(2,i) = time(2,i)
 end do

 !c check if chemical boundary condition during glaciation exist
 !c add a keyword (e.g., 'concentration input') to use this boundary. 
 
 subsection = 'concentration input'
 
 call findstrg(subsection,idat,b_react_bc)

 if (b_react_bc) then
   call check_pointer_ice_sheet_ (totbc,ncomp-1,.true.)
   call check_pointer_ice_sheet_ (typetotbc,ncomp-1,.true.)
   do i = 1, ncomp-1
     itemp = ncorder(i)                 !internal order
     if (component_type(itemp).eq.'aqueous'.or. &
         component_type(itemp).eq.'biomass') then
       read(idat,*,err=5) totbc(itemp),typetotbc(itemp)
     end if
   end do
   istotbc = .true.
 else
   call check_pointer_ice_sheet_ (totbc,1,.true.)
   call check_pointer_ice_sheet_ (typetotbc,1,.true.)
   istotbc = .false.
 end if

!%------------------------------------------------------------
!% Set the ice sheet object 
!%------------------------------------------------------------
call set_ (this,'ice sheet',lsource,zsource,a,b,logkxx,logkyy,logkzz, &
           temp,densice,densfresh,nstages,ncomp-1,totbc,typetotbc,    &
           isbc,istotbc,linearType,time,h,l,facpw,facpice,facpp,      &
           l1perm,l2perm,thickperm,isconstant,iserror)
!%------------------------------------------------------------
!% Deallocate local pointers 
!%------------------------------------------------------------
call check_pointer_ice_sheet_ (time,1,1,.false.)
call check_pointer_ice_sheet_ (h,1,1,.false.)
call check_pointer_ice_sheet_ (l,1,1,.false.)
call check_pointer_ice_sheet_ (facpw,1,1,.false.)
call check_pointer_ice_sheet_ (facpice,1,1,.false.)
call check_pointer_ice_sheet_ (facpp,1,1,.false.)
call check_pointer_ice_sheet_ (l1perm,1,1,.false.)
call check_pointer_ice_sheet_ (l2perm,1,1,.false.)
call check_pointer_ice_sheet_ (thickperm,1,1,.false.)
call check_pointer_ice_sheet_ (isbc,1,.false.)
call check_pointer_ice_sheet_ (totbc,1,.false.)
call check_pointer_ice_sheet_ (typetotbc,1,.false.)
if (iserror) goto 30  
!%------------------------------------------------------------
return

5  continue
iserror=.true.
write(*,*) 'Error when read concentration input in ice sheet block'
return

10 continue
iserror=.true.
write(*,*) 'Error when read ice sheet loading/unloding block'
return 

20 continue
iserror=.true.
write(*,*) 'Error ice sheet loading/unloding block not found'
return 

30 continue
iserror=.true.
write(*,*) 'Error when call service set_'
return 

end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine write_ice_sheet &
  (this, &
   ioutput, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Write ice sheet information 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)    :: this                     ! Type 

integer, intent(in)              :: ioutput

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i, &
 istage
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
write(ioutput,*) '-------------------------------------------------'
write(ioutput,*) 'Ice sheet object information'
write(ioutput,*) '-------------------------------------------------'
write(ioutput,*) 'Constant ice sheet loading:',this%isconstant
write(ioutput,*) 'Ice Sheet point source (x):',this%lsource,'[m]'
write(ioutput,*) 'Ice Sheet point source (z):',this%zsource,'[m]'
write(ioutput,*) 'Ice density:',this%densice
write(ioutput,*) 'Fresh-water density:',this%densfresh
write(ioutput,*) 'Log scale factor to kxx:',this%logkxx
write(ioutput,*) 'Log scale factor to kyy:',this%logkyy
write(ioutput,*) 'Log scale factor to kzz:',this%logkzz
write(ioutput,*) 'Temperature:',this%temp,'[oC]'
write(ioutput,*) 'Number of stages',this%nstages
!%------------------------------------------------------------
!% Loop for number of stages
!%------------------------------------------------------------
write(ioutput,*) '---------------------------------------------------------------------------' 
do istage=1,this%nstages
  write(ioutput,*) '---------------------------------------------------------------------------' 
  write(ioutput,30) 'Stage:',istage
  write(ioutput,10) 'Init and final time:',this%timestages(1,istage),this%timestages(2,istage)
  write(ioutput,10) 'Init and final max. thickness:',this%hstages(1,istage),this%hstages(2,istage)
  write(ioutput,10) 'Init and final max. extension:',this%lstages(1,istage),this%lstages(2,istage)
  if (this%linearType == 1) then
    write(ioutput,10) 'Scale factor for pw:',this%facpw(1,istage),this%facpw(2,istage)
    write(ioutput,10) 'Scale factor for pice:',this%facpice(1,istage),this%facpice(2,istage)
  else if (this%linearType == 2) then
    write(ioutput,10) 'Scale factor for pw:',this%facpw(1,istage),this%facpw(2,istage)
    write(ioutput,10) 'Scale factor for pice:',this%facpice(1,istage),this%facpice(2,istage)
    write(ioutput,10) 'Scale factor for boundary pore pressure:',this%facpp(1,istage),this%facpp(2,istage)
  else
    write(ioutput,20) 'Scale factor for pw:',this%facpw(1,istage)
    write(ioutput,20) 'Scale factor for pice:',this%facpice(1,istage)
  end if
end do
write(ioutput,*) '---------------------------------------------------------------------------' 
write(ioutput,*) '---------------------------------------------------------------------------' 
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
return 
10 format (a30,2(1pe15.6e3))
20 format (a30,1pe15.6e3)
30 format (a10,i5)
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine compute_dpicedt_ice_sheet &
  (this, &
   dpicedt, &
   time1, &
   time2, &
   l, &
   storcoeff, &
   density, &
   beta, &
   loadingfactor, &
   typedata, &
   iserror)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Set the ice sheet object 
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)    :: this           ! Type ice sheet object

character(len=*), intent(in)     :: typedata

real*8, intent(in)               :: l

real*8, intent(in)               :: storcoeff

real*8, intent(in)               :: density 

real*8, intent(in)               :: time1

real*8, intent(in)               :: time2

real*8, intent(in)               :: beta          ! Skepton's coeffcient

real*8, intent(in)               :: loadingfactor ! factor of loading efficiency coefficiency 

real*8, intent(out)              :: dpicedt

logical, intent(out)             :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
real*8                        :: &
 pice1, &
 pice2
real*8, parameter             :: &
 r0=0.0d0
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
dpicedt=r0
!%------------------------------------------------------------
call compute_pice_ (this,pice2,time2,l,typedata,iserror)
if (iserror) return
call compute_pice_ (this,pice1,time1,l,typedata,iserror)
if (iserror) return
!%------------------------------------------------------------
!% 
!%------------------------------------------------------------
dpicedt = -density*storcoeff*loadingfactor*beta*(pice2-pice1)

if(pice2/=pice2 .or. pice1/=pice1) then
  write(*,*) "pice is nan pice1",pice1,"pice2",pice2
end if

!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine destroy_ice_sheet &
  (this)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Destroy  
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(inout) :: this ! Type  
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
real*8, parameter             :: &
 r0=0.0d0
!-------------------------------------------------------------------------
!
!   $code
!
!%-----------------------------------------------------------
this%name=' '
this%a=r0
this%b=r0
this%densice=r0
this%densfresh=r0
this%nstages=0
this%logkxx=r0
this%logkyy=r0
this%logkzz=r0
this%temp=r0
this%isconstant=.false. 
!%-----------------------------------------------------------
!% Deallocate and nullify pointers 
!%-----------------------------------------------------------
call check_pointer_ice_sheet_ (this%timestages,1,1,.false.)
call check_pointer_ice_sheet_ (this%lstages,1,1,.false.)
call check_pointer_ice_sheet_ (this%hstages,1,1,.false.)
call check_pointer_ice_sheet_ (this%lslope,1,.false.)
call check_pointer_ice_sheet_ (this%hslope,1,.false.)
call check_pointer_ice_sheet_ (this%facpw,1,1,.false.)
call check_pointer_ice_sheet_ (this%facpice,1,1,.false.)
call check_pointer_ice_sheet_ (this%thickpermstages,1,1,.false.)
call check_pointer_ice_sheet_ (this%l1permstages,1,1,.false.)
call check_pointer_ice_sheet_ (this%l2permstages,1,1,.false.)
call check_pointer_ice_sheet_ (this%l1permslope,1,.false.)
call check_pointer_ice_sheet_ (this%l2permslope,1,.false.)
call check_pointer_ice_sheet_ (this%thickpermslope,1,.false.)
call check_pointer_ice_sheet_ (this%isbc,1,.false.)
if (this%istotbc) then
    call check_pointer_ice_sheet_ (this%totbc,1,.false.)
    this%istotbc=.false.
    this%ncomp=0
end if
!%-----------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine modify_for_permafrost_k_ice_sheet &
  (this, &
   kxx, &
   kyy, &
   kzz, &
   ncells, &
   time, &
   x, &
   z, &
   nthreads, &
   numofloops_thred, &
   iserror)

#ifdef OPENMP
   use omp_lib 
#endif
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Modify hydraulic conductivity vector. The hidraulic 
! conductivity is reduced according to log cycles specified by user
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)              :: this            

integer, intent(in)                        :: ncells

real*8, intent(inout), dimension(ncells)   :: kxx

real*8, intent(inout), dimension(ncells)   :: kyy

real*8, intent(inout), dimension(ncells)   :: kzz

real*8, intent(in), dimension(ncells)      :: x

real*8, intent(in), dimension(ncells)      :: z

real*8, intent(in)                         :: time

integer*4, intent(in)                      :: nthreads

integer*8, intent(in)                      :: numofloops_thred

logical, intent(out)                       :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
real*8                        :: &
 xloc, &
 zloc, &
 zperm, &
 l1perm, &
 l2perm, &
 l, &
 time1, &
 theta, &
 theta1 
logical                       :: &
 isbestage 
integer                       :: &
 icell, &
 i, &
 istage 
real*8, parameter             :: &
 r0=0.0d0, &
 r10=10.0d0 
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
if (ncells==0) return
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
call give_stage_ (this,istage,time,isbestage)
!%------------------------------------------------------------
if (.not.isbestage) return
!%------------------------------------------------------------
time1=time-this%timestages(1,istage) 
l=this%lslope(istage)*time1 + this%lstages(1,istage)
l1perm=this%l1permslope(istage)*time1 + this%l1permstages(1,istage) 
l2perm=this%l2permstages(1,istage) - this%l2permslope(istage)*time1 
zperm = this%thickpermslope(istage)*time1 + this%thickpermstages(1,istage)  
theta=datan(zperm/l1perm)
!%------------------------------------------------------------
!% Loop for cells 
!%------------------------------------------------------------
#ifdef OPENMP
    !$omp parallel                                                    &                                                              
    !$omp if (ncells > numofloops_thred)                              & 
    !$omp num_threads(nthreads)                                       &
    !$omp default(shared)                                             &
    !$omp private (icell, xloc, zloc, theta1)
    !$omp do schedule(static)
#endif
do icell=1,ncells

  xloc=dabs(x(icell)-this%lsource)
  zloc=dabs(z(icell)-this%zsource)
  
  theta1 = datan(zloc/xloc)
  if(theta1<=theta &
       .and.xloc<=l1perm &
       .and.xloc>=l2perm &
       .and.zloc<=zperm) then
     
      kxx(icell) = kxx(icell) * r10**this%logkxx
      kyy(icell) = kyy(icell) * r10**this%logkyy
      kzz(icell) = kzz(icell) * r10**this%logkzz          
  
  end if
       
end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif  
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine modify_for_permafrost_temp_ice_sheet &
  (this, &
   temp, &
   x, &
   z, &
   time, &
   iserror)
   
implicit none
!-------------------------------------------------------------------------
!
!   $Description: Modify temperature in the permafrost zone
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)              :: this            

real*8, intent(inout)                      :: temp

real*8, intent(in)                         :: x

real*8, intent(in)                         :: z

real*8, intent(in)                         :: time

logical, intent(out)                       :: iserror
 
!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
real*8                        :: &
 xloc, &
 zloc, &
 l1perm, &
 l2perm, &
 l, &
 time1, &
 zperm, &
 theta, &
 theta1 
logical                       :: &
 isbestage 
integer                       :: &
 istage 
real*8, parameter             :: &
 r0=0.0d0, &
 r10=10.0d0 
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
iserror=.false. 
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
!%------------------------------------------------------------
call give_stage_ (this,istage,time,isbestage)
!%------------------------------------------------------------
if (.not.isbestage) return
!%------------------------------------------------------------
time1=time-this%timestages(1,istage) 
l=this%lslope(istage)*time1 + this%lstages(1,istage)
l1perm=this%l1permslope(istage)*time1 + this%l1permstages(1,istage) 
l2perm=this%l2permslope(istage)*time1 + this%l2permstages(1,istage)
zperm = this%thickpermslope(istage)*time1 + this%thickpermstages(1,istage)  
theta=datan(zperm/l1perm)
!%------------------------------------------------------------
!%  
!%------------------------------------------------------------
xloc=dabs(x-this%lsource)
zloc=dabs(z-this%zsource)
theta1 = datan(zloc/xloc)
  
if(theta1<=theta &
       .and.xloc<=l1perm &
       .and.xloc>=l2perm &
       .and.zloc<=zperm) then
     
       temp = this%temp
      
end if 
!%------------------------------------------------------------
return
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine give_stage_ice_sheet &
  (this, &
   istage, &
   time, &
   isbe)
 
implicit none
!-------------------------------------------------------------------------
!
!   $Description:  
!
!   $Arguments:
!
 
type(t_ice_sheet), intent(in)              :: this            

integer,intent(out)                        :: istage

real*8, intent(in)                         :: time

logical, intent(out)                       :: isbe

!-------------------------------------------------------------------------
!
!   $Pre-cond:
!
!   $Post-cond:
!
!   $License:
!
!-------------------------------------------------------------------------
integer                       :: &
 i
!-------------------------------------------------------------------------
!
!   $code
!
!%------------------------------------------------------------
isbe=.false. 
!%------------------------------------------------------------
!%------------------------------------------------------------
istage=0
do i=1,this%nstages

 if (time>=this%timestages(1,i).and.time<this%timestages(2,i)) then
   istage=i
   isbe=.true.
   exit
 end if

end do
return
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine check_pointer_vi (pa,ndim,isallocate)
#ifdef PETSC
    use petsc_mpi_common, only : petsc_mpi_finalize
#endif

    implicit none

    ! External variables
    integer(4), intent(in)         :: ndim
    integer(4), pointer            :: pa(:)
    logical, intent(in)            :: isallocate
    integer                        :: stat

    if (isallocate) then
      if (associated(pa)) then
        if (size(pa).ne.ndim) then

           deallocate (pa,stat=stat)
           if (stat>0) goto 10
           allocate (pa(ndim),stat=stat) 

           if (stat>0) goto 10
        end if
      else
        allocate (pa(ndim),stat=stat)

        if (stat>0) goto 10
      end if
      pa=0
    else
      if (associated(pa)) then
        deallocate (pa,stat=stat)
        if (stat>0) goto 10
      end if
      pa => null () 
      
    end if

!c-----------------------------------------------------------
    return
10  print*,'Error, problems when allocate/deallocate memory'
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop
end subroutine
!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine check_pointer_vch (pa,ndim,isallocate)

    implicit none
    ! External variables

    character(len=*), pointer   :: pa(:)
    integer                     :: ndim
    logical                     :: isallocate
    integer                     :: stat

    if (isallocate) then
      if (associated(pa)) then
        if (size(pa).ne.ndim) then
          deallocate (pa,stat=stat)
           
          if (stat>0) goto 10  
          allocate (pa(ndim),stat=stat)
           
          if (stat>0) goto 10
          pa=' '        
        end if 
      else
        allocate (pa(ndim),stat=stat) 
      
        if (stat>0) goto 10
      end if
      
      pa=' ' 
    
    else
      if (associated(pa)) then
        deallocate (pa,stat=stat)
        if (stat>0) goto 10
      end if
      pa => null () 
      
    end if
!c-----------------------------------------------------------
    return
10  print*,'Error, problems when allocate/deallocate memory, stat:',stat
    stop 
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine check_pointer_vlogical (pa,ndim,isallocate)
#ifdef PETSC
    use petsc_mpi_common, only : petsc_mpi_finalize
#endif

    implicit none

    ! External variables
    integer(4), intent(in)         :: ndim
    logical, pointer               :: pa(:)
    logical, intent(in)            :: isallocate
    integer                        :: stat

    if (isallocate) then
      if (associated(pa)) then
        if (size(pa).ne.ndim) then

          deallocate (pa,stat=stat)
          if (stat>0) goto 10
          allocate (pa(ndim),stat=stat) 

          if (stat>0) goto 10
        end if
      else
        allocate (pa(ndim),stat=stat)

        if (stat>0) goto 10
      end if
      pa=.false.
    else
      if (associated(pa)) then
        deallocate (pa,stat=stat)
        if (stat>0) goto 10
      end if
      pa => null () 
      
    end if

!c-----------------------------------------------------------
    return
10  print*,'Error, problems when allocate/deallocate memory'
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************    
subroutine check_pointer_vr (pa,ndim,isallocate)
#ifdef PETSC
    use petsc_mpi_common, only : petsc_mpi_finalize
#endif
    implicit none

    ! External variables
    integer(4), intent(in)         :: ndim
    real(8), pointer               :: pa(:)
    logical, intent(in)            :: isallocate
    integer                        :: stat

    if (isallocate) then
      if (associated(pa)) then
        if (size(pa).ne.ndim) then

          deallocate (pa,stat=stat)
          if (stat>0) goto 10
          allocate (pa(ndim),stat=stat) 

          if (stat>0) goto 10
        end if
      else
        allocate (pa(ndim),stat=stat)

        if (stat>0) goto 10
      end if
      pa=0.0d0   
    else
      if (associated(pa)) then
        deallocate (pa,stat=stat)
        if (stat>0) goto 10
      end if
      pa => null () 
      
    end if

!c-----------------------------------------------------------
    return
10  print*,'Error, problems when allocate/deallocate memory'
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************
subroutine check_pointer_ar (pa,ndim1,ndim2,isallocate)
#ifdef PETSC
    use petsc_mpi_common, only : petsc_mpi_finalize
#endif 
    implicit none

    ! External variables
    real(8), pointer    :: pa(:,:)
    integer(4)          :: ndim1,ndim2
    logical             :: isallocate
    integer             :: stat

    if (isallocate) then
      if (associated(pa)) then
        if (size(pa,1).ne.ndim1.or.size(pa,2).ne.ndim2) then
          deallocate (pa,stat=stat)
       
          if (stat>0) goto 10
          allocate (pa(ndim1,ndim2),stat=stat)
       
          if (stat>0) goto 10
        end if 
      else
        allocate (pa(ndim1,ndim2),stat=stat) 
      
        if (stat>0) goto 10
      end if
       
      pa=0.0d0
    
    else
      if (associated(pa)) then
        deallocate (pa,stat=stat)
        if (stat>0) goto 10
      end if
      pa => null () 
      
    end if
!c-----------------------------------------------------------
    return
10  print*,'Error, problems when allocate/deallocate memory'
#ifdef PETSC
    call petsc_mpi_finalize
#endif
    stop 
end subroutine

!%************************************************************
!%***************Public subroutine****************************
!%************************************************************
!%************************************************************
!%************************************************************    
! subroutine findstrg(subsection,itmp,found_subsection)
!
!      logical found_subsection
!      character*72 subsection,string
! 
!!c  rewind input file
!
!      rewind(itmp)
!
!!c  search for test string in input file
!
!      found_subsection = .false.
!      do while (.not.found_subsection)
!        read(itmp,*,end=999) string
!        if (string.eq.subsection) then
!          found_subsection = .true.
!        end if
!      end do
!
!999   return
!      end subroutine
!%************************************************************
!%************************************************************
!%************************************************************
!%************************************************************
!%************************************************************
end module m_ice_sheet 
