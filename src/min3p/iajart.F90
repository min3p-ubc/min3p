!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 609 $
!> $Author: dsu $
!> $Date: 2018-09-14 11:47:55 -0700 (Fri, 14 Sep 2018) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/iajart.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine iajart
!c -----------------
!c
!c set up ia-ja data-structure for n-d scalar matrix
!c make use of known block structure of jacobian matrix
!c all diagonal blocks have the same structure
!c all off-diagobnal blocks have the same structure
!c      
!c                z
!c                     y
!c                7  
!c                |  5                  local connection list 
!c                | /                   for ja pointer array
!c                |/                    
!c       2--------1----------3  x     
!c               /|
!c              / |
!c             4  |
!c                6
!c
!c nonexistent connections (1D-2D-boundary effects) are skipped:
!c
!c      z
!c            
!c      4                     e.g.
!c      |                     x-z plane - on boundary x=0
!c      |                     
!c      |                     
!c      1----------2  x     
!c      |
!c      |
!c      |
!c      3
!c
!c written by:      Uli Mayer - August 6, 96 
!c
!c last modified:   Uli Mayer - November 19, 96
!c
!c                  Danyang Su - March 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c parm.inc: mnjart             = max. number of entries in art,jart  + -
!c
!c gen.f:    integer*4:
!c           ----------
!c           idbg               = unit number, debugging file         + -
!c           ilog               = unit number, logbook                + -
!c           n                  = number of primary unknowns          + -
!c           nn                 = total number of control volumes     + -
!c           nvx                = number of control volumes in        + -
!c                                x-direction
!c           nvy                = number of control volumes in        + -
!c                                y-direction
!c           nvz                = number of control volumes in        + -
!c                                z-direction
!c           iart(nn*n+1)       = row pointer array for art           * +
!c           jart(njart)        = connectivity list                   * +
!c           lart(njavs+1)      = pointer array                       * +
!c           kart(njart)        = mapping pointer                     * +
!c                                (global block -> nd-scalar)
!c           iadbl(n+1)         = row pointer array (diagonal block   + -
!c                                matrices)
!c           jadbl(n*n)         = column pointer array (diagonal      + -
!c                                block matrices)
!c           iaobl(n+1)         = row pointer array                   + -
!c                                (off-diagonal block matrices)       + -
!c           jaobl(n*n)         = column pointer array                + -
!c                                (diagonal block matrices)
!c           njart              = number of global connections        * +
!c           njadbl             = actual number of entries in         + -
!c                                diagonal block matrices
!c           njaobl             = actual number of entries in         + -
!c                                off-diagonal block matrices
!c
!c local:    integer*4:
!c           ----------
!c           ivx                = counter (number of control volumes
!c                                in x-direction)
!c           ivy                = counter (number of control volumes
!c                                in y-direction)
!c           ivz                = counter (number of control volumes
!c                                in z-direction)
!c           ivol               = pointer (current control volume)
!c           ivxp               = pointer (previous control volume
!c                                in x-direction) 
!c           ivxn               = pointer (next control volume in 
!c                                x-direction)
!c           ivyp               = pointer (previous control volume
!c                                in y-direction)
!c           ivyn               = pointer (next control volume in
!c                                y-direction)
!c           ivzp               = pointer (previous control volume
!c                                in z-direction)
!c           ivzn               = pointer (next control volume in
!c                                z-direction)
!c           jtemp              = pointer to colum entries
!c           ibl                = row pointer (block matrix)
!c           igl                = row pointer (global matrix)
!c           istart             = pointer (first entry of row)
!c           iend               = pointer (last entry of row)
!c           irow1              = counter (rows)
!c           icol1              = pointer (columns)
!c           istart1            = pointer (first entry of row)
!c           iend1              = pointer (last entry of row)
!c           i1                 = counter (column entries in row)
!c           irow2              = counter (rows)
!c           icol2              = pointer (columns)
!c           istart2            = pointer (first entry of row)
!c           iend2              = pointer (last entry of row)
!c           i2                 = counter (column entries in row)
!c           info_debug         = 0 -> no debugging information
!c                              = 1 -> write debugging information to
!c                                     prefix_o.dbg
!c                              = 2 -> write debugging information to
!c                                     prefix_o.dbg and quit
!c
!c external: -
!c ----------------------------------------------------------------------
 
      subroutine iajart
 
      use parm
      use gen
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      integer :: i1, i2, i3, icol,icol1, icol2, irow, info_debug,      &
                 ibl, igl, istart, iend, istart2, iend2,               &
                 istart3, iend3, ivx, ivy, ivz, ivxp, ivxn, ivyp,      &
                 ivyn, ivzp, ivzn, ivol, jbl, jgl, jtemp, jvol1,       &
                 ltemp, lstart, lend, ktemp

      info_debug = 0

!c  define initial row pointer
   
      iart(1) = 1
      ivol = 0
      jtemp = 0
      igl = 0

!c  loop over number of control volumes

      do ivz = 1,nvzgl                    !number of control volumes in z
        do ivy = 1,nvygl                  !number of control volumes in y 
          do ivx = 1,nvxgl                !number of control volumes in x

!c  pointer to current control volume

            ivol = ivol+1

!c  pointers to previous colums in x,y and z

            ivxp = ivx-1
            ivxn = ivx+1
            ivyp = ivy-1
            ivyn = ivy+1
            ivzp = ivz-1
            ivzn = ivz+1

            do ibl = 1,n                !loop over rows of block matrices

              igl = igl+1               !global row pointer
              
!c  assign entries of diagonal block 

              istart = iadbl(ibl)       !start of row (block matrix
              iend = iadbl(ibl+1)-1     !end of row (block matrix)
              do jbl = istart,iend      !loop over row entries
                jtemp = jtemp+1         !pointer to next entry
                if (jtemp.gt.mnjart) &  !exit if dimensions violated
                   goto 100
                jgl = (ivol-1)*n+jadbl(jbl)    !global column pointer
                jart(jtemp) = jgl       !assign global column pointer
#ifdef PETSC
                col_idx_l2pg_rt(jtemp) = &
                    (node_idx_lg2pg(ivol)-1)*n + jadbl(jbl)
#endif
              end do


!c  assign column pointers for off-diagonal entries in x-direction

              if (nvxgl.gt.1) then          !connections in x-direction

                if (ivxp.gt.0) then         !left connection   (2)
                  istart = iaobl(ibl)       !start of row (block matrix
                  iend = iaobl(ibl+1)-1     !end of row (block matrix)
                  do jbl = istart,iend        !loop over row entries
                    if (jtemp+1.gt.mnjart) &      !exit if dimensions violated
                        goto 100
                    if(sparse_blocks) then
                        if(kblsorb(ibl,jaobl(jbl))==1) then     !skip connections of sorbed specie 
                            cycle                               !components for off-dialog entries
                        end if
                    end if
                    jtemp = jtemp+1             !pointer to next entry
                    jgl = (ivol-2)*n+jaobl(jbl)        !global column pointer
                    jart(jtemp) = jgl           !assign global column pointer
                    
#ifdef PETSC
                    col_idx_l2pg_rt(jtemp) = &
                        (node_idx_lg2pg(ivol-1)-1)*n + jaobl(jbl)
#endif
                  end do
                end if

                if (ivxn.le.nvxgl) then       !right connection  (3)
                  istart = iaobl(ibl)       !start of row (block matrix
                  iend = iaobl(ibl+1)-1     !end of row (block matrix)
                  do jbl = istart,iend        !loop over row entries
                    if (jtemp+1.gt.mnjart)  &      !exit if dimensions violated
                       goto 100
                    if(sparse_blocks) then
                        if(kblsorb(ibl,jaobl(jbl))==1) then     !skip connections of sorbed specie 
                            cycle                               !components for off-dialog entries
                        end if
                    end if
                    jtemp = jtemp+1             !pointer to next entry
                    jgl = (ivol)*n+jaobl(jbl)          !global column pointer
                    jart(jtemp) = jgl           !assign global column pointer
                    
#ifdef PETSC
                    col_idx_l2pg_rt(jtemp) = &
                        (node_idx_lg2pg(ivol+1)-1)*n + jaobl(jbl)
#endif
                  end do
                end if

              end if                      !connections in x-direction

!c  assign column pointers for off-diagonal entries in y-direction

              if (nvygl.gt.1) then          !connections in y-direction

                if (ivyp.gt.0) then         !front connection (4)
                  istart = iaobl(ibl)       !start of row (block matrix
                  iend = iaobl(ibl+1)-1     !end of row (block matrix)
                  do jbl = istart,iend        !loop over row entries
                    if (jtemp+1.gt.mnjart)   &    !exit if dimensions violated
                       goto 100
                    if(sparse_blocks) then
                        if(kblsorb(ibl,jaobl(jbl))==1) then     !skip connections of sorbed specie 
                            cycle                               !components for off-dialog entries
                        end if
                    end if
                    jtemp = jtemp+1             !pointer to next entry
                    jgl = (ivol-nvxgl-1)*n+jaobl(jbl)    !global column pointer
                    jart(jtemp) = jgl           !assign global column pointer
#ifdef PETSC
                    col_idx_l2pg_rt(jtemp) = &
                        (node_idx_lg2pg(ivol-nvxgl)-1)*n + jaobl(jbl)
#endif
                  end do
                end if

                if (ivyn.le.nvygl) then       !back connection (5)
                  istart = iaobl(ibl)       !start of row (block matrix
                  iend = iaobl(ibl+1)-1     !end of row (block matrix)
                  do jbl = istart,iend        !loop over row entries
                    if (jtemp+1.gt.mnjart)   &    !exit if dimensions violated
                       goto 100
                    if(sparse_blocks) then
                        if(kblsorb(ibl,jaobl(jbl))==1) then     !skip connections of sorbed specie 
                            cycle                               !components for off-dialog entries
                        end if
                    end if
                    jtemp = jtemp+1             !pointer to next entry
                    jgl = (ivol+nvxgl-1)*n+jaobl(jbl)    !global column pointer
                    jart(jtemp) = jgl           !assign global column pointer
#ifdef PETSC
                    col_idx_l2pg_rt(jtemp) = &
                        (node_idx_lg2pg(ivol+nvxgl)-1)*n + jaobl(jbl)
#endif
                  end do
                end if
 
              end if                      !connections in y-direction
 

!c  assign column pointers for off-diagonal entries in z-direction

              if (nvzgl.gt.1) then          !connections in z-direction

                if (ivzp.gt.0) then      !bottom connection (6)
                  istart = iaobl(ibl)       !start of row (block matrix
                  iend = iaobl(ibl+1)-1     !end of row (block matrix)
                  do jbl = istart,iend        !loop over row entries
                    if (jtemp+1.gt.mnjart)  &     !exit if dimensions violated
                       goto 100
                    if(sparse_blocks) then
                        if(kblsorb(ibl,jaobl(jbl))==1) then     !skip connections of sorbed specie 
                            cycle                               !components for off-dialog entries
                        end if
                    end if
                    jtemp = jtemp+1             !pointer to next entry
                    jgl = (ivol-nvxgl*nvygl-1)*n+jaobl(jbl) !global column pointer
                    jart(jtemp) = jgl            !assign global column pointer
#ifdef PETSC
                    col_idx_l2pg_rt(jtemp) = &
                        (node_idx_lg2pg(ivol-nvxgl*nvygl)-1)*n + jaobl(jbl)
#endif
                  end do
                end if

                if (ivzn.le.nvzgl) then    !top connection (7)
                  istart = iaobl(ibl)       !start of row (block matrix
                  iend = iaobl(ibl+1)-1     !end of row (block matrix)
                  do jbl = istart,iend        !loop over row entries
                    if (jtemp+1.gt.mnjart)  &      !exit if dimensions violated
                       goto 100
                    if(sparse_blocks) then
                        if(kblsorb(ibl,jaobl(jbl))==1) then     !skip connections of sorbed specie 
                            cycle                               !components for off-dialog entries
                        end if
                    end if
                    jtemp = jtemp+1             !pointer to next entry
                    jgl = (ivol+nvxgl*nvygl-1)*n+jaobl(jbl) !global column pointer
                    jart(jtemp) = jgl            !assign global column pointer
#ifdef PETSC
                    col_idx_l2pg_rt(jtemp) = &
                        (node_idx_lg2pg(ivol+nvxgl*nvygl)-1)*n + jaobl(jbl)
#endif
                  end do
                end if

              end if                      !connections in z-direction
     
              iart(igl+1) = jtemp+1       !next row pointer
              
#ifdef PETSC
              row_idx_l2pg_rt(igl) = (node_idx_lg2pg(ivol)-1)*n + ibl
              if(node_idx_lg2l(ivol) < 0) then
                  row_idx_l2pg_rt(igl) = - row_idx_l2pg_rt(igl)
              end if
#endif

            end do                        !loop over rows of block matrices
          end do                          !number of increments in x
        end do                            !number of increments in y
      end do                              !number of increments in z

!c  assign actual number of entries

      njart = jtemp

!c  assign mapping pointer array for assembly

      ltemp = 1
      ktemp = 0
      lart(1) = 1

      do ivol=1,nngl                !loop - control volumes
        istart = iavs(ivol)       
        iend = iavs(ivol+1)-1     
        do i1 = istart,iend         !loop - connections
          jvol1 = javs(i1)

!c  diagonal block 

          if (ivol.eq.jvol1) then
            do ibl=1,n                  !loop - rows of block matrix
              istart2 = iadbl(ibl)
              iend2 = iadbl(ibl+1)-1
              irow = (ivol-1)*n+ibl       !row - global scalar matrix
              do i2 = istart2,iend2       !loop - columns in block matrix
                ktemp = ktemp+1
                icol1 = (jvol1-1)*n+jadbl(i2) !column - global scalar matrix
                istart3 = iart(irow)
                iend3   = iart(irow+1)

!c  search row in global scalar matrix

                do i3 = istart3,iend3   
                  icol2 = jart(i3)          !column - global scalar matrix
                  if (icol1.eq.icol2) then
                    kart(ktemp) = i3        !define pointer array
                    goto 110
                  end if
                end do
 110            continue
              end do
            end do

!c  off-diagonal blocks

          elseif (ivol.ne.jvol1) then 
            do ibl=1,n                  !loop - rows of block matrix
              istart2 = iaobl(ibl)
              iend2 = iaobl(ibl+1)-1
              irow = (ivol-1)*n+ibl
              do i2 = istart2,iend2       !loop - columns in block matrix
                if(sparse_blocks) then
                    if(kblsorb(ibl,jaobl(i2))==1) then     !skip connections of sorbed specie 
                        cycle                               !components for off-dialog entries
                    end if
                end if
                ktemp = ktemp+1
                icol1 = (jvol1-1)*n+jaobl(i2)  !current column
                istart3 = iart(irow)
                iend3   = iart(irow+1)

!c  search row in global scalar matrix

                do i3 = istart3,iend3
                  icol2 = jart(i3)
                  if (icol1.eq.icol2) then
                    kart(ktemp) = i3          !define pointer array
                    goto 120
                  end if
                end do
 120            continue
              end do
            end do
          end if
          ltemp = ltemp+1
          lart(ltemp) = ktemp+1
        end do                            !loop - connections
      end do                           !loop - control volumes
      
!cdbg
#ifdef DEBUG
      if (info_debug.gt.0) then
        write(idbg,'(/a/)')                                             &
             'memory requirements for reactive transport simulation:'
        write(idbg,'(a,i10/a,i10/)')                                    &
             'max. number of entries in stiffness matrix:   = ',mnjart, &
             'actual number of entries in stiffness matrix: = ',njart
      end if
#endif

!cdbg
#ifdef DEBUG
      if (info_debug.gt.0) then

!c  row pointer array for global scalar matrix

        do irow=1,nngl*n+1
          write(idbg,*) 'ia(',irow,')=',iart(irow)
        end do

!c  column pointer array for global scalar matrix

        do irow=1,nngl*n
          istart = iart(irow)
          iend = iart(irow+1)-1
          write(idbg,*) ('ja(',i1,')=',jart(i1),i1=istart,iend)
        end do

!c  pointer array to first entry of block for global block matrix
!c  and symmetric entry

        do i1=1,njavs
          i2 = isymvs(i1)
          write(idbg,*)'la(',i1,')=',lart(i1),'la_sym(',i1,')=',lart(i2)
        end do

!c  mapping pointer (block by block) to (row by row)
!c                  (global block)   to (global scalar)

        do irow = 1,nngl+1
          write(idbg,*)'irow = ',irow
          istart = iavs(irow)
          iend =   iavs(irow+1)-1
          do i1 = istart,iend
            icol = javs(i1)
            write(idbg,*) 'icol = ',icol
            lstart = lart(i1)
            lend   = lart(i1+1)-1
            write(idbg,*) ('ka(',i2,')=',kart(i2),i2=lstart,lend)
          end do
        end do
        if (info_debug.eq.2) then
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      end if
#endif
!cdbg
      return

!c  exit if array bounds are violated
     
100   continue
      if (rank == 0) then
        write(ilog,*) 'stop in routine iajart' 
        write(ilog,*) 'check array dimensions of mnjart'
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

      end
