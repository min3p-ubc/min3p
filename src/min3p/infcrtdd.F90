!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/infcrtdd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine infcrtdd
!c -------------------
!c
!c compute influence coefficients for advective and dispersive flux 
!c terms for rectangular, cartesian finite volume discretization 
!c (reactive transport) for aqueous phase using density dependent 
!c flow equation
!c
!c from Uli Mayer template
!c
!c written by:      Tom Henderson - October 22, 2002
!c
!c last modified:   Tom Henderson - July 11, 2003
!c
!c                  Danyang Su - March 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c     input:
!c
!c passed:   real*8:
!c           -------
!c           d(3, ibk)          = dimension of cells in x,y,z         + -
!c                                direction
!c           density(nn)        = fluid density                       + - 
!c           dvolcoef           = volume flux coefficient including   * +       
!c                                viscosity and relative permeability
!c           diffu              = phase molecular diffusion (m2/day)
!c           disx(nzn)          = dispersion, x direction (m)
!c           disy(nzn)          =    "      , y    "      (m)
!c           disz(nzn)          =    "      , z    "      (m)
!c           cinfrt_va()        = influence coefficients 
!c                                J^w_ij/A_ij
!c                                (advective flux terms)
!c           cinfrt_da()        = influence coefficients
!c                                D_ij * A_ij / d_ij  
!c                                (dispersvie flux terms)
!c           viscosity(nn)      = fluid viscosity                     - -     
!c
!c           integer*4:
!c           ----------
!c           ibk                = block i
!c           id                 = connected block j
!c           idbg               = output for debugging information
!c           ilog               = unit number, logbook
!c           nmax               = max cells for dim purposes
!c           nphas              = max number of phases
!c           njamxc             = max dim ja array (ncomp.com)
!c           nvx                = number of control volumes 
!c                                in x direction
!c           nvy                = number of control volumes 
!c                                in y direction
!c           nvz                = number of control volumes 
!c                                in z direction
!c           pornew(ibk)        = porosity
!c           sanew(nmax)        = aqueous phase saturation
!c                                - new time level
!c           uvsnew(nmax)       = pressure
!c           relperm(nmax)      = rel permeability
!c           cinfvs(nmax)       = influence coefficient 
!c                                (variably saturated flow) 
!c           ia(), ja()         = ysmp pointers
!c           isymm(ii)          = symmetry pointer for cell ibk
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions
!c           variably_saturated = .true.  -> .not.fully_saturated,
!c                                        -> variably saturated
!c                                           conditions
!c           half_cells         = .true.  -> half cells on boundary
!c           tortuosity_corr    = .true.  -> Millington-Quirk 
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c
!c
!c
!c local:
!c
!c external: diffcoff  = compute effective diffusion coefficient
!c           fluxdd    = flux function for fully saturated flow 
!c --------------------------------------------------------------------------

      subroutine infcrtdd (nvxgls, nvxgle, nvxgbl,                    &
                         nvygls, nvygle, nvygbl,                      &
                         nvzgls, nvzgle, nvzgbl,                      &
                         nvx, nvy, nvz, ia, ja, isymm,                &
                         cinfvs, cinfrt_va, cinfrt_da, d,             &
                         mprop, nzn, diffu, diffu_tensor,             &
                         type_diffu, frozen_diffu,                    &
                         tkel, disx, disy, disz,                      &
                         pornew, sanew, uvsnew,                       &
                         density, zg, viscosity,relperm,              &
                         idbg, ilog, fully_saturated,                 &
                         variably_saturated, njamxc, nmax,            &
                         tortuosity_corr,half_cells,time,tfinal,      &
                         cinfrt_da_ic, diff_coff, nc, diff_ic,        &
                         diff_ic_tensor, type_diff_ic,                &
                         assigned_tau,tau,type_tortuosity,marchies,   &
                         harmonic_porosity,delx,dely,delz,av_dens_z,  &
                         ups_heat,gacc,cinfrad,radial_coord, tau_fac, &
                         sonew)
#ifdef OPENMP
      use omp_lib 
#endif
      use geometry_definition
      use geometry
      use mod_diffcoff, only : diffcoff
      use gen, only :                                                 &
#ifdef OPENMP
                      numofthreads_global,                            &
                      numofloops_thred_global,                        &
                      numofloops_thred_infcrtdd_1,                    &
                      numofloops_thred_infcrtdd_2,                    &
                      numofloops_thred_infcrtdd_3,                    &
#endif
                      b_use_fixed_flow_vel, fixed_flow_vel,           &
                      b_use_zero_flow_vel,                            &
                      tor_corr_a_mq, tor_corr_b_mq,                   &
                      b_water_freezing, rank, b_enable_output

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none

      real*8, external :: fluxdd, pressure_melt_k

      integer :: nvxgls, nvxgle, nvxgbl, nvygls, nvygle, nvygbl,       &
                 nvzgls, nvzgle, nvzgbl, ivxgbl, ivygbl, ivzgbl,       &
                 ivxpgbl, ivypgbl, ivzpgbl, ivxngbl, ivyngbl, ivzngbl, &
                 nvx, nvy, nvz, type_diffu, type_diff_ic,              &
                 idbg, ilog, nzn, nc, mprop(*), isymm(njamxc),         &
                 ia(nmax+1), ja(njamxc)

      logical :: half_cells, fully_saturated, variably_saturated,      &
                 tortuosity_corr,diff_coff,assigned_tau,               &
                 harmonic_porosity,av_dens_z,radial_coord

      real*8 :: diffu, frozen_diffu, tkel(nmax), diff_ic(nc),          &
                disx(nzn), disy(nzn), disz(nzn),                       &
                pornew(nmax), uvsnew(nmax),                            &
                density(nmax), zg(nmax), viscosity(nmax),              &
                relperm(nmax),sanew(nmax), d(3,nmax),                  &
                cinfvs(njamxc), cinfrt_va(njamxc),                     &
                cinfrt_da(njamxc),cinfrt_da_ic(nc,njamxc),tau(nmax),   &
                cinfrad(njamxc), tau_fac(nmax),                        &
                marchies(nmax),sonew(nmax)
     
      real*8 :: delx(nvx),dely(nvy),delz(nvz),ups_heat,rpel_av,        &
                visco_av,gacc     
     
      character(len=*) :: type_tortuosity

      real*8 :: value_tau

      type(tensor) :: diffu_tensor, diff_ic_tensor(nc)
      
      
!c     local variables
      
      integer :: info_debug, ic, njamxc, nmax

      real*8, parameter :: eps = 1.0d-300, r0 = 0.0d0,                &
                rhalf = 0.5d0, r1 = 1.0d0, r2 = 2.0d0

      real*8 :: aread(3,12),areax(3,12),vel(3),dist(3,12),             &
                porav, satav, vx2, vy2, vz2, vmag,                     &
                tend(3), areai, diffav, diff_eff,  disx_avg, disy_avg, &
                disz_avg, dflux, delp_dd, delz_dd,                     &
                rho_av, dvolcoef, time, tfinal,tauav, marchieav
     
!c      added for dgm model
      real*8 :: so_av           
      
!cprovi    changed: Nov. 09, added for harmonic averaging
      real*8 :: diff_i,diff_j,diff_ij,areaf,por_i,por_j,              &                
                delx_i,dely_i,delz_i,delx_j,dely_j,delz_j,            &
                tau_i, tau_j

      type(tensor) :: diffav_tensor, diff_eff_tensor,                 &
                      diff_i_tensor, diff_j_tensor
     
      integer :: ibk, ivz, ivy, ivx, ibkz, ibky,                      &
                 ii, id, ixx, iyy, izz, iisav,                        &
                 idim, npair(3), iface(3,12), ndim,                   &
                 fvpair(3,12,2), ipair, idim2, idim3, irk_ibk, irk_id
    
!cprovi    changed: Nov. 09, added for harmonic averaging
      integer :: ivxp,ivxn,ivyp,ivyn,ivzp,ivzn,jtemp,nedge,           &
                 ivol,jvol,izn,jzn
#ifdef OPENMP      
      integer :: nvols
#endif

      character*1 :: iups

!c  compute influence coefficients for advective flux terms
!c  (influence coefficients are equal Darcy flux = J_ij/A_ij)

      delx_i = r0
      dely_i = r0
      delz_i = r0
      delx_j = r0
      dely_j = r0
      delz_j = r0

!c  loop over control volumes

      info_debug = 0 
      ivol=0
      tau_i = r1
      tau_j = r1
#ifdef OPENMP      
      nvols = nvx * nvy * nvz
#endif
      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nvols > numofloops_thred_infcrtdd_1)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ibk, ibky, ibkz, id, idim, idim2, idim3,           &
    !$omp ii, iisav, ivx, ivy, ivz, ixx, iyy, izz,                    &
    !$omp delp_dd, delz_dd, dvolcoef, rho_av, rpel_av, visco_av)                  
    !$omp do schedule(static)
#endif
      do ivz = 1,nvz                !increments in z-direction         
        ibkz = (ivz-1)*nvx*nvy

        do ivy = 1,nvy              !increments in y-direction
          ibky = (ivy-1)*nvx
          
          do ivx = 1,nvx            !increments in x-direction 
            ibk = ibkz+ibky+ivx

!c  loop over three -ve faces

            do idim = 1,3           !loop over dimensions
              ixx = ivx
              iyy = ivy
              izz = ivz

!c  compute in -tive face direction only

              if (idim.eq.1) then           !in x-direction
                ixx = ixx-1
                id = ibk-1
                idim2 = 2
                idim3 = 3
              elseif (idim.eq.2) then       !in y-direction
                iyy = iyy-1
                id = ibk-nvx
                idim2 = 3
                idim3 = 1
              elseif (idim.eq.3) then       !in z-direction
                izz = izz-1
                id = ibk-nvx*nvy
                idim2 = 1
                idim3 = 2
              endif

!c  skip if edge

              if (ixx.le.0 .or. iyy.le.0 .or. izz.le.0) cycle

!c  find -ve face in row of connected cells to ibk

              do ii = ia(ibk),ia(ibk+1)-1
                if (ja(ii).eq.id) then
                  iisav = ii
                  go to 211
                endif
              end do
              if (rank == 0) then
                write(ilog,*) ' error-cannot find id in list-infcrtdd 1'
                write(ilog,*) ' ibk, id ', ibk, id
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
211           continue


!c  find darcy volume (not mass) flux between node pair

              delp_dd = uvsnew(id) - uvsnew(ibk)
              delz_dd = zg(id) - zg(ibk)

              if (delz_dd .ne. r0) then
                rho_av = rhalf * (density(ibk) + density(id))

!c  convert delz_dd to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
 
                delz_dd = delz_dd * rho_av * gacc
                delp_dd = delp_dd + delz_dd
           
              end if
                
!c  assign coefficients for upstream weighting
!c calculate water volume (not mass!!) fluxes
 
              
              if (delp_dd .gt. r0) then
              rpel_av=ups_heat*relperm(id)+           &
                      (r1-ups_heat)*relperm(ibk)
              visco_av=ups_heat*viscosity(id)+        &
                      (r1-ups_heat)*viscosity(ibk)       
              else          
               rpel_av=ups_heat*relperm(ibk)+           &
                      (r1-ups_heat)*relperm(id)
               visco_av=ups_heat*viscosity(ibk)+        &
                      (r1-ups_heat)*viscosity(id)               
              end if
              
              dvolcoef=rpel_av/visco_av

#ifdef OPENMP
    !$omp critical
#endif 
              if (b_use_fixed_flow_vel) then
                            
                if (b_use_zero_flow_vel) then
                  cinfrt_va(iisav) = r0
                  cinfrt_va(isymm(iisav)) = r0
                else
                  !c TBD
                end if
              
              else
                cinfrt_va(iisav) = - fluxdd(delp_dd,cinfvs(ii), &
                                     dvolcoef)

!c  matrix is symmetric n a symbolic sense, since cinfrt_va between 
!c  cell ibk and id is equal to - cinfrt_va between cells id and ibk

                cinfrt_va(isymm(iisav)) = - cinfrt_va(iisav)
              end if
#ifdef OPENMP
    !$omp end critical
#endif 
            end do            
          end do         
        end do
      end do      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif       

!c  compute the influence coefficients for dispersive flux terms
!c  loop over the number of "pseudo dispersion elements"

!c  zero the influence coefficient for dispersive flux term
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nvols > numofloops_thred_infcrtdd_2)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ibk, ii)                  
    !$omp do schedule(static)
#endif
      do ibk = 1, nmax
        do ii = ia(ibk),ia(ibk+1)-1
          cinfrt_da(ii) = r0
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!c  loop over control volumes
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nvols > numofloops_thred_infcrtdd_3)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ibk, id, idim, idim2, idim3, iface, ii, iisav,     &
    !$omp ipair, irk_id, irk_ibk, ivx, ivy, ivz, ivol, ivxp, ivxn,    &
    !$omp ivyp, ivyn, ivzp, ivzn, jtemp, jvol, jzn, ndim,             &
    !$omp ivxgbl, ivygbl, ivzgbl, ivxpgbl, ivypgbl, ivzpgbl,          &
    !$omp ivxngbl, ivyngbl, ivzngbl,                                  &
    !$omp areax, aread, areai, areaf, delp_dd, delz_dd, dflux,        &
    !$omp delx_i, delx_j, dely_i, dely_j, delz_i, delz_j, dist,       &
    !$omp diffav, diffav_tensor, diff_eff, diff_eff_tensor,           &
    !$omp diff_i, diff_ij, diff_j, diff_i_tensor, diff_j_tensor,      &
    !$omp disx_avg, disy_avg, disz_avg, dvolcoef, fvpair,             &
    !$omp marchieav, npair, porav, por_i, por_j, rho_av, satav,       &
    !$omp tauav, tau_i, tau_j, tend, vel, vmag, vx2, vy2, vz2,        &
    !$omp so_av)                                                      
    !$omp do schedule(static)
#endif
      do ivz = 1, nvz        !increments in z-direction
        ivzgbl = ivz+nvzgls-1  
        do ivy = 1, nvy      !increments in y-direction
          ivygbl = ivy+nvygls-1  
          do ivx = 1, nvx    !increments in x-direction
            ivxgbl = ivx+nvxgls-1
!c  find node pairs for elemental velocities as well
!c  as influence coefficient for node pairs within dipersion element

!            call cliqdisp (nvx, nvy, nvz, ivx, ivy, ivz,
!     &                     fvpair, npair, aread, d, half_cells,
!    &                     nmax,idbg)
            call cliqdisp (nvx, nvy, nvz, ivx, ivy, ivz,              &
                          fvpair, npair,aread,areax,dist,d,           & 
                          half_cells, ia, ja, njamxc,                 &
                          nmax, idbg, cinfrad, radial_coord)

!c  check if fully connected "pseudo dispersion element"
!c  was found for dimensionality of problem

            if ((nvx .gt. 1 .and. npair(1) .eq. 0) .or.               &
               (nvy .gt. 1 .and. npair(2) .eq. 0) .or.                &
               (nvz .gt. 1 .and. npair(3) .eq. 0)) cycle

!c loop over the dimensions x,y,z

              do idim = 1, 3

                idim2 = idim + 1
                idim3 = idim + 2
                if (idim2 .gt. 3) idim2 = idim2 - 3
                if (idim3 .gt. 3) idim3 = idim3 - 3

!c  zero advective velocity

                vel(idim) = r0

!c  loop over the number of node pairs in the dimension

                do ipair = 1, npair(idim)

                  ibk = fvpair(idim, ipair, 1)
                  id = fvpair(idim, ipair, 2)

                  do ii = ia(ibk), ia(ibk+1)-1
                    if (ja(ii) .eq. id) then
                      iisav = ii
                      go to 431
                    endif
                  end do
                  if (rank == 0) then
                    write(ilog,*) ' error-cannot find id in list-infcrtdd 2'
                    write(ilog,*) ' ibk, id ', ibk, id
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop
431               continue
                  iface(idim, ipair) = iisav

!c  calculate average interfacial area between nodes
                  if (.not.b_use_fixed_flow_vel) then
!cprovi------------------------------------------------
!cprovi Assign the interfacial area
!cprovi------------------------------------------------                
                    areai = areax(idim, ipair)

!c  find darcy volume (not mass) flux between node pair

                    delp_dd = uvsnew(id) - uvsnew(ibk)
                    delz_dd = zg(id) - zg(ibk)

                    if (delz_dd .ne. r0) then
                      rho_av = rhalf * (density(ibk) + density(id))

!c  convert delz_dd to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential
                      if (av_dens_z) then  
                        delp_dd=rho_av*(uvsnew(id)/density(id)-    &
                                uvsnew(ibk)/density(ibk))
                      end if
                      delz_dd = delz_dd * rho_av * gacc
                      delp_dd = delp_dd + delz_dd
           
                    end if
                
!c  assign coefficients for upstream weighting
!c calculate water volume (not mass!!) fluxes
 
                    if (delp_dd .gt. r0) then
                      dvolcoef = relperm(id)/viscosity(id)       
                    else          
                      dvolcoef = relperm(ibk)/viscosity(ibk)          
                    end if
                   
                    dflux = - fluxdd(delp_dd,cinfvs(iisav),   &
                                     dvolcoef)

!c  velocity is the flux (m^3/day) divided
!c  by the interfacial area between the two nodes

                    vel(idim) = vel(idim) + dflux / areai
                  end if

                end do !ipair = 1, npair(idim)
               
!c  find the average elemental velocity in the
!c  x,y,z directions

                if (.not.b_use_fixed_flow_vel) then
                  vel(idim) = vel(idim)/(float( npair(idim) ) + eps)
                end if
              end do !idim = 1, 3

              if (b_use_fixed_flow_vel) then
                vel(1) = fixed_flow_vel%x
                vel(2) = fixed_flow_vel%y
                vel(3) = fixed_flow_vel%z
              end if

!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
!cprovi Not harmonic average in porosity 
!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
      
              if (.not.harmonic_porosity) then  


!c  average porosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element
                porav = r0
                do idim = 1, 3
                   do ipair = 1, npair(idim)
                      ibk = fvpair(idim, ipair, 1)
                      id = fvpair(idim, ipair, 2)
                      porav = porav                       &
                           + dmin1( r1, pornew(ibk) )     &
                           + dmin1( r1, pornew(id) )
                   end do
                end do 

                ndim = 0
                if (nvx .gt. 1) ndim = ndim + 1
                if (nvy .gt. 1) ndim = ndim + 1
                if (nvz .gt. 1) ndim = ndim + 1
                porav = porav / float(ndim) / r2**ndim
            
!c  average tortuosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element
                if (assigned_tau) then
                  tauav = r0
                  do idim = 1, 3
                    do ipair = 1, npair(idim)
                      ibk = fvpair(idim, ipair, 1)
                      id = fvpair(idim, ipair, 2)
 !c                     tauav = tauav                                 &
 !c                           + dmin1( r1, tau(ibk) * tau_fac(ibk) )  &
 !c                           + dmin1( r1, tau(id) * tau_fac(id) )
                      tauav = tauav                                   &
                            + tau(ibk) * tau_fac(ibk)                 &
                            + tau(id) * tau_fac(id)
                    end do
                  end do 

                  ndim = 0
                  if (nvx .gt. 1) ndim = ndim + 1
                  if (nvy .gt. 1) ndim = ndim + 1
                  if (nvz .gt. 1) ndim = ndim + 1
                  tauav = tauav / float(ndim) / r2**ndim
                end if

!c  calculate average dispersivities for the "pseudo
!c  dispersion element"

                diffav = r0
                diffav_tensor = tensor_zero
                disx_avg = r0
                disy_avg = r0
                disz_avg = r0

                do idim = 1, 3                     !loop over dimensions
                  do ipair = 1, npair(idim)        !node pairs

                    ibk = fvpair(idim, ipair, 1)
                    id = fvpair(idim, ipair, 2)

!c  material property -> currently hardwired

                    irk_ibk = mprop(ibk)
                    irk_id = mprop(id)

                    if (type_diffu == 0) then
                      diffav = diffav                      &
                             + diffu                       &
                             + diffu
                    else if (type_diffu > 0) then
                      diffav_tensor = diffav_tensor        &
                             + diffu_tensor                &
                             + diffu_tensor
                    end if

                    disx_avg = disx_avg         &
                             + disx(irk_ibk)    &
                             + disx(irk_id)

                    disy_avg = disy_avg         &
                             + disy(irk_ibk)    &
                             + disy(irk_id)

                    disz_avg = disz_avg         &
                             + disz(irk_ibk)    &
                             + disz(irk_id)

                  end do                            !node pairs
                end do                              !dimensions 
                if (type_diffu == 0) then
                  diffav = diffav / float(ndim) / r2**ndim
                else if (type_diffu > 0) then
                  diffav_tensor = diffav_tensor / (float(ndim) * r2**ndim)
                end if

                disx_avg = disx_avg / float(ndim) / r2**ndim
                disy_avg = disy_avg / float(ndim) / r2**ndim
                disz_avg = disz_avg / float(ndim) / r2**ndim

                if (b_water_freezing) then
                  if (tkel(ibk) < pressure_melt_k(ibk,r0) .or.         &
                      tkel(id) < pressure_melt_k(id,r0)) then
                    if (type_diffu == 0) then
                      diffav = diffav*frozen_diffu
                    else if (type_diffu > 0) then
                      diffav_tensor = diffav_tensor*frozen_diffu
                    end if
                  end if
                end if  

!c  calculate the dispersion tensor for the "pseudo dispersion element"
!c  average porosity of the element

                satav = r0
                so_av = r0
                do idim = 1, 3
                  do ipair = 1, npair(idim)
                    ibk = fvpair(idim, ipair, 1)
                    id = fvpair(idim, ipair, 2)
                    satav = satav                     &
                          + dmin1( r1, sanew(ibk) )   &
                          + dmin1( r1, sanew(id) )
                        so_av = so_av                     &
                          + dmin1( r1, sonew(ibk) )   &
                          + dmin1( r1, sonew(id) ) 
                  end do
                end do
                satav = satav / float(ndim) / r2**ndim
                so_av = so_av / float(ndim) / r2**ndim
                        vx2 = vel(1)**2
                vy2 = vel(2)**2
                vz2 = vel(3)**2
                vmag = dsqrt(vx2 + vy2 + vz2)
                vx2 = vx2 / (vmag + eps)
                vy2 = vy2 / (vmag + eps)
                vz2 = vz2 / (vmag + eps)
               
!c  calculate the average marchie factor

                marchieav = r0
                do idim = 1, 3
                   do ipair = 1, npair(idim)
                      ibk = fvpair(idim, ipair, 1)
                      id = fvpair(idim, ipair, 2)
                      marchieav = marchieav + marchies(ibk) + marchies(id)
                   end do
                end do
                marchieav = marchieav / float(ndim) / r2**ndim 

!c  calculate effective diffusion coefficient
                if (.not.diff_coff) then
                  if (type_diffu == 0) then
                    diff_eff = diffcoff(diffav,satav,porav,       &
                                        tortuosity_corr,          &
                                        assigned_tau,tauav,       &
                                        type_tortuosity,          &
                                        marchieav,so_av,          &
                                        tor_corr_a_mq,            &
                                        tor_corr_b_mq)

                    tend(1) = disx_avg * vx2                      &
                            + disy_avg * vy2                      &
                            + disz_avg * vz2                      &
                            + diff_eff

                    tend(2) = disy_avg * vx2                      &
                            + disx_avg * vy2                      &
                            + disz_avg * vz2                      &
                            + diff_eff

                    tend(3) = disz_avg * vx2                      &
                            + disz_avg * vy2                      &
                            + disx_avg * vz2                      &
                            + diff_eff
                  else if (type_diffu > 0) then
                    diff_eff_tensor =                             &
                               diffcoff(diffav_tensor,satav,porav,&
                                        tortuosity_corr,          &
                                        assigned_tau,tauav,       &
                                        type_tortuosity,          &
                                        marchieav,so_av,          &
                                        tor_corr_a_mq,            &
                                        tor_corr_b_mq)

                    tend(1) = disx_avg * vx2                      &
                            + disy_avg * vy2                      &
                            + disz_avg * vz2                      &
                            + diff_eff_tensor%xx

                    tend(2) = disy_avg * vx2                      &
                            + disx_avg * vy2                      &
                            + disz_avg * vz2                      &
                            + diff_eff_tensor%yy

                    tend(3) = disz_avg * vx2                      &
                            + disz_avg * vy2                      &
                            + disx_avg * vz2                      &
                            + diff_eff_tensor%zz
                  end if

!c  build total influence coefficient from all elemental contributions
#ifdef OPENMP
    !$omp critical
#endif 
                  do idim = 1, 3                   !loop over dimensions
 
!c  adjust for 1d-, 2d, 3d - discretization
                    do ipair = 1, npair(idim)             !node pairs
  
                      iisav = iface(idim, ipair)

                      cinfrt_da(iisav) = cinfrt_da(iisav)        &
                                       + tend(idim)              &
                                       * aread(idim, ipair)

                      cinfrt_da(isymm(iisav)) =                  &
                                 cinfrt_da(isymm(iisav))         &
                                 + tend(idim) * aread(idim, ipair)

                    end do                                !node pairs
                    
                  end do                           !loop over dimensions
#ifdef OPENMP
    !$omp end critical
#endif 
                else 
                  do ic = 1,nc

                    if (type_diff_ic == 0) then
                      diff_eff = diffcoff(diff_ic(ic),satav,porav,           &
                                          tortuosity_corr,assigned_tau,      &
                                          tauav,type_tortuosity,marchieav,   &
                                          so_av,tor_corr_a_mq,tor_corr_b_mq)
                      tend(1) = disx_avg * vx2 + disy_avg * vy2              &
                              + disz_avg * vz2 + diff_eff
                  
                      tend(2) = disy_avg * vx2 + disx_avg * vy2              &
                              + disz_avg * vz2 + diff_eff
                  
                      tend(3) = disz_avg * vx2 + disz_avg * vy2              & 
                              + disx_avg * vz2 + diff_eff
                    else if (type_diff_ic > 0) then
                      diff_eff_tensor = diffcoff(diff_ic_tensor(ic),         &
                                        satav,porav,tortuosity_corr,         &
                                        assigned_tau,tauav,type_tortuosity,  &
                                        marchieav,so_av,                     &
                                        tor_corr_a_mq,tor_corr_b_mq)
                      tend(1) = disx_avg * vx2 + disy_avg * vy2              &
                              + disz_avg * vz2 + diff_eff_tensor%xx
                  
                      tend(2) = disy_avg * vx2 + disx_avg * vy2              &
                              + disz_avg * vz2 + diff_eff_tensor%yy
                  
                      tend(3) = disz_avg * vx2 + disz_avg * vy2              & 
                              + disx_avg * vz2 + diff_eff_tensor%zz
                    end if
#ifdef OPENMP
    !$omp critical
#endif 
                    do idim = 1, 3                   !loop over dimensions
 
!c  adjust for 1d-, 2d, 3d - discretization

                      do ipair = 1, npair(idim)             !node pairs
  
                        iisav = iface(idim, ipair)

                        cinfrt_da_ic(ic,iisav) =                     &
                                     cinfrt_da_ic(ic,iisav)          &
                                      + tend(idim)                   &
                                      * aread(idim, ipair)

                        cinfrt_da_ic(ic,isymm(iisav)) =              &
                                     cinfrt_da_ic(ic,isymm(iisav))   &
                                     + tend(idim)                    &
                                     * aread(idim, ipair)

                      end do                                !node pairs
                    end do                             !loop over dimensions 
#ifdef OPENMP
    !$omp end critical
#endif 
                  end do
                end if  
!cprovi-----------------------------------------------------------------------
!cprovi-----------------------------------------------------------------------           
              else ! Harmonic porosity

!c  average porosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element
!c    changed Nov.09
                ndim = 0
                if (nvx .gt. 1) ndim = ndim + 1
                if (nvy .gt. 1) ndim = ndim + 1
                if (nvz .gt. 1) ndim = ndim + 1
!c  calculate average dispersivities for the "pseudo
!c  dispersion element"

                diffav = r0
                diffav_tensor = tensor_zero
                disx_avg = r0
                disy_avg = r0
                disz_avg = r0

                do idim = 1, 3                      !loop over dimensions
                  do ipair = 1, npair(idim)        !node pairs

                    ibk = fvpair(idim, ipair, 1)
                    id = fvpair(idim, ipair, 2)

!c  material property -> currently hardwired

                    irk_ibk = mprop(ibk)
                    irk_id = mprop(id)

                    disx_avg = disx_avg       &
                             + disx(irk_ibk)  &
                             + disx(irk_id)

                    disy_avg = disy_avg       &
                             + disy(irk_ibk)  &
                             + disy(irk_id)

                    disz_avg = disz_avg       &
                             + disz(irk_ibk)  &
                             + disz(irk_id)

                  end do                          !node pairs
                end do                            !dimensions

                disx_avg = disx_avg / float(ndim) / r2**ndim
                disy_avg = disy_avg / float(ndim) / r2**ndim
                disz_avg = disz_avg / float(ndim) / r2**ndim

!c  calculate the dispersion tensor for the "pseudo dispersion element"
!c  average porosity of the element
!c    changed: Nov. 09
                vx2 = vel(1)**2
                vy2 = vel(2)**2
                vz2 = vel(3)**2
                vmag = dsqrt(vx2 + vy2 + vz2)
                vx2 = vx2 / (vmag + eps)
                vy2 = vy2 / (vmag + eps)
                vz2 = vz2 / (vmag + eps)

!c  calculate effective diffusion coefficient
!c    changed: Nov. 09            

                tend(1) = disx_avg * vx2    &
                        + disy_avg * vy2    &
                        + disz_avg * vz2


                tend(2) = disy_avg * vx2    &
                        + disx_avg * vy2    &
                        + disz_avg * vz2


                tend(3) = disz_avg * vx2    &
                        + disz_avg * vy2    &
                        + disx_avg * vz2


!c  build total influence coefficient from all elemental contributions
#ifdef OPENMP
    !$omp critical
#endif 
                do idim = 1, 3                  !loop over dimensions
!c  adjust for 1d-, 2d, 3d - discretization
                  do ipair = 1, npair(idim)            !node pairs 
                    iisav = iface(idim, ipair)
                    cinfrt_da(iisav) = cinfrt_da(iisav)     &
                                     + tend(idim)           &
                                     * aread(idim, ipair)

                    cinfrt_da(isymm(iisav)) =               &
                                    cinfrt_da(isymm(iisav)) &
                                    + tend(idim)            &
                                    * aread(idim, ipair)
                  end do                                !node pairs
                end do                                  !loop over dimensions
#ifdef OPENMP
    !$omp end critical
#endif 
!c    changed: Nov.09. add diffusion

!c  pointer to current control volume
#ifdef OPENMP
                ivol = ((ivz-1)*nvy + ivy-1) * nvx + ivx
#else
                ivol = ivol+1
#endif    
                jtemp = ia(ivol)

!c  assign conductivities for current control volume
!c    changed: Nov. 09, not used for the time being

           
                por_i = pornew(ivol) !assign porosity
                if (assigned_tau) then
                  tau_i = tau(ivol)*tau_fac(ivol)    !
                end if 
                satav = dmin1(r1, sanew(ivol))
                so_av = dmin1(r1, sonew(ivol))
                marchieav = marchies(ivol)

                if (type_diffu == 0) then
                  diffav = diffu
                  diff_i = diffcoff(diffav,satav,por_i,tortuosity_corr,& 
                                   assigned_tau,tau_i,type_tortuosity, &
                                   marchieav,so_av,                    &
                                   tor_corr_a_mq,tor_corr_b_mq) 
                else if (type_diffu > 0) then
                  diffav_tensor = diffu_tensor
                  diff_i_tensor = diffcoff(                            &
                          diffav_tensor,satav,por_i,tortuosity_corr,   & 
                          assigned_tau,tau_i,type_tortuosity,          &
                          marchieav,so_av,                             &
                          tor_corr_a_mq,tor_corr_b_mq) 
                end if
                             
                if (b_water_freezing) then
                  if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                    if (type_diffu == 0) then
                      diff_i = diff_i*frozen_diffu
                    else if (type_diffu > 0) then
                      diff_i_tensor = diff_i_tensor*frozen_diffu
                    end if
                  end if
                end if

                jtemp = jtemp+1          ! skip diagonal

!c  pointers to previous colums in x,y and z

                ivxp = ivx-1
                ivxn = ivx+1
                ivyp = ivy-1
                ivyn = ivy+1
                ivzp = ivz-1
                ivzn = ivz+1
            
                ivxpgbl = ivxgbl-1
                ivxngbl = ivxgbl+1
                ivypgbl = ivygbl-1
                ivyngbl = ivygbl+1
                ivzpgbl = ivzgbl-1
                ivzngbl = ivzgbl+1

!c  assign interfacial distances of current control volume

                if (half_cells) then            !half_cells on boundary

                  if (nvx.gt.1) then                        !in x-direction
                    if (ivxgbl.eq.1.or.ivxgbl.eq.nvxgbl) then        !boundary
                      delx_i = delx(ivxgbl)
                    elseif (ivxgbl.gt.0.and.ivxgbl.lt.nvxgbl) then  !interior
                      delx_i = rhalf*delx(ivxgbl) 
                    end if
                  end if

                  if (nvy.gt.1) then                        !in y-direction
                    if (ivygbl.eq.1.or.ivygbl.eq.nvygbl) then        !boundary
                      dely_i = dely(ivygbl)
                    elseif (ivygbl.gt.0.and.ivygbl.lt.nvygbl) then  !interior
                      dely_i = rhalf*dely(ivygbl) 
                    end if
                  end if

                  if (nvz.gt.1) then                        !in z-direction
                    if (ivzgbl.eq.1.or.ivzgbl.eq.nvzgbl) then        !boundary
                      delz_i = delz(ivzgbl)
                    elseif (ivzgbl.gt.0.and.ivzgbl.lt.nvzgbl) then  !interior
                      delz_i = rhalf*delz(ivzgbl) 
                    end if
                  end if

                else                            !full cells on boundary

                  if (nvx.gt.1) then                        !in x-direction
                    delx_i = rhalf*delx(ivxgbl) 
                  end if

                  if (nvy.gt.1) then                        !in y-direction
                    dely_i = rhalf*dely(ivygbl) 
                  end if

                  if (nvz.gt.1) then                        !in z-direction
                    delz_i = rhalf*delz(ivzgbl) 
                  end if

                end if                          !(half_cells)

!c  calculate influence coefficients in x-direction

                if (nvx.gt.1) then              !connections in x-direction

                  if (ivxp.gt.0) then          !left connection  (2)
                    areaf = dely(ivygbl)*delz(ivzgbl)
                    if (half_cells) then        !half cells on boundary
                      if (ivxpgbl.eq.1) then
                        delx_j = delx(ivxpgbl)
                      elseif (ivxpgbl.gt.1) then
                        delx_j = rhalf*delx(ivxpgbl)       
                      end if
                    else                        !full cells on boundary
                      delx_j = rhalf*delx(ivxpgbl)       
                    end if                      !(half_cells)
                    jvol = ja(jtemp)             
                    jzn = mprop(jvol)
                 
                    por_j = pornew(jvol)
                    if (assigned_tau) then
                     tau_j = tau(jvol)*tau_fac(jvol)    !
                    end if 

                    satav = dmin1(r1, sanew(jvol))
                    so_av = dmin1(r1, sonew(jvol))
                    marchieav = marchies(jvol)

                    if (type_diffu == 0) then
                      diffav = diffu
                      diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,  &
                                       assigned_tau,tau_j,type_tortuosity,   &
                                       marchieav,so_av,                      &
                                       tor_corr_a_mq,tor_corr_b_mq)
                    else if (type_diffu > 0) then
                      diffav_tensor = diffu_tensor
                      diff_j_tensor = diffcoff(                              &
                              diffav_tensor,satav,por_j,tortuosity_corr,     &
                              assigned_tau,tau_j,type_tortuosity,            &
                              marchieav,so_av,                               &
                              tor_corr_a_mq,tor_corr_b_mq)
                    end if

                    if (b_water_freezing) then
                      if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                        if (type_diffu == 0) then                        
                          diff_j = diff_j*frozen_diffu
                        else if (type_diffu > 0) then
                          diff_j_tensor = diff_j_tensor*frozen_diffu
                        end if
                      end if
                    end if                                 

!c  permeability update due to porosity changes

                    if (type_diffu > 0) then
                      diff_i = diff_i_tensor%xx
                      diff_j = diff_j_tensor%xx
                    end if

                    diff_ij = diff_i*diff_j

                    if(diff_ij.gt.0.0) then
                      cinfrt_da(jtemp) =  cinfrt_da(jtemp)+                  &
                            diff_ij*areaf/(diff_i*delx_j+ diff_j*delx_i)
                    endif

                    jtemp = jtemp+1
                  end if

                  if (ivxn.le.nvx) then        !right connection  (3)
                    areaf = dely(ivygbl)*delz(ivzgbl)
                    if (half_cells) then        !half cells on boundary
                      if (ivxngbl.eq.nvxgbl) then
                        delx_j = delx(ivxngbl)
                      elseif (ivxngbl.lt.nvxgbl) then
                        delx_j = rhalf*delx(ivxngbl)       
                      end if
                    else                        !full cells on boundary
                      delx_j = rhalf*delx(ivxngbl)
                    end if                      !(half_cells)
                    jvol = ja(jtemp)             
                    jzn = mprop(jvol)
             
                    por_j = pornew(jvol)
                    if (assigned_tau) then
                     tau_j = tau(jvol)*tau_fac(jvol)    !
                    end if

                    satav = dmin1(r1, sanew(jvol))
                    so_av = dmin1(r1, sonew(jvol))
                    marchieav = marchies(jvol)

                    if (type_diffu == 0) then
                      diffav = diffu
                      diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,  &
                                       assigned_tau,tau_j,type_tortuosity,   &
                                       marchieav,so_av,                      &
                                       tor_corr_a_mq,tor_corr_b_mq)
                    else
                      diffav_tensor = diffu_tensor
                      diff_j_tensor = diffcoff(                              &
                              diffav_tensor,satav,por_j,tortuosity_corr,     &
                              assigned_tau,tau_j,type_tortuosity,            &
                              marchieav,so_av,                               &
                              tor_corr_a_mq,tor_corr_b_mq)
                    end if

                    if (b_water_freezing) then
                      if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                        if (type_diffu == 0) then
                          diff_j = diff_j*frozen_diffu
                        else
                          diff_j_tensor = diff_j_tensor*frozen_diffu
                        end if
                      end if
                    end if                                 

!c  permeability update due to porosity changes

                    if (type_diffu > 0) then
                      diff_i = diff_i_tensor%xx
                      diff_j = diff_j_tensor%xx
                    end if

                    diff_ij = diff_i*diff_j

                    if(diff_ij.gt.0.0) then
                      cinfrt_da(jtemp) =  cinfrt_da(jtemp)+                  &
                           diff_ij*areaf/(diff_i*delx_j+diff_j*delx_i)
                    endif
                    jtemp = jtemp+1
                  end if

                end if                          !connections in x-direction

!c  calculate influence coefficients in y-direction

                if (nvy.gt.1) then              !connections in y-direction

                  if (ivyp.gt.0) then          !front connection (4)
                    areaf = delx(ivxgbl)*delz(ivzgbl)
                    if (half_cells) then        !half cells on boundary
                      if (ivypgbl.eq.1) then
                        dely_j = dely(ivypgbl)
                      elseif (ivypgbl.gt.1) then
                        dely_j = rhalf*dely(ivypgbl)       
                      end if
                    else                        !full cells on boundary
                    dely_j = rhalf*dely(ivypgbl)       
                  end if                      !(half_cells)
                  jvol = ja(jtemp)             
                  jzn = mprop(jvol)
                 
                  por_j = pornew(jvol)
                  if (assigned_tau) then
                    tau_j = tau(jvol)*tau_fac(jvol)    !
                  end if

                  satav = dmin1(r1, sanew(jvol))
                  so_av = dmin1(r1, sonew(jvol))
                  marchieav = marchies(jvol)

                  if (type_diffu == 0) then
                    diffav = diffu
                    diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,    & 
                                     assigned_tau,tau_j,type_tortuosity,     &
                                     marchieav,so_av,                        &
                                     tor_corr_a_mq,tor_corr_b_mq)
                  else if (type_diffu > 0) then
                    diffav_tensor = diffu_tensor
                    diff_j_tensor = diffcoff(                                &
                            diffav_tensor,satav,por_j,tortuosity_corr,       & 
                            assigned_tau,tau_j,type_tortuosity,              &
                            marchieav,so_av,                                 &
                            tor_corr_a_mq,tor_corr_b_mq)
                  end if

                  if (b_water_freezing) then
                    if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                      if (type_diffu == 0) then
                        diff_j = diff_j*frozen_diffu
                      else if (type_diffu > 0) then
                        diff_j_tensor = diff_j_tensor*frozen_diffu
                      end if
                    end if
                  end if                                  

!c  permeability update due to porosity changes

                  if (type_diffu > 0) then
                    diff_i = diff_i_tensor%yy
                    diff_j = diff_j_tensor%yy
                  end if

                  diff_ij = diff_i*diff_j

                  if(diff_ij.gt.0.0) then
                    cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                         diff_ij*areaf/(diff_i*dely_j+diff_j*dely_i)
                  endif
                  jtemp = jtemp+1
                end if

                if (ivyn.le.nvy) then        !back connection (5)
                  areaf = delx(ivxgbl)*delz(ivzgbl)
                  if (half_cells) then        !half cells on boundary
                    if (ivyngbl.eq.nvygbl) then
                      dely_j = dely(ivyngbl)
                    elseif (ivyngbl.lt.nvygbl) then
                      dely_j = rhalf*dely(ivyngbl)
                    end if
                  else                        !full cells on boundary
                    dely_j = rhalf*dely(ivyngbl)
                  end if                      !(half_cells)
                  jvol = ja(jtemp)             
                  jzn = mprop(jvol)
             
                  por_j = pornew(jvol)
                  if (assigned_tau) then
                   tau_j = tau(jvol)*tau_fac(jvol)    !
                  end if

                  satav = dmin1(r1, sanew(jvol))
                  so_av = dmin1(r1, sonew(jvol))
                  marchieav = marchies(jvol)

                  if (type_diffu == 0) then
                    diffav = diffu
                    diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,    & 
                                     assigned_tau,tau_j,type_tortuosity,     &
                                     marchieav,so_av,                        &
                                     tor_corr_a_mq,tor_corr_b_mq)
                  else if (type_diffu > 0) then
                    diffav_tensor = diffu_tensor
                    diff_j_tensor = diffcoff(                                &
                            diffav_tensor,satav,por_j,tortuosity_corr,       & 
                            assigned_tau,tau_j,type_tortuosity,              &
                            marchieav,so_av,                                 &
                            tor_corr_a_mq,tor_corr_b_mq)
                  end if

                  if (b_water_freezing) then
                    if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                      if (type_diffu == 0) then
                        diff_j = diff_j*frozen_diffu
                      else if (type_diffu > 0) then
                        diff_j_tensor = diff_j_tensor*frozen_diffu
                      end if
                    end if
                  end if                                  

!c  permeability update due to porosity changes

                  if (type_diffu > 0) then
                    diff_i = diff_i_tensor%yy
                    diff_j = diff_j_tensor%yy
                  end if

                  diff_ij = diff_i*diff_j

                  if(diff_ij.gt.0.0) then
                    cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                         diff_ij*areaf/(diff_i*dely_j+diff_j*dely_i)
                  endif

                  jtemp = jtemp+1
                end if

              endif                          !connections in y-direction

!c  calculate influence coefficients in z-direction

              if (nvz.gt.1) then              !connections in z-direction

                if (ivzp.gt.0) then          !bottom connection (6)
                  areaf = delx(ivxgbl)*dely(ivygbl)
                  if (half_cells) then        !half cells on boundary
                    if (ivzpgbl.eq.1) then
                      delz_j = delz(ivzpgbl)
                    elseif (ivzpgbl.gt.1) then
                      delz_j = rhalf*delz(ivzpgbl)       
                    end if
                  else                        !full cells on boundary
                    delz_j = rhalf*delz(ivzpgbl)       
                  end if                      !(half_cells)
                  jvol = ja(jtemp)             
                  jzn = mprop(jvol)
             
                  por_j = pornew(jvol)
                  if (assigned_tau) then
                   tau_j = tau(jvol)*tau_fac(jvol)    !
                  end if

                  satav = dmin1(r1, sanew(jvol))
                  so_av = dmin1(r1, sonew(jvol))
                  marchieav = marchies(jvol)

                  if (type_diffu == 0) then
                    diffav = diffu
                    diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,    & 
                                     assigned_tau,tau_j,type_tortuosity,     &
                                     marchieav,so_av,                        &
                                     tor_corr_a_mq,tor_corr_b_mq)
                  else if (type_diffu > 0) then
                    diffav_tensor = diffu_tensor
                    diff_j_tensor = diffcoff(                                &
                            diffav_tensor,satav,por_j,tortuosity_corr,       & 
                            assigned_tau,tau_j,type_tortuosity,              &
                            marchieav,so_av,                                 &
                            tor_corr_a_mq,tor_corr_b_mq)
                  end if

                  if (b_water_freezing) then
                    if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                      if (type_diffu == 0) then
                        diff_j = diff_j*frozen_diffu
                      else if (type_diffu > 0) then
                        diff_j_tensor = diff_j_tensor*frozen_diffu
                      end if
                    end if
                  end if                 

!c  permeability update due to porosity changes

                  if (type_diffu > 0) then
                    diff_i = diff_i_tensor%zz
                    diff_j = diff_j_tensor%zz
                  end if

                  diff_ij = diff_i*diff_j

                  if(diff_ij.gt.0.0) then
                    cinfrt_da(jtemp) =  cinfrt_da(jtemp)+              &
                         diff_ij*areaf/(diff_i*delz_j+diff_j*delz_i)
                  endif

                  jtemp = jtemp+1
                end if

                if (ivzn.le.nvz) then        !top connection (7)
                  areaf = delx(ivxgbl)*dely(ivygbl)
                  if (half_cells) then        !half cells on boundary
                    if (ivzngbl.eq.nvzgbl) then
                      delz_j = delz(ivzngbl)
                    elseif (ivzngbl.lt.nvzgbl) then
                      delz_j = rhalf*delz(ivzngbl)
                    end if
                  else                        !full cells on boundary
                    delz_j = rhalf*delz(ivzngbl)
                  end if                      !(half_cells)
                  jvol = ja(jtemp)             
                  jzn = mprop(jvol)
               
                  por_j = pornew(jvol)
                  if (assigned_tau) then
                   tau_j = tau(jvol)*tau_fac(jvol)    !
                  end if

                  satav = dmin1(r1, sanew(jvol))        !satav=dmin1(r1, sanew(ivol)), bug? DSU 2013-2-28
                  so_av = dmin1(r1, sonew(jvol))
                  marchieav = marchies(jvol)

                  if (type_diffu == 0) then
                    diffav = diffu
                    diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,    & 
                                     assigned_tau,tau_j,type_tortuosity,     &
                                     marchieav,so_av,                        &
                                     tor_corr_a_mq,tor_corr_b_mq)
                  else if (type_diffu > 0) then
                    diffav_tensor = diffu_tensor
                    diff_j_tensor = diffcoff(                                &
                            diffav_tensor,satav,por_j,tortuosity_corr,       & 
                            assigned_tau,tau_j,type_tortuosity,              &
                            marchieav,so_av,                                 &
                            tor_corr_a_mq,tor_corr_b_mq)
                  end if

                  if (b_water_freezing) then
                    if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                      if (type_diffu == 0) then
                        diff_j = diff_j*frozen_diffu
                      else if (type_diffu > 0) then
                        diff_j_tensor = diff_j_tensor*frozen_diffu
                      end if
                    end if
                  end if 
!c  permeability update due to porosity changes 

                  if (type_diffu > 0) then
                    diff_i = diff_i_tensor%zz
                    diff_j = diff_j_tensor%zz
                  end if

                  diff_ij = diff_i*diff_j

                  if(diff_ij.gt.0.0) then
                    cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                         diff_ij*areaf/(diff_i*delz_j+diff_j*delz_i)
                  endif

                  jtemp = jtemp+1
                end if

              end if                          !connections in z-direction
           
            end if                 
          end do
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!cdbg
      if (time .gt.(tfinal-1.0d-10)) then
#ifdef DEBUG
        if (info_debug.gt.0) then
!c      do ibk = 1,nmax
!c        do ii = ia(ibk),ia(ibk+1)-1
!c          write(idbg,*) 'cinfrt_va(',ii,') = ',cinfrt_va(ii)
!c        end do
!c        end do
        write(idbg,*) time

        do ibk = 1,nmax
          do ii = ia(ibk),ia(ibk+1)-1
            write(idbg,'(a,i4,a,es20.10)') 'cinfrt_va(',ii,') = ',    &
                                      cinfrt_va(ii)
            write(idbg,'(a,i4,a,es20.10)') 'cinfrt_da(',ii,') = ',    &
                                      cinfrt_da(ii)
          end do
        end do
        end if
#endif
        if (info_debug.gt.1) then
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      end if  
!cdbg
      return
      end

