!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/solver/solver.cfg $
!---------------------------------------------------------------------
!********************************************************************!

!> **********************************************************
!>                      Block:  Note
!> User can configure the solver by solver configuration file as shown here
!> or use command line options. For PETSc solver, only the most used options
!> are covered in the solver configuration file. Please use command line options
!> for all other settings. An example to use PETSc solver is shown below.
!>
!> mpirun ./min3p-hpc-mpi input_name -flow_ksp_gmres_restart 300 
!> -flow_pc_type asm -flow_pc_factor_shift_type nonzero -flow_sub_pc_type ilu 
!> -flow_sub_pc_factor_levels 3 -flow_sub_pc_factor_shift_type nonzero 
!> -react_pc_type asm -react_pc_factor_shift_type nonzero -react_sub_pc_type ilu 
!> -react_sub_pc_factor_levels 3 -react_sub_pc_factor_shift_type nonzero
!>
!> mpirun ../min3p-hpc-mpi prefix -log_view -flow_ksp_gmres_restart 300 
!> -flow_pc_type asm -flow_pc_factor_shift_type nonzero -flow_sub_pc_type ilu 
!> -flow_sub_pc_factor_shift_type nonzero -flow_ksp_max_it 5000 
!> -react_ksp_gmres_restart 300 -react_pc_type asm -react_pc_factor_shift_type nonzero 
!> -react_sub_pc_type ilu -react_sub_pc_factor_shift_type nonzero 
!> -react_ksp_max_it 5000 -heat_ksp_gmres_restart 300 -heat_pc_type asm 
!> -heat_pc_factor_shift_type nonzero -heat_sub_pc_type ilu 
!> -heat_sub_pc_factor_shift_type nonzero -heat_ksp_max_it 5000
!> **********************************************************


!> **********************************************************
!>              Block:  Golbal solver setting
!> **********************************************************
!> This command indicates that the input parameters in the MIN3P input
!> file have the priority over the input parameters in the parallel
!> solver configuration file.
!> By default, the parameters in this file will overwrite the same
!> parameters in the MIN3P input file.
!> For example, if there are solver convergence parameters in both 
!> files, you can use the following command if you want to use MIN3P
!> input parameters first.
!> If this option is used, it's better to set 
!> "KSP CONVERGENCE CRITERIA TYPE" to "USERDEFINED"
!> Requirement: Optional
!> 
GLOBAL: USE MIN3P INPUT PARAMETERS FIRST

!> Select solver
!> i_solver_type = 0 use ws209 solver (default)
!>                 1 use pardiso solver
!>                 2 use PETSc solver
!>                 3 use LIS solver
!> Requirement: Optional
!> Note: this setting is for both flow solver and reactive transport solver
!SOLVER TYPE
!1

!> i_solver_type_flow = 0 use ws209 solver (default)
!>                      1 use pardiso solver
!>                      2 use PETSc solver
!>                      3 use LIS solver
!> Requirement: Optional if use ws209 solver
!>              Required if use pardiso solver, PETSc solver or LIS solver
SOLVER TYPE FLOW
2

!> i_solver_type_heat = 0 use ws209 solver (default)
!>                      1 use pardiso solver
!>                      2 use PETSc solver
!>                      3 use LIS solver
!> Requirement: Optional if use ws209 solver
!>              Required if use pardiso solver, PETSc solver or LIS solver
SOLVER TYPE HEAT TRANSPORT
2

!>
!> i_solver_type_react = 0 use ws209 solver (default)
!>                       1 use pardiso solver
!>                       2 use PETSc solver
!>                       3 use LIS solver
!> Requirement: Optional if use ws209 solver
!>              Required if use pardiso solver, PETSc solver or LIS solver
SOLVER TYPE REACTIVE TRANSPORT
2

!>
!> Use number of threads from MPI calling.
!> If this command is enabled, the number of threads
!> in OpenMP calling will be replaced by the number 
!> of processors in mpi calling.
GLOBAL: USE NUMBER OF THREADS FROM MPI

!>
!> Set the number of threads for global use
!> Default value: 1
!> Requirement: Optional
GLOBAL: NUMBER OF THREADS
4  

!>
!> Loops like vector initialization will be parallelized if 
!> the loops number is larger than this threshold.
!> Default value: 1000
GLOBAL: NUMBER OF LOOPS THRESHOLD
10000

!> **********************************************************
!>              Block:  Matrix assembly setting
!> **********************************************************

!>
!> Set the matrix assembly type for flow problem
!> i_matrix_assembly_type_flow = 0 use sequential mode (default)
!>                               1 use Openmp parallel mode
!>                               2 use MPI parallel mode (not in use) 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: TYPE IN FLOW
1

!>
!> Set the number of threads in matrix assembly for flow problem.
!> If not specified, use 'GLOBAL: NUMBER OF THREADS' instead.
!> Default value: 1
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: NUMBER OF THREADS IN FLOW
4

!> Set the schedule type in matrix assembly for flow problem.
!> If not specified, use the dynamic schedule method.
!> Current the schedule method is compiler configured.
!> i_schedule_type_flow = 0 use static schedule method (not in use)
!>                        1 use dynamic schedule method (not in use)
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: SCHEDULE TYPE IN FLOW
0

!> Set the chunk size factor for matrix assembly for flow problem.
!> This value should be from 0 to (number of volumes)/(number of processors).
!> If larger than (number of volumes)/(number of processors), the chunk size
!> will be set to 1.
!> If the value is not specified or 0, use the system default size. 
!> i_chunksize_factor_flow = 0 use system default size
!>                           1-n
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: CHUNK SIZE FACTOR IN FLOW
0

!>
!> Set the matrix assembly type for heat transport problem
!> i_matrix_assembly_type_flow = 0 use sequential mode (default)
!>                               1 use Openmp parallel mode
!>                               2 use MPI parallel mode (not in use) 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: TYPE IN HEAT TRANSPORT
1

!>
!> Set the number of threads in matrix assembly for heat transport problem.
!> If not specified, use 'GLOBAL: NUMBER OF THREADS' instead.
!> Default value: 1
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: NUMBER OF THREADS IN HEAT TRANSPORT
4

!> Set the schedule type in matrix assembly for heat transport problem.
!> If not specified, use the dynamic schedule method.
!> Current the schedule method is compiler configured.
!> i_schedule_type_flow = 0 use static schedule method (not in use)
!>                        1 use dynamic schedule method (not in use)
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: SCHEDULE TYPE IN HEAT TRANSPORT
0

!> Set the chunk size factor for matrix assembly for heat transport problem.
!> This value should be from 0 to (number of volumes)/(number of processors).
!> If larger than (number of volumes)/(number of processors), the chunk size
!> will be set to 1.
!> If the value is not specified or 0, use the system default size. 
!> i_chunksize_factor_flow = 0 use system default size
!>                           1-n
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: CHUNK SIZE FACTOR IN HEAT TRANSPORT
0

!>
!> Set the matrix assembly type for reactive transport problem
!> i_matrix_assembly_type_react = 0 use sequential mode (default)
!>                                1 use Openmp parallel mode
!>                                2 use MPI parallel mode (not in use) 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: TYPE IN REACTIVE TRANSPORT 
1
MATRIX ASSEMBLY: TYPE IN REACTIVE TRANSPORT JACRT
0    !Set jacrt to sequential version
MATRIX ASSEMBLY: TYPE IN REACTIVE TRANSPORT JACBRT
1    !Set jacbrt to parallel version

!>
!> Set the number of threads in matrix assembly for reactive 
!> transport problem.
!> If not specified, use 'GLOBAL: NUMBER OF THREADS' instead.
!> Default value: 1
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: NUMBER OF THREADS IN REACTIVE TRANSPORT
4

!> Set the schedule type in matrix assembly for reactive 
!> transport problem.
!> If not specified, use the dynamic schedule method.
!> Current the schedule method is compiler configured.
!> i_schedule_type_flow = 0 use static schedule method (not in use)
!>                         1 use dynamic schedule method (not in use)
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: SCHEDULE TYPE IN REACTIVE TRANSPORT
0

!> Set the chunk size factor for matrix assembly for reactive 
!> transport problem.
!> This value should be from 0 to (number of volumes)/(number of processors).
!> If the value is not specified or 0, use the system default size.
!> If larger than (number of volumes)/(number of processors), the chunk size
!> will be set to 1. 
!> i_chunksize_factor_react = 0 use system default size
!>                            1-n
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
MATRIX ASSEMBLY: CHUNK SIZE FACTOR IN REACTIVE TRANSPORT
0

!> **********************************************************
!>              Block:  Pardiso solver setting
!> **********************************************************

!> Set this parameter if you want to check the result of matrix
!> solver with ws209. Only valid if  i_solver_type = 0
!> Requirement: Optional if you need to compare the result of
!>              matrix solver.
! PARDISO: SOLVER TEST WITH WS209

!> Set the number of threads for pardiso solver.
!> If the solver type is not pardiso, ignore it.
!> If the number of threads is less than 1, use dynamic
!> number of threads determined by pardiso. 
!> Default value: 1
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
PARDISO: NUMBER OF THREADS
0

!> Maximum number of iterative refinement steps that the 
!> solver will perform. The solver will perform not more 
!> than the absolute value of this parameter for iterative
!> refinement and will stop the process if a satisfactory
!> level of accuracy of the solution in terms of backward
!> error has been achieved.
!> If this parameter is negative, the accumulation of the
!> residuum is using extended precision real types.
!> Default value: 9
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
PARDISO: MAX ITERATIVE REFINEMENT STEPS IN FLOW
9

PARDISO: MAX ITERATIVE REFINEMENT STEPS IN HEAT TRANSPORT
9

PARDISO: MAX ITERATIVE REFINEMENT STEPS IN REACTIVE TRANSPORT
9

!> This parameter instructs PARDISO how to handle small
!> pivots or zero pivots for unsymmetric matrices. 
!> It indicates the iterative refinement contraction
!> rate. The default value is 13, which means eps = 10^(-13)

!> is used in handling small pivots.
!> Default value: 13
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
PARDISO: PIVOTING PERTURBATION IN FLOW
13

PARDISO: PIVOTING PERTURBATION IN HEAT TRANSPORT
13

PARDISO: PIVOTING PERTURBATION IN REACTIVE TRANSPORT
13

!> This parameter controls preconditioned CGS [Sonn89] for nonsymmetric matrices. iparm(4) has the form iparm(4)= 10*L+K.
!> K=0 The factorization is always computed as required by phase.
!> K=1 CGS iteration replaces the computation of LU. The preconditioner is LU that was computed at a previous step 
!> (the first step or last step with a failure) in a sequence of solutions needed for identical sparsity patterns.
!> iparm(4)    Description 
!> 31    LU-preconditioned CGS iteration with a stopping criterion of 1.0E-3 for nonsymmetric matrices 
!> 61    LU-preconditioned CGS iteration with a stopping criterion of 1.0E-6 for nonsymmetric matrices 
!> Default value: 0
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
PARDISO: CGS CRITERION IN FLOW
0

PARDISO: CGS CRITERION IN HEAT TRANSPORT
0

PARDISO: CGS CRITERION IN REACTIVE TRANSPORT
0

!> This parameter control when symbolic factorization should take.
!> In pardiso solver, when the previous reordering is not quite good 
!> to get correct results, reorder the matrix (symbolic factorization) again.
!> For nonsymmetric case, it's better to call reorder step for each matrix,
!> but this can waste a lot of time.
!> When preconditioned CGS is used, this value will be compared to the number of completed iterations,
!> otherwise, this value will be compared to the number of iterative refinement steps performed.
!> When the iteration number is larger than the provided, do symbolic factorization again.
!> Default value: 9
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
PARDISO: MAXIMUM SOLVER ITERATION IN FLOW
5

PARDISO: MAXIMUM SOLVER ITERATION IN FLOW
5

PARDISO: MAXIMUM SOLVER ITERATION IN REACTIVE TRANSPORT   
5

!> This parameter control when symbolic factorization should take.
!> In pardiso solver, when the previous reordering is not quite good 
!> to get correct results, reorder the matrix (symbolic factorization) again.
!> For nonsymmetric case, it's better to call reorder step for each matrix,
!> but this can waste a lot of time. 
!> When the maximum residual is larger than the provided, do symbolic factorization again.
!> Default value: 1.0E-5
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
PARDISO: MAXIMUM RESIDUAL IN FLOW
1.0E-8

PARDISO: MAXIMUM RESIDUAL IN HEAT TRANSPORT
1.0E-8

PARDISO: MAXIMUM RESIDUAL IN REACTIVE TRANSPORT
1.0E-8

!> This parameter control when symbolic factorization should take.
!> In pardiso solver, when the previous reordering is not quite good 
!> to get correct results, reorder the matrix (symbolic factorization) again.
!> For nonsymmetric case, it's better to call reorder step for each matrix,
!> but this can waste a lot of time. 
!> 0 symbolic factorization at first run
!> 1 symbolic factorization every step
!> Default value: 0
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
PARDISO: SYMBOLIC FACTORIZATION TYPE IN FLOW
0

PARDISO: SYMBOLIC FACTORIZATION TYPE IN HEAT TRANSPORT
0

PARDISO: SYMBOLIC FACTORIZATION TYPE IN REACTIVE TRANSPORT
0

!> **********************************************************
!>              Block:  Domain decomposition setting
!> **********************************************************
!> Stencil width
!> Domain decomposition is based on PETSc DMDA for the structured grid
!> and unstructured grid.
!> By default, the stencil width is 1, which can meet the requirements
!> of most cases, but for the case with "vanleer" spatial weighting, 
!> it will consider the second upstream point for flux limiter that the 
!> stencil width should be 2 or more.
!> For unstructured grid, stencil width 1 means only the facets, edges
!> and vertices may be shared along the partition boundary, whereas for 
!> stencil width 2, one additional "layer" of cells around each 
!> partition (the partitioning is done based on cell connectivity). 
!> For second neighbours, stencil width 2 is needed. 
!> There is conceptually no upper bound on the overlap. For gradient 
!> reconstruction using Green Gauss method, Least Square and
!> Least Square Second Order method, stencil width >=1 is required. 
!> For Least Square Third Order or Least Square Fourth Order method, 
!> stencil width >= 2 is required. Depending on the mesh quality, 
!> if the local boundary does not have enough connections 
!> commpard to the global mesh, it may cause inaccurate gradient 
!> value that causes small difference in the parallel version.
PETSC: STENCIL WIDTH
2

!> PETSc partitioner type
!> PETSc supports partioning using different libraries. 
!> Parmetis is used as the default partioner type if not specified.
!> The following partitioner type can be used.
!> Please make sure the specified external library is installed
!>   PETSCPARTITIONERCHACO    "chaco"
!>   PETSCPARTITIONERPARMETIS "parmetis"
!>   PETSCPARTITIONERPTSCOTCH "ptscotch"
!>   PETSCPARTITIONERSHELL    "shell"
!>   PETSCPARTITIONERSIMPLE   "simple"
!>   PETSCPARTITIONERGATHER   "gather"
PETSC: PARTITIONER TYPE
parmetis

!> **********************************************************
!>              Block:  PETSc solver setting
!> **********************************************************
!> Set this parameter if you want to check the result of matrix
!> solver with ws209. Only valid if  i_solver_type = 0
!> Requirement: Optional if you need to compare the result of
!>              matrix solver.
PETSC: SOLVER TEST WITH WS209

!> Set this command to use the default configuration by PETSc.
!> If you want to use the default solver configuration or 
!> if you want to read the configuration from the command line,
!> uncomment this command. Otherwise, comment this.
PETSC: USE DEFAULT CONFIGURATION IN FLOW

!> Set PETSc solver method for flow problem
!> Iterative solver: gmres, bcgs
!> Direct solver: superlu, mumps
!> The following methods are supported in PETSc:
!> KSPGMRES      "gmres"
!> KSPBCGS       "bcgs"
!> MUMPS         "mumps"
!> SUPERLU       "superlu"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               PETSC: KSP TYPE IN FLOW
!>               kspgmres or gmres
!> The default value is gmres
PETSC: KSP TYPE IN FLOW
kspgmres

!> Set PETSc preconditioner type for flow problem
!> The following methods are supported in PETSc:
!> Algorithm          Name       Parallel
!> PCNONE            "none"         N
!> PCJACOBI          "jacobi"       Y
!> PCLU              "lu"           N
!> PCBJACOBI         "bjacobi"      Y
!> PCILU             "ilu"          N
!> PCASM             "asm"          Y
!> PCKSP             "ksp"          Y
!> PCHYPRE           "hypre"        Y
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               PETSC: PRECONDITIONER TYPE IN FLOW
!>               pcbjacobi or bjacobi
!> The default value is bjacobi
PETSC: PRECONDITIONER TYPE IN FLOW
pcbjacobi

!>
!> Set PC Factor type for flow problem
!> The following methods are supported in PETSc:
!> MAT_SHIFT_NONE                "none"
!> MAT_SHIFT_NONZERO             "nonzero"
!> MAT_SHIFT_POSITIVE_DEFINITE   "positive_definite"
!> MAT_SHIFT_INBLOCKS            "inblocks"
!> Requirements: Optionsl, work for bjacobi and asm PC type
!>               and gmres/bcgs KSP type
!>
PETSC: PC FACTOR SHIFT TYPE IN FLOW
none


!!> Set norm type
!!>  KSP_NORM_NONE - skips computing the norm, this should only be used if you are using
!!>                the Krylov method as a smoother with a fixed small number of iterations.
!!>                Implicitly sets KSPSkipConverged as KSP convergence test.
!!>                Supported only by CG, Richardson, Bi-CG-stab, CR, and CGS methods.
!!>  KSP_NORM_PRECONDITIONED - the default for left preconditioned solves, uses the l2 norm
!!>                of the preconditioned residual
!!>  KSP_NORM_UNPRECONDITIONED - uses the l2 norm of the true b - Ax residual, supported only by
!!>                CG, CHEBYSHEV, and RICHARDSON, automatically true for right (see KSPSetPCSide())
!!>                preconditioning..
!!>  KSP_NORM_NATURAL - supported  by KSPCG, KSPCR, KSPCGNE, KSPCGS
!!PETSC: KSP NORM TYPE IN FLOW
!!ksp_norm_preconditioned

!> Set KSP solver convergence criteria
!> By default, KSP solver will reach convergence when 
!> rnorm < MAX (rtol * rnorm_0, abstol) or divergence if 
!> rnorm > dtol * rnorm_0. The rnorm here is preconditioned 
!> residual norm. If '-ksp_norm_type unpreconditioned' is used,
!> rnorm is the true residual norm.
!> If the solver convergence criteria is set to user-defined
!> criteria, then the true residual will be calculated every
!> iteration. The solver will reach convergence when 
!> rnorm < MAX (rtol * rnorm_0, abstol).
!> The following methods are supported in PETSc:
!> KSPDEFAULT        "default"
!> KSPUSERDEFINED    "userdefined"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               PETSC: KSP CONVERGENCE CRITERIA TYPE IN FLOW
!>               kspdefault or default
!> The default value is kspdefault
PETSC: KSP CONVERGENCE CRITERIA TYPE IN FLOW
kspdefault

!> Set the relative convergence tolerance for flow problem
!> The default value is 1.0E-5
PETSC: RELATIVE CONVERGENCE TOLERANCE IN FLOW
1.0E-5 
!> Set the absolute convergence tolerance for flow problem
!> The default value is 1.0E-50
PETSC: ABSOLUTE CONVERGENCE TOLERANCE IN FLOW
1.0E-20 
!> Set the divergence tolerance for flow problem
!> The default value is 1.0E5
PETSC: DIVERGENCE TOLERANCE IN FLOW
1.0E5
!> Set the maximum number of iterations for flow problem
!> The default value is 50000
PETSC: MAXIMUM NUMBER OF ITERATIONS IN FLOW
100

!> Check direct solver norm in flow problem. If this is set, 
!> the direct solver will use the value set in 
!> 'ABSOLUTE CONVERGENCE TOLERANCE IN FLOW' 
!> to check if the solution meets the convergence criteria.
!PETSC: CHECK DIRECT SOLVER NORM IN FLOW

!> Set previous solution as initial guess for the next solve
!> for flow problem. This is usually effective when the linear 
!> systems do not change very much between successive steps.
!> This is not controlled by DEFAULT CONFIGURATION.
!> The default value is to set initial guess to zero.
!PETSC: KSP SET INITIAL GUESS NONZERO IN FLOW

!> Set operators, keeping the identical preconditioner matrix
!> for all linear solves. This approach is often effective when
!> the linear systems do not change very much between successive
!> steps. 
!> This is not controlled by DEFAULT CONFIGURATION.
!> The default value is NOT reusing the same preconditioner.
!PETSC: KSP REUSE PRECONDITIONER IN FLOW

!> Set this command to use the default configuration by PETSc.
!> If you want to use the default solver configuration or 
!> if you want to read the configuration from the command line,
!> uncomment this command. Otherwise, comment this.
PETSC: USE DEFAULT CONFIGURATION IN HEAT TRANSPORT

!> Set PETSc solver method for decoupled heat transport problem
!> Iterative solver: gmres, bcgs
!> Direct solver: superlu, mumps
!> The following methods are supported in PETSc:
!> KSPGMRES      "gmres"
!> KSPBCGS       "bcgs"
!> MUMPS         "mumps"
!> SUPERLU       "superlu"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               PETSC: KSP TYPE IN HEAT TRANSPORT
!>               kspgmres or gmres
!> The default value is gmres
PETSC: KSP TYPE IN HEAT TRANSPORT
kspgmres

!> Set PETSc preconditioner type for decoupled heat transport problem
!> The following methods are supported in PETSc:
!> Algorithm          Name       Parallel
!> PCNONE            "none"         N
!> PCJACOBI          "jacobi"       Y
!> PCLU              "lu"           N
!> PCBJACOBI         "bjacobi"      Y
!> PCILU             "ilu"          N
!> PCASM             "asm"          Y
!> PCKSP             "ksp"          Y
!> PCHYPRE           "hypre"        Y
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               PETSC: PRECONDITIONER TYPE IN HEAT TRANSPORT
!>               pcbjacobi or bjacobi
!> The default value is bjacobi
PETSC: PRECONDITIONER TYPE IN HEAT TRANSPORT
pcbjacobi

!>
!> Set PC Factor type for decoupled heat transport problem
!> The following methods are supported in PETSc:
!> MAT_SHIFT_NONE                "none"
!> MAT_SHIFT_NONZERO             "nonzero"
!> MAT_SHIFT_POSITIVE_DEFINITE   "positive_definite"
!> MAT_SHIFT_INBLOCKS            "inblocks"
!> Requirements: Optionsl, work for bjacobi and asm PC type
!>               and gmres/bcgs KSP type
!>
PETSC: PC FACTOR SHIFT TYPE IN HEAT TRANSPORT
none


!!> Set norm type
!!>  KSP_NORM_NONE - skips computing the norm, this should only be used if you are using
!!>                the Krylov method as a smoother with a fixed small number of iterations.
!!>                Implicitly sets KSPSkipConverged as KSP convergence test.
!!>                Supported only by CG, Richardson, Bi-CG-stab, CR, and CGS methods.
!!>  KSP_NORM_PRECONDITIONED - the default for left preconditioned solves, uses the l2 norm
!!>                of the preconditioned residual
!!>  KSP_NORM_UNPRECONDITIONED - uses the l2 norm of the true b - Ax residual, supported only by
!!>                CG, CHEBYSHEV, and RICHARDSON, automatically true for right (see KSPSetPCSide())
!!>                preconditioning..
!!>  KSP_NORM_NATURAL - supported  by KSPCG, KSPCR, KSPCGNE, KSPCGS
!!PETSC: KSP NORM TYPE IN HEAT TRANSPORT
!!ksp_norm_preconditioned

!> Set KSP solver convergence criteria
!> By default, KSP solver will reach convergence when 
!> rnorm < MAX (rtol * rnorm_0, abstol) or divergence if 
!> rnorm > dtol * rnorm_0. The rnorm here is preconditioned 
!> residual norm. If '-ksp_norm_type unpreconditioned' is used,
!> rnorm is the true residual norm.
!> If the solver convergence criteria is set to user-defined
!> criteria, then the true residual will be calculated every
!> iteration. The solver will reach convergence when 
!> rnorm < MAX (rtol * rnorm_0, abstol).
!> The following methods are supported in PETSc:
!> KSPDEFAULT        "default"
!> KSPUSERDEFINED    "userdefined"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               PETSC: KSP CONVERGENCE CRITERIA TYPE IN HEAT TRANSPORT
!>               kspdefault or default
!> The default value is kspdefault
PETSC: KSP CONVERGENCE CRITERIA TYPE IN HEAT TRANSPORT
kspdefault

!> Set the relative convergence tolerance for decoupled heat transport problem
!> The default value is 1.0E-5
PETSC: RELATIVE CONVERGENCE TOLERANCE IN HEAT TRANSPORT
1.0E-5 
!> Set the absolute convergence tolerance for decoupled heat transport problem
!> The default value is 1.0E-50
PETSC: ABSOLUTE CONVERGENCE TOLERANCE IN HEAT TRANSPORT
1.0E-20 
!> Set the divergence tolerance for decoupled heat transport problem
!> The default value is 1.0E5
PETSC: DIVERGENCE TOLERANCE IN HEAT TRANSPORT
1.0E5
!> Set the maximum number of iterations for decoupled heat transport problem
!> The default value is 50000
PETSC: MAXIMUM NUMBER OF ITERATIONS IN HEAT TRANSPORT
100

!> Check direct solver norm in decoupled heat transport problem. If this is set, 
!> the direct solver will use the value set in 
!> 'ABSOLUTE CONVERGENCE TOLERANCE IN HEAT TRANSPORT' 
!> to check if the solution meets the convergence criteria.
!PETSC: CHECK DIRECT SOLVER NORM IN HEAT TRANSPORT

!> Set previous solution as initial guess for the next solve
!> for decoupled heat transport problem. This is usually effective when the linear 
!> systems do not change very much between successive steps.
!> This is not controlled by DEFAULT CONFIGURATION.
!> The default value is to set initial guess to zero.
!PETSC: KSP SET INITIAL GUESS NONZERO IN HEAT TRANSPORT

!> Set operators, keeping the identical preconditioner matrix
!> for all linear solves. This approach is often effective when
!> the linear systems do not change very much between successive
!> steps. 
!> This is not controlled by DEFAULT CONFIGURATION.
!> The default value is NOT reusing the same preconditioner.
!PETSC: KSP REUSE PRECONDITIONER IN HEAT TRANSPORT

!> Set this command to use the default configuration by PETSc.
!> If you want to use the default solver configuration or 
!> if you want to read the configuration from the command line,
!> uncomment this command. Otherwise, comment this.
PETSC: USE DEFAULT CONFIGURATION IN REACTIVE TRANSPORT

!> Set PETSc solver method for reactive transport problem
!> Iterative solver: gmres, bcgs
!> Direct solver: superlu, mumps
!> The following methods are supported in PETSc
!> KSPGMRES      "gmres"
!> KSPBCGS       "bcgs"
!> MUMPS         "mumps"
!> SUPERLU       "superlu"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               PETSC: KSP TYPE IN REACTIVE TRANSPORT
!>               kspgmres or gmres
!> The default value is gmres
PETSC: KSP TYPE IN REACTIVE TRANSPORT
kspgmres

!> Set PETSc preconditioner type for reactive transport problem
!> The following methods are supported in PETSc:
!> Algorithm          Name       Parallel
!> PCNONE            "none"         N
!> PCJACOBI          "jacobi"       Y
!> PCLU              "lu"           N
!> PCBJACOBI         "bjacobi"      Y
!> PCILU             "ilu"          N
!> PCASM             "asm"          Y
!> PCKSP             "ksp"          Y
!> PCHYPRE           "hypre"        Y
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               PETSC: PRECONDITIONER TYPE IN REACTIVE TRANSPORT
!>               pcbjacobi or bjacobi
!> The default value is bjacobi
PETSC: PRECONDITIONER TYPE IN REACTIVE TRANSPORT
pcbjacobi

!>
!> Set PC Factor type for reactive transport problem
!> The following methods are supported in PETSc:
!> MAT_SHIFT_NONE                "none"
!> MAT_SHIFT_NONZERO             "nonzero"
!> MAT_SHIFT_POSITIVE_DEFINITE   "positive_definite"
!> MAT_SHIFT_INBLOCKS            "inblocks"
!> Requirements: Optionsl, work for bjacobi and asm PC type
!>               and gmres/bcgs KSP type
!>
PETSC: PC FACTOR SHIFT TYPE IN REACTIVE TRANSPORT
none

!!> Set norm type
!!>  KSP_NORM_NONE - skips computing the norm, this should only be used if you are using
!!>                the Krylov method as a smoother with a fixed small number of iterations.
!!>                Implicitly sets KSPSkipConverged as KSP convergence test.
!!>                Supported only by CG, Richardson, Bi-CG-stab, CR, and CGS methods.
!!>  KSP_NORM_PRECONDITIONED - the default for left preconditioned solves, uses the l2 norm
!!>                of the preconditioned residual
!!>  KSP_NORM_UNPRECONDITIONED - uses the l2 norm of the true b - Ax residual, supported only by
!!>                CG, CHEBYSHEV, and RICHARDSON, automatically true for right (see KSPSetPCSide())
!!>                preconditioning..
!!>  KSP_NORM_NATURAL - supported  by KSPCG, KSPCR, KSPCGNE, KSPCGS
!!PETSC: KSP NORM TYPE IN REACTIVE TRANSPORT
!!ksp_norm_preconditioned

!> Set KSP solver convergence criteria
!> By default, KSP solver will reach convergence when 
!> rnorm < MAX (rtol * rnorm_0, abstol) or divergence if 
!> rnorm > dtol * rnorm_0. The rnorm here is preconditioned 
!> residual norm. If '-ksp_norm_type unpreconditioned' is used,
!> rnorm is the true residual norm.
!> If the solver convergence criteria is set to user-defined
!> criteria, then the true residual will be calculated every
!> iteration. The solver will reach convergence when 
!> rnorm < MAX (rtol * rnorm_0, abstol).
!> The following methods are supported in PETSc:
!> KSPDEFAULT        "default"
!> KSPUSERDEFINED    "userdefined"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               PETSC: KSP CONVERGENCE CRITERIA TYPE IN REACTIVE TRANSPORT
!>               kspdefault or default
!> The default value is kspdefault
PETSC: KSP CONVERGENCE CRITERIA TYPE IN REACTIVE TRANSPORT
kspdefault

!> Set the relative convergence tolerance for reactive transport problem
!> The default value is 1.0E-5
PETSC: RELATIVE CONVERGENCE TOLERANCE IN REACTIVE TRANSPORT
1.0E-5 
!> Set the absolute convergence tolerance for reactive transport problem
!> The default value is 1.0E-50
PETSC: ABSOLUTE CONVERGENCE TOLERANCE IN REACTIVE TRANSPORT
1.0E-20 
!> Set the divergence tolerance for reactive transport problem
!> The default value is 1.0E5
PETSC: DIVERGENCE TOLERANCE IN REACTIVE TRANSPORT
1.0E5
!> Set the maximum number of iterations for reactive transport problem
!> The default value is 50000
PETSC: MAXIMUM NUMBER OF ITERATIONS IN REACTIVE TRANSPORT
100

!> Check direct solver norm in flow problem. If this is set,
!> the direct solver will use the value set in
!> 'ABSOLUTE CONVERGENCE TOLERANCE IN REACTIVE TRANSPORT' 
!> to check if the solution meets the convergence criteria.
!PETSC: CHECK DIRECT SOLVER NORM IN REACTIVE TRANSPORT


!> Set previous solution as initial guess for the next solve
!> for reactive transport problem. This is usually effective when the linear 
!> systems do not change very much between successive steps.
!> This is not controlled by DEFAULT CONFIGURATION.
!> The default value is to set initial guess to zero.
!PETSC: KSP SET INITIAL GUESS NONZERO IN REACTIVE TRANSPORT

!> Set operators, keeping the identical preconditioner matrix
!> for all linear solves. This approach is often effective when
!> the linear systems do not change very much between successive
!> steps.
!> This is not controlled by DEFAULT CONFIGURATION.
!> The default value is NOT reusing the same preconditioner.
!PETSC: KSP REUSE PRECONDITIONER IN REACTIVE TRANSPORT

!> **********************************************************
!>              Block: LIS  solver setting
!> **********************************************************
!> Set this parameter if you want to check the result of matrix
!> solver with ws209. Only valid if  i_solver_type = 0
!> Requirement: Optional if you need to compare the result of
!>              matrix solver.
LIS: SOLVER TEST WITH WS209

!> Set this command to use the default configuration by LIS.
!> If you want to use the default solver configuration or 
!> if you want to read the configuration from the command line,
!> uncomment this command. Otherwise, comment this.
LIS: USE DEFAULT CONFIGURATION IN FLOW

!> Set LIS solver method for flow problem
!> The following methods are supported in this file:
!> "bicg"
!> "gmres"
!> "bicgstab"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: KSP TYPE IN FLOW
!>               gmres
!> The default value is bicg
LIS: KSP TYPE IN FLOW
bicg

!> Set LIS preconditioner type for flow problem
!> The following methods are supported in this file:
!> "none"
!> "jacobi"
!> "ilu"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: PRECONDITIONER TYPE IN FLOW
!>               jacobi
!> The default value is none
LIS: PRECONDITIONER TYPE IN FLOW
none

!> Set LIS solver precision for flow problem
!> the following precision are supported in this file:
!> "double"
!> "quad"
!> Note: double precision operations sometimes require large
!> number of iterations because of the rounding error. Quadruple
!> precision operations can improve this operation. Both 
!> matrix and vectors are still double precision.
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: SOLVER PRECISION IN FLOW
!>               quad
!> The default value is double
LIS: SOLVER PRECISION IN FLOW
double

!> Set the relative convergence tolerance for flow problem
!> The default value is 1.0E-12
LIS: CONVERGENCE TOLERANCE IN FLOW
1.0E-12 

!> Set the maximum number of iterations for flow problem
!> The default value is 1000
LIS: MAXIMUM NUMBER OF ITERATIONS IN FLOW
1000

!> Set other options that are not included above
!> Please look into LIS solver manual for detail
!> 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: SOLVER OPTIONS IN FLOW
!>               -i cg -p ssor
!LIS: SOLVER OPTIONS IN FLOW
!-i cg -p ssor -print mem

!> Set this command to use the default configuration by LIS.
!> If you want to use the default solver configuration or 
!> if you want to read the configuration from the command line,
!> uncomment this command. Otherwise, comment this.
LIS: USE DEFAULT CONFIGURATION IN HEAT TRANSPORT

!> Set LIS solver method for decoupled heat transport problem
!> The following methods are supported in this file:
!> "bicg"
!> "gmres"
!> "bicgstab"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: KSP TYPE IN HEAT TRANSPORT
!>               gmres
!> The default value is bicg
LIS: KSP TYPE IN HEAT TRANSPORT
bicg

!> Set LIS preconditioner type for decoupled heat transport problem
!> The following methods are supported in this file:
!> "none"
!> "jacobi"
!> "ilu"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: PRECONDITIONER TYPE IN HEAT TRANSPORT
!>               jacobi
!> The default value is none
LIS: PRECONDITIONER TYPE IN HEAT TRANSPORT
none

!> Set LIS solver precision for decoupled heat transport problem
!> the following precision are supported in this file:
!> "double"
!> "quad"
!> Note: double precision operations sometimes require large
!> number of iterations because of the rounding error. Quadruple
!> precision operations can improve this operation. Both 
!> matrix and vectors are still double precision.
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: SOLVER PRECISION IN HEAT TRANSPORT
!>               quad
!> The default value is double
LIS: SOLVER PRECISION IN HEAT TRANSPORT
double

!> Set the relative convergence tolerance for decoupled heat transport problem
!> The default value is 1.0E-12
LIS: CONVERGENCE TOLERANCE IN HEAT TRANSPORT
1.0E-12 

!> Set the maximum number of iterations for decoupled heat transport problem
!> The default value is 1000
LIS: MAXIMUM NUMBER OF ITERATIONS IN HEAT TRANSPORT
1000

!> Set other options that are not included above
!> Please look into LIS solver manual for detail
!> 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: SOLVER OPTIONS IN HEAT TRANSPORT
!>               -i cg -p ssor
!LIS: SOLVER OPTIONS IN HEAT TRANSPORT
!-i cg -p ssor -print mem

!> Set this command to use the default configuration by LIS.
!> If you want to use the default solver configuration or 
!> if you want to read the configuration from the command line,
!> uncomment this command. Otherwise, comment this.
LIS: USE DEFAULT CONFIGURATION IN REACTIVE TRANSPORT

!> Set LIS solver method for reactive transport problem
!> The following methods are supported in this file:
!> "bicg"
!> "gmres"
!> "bicgstab"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: KSP TYPE IN REACTIVE TRANSPORT
!>               gmres
!> The default value is bicg
LIS: KSP TYPE IN REACTIVE TRANSPORT
bicg

!> Set LIS preconditioner type for reactive transport problem
!> The following methods are supported in this file:
!> "none"
!> "jacobi"
!> "ilu"
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: PRECONDITIONER TYPE IN REACTIVE TRANSPORT
!>               jacobi
!> The default value is none
LIS: PRECONDITIONER TYPE IN REACTIVE TRANSPORT
none

!> Set LIS solver precision for reactive transport problem
!> the following precision are supported in this file:
!> "double"
!> "quad"
!> Note: double precision operations sometimes require large
!> number of iterations because of the rounding error. Quadruple
!> precision operations can improve this operation. Both 
!> matrix and vectors are still double precision.
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: SOLVER PRECISION IN REACTIVE TRANSPORT
!>               quad
!> The default value is double
LIS: SOLVER PRECISION IN REACTIVE TRANSPORT
double

!> Set the relative convergence tolerance for reactive transport problem
!> The default value is 1.0E-12
LIS: CONVERGENCE TOLERANCE IN REACTIVE TRANSPORT
1.0E-12 

!> Set the maximum number of iterations for reactive transport problem
!> The default value is 1000
LIS: MAXIMUM NUMBER OF ITERATIONS IN REACTIVE TRANSPORT
1000

!> Set other options that are not included above
!> Please look into LIS solver manual for detail
!> 
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Input example:
!>               LIS: SOLVER OPTIONS IN REACTIVE TRANSPORT
!>               -i cg -p ssor
!LIS: SOLVER OPTIONS IN REACTIVE TRANSPORT
!-i cg -p ssor -print mem


!> **********************************************************
!>              Block:  ws209 solver setting
!> **********************************************************

!> Set the number of threads for ws209 solver.
!> Only works when the solver type is ws209.
!> Default value: 1
!> Requirement: Optional if use sequential mode
!>              Required if use parallel mode
!> Note: WS209 (WatSolv) solver is not fully parallelized.
WS209: NUMBER OF THREADS
4

!> **********************************************************
!>              Block:  Output setting
!> **********************************************************

!> Set if output detail runtime statistics analysis.
!> Comment out if you do not want to export it.
!> Requirement: Required if runtime profile is needed.
OUTPUT RUNTIME STATISTICS ANALYSIS

!> Set if output the matrix data for all the linear equations.
!> Comment out if you do not want to export it.
!> Requirement: Optional, only for test.
OUTPUT SPARSE MATRIX DATA SET AND RHS

!> Set if output the matrix data for all the linear equations
!> at the specific timestep.
!> Comment out if you do not want to export it.
!> Requirement: Optional, only for test.
OUTPUT SPARSE MATRIX DATA SET AND RHS AT TIMESTEP
100

!> Set if output the matrix data for all the linear equations using PETSc.
!> Comment out if you do not want to export it.
!> Requirement: Optional, only for test.
OUTPUT SPARSE MATRIX DATA SET AND RHS USING PETSC

!> Set the output matrix format  
!> 0: export a (ia, ja), b, x as 1d array into separated files
!> 1: export a (ia, ja) as matrix market exchange format(.mtx), 
!>    and b and x as 1d array into separated files
!> Requirement: Optional, only for test.
!> E.g.
!> OUTPUT MATRIX FORMAT SELECTION
!> 1

OUTPUT MATRIX FORMAT SELECTION
1

!> Estimate condition number of matrix before solving euations.
!> Enable this will increase the running time. 
!> Comment out if you do not want to export it.
!> Requirement: Required if condition number is needed.
OUTPUT CONDITION NUMBER

!> **********************************************************
!>              Block:  OpenMP Parallel Controls 
!> **********************************************************
!> Format: Command for specified subroutine
!>         Threshold for loop amount
!> If the threshold is smaller than the loop amount, OpenMP 
!> parallelization is enabled for this subroutine, otherwise,
!> if the threshold is larger than the loop amount, OpenMP
!> parallelization is disabled for this subroutine.
!> **********************************************************
mbalrt: number of threads 1
1
mbalrt: number of threads 2
1
mbalrt: number of threads 3
1
mbalrt: number of threads 4
1
mbalrt: number of threads 5
1
mbalrt: number of threads 6
1
mbalrt: number of threads 7
1
mbalrt: number of threads 8
1
mbalrt: number of threads 9
1
mbalrt: number of threads 10
1
mbalrt: number of threads 11
1
msysrt: number of threads 1
1
msysrt: number of threads 2
1
msysrt: number of threads 3
1
msysrt: number of threads 4
1
msysrt: number of threads 5
1
msysrt: number of threads 6
1
mbal_mcd: number of threads 1
1
mbal_mcd: number of threads 2
1
mbal_mcd: number of threads 3
1
infcrtdd: number of threads 1
1
infcrtdd: number of threads 2
1
infcrtdd: number of threads 3
1
infcrt_a: number of threads 1
1
infcrt_a: number of threads 2
1
infcrt_a: number of threads 3
1
infcrt_g: number of threads 1
1
infcrt_g: number of threads 2
1
infcrt_mcd: number of threads 1
1
infcrt_mcd: number of threads 2
1
diffcoff_mcd: number of threads 1
1
i2upfind: number of threads 1
1
i2upfind_heat: number of threads 1
1
ddtds: number of threads 1
1
ddtds_energybal: number of threads 1
1
ddtds_energybal: number of threads 2
1
comp_bc_ice: number of threads 1
1
comp_bc_ice: number of threads 2
1
timeloop: number of threads 1
1
infheat_c: number of threads 1
1
infheat_d: number of threads 1
1
infevap: number of threads 1
1
updatedd: number of threads 1
1
updatedd: number of threads 2
1
updatedd_ener: number of threads 1
1
updatedd_ener: number of threads 2
1
updatedd_ener: number of threads 3
1
ddvsflow: number of threads 1
1
seepfdd: number of threads 1
1
tstepvs: number of threads 1
1
updatevs: number of threads 1
1
updatevs: number of threads 2
2
seepface: number of threads 1
1
soilparm: number of threads 1
1
msysdd: number of threads 1
1
msysdd: number of threads 2
1
msysdd: number of threads 3
1
msysvs: number of threads 1
1
mbalvs: number of threads 1
1
mbalvs: number of threads 2
1
mbalvs: number of threads 3
1
energysys: number of threads 1
1
energy_bal: number of threads 1
1
energy_bal: number of threads 2
1
velodd: number of threads 1
1
nexttime: number of threads 1
1
nexttime: number of threads 2
1
infcvs: number of threads 1
1
xyzcoord: number of threads 1
1
cvolume: number of threads 1
1
iajavs: number of threads 1
1
iajavs: number of threads 2
1
iajavs_dp: number of threads 1
1
iajavs_ener: number of threads 1
1
iajavs_ener: number of threads 2
1
matrix_uti: number of threads 1
1
iajart: number of threads 1
1
iajart: number of threads 2
1
initpppm: number of threads 1
1
initppdd: number of threads 1
1
initppvs: number of threads 1
1
initppvs: number of threads 2
1
initppeb: number of threads 1
1
initppeb: number of threads 2
1
initicvs: number of threads 1
1
initsatw: number of threads 1
1
initsatw: number of threads 2
1
initsatw: number of threads 3
1
initicener: number of threads 1
1
initprob: number of threads 1
1
initprob: number of threads 2
1
initicrt: number of threads 1
1
initicdd: number of threads 1
1
restart_r: number of threads 1
1
batreac: number of threads 1
1
batreac: number of threads 2
1
intpolt: number of threads
1
mbaldd: number of threads 1
1
mbaldd: number of threads 2
1
mbaldd: number of threads 3
1
mbaldd: number of threads 4
1
