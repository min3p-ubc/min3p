!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 826 $
!> $Author: dsu $
!> $Date: 2022-03-24 10:10:16 -0700 (Thu, 24 Mar 2022) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/cliqdisp.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine cliqdisp
!c -------------------
!c
!c       z                       Eight neighbouring nodes to ibk
!c                               are grouped into following clique
!c       ^  id1 ----- ibk        list for "pseudo dipersion element".
!c       |                _ y    Dispersive flux between pairs of
!c       |  /|        /|  /|     nodes only occurs across interfacial
!c         / |       / | /       area contained within elemental
!c           |         |         volume.
!c      id3 ----- id2  |
!c           |         |         possible fvpairs are:
!c       |         |             - in x-direction (fvpair(1,1-4,1-2):
!c       |  id5 ---|- id4          ibk-id1, id2-id3, id4-id5, id6-id7
!c       |         |             - in y-direction (fvpair(2,1-4,1-2):
!c       |  /      |  /            ibk-id2, id1-id3, id4-id6, id5-id7 
!c       | /       | /           - in z-direction (fvpair(3,1-4,1-2):
!c                                 ibk-id4, id2-id6, id1-id5, id3-id7
!c      id7 ----- id6  --> x
!c
!c written by:      Andre Unger
!c
!c last modified:   Uli Mayer - November 19, 96
!c                  THH add radial flow option Mar 07 
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           d(3,ibk)           = dimension of control volumes        + -
!c                                in x,y,z direction
!c           aread(3,ipair)     = A_ij/d_ij for current "pseudo       * +
!c                                dispersion element" associated 
!c                                with control volume ibk, up to 4 
!c                                entries for each dimension
!c       
!c           integer*4:
!c           ----------
!c           nx                 = number of control volumes in        + -
!c                                x-direction
!c           ny                 = number of control volumes in        + -
!c                                y-direction
!c           nz                 = number of control volumes in        + -
!c                                z-direction
!c           ix                 = edge marker in x-direction          + -
!c                                for current "pseudo dispersion
!c                                element" clique list
!c           iy                 = edge marker in y-direction          + -
!c                                for current "pseudo dispersion
!c                                element" clique list
!c           iz                 = edge marker in z-direction          + -
!c                                for current "pseudo dispersion
!c                                element" clique list
!c           idbg               = unit number - debugging file        + -
!c           nmax               = number of control volumes           + -
!c           fvpair(3,ipair,2)  = two control volumes in each pair    * +
!c                                for each dimension
!c           npair(3)           = number of pairs of control volumes  * +
!c                                in each dimension
!c
!c           logical:
!c           --------
!c           half_cells         = .true.  -> half cells on boundary   + -
!c
!c common:   -
!c
!c local:    real*8:
!c           -------
!c           d_ij               = distance between control volumes 
!c                                i and j
!c           edmult             = edge multiplier
!c           eps                = small increment
!c           rhalf              = constant
!c   
!c           integer*4:
!c           ----------
!c           jpair(3,2)         = pointer array to neighboring 
!c                                grid lines
!c           idim               = counter (dimensions)
!c           idim2              = pointer (dimension)
!c           idim3              = pointer (dimension)
!c           jx                 = counter (neighbors in x-direction)
!c           jy                 = counter (neighbors in y-direction)
!c           jz                 = counter (neighbors in z-direction)
!c           ix1                = pointer (grid line in x-direction)
!c           ix2                = pointer (grid line in x-direction)
!c           iy1                = pointer (grid line in y-direction)
!c           iy2                = pointer (grid line in y-direction)
!c           iz1                = pointer (grid line in z-direction)
!c           iz2                = pointer (grid line in z-direction)
!c           ibk                = pointer (current control volume i
!c                                         of node pair) 
!c           id                 = pointer (current control volume j
!c                                         of node pair)
!c           icount             = counter (number of pairs of control
!c                                         volumes)
!c
!c external: -
!c ----------------------------------------------------------------------

      subroutine cliqdisp (nx, ny, nz, ix, iy, iz,                     &
                          fvpair, npair,                               &
                          aread, area,dist,d,half_cells,ia,ja, njamxc, &
                          nmax, idbg, cinfrad, radial_coord)
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      use gen, only : nvxgbl, nvygbl, nvzgbl, nvxgls, nvygls, nvzgls,  &
                      b_enable_output  
      
      implicit none

!c  passed variables

      integer ix, iy, iz, nx, ny, nz,                                  &
             fvpair(3,12,2), npair(3), nmax, idbg, njamxc,             &
             ia(nmax+1),ja(njamxc)

      real*8 aread(3,12),area(3,12),dist(3,12),d(3,nmax),cinfrad(njamxc)

      logical half_cells, radial_coord

!c  local variables

      real*8 edmult, d_ij
      real*8, parameter :: rhalf = 0.5d0, eps = 1.0d-300, r2=2.0d0

      integer jpair(3,2), idim, idim2, idim3, jx, jy, jz,     &
             ix1, ix2, iy1, iy2, iz1, iz2, ibk, id, icount,   &       
             ii,iisav, i, iii, ipair

      ibk = 0
      id = 0
      iisav = 0
      d_ij = 0.0d0

!c           z                         Eight neighbouring nodes to ibk
!c                                     are grouped into following clique
!c           ^  id1 ----- ibk          list for "pseudo dipersion element".
!c           |                _ y      Dispersive flux between pairs of
!c           |  /|        /|  /|       nodes only occurs across interfacial
!c             / |       / | /         area contained within elemental
!c               |         |           volume.
!c          id3 ----- id2  |
!c               |         |
!c           |         |
!c           |  id5 ---|- id4
!c           |         |
!c           |  /      |  /
!c           | /       | /
!c
!c          id7 ----- id6  --> x


      jpair(1,1) = ix
      jpair(1,2) = ix - 1
      jpair(2,1) = iy
      jpair(2,2) = iy - 1
      jpair(3,1) = iz
      jpair(3,2) = iz - 1

!c  loop over the number of dimensions

      do 10 idim = 1, 3

!c  create all pairs of control volumes in dimension idim

         icount = 0
         idim2 = idim + 1
         idim3 = idim + 2
         if (idim2 .gt. 3) idim2 = idim2 - 3
         if (idim3 .gt. 3) idim3 = idim3 - 3

!c  loop over pairs of control volumes in each dimension

         do 20 jz = 1, 2
            if (jpair(3,jz) .gt. 0) then
               if (idim .eq. 3 .and. (jz .eq. 2 .or. &
                       jpair(3,1) .le. 1)) goto 21

               do 30 jy = 1, 2
                  if (jpair(2,jy) .gt. 0) then
                     if (idim .eq. 2 .and. (jy .eq. 2 .or. &
                             jpair(2,1) .le. 1)) goto 31

                     do 40 jx = 1, 2
                        if (jpair(1,jx) .gt. 0) then
                           if (idim .eq. 1 .and. (jx .eq. 2 .or. &
                                   jpair(1,1) .le. 1)) goto 41

!c  find node pair

                           if (idim .eq. 1) then
                              ix1 = jpair(1,1)
                              ix2 = jpair(1,2)
                              iy1 = jpair(2,jy)
                              iz1 = jpair(3,jz)
                              ibk = (iz1-1)*nx*ny + (iy1-1)*nx + ix1
                              id = (iz1-1)*nx*ny + (iy1-1)*nx + ix2

                           else if (idim .eq. 2) then
                              ix1 = jpair(1,jx)
                              iy1 = jpair(2,1)
                              iy2 = jpair(2,2)
                              iz1 = jpair(3,jz)
                              ibk = (iz1-1)*nx*ny + (iy1-1)*nx + ix1
                              id = (iz1-1)*nx*ny + (iy2-1)*nx + ix1

                           else if (idim .eq. 3) then
                              ix1 = jpair(1,jx)
                              iy1 = jpair(2,jy)
                              iz1 = jpair(3,1)
                              iz2 = jpair(3,2)
                              ibk = (iz1-1)*nx*ny + (iy1-1)*nx + ix1
                              id = (iz2-1)*nx*ny + (iy1-1)*nx + ix1
                           end if

                           icount = icount + 1
                           fvpair(idim, icount, 1) = ibk
                           fvpair(idim, icount, 2) = id

!c  reduce dispersive flux area between nodes ibk and id to the 
!c  area contained within the "pseudo dipsersion element"
!c  if off dimensions (idim2, idim3) lie on edge of grid, 
!c  their range of influence extends to edge of grid

                           edmult = rhalf
!c  the following codes has been modified to for domain decomposition method
!c  e.g, previous: if (iy1 .ne. 1 .and. iy1 .ne. ny) then
!c       now     : if ((iy1+nvygls-1) .ne. 1 .and. (iy1+nvygls-1) .ne. nvygbl) then

                           if (idim .eq. 1) then
                              if ((iy1+nvygls-1) .ne. 1 .and. (iy1+nvygls-1) .ne. nvygbl) then
                                 edmult = edmult * rhalf
                              end if
                              if ((iz1+nvzgls-1) .ne. 1 .and. (iz1+nvzgls-1) .ne. nvzgbl) then
                                 edmult = edmult * rhalf
                              end if

                           else if (idim .eq. 2) then
                              if ((ix1+nvxgls-1) .ne. 1 .and. (ix1+nvxgls-1) .ne. nvxgbl) then
                                 edmult = edmult * rhalf
                              end if
                              if ((iz1+nvzgls-1) .ne. 1 .and. (iz1+nvzgls-1) .ne. nvzgbl) then
                                 edmult = edmult * rhalf
                              end if

                           else if (idim .eq. 3) then
                              if ((ix1+nvxgls-1) .ne. 1 .and. (ix1+nvxgls-1) .ne. nvxgbl) then
                                 edmult = edmult * rhalf
                              end if
                              if ((iy1+nvygls-1) .ne. 1 .and. (iy1+nvygls-1) .ne. nvygbl) then
                                 edmult = edmult * rhalf
                              end if
                           end if

!c  half cells on boundary
!c  dispersive distance requires consideration of half cells
!c  the following codes has been modified to for domain decomposition method
!c  e.g, previous: if (ix.eq.2) then
!c       now     : if ((ix+nvxgls-1).eq.2) then
                           if (half_cells) then

                              if (idim .eq. 1) then
                                 if ((ix+nvxgls-1).eq.2) then
                                   d_ij = rhalf*d(idim,ibk)+d(idim,id)
                                 elseif ((ix+nvxgls-1).eq.nvxgbl) then
                                   d_ij = d(idim,ibk)+rhalf*d(idim,id)
                                 else
                                   d_ij = rhalf*(d(idim,ibk)+d(idim,id))
                                 end if

                              else if (idim .eq. 2) then
                                 if ((iy+nvygls-1).eq.2) then
                                   d_ij = rhalf*d(idim,ibk)+d(idim,id)
                                 elseif ((iy+nvygls-1).eq.nvygbl) then
                                   d_ij = d(idim,ibk)+rhalf*d(idim,id)
                                 else
                                   d_ij = rhalf*(d(idim,ibk)+d(idim,id))
                                 end if

                              else if (idim .eq. 3) then
                                 if ((iz+nvzgls-1).eq.2) then
                                   d_ij = rhalf*d(idim,ibk)+d(idim,id)
                                 elseif ((iz+nvzgls-1).eq.nvzgbl) then
                                   d_ij = d(idim,ibk)+rhalf*d(idim,id)
                                 else 
                                   d_ij = rhalf*(d(idim,ibk)+d(idim,id))
                                 end if
   
                              end if

                           else if (.not.half_cells) then

!c  full cells on boundary: 
!c  dispersive distance by arithmetic average of dimensions of cell

                              d_ij = rhalf*(d(idim,ibk)+d(idim,id))

                           end if
                           
                           dist(idim,icount) = d_ij + eps

                           aread(idim, icount) =                  &
                              (d(idim2, ibk) * d(idim3, ibk)      &
                             + d(idim2, id) * d(idim3, id))       &
                             * edmult / (d_ij + eps)
     
                           area(idim, icount) =                       &
                              (d(idim2, ibk) * d(idim3, ibk)          &
                             + d(idim2, id) * d(idim3, id)) * rhalf
                           
!!c overwrite intercell area for radial coordinates

                           if (radial_coord) then
                             do ii = ia(ibk),ia(ibk+1)-1
                               if (ja(ii) .eq. id) then
                                 iisav = ii
                                 go to 431
                               endif
                             end do
!431                          aread(idim, icount) = cinfrad(iisav)/     &
!                                                   (d_ij + eps)
!MX      
431                          aread(idim, icount) = cinfrad(iisav)*edmult*2.0/     &
                                                   (d_ij + eps)
                             
                             area(idim, icount) = cinfrad(iisav)  
                             
                           end if

                           continue
41                         continue
                        end if
40                   continue
31                   continue
                  end if
30             continue
21             continue
            end if
20       continue

         npair(idim) = icount

10    continue

!cdbg 
#ifdef DEBUG
      iii = 0
      if (iii.gt.0) then
        do idim = 1,3
          write(idbg,*) 'npair(',idim,') = ',npair(idim)
          do ipair = 1,npair(idim)
            write(idbg,*) 'aread(',idim,ipair,') = ',aread(idim,ipair)
            write(idbg,*) 'area(',idim,ipair,') = ',area(idim,ipair)
            write(idbg,*) ('fvpair(',idim,ipair,i,') = ',     &
                            fvpair(idim,ipair,i),i=1,2)
            write(idbg,*) 
          end do
        end do
        if (iii.eq.2) then
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if
      end if
#endif
!cdbg

      return
      end
