!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 878 $
!> $Author: dsu $
!> $Date: 2024-02-14 20:08:49 -0800 (Wed, 14 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/velodd.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine velodd
!c -------------------
!c
!c compute average interfacial velocities in x,y,z directions 
!c for rectangular, cartesian finite volume discretization
!c
!c from Uli Mayer template 
!c
!c written by:      Tom Henderson - September 24, 2002
!c
!c last modified:   Tom Henderson - September 8, 2003
!c                  correct velocity calculation for NAPL
!c                  presence
!c
!c                  THH Mar 05 for lattice divide by zero errors: linflux calc
!c                  THH July 2006 output continuous velocities
!c
!c                  Danyang Su - March. 14, 2014
!c                  HPC capabilities
!c
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           cinfvs(nn)         = influence coefficient               + -
!c                                (variably saturated flow) 
!c           dimcv(3,nn)        = dimension of cells in x,y,z         + -
!c                                direction
!c           pressure(nn)       = fluid pressure                      + -
!c           density(nn)        = density                             + -
!c           viscosity(nn)      = viscosity                           + -
!c           relperm(nn)        = relative permeability               + -
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           iavs(nn+1)         = row pointer array for 1d-scalar     + -
!c                                matrix
!c           idbg               = output for debugging information    + -
!c           ilog               = unit number, logbook                + -
!c           ivel               = unit number, average interfacial    + -
!c                                velocities
!c           javs(njavs)        = connectivity list for 1d-scalar     + -
!c                                matrix
!c           njavs              = number of global connections        + -
!c           nn                 = total number of control volumes     + -
!c           nvx                = number of control volumes           + -
!c                                in x direction
!c           nvy                = number of control volumes           + -
!c                                in y direction
!c           nvz                = number of control volumes           + -
!c                                in z direction
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions     + -
!c           half_cells         = .true.  -> half cells on boundary   + -
!c
!c common:   -
!c
!c local:    real*8:
!c           -------
!c           aread(3,12)        = A_ij/d_ij for current "pseudo
!c                                dispersion element" associated
!c                                with control volume ivol, up to 4
!c                                entries for each dimension
!c           areai              = interfacial area
!c           dflux              = interfacial flux
!c           eps                = constant
!c           r0                 = constant
!c           rhalf              = constant
!c           vel(3)             = average interfacial velocities
!c           gacc               = gravitational acceleration [m s^-2]
!c           dvolcoef           = relperm/viscosity for var_sat flow
!c                              = 1.0/viscosity for fully_sat flow
!c
!c           integer*4:
!c           ----------
!c           cvpair(3,12,2)     = pointers to connected control 
!c                                volumes in each pair for each 
!c                                dimension
!c           i1                 = pointer (connectivity list)
!c           i1sav              = pointer (connectivity list)
!c           idim               = pointer (dimensions)
!c           idim2              = pointer (dimensions)
!c           idim3              = pointer (dimensions)
!c           ipair              = counter (control volume pairs in
!c                                         dimension)
!c           ivol               = pointer (control volume i)
!c           jvol               = pointer (connected control volume j)
!c           ivol2              = counter (control volumes)
!c           ivx                = counter (number of control
!c                                volumes in x-direction)
!c           ivy                = counter (number of control
!c                                volumes in y-direction)
!c           ivz                = counter (number of control
!c                                volumes in z-direction)
!c           npair(3)           = number of control volume pairs
!c                                in dimension
!c
!c           character:
!c           ----------
!c           iups               = upstream pointer
!c
!c external: cliqdisp  = find control volume pairs for computation of 
!c                       average interfacial velocities
!c ----------------------------------------------------------------------

      subroutine velodd (nvx, nvy, nvz, iavs, javs, cinfvs, dimcv, xg,&
                           yg, zg, uvsnew, density, viscosity,        &
                           relperm, idbg, ilog,ivel, fully_saturated, &
                           njavs, nn, nn_loc, half_cells, pornew,     &
                           sanew, delt, courant_max,courant_num,      &
                           iprint,time_io,cinfrad,radial_coord,offset)

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use gen, only : rank, b_enable_output, node_idx_lg2l,            &
                      b_output_binary, realbuffer, ascii_fmt,          &
                      b_output_mpiio_single, node_idx_vel_lg2g,        &
                      b_output_multizone,nfloatbit,                    &
                      b_use_fixed_flow_vel, fixed_flow_vel,            &
                      mem_cur, mem_max, memory_monitor,                &
                      b_mpiarray_ivel_dd_init,                         &
                      mpiarray_filetype_ivel_dd,                       &
                      mpiarray_sizes_gbl_ivel_dd,                      &
                      mpiarray_sizes_sub_ivel_dd,                      &
                      mpiarray_starts_sub_ivel_dd

      use dens, only : av_dens_z, ref_dens

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      use module_binary_mpiio, only : binary_write_data,               &
                                      binary_subarray_initialize

      implicit none 

#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

      external :: cliqdisp, checkerr

!c  passed variables

      integer :: nvx, nvy, nvz, njavs, nn, nn_loc, iavs(nn+1),        &
                 javs(njavs), idbg, ilog, ivel, iprint, ierr
                                                                       
      logical :: half_cells, fully_saturated,radial_coord
                                                                       
      real*8  :: uvsnew(nn), density(nn), viscosity(nn), relperm(nn),  &
                dimcv(3,nn), cinfvs(njavs), xg(nn), yg(nn), zg(nn),    &
                pornew(nn), sanew(nn),delt, courant_max,time_io,       &
                cinfrad(njavs) 

#ifdef PETSC
      integer(kind=MPI_OFFSET_KIND) :: offset, offset_temp
#else
      integer*8 :: offset, offset_temp
#endif

!c  local variables

      real*8,parameter :: eps = 1.0d-300, r0 = 0.0d0, r1 = 1.0d0,     &
                  rhalf = 0.5d0, gacc = 9.80665d0
      
      real*8 aread(3,12), areax(3,12), dist(3,12), vel(3), areai, dflux,&
             linvel(3), linflux, del_ivol, del_jvol, vel_ivol,         &
             vel_jvol, courant, del_press, del_zvol, dvolcoef,         &
             rho_av, velobs(12), xg_out, yg_out, zg_out
                                                                        
      integer ivol, ivz, ivy, ivx, i1, jvol, i1sav, idim, npair(3),    &
              cvpair(3,12,2), ipair, idim2, idim3, courant_num,        &
              ivelout, nvel, ivol2, ivol_l

      character*1 iups

#ifdef PETSC
      integer*4 :: courant_num_gbl
      real*8 :: courant_max_gbl
      PetscErrorCode :: ierrcode
#else
      integer :: ierrcode
#endif
      

      courant_max = r0
      courant_num = 0
      


!c Temp velocity output
      ivelout = 0 ! print continuous velocities
      nvel=12     ! number of obs points

      velobs = (/ 7116, 7461, 9999, 10344, 11921, 12266, 12882, 13227,&
          14804, 15149, 17687, 18032 /)

!    velobs = (/ 6647, 7011, 9347, 9711, 11147, 11511, 12047, 12411,
!     &     13847, 14211, 16547, 16911 /)

      if (b_output_binary .and. iprint .eq. 1) then
        allocate(realbuffer(nn_loc*9), stat = ierr)
        call checkerr(ierr,'velodd-realbuffer',ilog)
        realbuffer = 0.0d0
        call memory_monitor(sizeof(realbuffer),'realbuffer',.true.)
      end if

!c  compute average interfacial velocities

      ivol2 = 0
      
      ivol_l = 0
      
      do ivz = 1, nvz          !increments in z-direction
        do ivy = 1, nvy        !increments in y-direction
          do ivx = 1, nvx      !increments in x-direction

            ivol2 = ivol2 + 1  !counter - control volumes

!c  skip ghost nodes
#ifdef PETSC
            if(node_idx_lg2l(ivol2) < 0) then
                cycle
            end if
#endif

!c  find node pairs for interfacial velocities

!            call cliqdisp (nvx, nvy, nvz, ivx, ivy, ivz,
!     &                     cvpair, npair, aread, dimcv, half_cells,
!     &                     nn,idbg)
            call cliqdisp (nvx, nvy, nvz, ivx, ivy, ivz,              &
                           cvpair,npair,aread,areax,dist,dimcv,       &
                           half_cells,iavs,javs,njavs,                &
                           nn,idbg,cinfrad,radial_coord)
                                                                      
!c  check connections
                                                                       
            if ((nvx .gt. 1 .and. npair(1) .eq. 0) .or.               &
                (nvy .gt. 1 .and. npair(2) .eq. 0) .or.               &
                (nvz .gt. 1 .and. npair(3) .eq. 0)) cycle
            
            ivol_l = ivol_l + 1

!c  loop over the dimensions x,y,z

            do idim = 1, 3

              idim2 = idim + 1
              idim3 = idim + 2
              if (idim2 .gt. 3) idim2 = idim2 - 3
              if (idim3 .gt. 3) idim3 = idim3 - 3

!c  zero average interfacial velocity

              vel(idim) = r0
              linvel(idim) = r0

!c  loop over the number of control volume pairs in the dimension

              do ipair = 1, npair(idim)

                ivol = cvpair(idim, ipair, 1)
                jvol = cvpair(idim, ipair, 2)

                do i1 = iavs(ivol), iavs(ivol+1)-1
                  if (javs(i1) .eq. jvol) then
                    i1sav = i1
                    go to 500
                  endif
                end do
                
                if (rank == 0) then
                  write(ilog,*) ' error-cannot find jvol in list'
                  write(ilog,*) ' ivol, jvol ', ivol, jvol
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop

500             continue

!c  calculate average interfacial area between nodes
                if (.not.b_use_fixed_flow_vel) then
!cprovi------------------------------------------------
!cprovi Assign the interfacial area
!cprovi------------------------------------------------                
                  areai = areax(idim, ipair)

!c  find flux between control volume pair

                  del_press = uvsnew(jvol) - uvsnew(ivol)
                  del_zvol = zg(jvol) - zg(ivol)

                  if (del_zvol .ne. r0) then
                    rho_av = rhalf * (density(ivol) + density(jvol))

                    if (av_dens_z) then
                      del_press = rho_av*(uvsnew(jvol)/density(jvol)-  &
                                          uvsnew(ivol)/density(ivol))
                    end if

!c  convert del_z to total elevation potential wrt fluid pressure
!c  and calculate difference in total pressure potential

                    del_zvol = del_zvol * rho_av * gacc
                    del_press = del_press + del_zvol
                  end if

!c  assign coefficients for upstream weighting of density and viscosity
!c  required for mass flux calculation
 
                  if (del_press .gt. r0) then
                    dvolcoef = relperm(jvol) / viscosity(jvol)  
                  else
                    dvolcoef = relperm(ivol) / viscosity(ivol) !upstream           
                  end if

                  dflux = - cinfvs(i1sav) * dvolcoef * del_press

!c  distance-weighted seepage velocity calculation

                  del_ivol = rhalf * dimcv(idim,ivol)
                  del_jvol = rhalf * dimcv(idim,jvol)

                  vel_ivol = dflux / areai /                           &
                               (sanew(ivol) * pornew(ivol))
                  vel_jvol = dflux / areai /                           &
                               (sanew(jvol) * pornew(jvol))

                  linflux  = (del_ivol + del_jvol)/                    &
                             (del_ivol/(vel_ivol + eps) +              &
                              del_jvol/(vel_jvol + eps))

!c  Courant number calculation

                  courant = dabs(linflux * delt / (del_ivol + del_jvol))

!c total instances with courant exceeding unity
                  if (courant.gt.r1) then
                    courant_num = courant_num + 1
                  end if              

                  if (courant.gt.courant_max) then
                    courant_max = courant
                  end if

                  continue
!c  Darcy velocity is the flux (m^3/day) divided
!c  by the interfacial area between the two control volumes

                  vel(idim) = vel(idim) - dflux / areai
                  linvel(idim) = linvel(idim) - linflux
                end if

              end do  !ipair = 1, npair(idim)

!c  find the average interfacial Darcy velocity in the x,y,z directions
              if (.not.b_use_fixed_flow_vel) then
                vel(idim) = vel(idim)/(float( npair(idim) ) + eps)
                linvel(idim) = linvel(idim)/(float( npair(idim) ) + eps)
              end if

            end do  !do idim = 1, 3

            if (b_use_fixed_flow_vel) then
              vel(1) = fixed_flow_vel%x
              vel(2) = fixed_flow_vel%y
              vel(3) = fixed_flow_vel%z
              linvel = vel
            end if

!c  write average interfacial velocities to output file if called by
!c  ouputdd routine: iprint = 1; else iprint = 0

            if (iprint .eq. 1) then
              if (nvx.gt.1) then
                xg_out = xg(ivol2) - rhalf * dimcv(1,ivol2)
              else
                xg_out = xg(ivol2)
              end if

              if (nvy.gt.1) then
                yg_out = yg(ivol2) - rhalf * dimcv(2,ivol2)
              else
                yg_out = yg(ivol2)
              end if

              if (nvz.gt.1) then
                zg_out = zg(ivol2) - rhalf * dimcv(3,ivol2)
              else
                zg_out = zg(ivol2)
              end if
              
              if (b_output_binary) then
                realbuffer((ivol_l-1)*9+1:ivol_l*9) = (/xg_out, yg_out,&
                           zg_out, vel(1), vel(2), vel(3), linvel(1),  &
                           linvel(2), linvel(3)/) 
              else
                write(ivel,ascii_fmt) xg_out,yg_out,zg_out,            &
                                     (vel(idim),idim=1,3),             &
                                     (linvel(idim),idim=1,3)
              end if
            end if    !(iprint .eq. 1)            
                                                                     
            if (ivelout .eq. 1 ) then
            do i1 = 1,nvel
              if (ivol2 .eq. velobs(i1)) then
                                                                       
                  if (nvx.gt.1) then                                   
                    xg_out = xg(ivol2) - rhalf * dimcv(1,ivol2)        
                  else                                                 
                    xg_out = xg(ivol2)                                 
                  end if
                                                                       
                  if (nvy.gt.1) then                                   
                    yg_out = yg(ivol2) - rhalf * dimcv(2,ivol2)        
                  else                                                 
                    yg_out = yg(ivol2)                                 
                  end if
                                                                       
                  if (nvz.gt.1) then                                   
                    zg_out = zg(ivol2) - rhalf * dimcv(3,ivol2)        
                  else                                                 
                    zg_out = zg(ivol2)                                 
                  end if
#ifdef DEBUG                                                 
                  write(idbg,ascii_fmt) ivol2,time_io,                &
                      xg_out,yg_out,zg_out,                           &
                      (linvel(idim),idim=1,3)
#endif
              end if !(ivol2 .eq. velobs(i1))
            end do
            end if !(ivelout .eq. 1)

          end do
        end do
      end do


#ifdef PETSC
      call MPI_Allreduce(courant_num, courant_num_gbl,1,MPI_INTEGER4, &
                         MPI_SUM,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      courant_num = courant_num_gbl

      call MPI_Allreduce(courant_max, courant_max_gbl,1,MPI_REAL8,    &
                         MPI_MAX,Petsc_Comm_World,ierrcode)
      CHKERRQ(ierrcode)
      courant_max = courant_max_gbl
#endif

      if (b_output_binary .and. iprint .eq. 1) then 
        if (b_output_multizone .or. .not.b_output_mpiio_single) then
          call binary_write_data(ivel, ivol_l*9, realbuffer,           &
                       offset,b_output_mpiio_single)
        else
          call binary_subarray_initialize(9,b_mpiarray_ivel_dd_init,   &
                      .true.,mpiarray_filetype_ivel_dd,                &
                      mpiarray_sizes_gbl_ivel_dd,                      &
                      mpiarray_sizes_sub_ivel_dd,                      &
                      mpiarray_starts_sub_ivel_dd)
          call binary_write_data(ivel, ivol_l*9, realbuffer,           &
                       offset,mpiarray_filetype_ivel_dd)
        end if
        call memory_monitor(-sizeof(realbuffer),'realbuffer',.true.)
        deallocate(realbuffer)
      end if

      return
      end

