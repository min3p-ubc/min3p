!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/jacbrt.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine jacbrt
!c -----------------
!c
!c modifed for density dependent flow 
!c
!c incorporate Dirichlet, Neumann and Cauchy type boundary condition in 
!c Jacobian matrix and rhs vector for reactive transport
!c
!c
!c written by:      Uli Mayer - August 20, 96
!c
!c last modified:   Tom Henderson - January 26, 2007
!c                  Lump 'point' BC with Cauchy BC to simulate pumping well
!c                  
!c                  Sergi Molins - May 2, 2006 
!c                                 tried to include DGM diff + advection 
!c                                 in 'mixed' type b.c. section without success
!c                  Sergi Molins - June 12, 2006
!c                                 gsatmin = 0.0 (larger values cause DGM/ MS
!c                                 modules to fail under saturated conditions)
!c                                 relpgij passed to dgm_dfluxdg.f
!c
!c                  Danyang Su   - March 27, 2014
!c                                 Add gas advection, modified from Sergi Molins's codes
!c                  Danyang Su   - Sept. 10, 2018
!c                                 Add Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           art(njart)         = jacobian matrix                     + +
!c           bcondrt_a(nc,nbrt) = concentrations in boundary control  + -
!c                                volumes (aqueous phase)
!c                                first type b.c. -> free species 
!c                                                   concentrations
!c                                third type b.c. -> total aqueous
!c                                                   component
!c                                                   concentrations
!c           bcondrt_g(nc,nbrt) = concentrations in boundary control  + -
!c                                volumes (gaseous phase)
!c                                third type b.c. -> total gaseous
!c                                                   component
!c                                                   concentrations
!c           bdycrt_d(nbrt)     = boundary influence coefficients for + -
!c                                diffusive mass fluxes across
!c                                boundary (excluding diffusion
!c                                coefficient)
!c           brt(nn*n)          = rhs vector                          + +
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           c(nc,nn)            = concentrations of free species      + -
!c                                - old time level [moles/l water]
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           gamma(nc+nx,nn)    = activity coefficients of free       + -
!c                                species
!c           dinc_rt            = factor to compute increment for     + -
!c                                numerical differentiation
!c           dtotcflux(n)       = derivatives of total mass fluxes    * +
!c                                (water phase)
!c           dtotgflux(n)       = derivatives of total mass fluxes    * +
!c                                (gaseous phase)
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles/l air]
!c           pornew(nn)         = porosity                            + -
!c           sgnew(nn)          = gaseous phase saturation            + -
!c                                (new time level)
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                (new time level)
!c           sionnew(nn)        = ionic strength                      + -
!c                                - new time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totcnew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totgnew(n,nn)      = total gaseous component             * +
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totcflux(n)        = total mass fluxes (aqueous phase)   * +
!c           totgflux(n)        = total mass fluxes (gaseous phase)   * +
!c
!c           integer*4:
!c           ----------
!c           iart(nn*n+1)       = row pointer array for art           + -
!c           iavs(nn+1)         = row pointer array for avs           + -
!c           igen               = unit number, generic output file    + -
!c           idbg               = unit number, debugging file         + -
!c           ilog               = unit number, logbook file           + -
!c           jabrt(nbrt)        = pointer array - boundary conditions + -
!c                                (reactive transport)
!c           lart(njavs+1)      = pointer array                       + -
!c           kadbl(n,n)         = pointer array for conversion to     + -
!c                                sparse format (diagonal block
!c                                matrices)
!c           kaobl(n,n)         = pointer array for conversion        + -
!c                                to sparse format
!c                                (off-diagonal block matrices)
!c           kart(njart)        = mapping pointer
!c                                (global block -> nd-scalar)         + -
!c           l_prfx             = length of prefix of I/O files       + -
!c           l_zone_name        = length of zone name                 + -
!c           n                  = number of primary unknowns          + -
!c           nbrt               = number of specified boundary        + -
!c                                control volumes
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           tec_header         = .true.  -> write header for tecplot + -
!c                                           postprocessing to output
!c                                           files
!c                                .false. -> skip headers
!c
!c           character:
!c           ----------
!c           btypert(nn)        = type of boundary control volumes    + -
!c                                'first'  = Dirichlet
!c                                           (specified
!c                                            concentration)
!c                                'second' = Neumann
!c                                           (specified dispersive flux, 
!c                                            free mass outflux for aqueous
!c                                            phase, free exit)
!c                                'third'  = Cauchy
!c                                           (specified dispersive and advective flux, 
!c                                            for aqueous phase)
!c                                'third-evap'
!c                                         = Cauchy
!c                                           (specified advective
!c                                            mass influx for
!c                                            aqueous phase, for outflux,
!c                                            use closed boundary for transport,
!c                                            like evaporation)
!c                                'mixed'  = mixed
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and free
!c                                            diffusive mass influx
!c                                            for gaseous phase)
!c                            'mixed-evap' = mixed-evap
!c                                           (specified advective
!c                                            mass influx and
!c                                            free diffusive mass
!c                                            influx for aqueous
!c                                            phase and gaseous phase,
!c                                            for outflux, use closed boundary
!c                                            for transport for aqueous phase,
!c                                            like evaporation)
!c           prefix             = prefix name for all I/O files       + -
!c           tortuosity_corr    = .true.  -> Millington-Quirk         + -
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c           zone_name          = name of zone                        * *
!c
!c phys.f:   real*8:
!c           -------
!c           diff_a             = diffusion coefficient in aqueous    + -
!c                                phase (equal for all species)
!c           diff_g             = diffusion coefficient in gaseous    + -
!c                                phase (equal for all species)
!c
!c chem.f:   real*8:
!c           -------
!c           acth2omin          = min. activity for h2o
!c           adav               = coefficient for Davies equation     + -
!c           bdav               = coefficient for Davies equation     + -
!c           cinc(nc,nthreads)  = incremented free species            * +
!c                                concentrations
!c                                [moles/l water]
!c           cxinc(nx,nthreads) = secondary aqueous species           * +
!c                                concentrations dependent on
!c                                incremented free species
!c                                concentrations
!c                                [moles/l water]
!c           chargec(ic)        = charge of free species              + -
!c           chargex(ix)        = charge of secondary aqueous         + -
!c                                species
!c           dhac(ic)           = debye-huckel a for free species     + -
!c           dhbc(ic)           = debye-huckel b for free species     + -
!c           dhax(ix)           = debye-huckel a for secondary        + -
!c                                aqueous species
!c           dhbx(ix)           = debye-huckel b for secondary        + -
!c                                aqueous species
!c           dhad(nthreads)     = Debye Huckel constant a_d depending + -
!c                                on dielectric constant and
!c                                temperature (only for 25C)
!c           dhbd(nthreads)     = Debye Huckel constant b_d depending + -
!c                                on dielectric constant and
!c                                temperature (only for 25C)
!c           dtotc(n,ntheads)   = derivatives of total aqueous        * *
!c                                component concentrations
!c                                [moles/l water]
!c           dtotg(n)           = derivatives of total gaseous        * *
!c                                component concentrations
!c                                [moles/l air]
!c           eqr(nr,nthreads)   = equilibrium constant for redox      + -
!c                                couple reaction equation
!c           eqx(nx,nthreads)   = equilibrium constants for           + -
!c                                aqueous complexes
!c           ginc(ng,nthreads)  = gas concentrations dependent on     * *
!c                                incremented free species
!c                                concentrations
!c                                [moles/l air]
!c           totcn(n,nthreads)  = total aqueous component             + -
!c                                concentrations
!c                                - new time level, [moles/l water]
!c           xnug(ng*nc)        = stoichiometric coefficient matrix   + -
!c                                for formation of gases from
!c                                free species
!c           xnur(nr*nc)        = stoichiometric coefficient of       + -
!c                                component in redox couple
!c                                reaction equation
!c           xnux(nx*nc)        = stoichiometric coefficient matrix   + -
!c                                for formation of aqueous complexes
!c                                from components
!c
!c           integer*4:
!c           ----------
!c           iaga(ng+1)         = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                free species in gases
!c           iarc(nr+1)         = row pointer array to                + -
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           iax(nx+1)          = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                free species in
!c                                secondary aqueous species
!c           jaga(ng*nc)        = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in gases
!c           jarc(nr*nc)        = column pointer array to             + -
!c                                stoichiometric coefficients in
!c                                redox reaction
!c           jax(nx*nc)         = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                free species in secondary aqueous
!c                                species
!c           nc                 = number of components                + -
!c           nr                 = number of redox couples             + -
!c           nx                 = number of secondary aqueous species + -
!c
!c           logical:
!c           --------
!c           analyt_deriv_rt    = .true.  -> form derivatives         + -
!c                                           analytically
!c           redox_equil        = .true.  -> equilibrium reactions    + -
!c                                           for redox couples
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           update_activity(nthreads)    
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       + -
!c                                'surface' = surface site
!c                                'biomass' = biomass
!c           namec(nc)          = component names                     + -
!c           namex(nx)          = names of secondary aqueous species  + -
!c
!c dens.f:   logical:
!c           --------
!c          density_dependence = .true.  -> density-dependent flow   + -
!c
!c local:    real*8:
!c           -------
!c           bdyinfrt_da        = boundary influence coefficient
!c                                for diffusive mass flux (aqueous
!c                                phase)
!c           bdyinfrt_dg        = boundary influence coefficient
!c                                for diffusive mass flux (gaseous
!c                                phase)
!c           diff_eff           = effective diffusion coefficient
!c           drtinc             = increment for numerical 
!c                                differentiation
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter (row entries)
!c           i2                 = pointer (entries in ja, a arrays
!c                                         for nd-scalar matrix)
!c           ibl                = counter (rows of block matrix)
!c           ibrt               = counter (boundary control volumes)
!c           ic                 = counter (components)
!c           ig                 = counter (gases)
!c           ir                 = counter (redox couples)
!c           ix                 = counter (aqueous complexes)
!c           idiag              = pointer (diagonal entry - global
!c                                         scalar matrix)
!c           iend               = pointer (end)
!c           iend2              = pointer (end)
!c           irow               = pointer (row in global scalar 
!c                                         matrix)
!c           istart             = pointer (start) 
!c           istart2            = pointer (start) 
!c           ivol               = pointer to current control volume
!c           jbl                = counter (columns of block matrix)
!c           ldiag              = pointer (diagonal block in global
!c                                         block matrix)
!c           info_debug         = 0 -> no debugging information
!c                              = 1 -> write debugging information to
!c                                     prefix_o.dbg
!c                              = 2 -> write debugging information to
!c                                     prefix_o.dbg and quit
!c
!c external: acoff     = compute activity coefficient 
!c           bdryflux  = compute water flux across boundary control 
!c                       volumes
!c           comptotc  = comptotc  = compress concentration vector, if number
!c                       of unknowns is reduced due to redox
!c                       equilibrium reactions
!c           ddbdflux  = compute water flux across boundary control 
!c                       volumes - density dependent flow
!c           diffcoff  = compute effective diffusion coefficient
!c           dtotconc  = compute numerical derivative of total aqueous
!c                       component concentrations
!c           atotconc  = compute analytical derivatives of total aqueous
!c                       component concentrations
!c           dtotcong  = compute derivative of total gaseous
!c                       component concentrations
!c           fluxd     = diffusive/dispersive flux
!c           gasconc   = compute gas concentrations based on
!c                       concentrations of free species
!c           secspec   = compute aqueous complex concentration 
!c                       based on concentrations of free species
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totconc   = compute total aqueous component 
!c                       concentrations based on concentrations 
!c                       of free species and secondary aqueous 
!c                       species
!c ----------------------------------------------------------------------
 
      subroutine jacbrt
 
      use parm
      use gen
      use phys
      use chem
      use dens
      use dgml
      use mod_diffcoff, only : diffcoff
#ifdef OPENMP
      use omp_lib 
#endif      
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

#ifdef USG
      use usg_mesh_data, only : node_num_cells, node_cells
#endif

      implicit none
      
      integer :: idiag, i1, i2, ibl, ibvs, icol, ierr, ig, info_debug, &
                 ibrt, ivol, ic, ir, ix, istart, iend, istart2, iend2, &
                 irow, iaq, jbl, ldiag, i, j, icell, idim
      
      real*8 :: area_ivol, bdyinfrt_da, bdyinfrt_dg, dgflux, dfluxvg,  &
                diff_eff, diff_loc, drtinc, gasdiff2, diffcoff_g,      &
                totwflux_atm, tothflux_atm
      real*8, external :: acoff, bdryflux, ddbdflux, fluxd, fluxvg,    &
                gasm, gasd_m, gasp_m, gasv, gasp, pressure_melt_k
      
      integer :: tid, ivol_track, ivol_gbl

      external comptotc, dtotcong, secspec, totconc,                   &
               giups_brt, wgprop, wgpropd, atotconc, dtotconc,         &
               gasconc, tcorr, gcreact, jacbevap
           
!cprovi-------------------------------------------------------------------
!cprovi This variables was added by Sergio Andres Bea Jofre 
!cprovi-------------------------------------------------------------------      
      real*8             inoutflow
      logical            compute_diff
!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, rsmall=1.0d-1,      &
                           rverysmall=1.0d-30, gsatmin=0.0d0
     
!cdsu added for dgm model
!c dgm variables and initialization
      integer*4 :: ipvt(ng)
        real*8    :: dgm_gflux(nc), dgm_dgflux(nc)
        real*8    :: ludecomp(ng,ng), fmat(ng)

!c ms variables    
        real*8    :: ms_gflux(nc), ms_dgflux(nc), neflux(nc),            &
                   lumat2(ng-1,ng-1)
      real*8 :: so_av, cinfrt, mdens_g_inc, dgmfrac(ng)
      
!cdsu-------------------------------------------------------------------
!cdsu---------------------Gas transport variables-----------------------
!cdsu-------------------------------------------------------------------
      character*12 :: spt_weight
      real*8 ::                   &
             gsatijbrt          , &
             gporijbrt          , &
             tauijbrt           , &
             mdens_g_ivol       , &
             mdens_g_brt        , &
             gpivol_ivol        , &
             gdens_ivol         , &
             gvisc_ivol         , &
             gpivol_brt         , &
             gdens_brt          , &
             gvisc_brt          , &
             relpgij            , &
             densgij            , &
             viscgij            , &
             gpij               , &
             dgpivol            , &
             dmdens_i           , &
             ddens_i            , &
             wfac               , &
             relpgi             , &
             relpgj


!cpvovi---------------------------------------------------------------
!cpvovi---------------------------------------------------------------
!cpvovi---------------------------------------------------------------      
      real (type_r8), allocatable :: bdyinfrt_da_ic(:)
      
      
#ifdef OPENMP
      tid = omp_get_thread_num() + 1
#else
      tid = 1
#endif

      gsatijbrt = r0
  
      allocate (bdyinfrt_da_ic(nc), stat = ierr)
      bdyinfrt_da_ic(1:nc) = r0
      call checkerr(ierr,'bdyinfrt_da_ic',ilog)
      call memory_monitor(sizeof(bdyinfrt_da_ic),'bdyinfrt_da_ic',.true.)

!cpvovi---------------------------------------------------------------
!cpvovi---------------------------------------------------------------
!cpvovi---------------------------------------------------------------
      if(iter_rt.le.1 .and. mtime.le.1) then
        info_debug = 0
        ivol_track = -1
      else
        info_debug = 0
        ivol_track = -1
      end if      

!c    assign gas advection spatial weighting
      spt_weight = spatial_weighting
      
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (i_matrix_assembly_type_jacbrt == 1)                     &
    !$omp num_threads(numofthreads_matrix_react)                      &
    !$omp default(shared)                                             &
    !$omp private(tid, i2, ibl, ibrt, ibvs, ic, idiag, iend, iend2,   &
    !$omp iaq, ig, ir, irow, istart, istart2, ivol, ix, jbl, ldiag,   &
    !$omp ivol_gbl, idim, totwflux_atm, tothflux_atm, area_ivol,      &
    !$omp bdyinfrt_da, bdyinfrt_da_ic, bdyinfrt_dg, compute_diff,     &
    !$omp diff_eff, diff_loc, drtinc, dtotcflux, dtotgflux, inoutflow,&
    !$omp totcflux, totgflux, zone_name,                              &
    !$omp icell, relpgi, relpgj, relpgij,                             &     !USG code
    !$omp gsatijbrt, gporijbrt, tauijbrt, mdens_g_ivol,               &     !Gas transport variables
    !$omp mdens_g_brt, gpivol_ivol, gdens_ivol, gvisc_ivol,           &
    !$omp gpivol_brt, gdens_brt, gvisc_brt, totgnew_brt,              &
    !$omp gmfrac_ivol, gmfrac_brt, scalfac_aq, totgmfrac_ivol,        &
    !$omp totgmfrac_brt, iupsgbrt, totgij, gij,                       &     
    !$omp dgpivol, dmdens_i, ddens_i, dg, wfac,                       &
    !$omp cinfrt, ms_gflux, ms_dgflux, dgm_gflux, dgm_dgflux,         &
    !$omp dgmfrac, fmat, ipvt, ludecomp, lumat2, neflux,              &
    !$omp mdens_g_inc, so_av, dgflux)                                       !End of Gas transport variables

!c  loop over boundary control volumes
#ifdef SCHEDULE_DYNAMIC
    !$omp do schedule(dynamic)
#elif SCHEDULE_STATIC
    !$omp do schedule(static)
#elif SCHEDULE_GUIDED
    !$omp do schedule(guided) 
#else
    !$omp do schedule(auto)
#endif

#endif   

      do ibrt = 1,nbrt
          
#ifdef OPENMP
        tid = omp_get_thread_num() + 1
#else
        tid = 1
#endif
          
        ivol = jabrt(ibrt)
        if (ivol < 0) then
          cycle
        end if

        if (compute_ice_sheet_loading) then
          if (.not. b_jabrt_ice(ibrt)) then
            cycle
          end if
        end if
          
#ifdef DEBUG
#ifdef PETSC
        ivol_gbl = node_idx_lg2g(ivol)
#else
        ivol_gbl = ivol
#endif
#endif

        bdyinfrt_da = r0
        bdyinfrt_da_ic = r0
        bdyinfrt_dg = r0
        drtinc = r0
        dtotcflux = r0
        dtotgflux = r0
        inoutflow = r0
        totcflux = r0
        compute_diff = .false.

#ifdef DEBUG
        if(info_debug > 20) then
          if(ivol_gbl == ivol_track .or. ivol_track == 0) then
            write(idbg, *) "btypert(ivol):",trim(btypert(ivol))
          end if
        end if
#endif

!c  temperature corrections for debye-huckel, equilibrium and
!c  rate constants

        if (temp_corr.or.heat_transport) then
          call tcorr(tkel(ivol),ivol,tid)
        end if
 
!c ----------------------------------------------------------------------
!c Dirichlet type boundary condition
!c  -> fixed free species concentration
!c  -> put 1 on diagonal, zero out rest of row and rhs
!c ----------------------------------------------------------------------

        if (btypert(ivol).eq.'first') then  !boundary types

!c  temperature correction for boundary concentrations
         
          if (temp_corr.or.heat_transport) then

            do ic = 1,nc-1
              totcn(ic,tid) = totcnew(ic,ivol)
              totco(ic,tid) = totcold(ic,ivol)
            end do
            
            do iaq=1,naq
              scalfac_aq(iaq)=scalfac_aq_ivol(iaq,ivol)
            end do 

            zone_name = 'temperature-correction'
            call gcreact(cnew(1,ivol),c(1,ivol),cx(1,ivol),       &
                         gamma(1,ivol),gamma(nc+1,ivol),          &
                         gnew(1,ivol),sanew(ivol),sgnew(ivol),    &
                         pornew(ivol),igen,ilog,tid,idbg,         &
                         tec_header,prefix,l_prfx,                &
                         zone_name,l_zone_name,                   &
                         mtime,i_append_sim,mtime_append)
          end if

          istart = (ivol-1)*n+1           !pointer - first row
          iend = ivol*n                   !pointer - last row

          do irow = istart,iend           !loop over rows
            istart2 = iart(irow)+1        !pointer - start of row
            iend2 = iart(irow+1)-1        !pointer - end of row
            idiag = iart(irow)            !pointer - diagonal

            art(idiag) = r1
            do i1=istart2,iend2          
              art(i1) = r0                !modify jacobian matrix
            end do
            brt(irow) = r0                !modify rhs-vector
          end do
          
#ifdef DEBUG
          if(info_debug > 20) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then 
              write(idbg, *)                                          &
                "--> brt first boundary type, istart, iend, brt ",    &
                istart, iend, brt(istart:iend)
            end if
          end if 
#endif

!c ----------------------------------------------------------------------
!c  Neumann type boundary condition
!c  -> advective mass flux across outflow boundary
!c     modify rhs-vector and Jacobian matrix
!c ----------------------------------------------------------------------
 
        elseif (btypert(ivol).eq.'second') then

!c  modify rhs-vector

          istart = (ivol-1)*n+1           !pointer - first row
          iend = ivol*n                   !pointer - last row

          ic = 0
          do irow = istart,iend           !rows (global scalar matrix)
            ic = ic+1
            if (component_type(ic).eq.'aqueous') then
              if (density_dependence) then
                totcflux(ic) = ddbdflux(ivol) * totcnew(ic,ivol)
                brt(irow) = brt(irow) + totcflux(ic)              
              else
                totcflux(ic) = bdryflux(ivol) * totcnew(ic,ivol)
                brt(irow) = brt(irow) + totcflux(ic)
              end if
#ifdef DEBUG
              if(info_debug > 20) then
                if(ivol_gbl == ivol_track .or. ivol_track == 0) then 
                  write(idbg, *)                                      & 
                    "--> brt second boundary type, irow, brt ",       &
                    irow, brt(irow)
                end if
              end if
#endif
            end if
          end do

          idiag = iavs(ivol)        !diagonal pointer - block matrix

!c  compute derivatives of total mass flux across boundary

!c  temporary storage for free species concentrations

          do ic=1,nc
            cinc(ic,tid) = cnew(ic,ivol)
          end do

          do jbl=1,n                !loop over columns of block matrix

!c  compute increment for numerical differentiation

            drtinc = dinc_rt*cnew(jbl,ivol)

!c  increment free species concentration for current column

            cinc(jbl,tid) = cnew(jbl,ivol)+drtinc

!c  recompute activity coefficients

            if (update_activity(tid).eq.'double_update') then
!cprovi----------------------------------------------       
               if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andr�s Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi Cuidado, las componentes pueden no ser acuosas
!cprovi preguntarle a Uli 
!cprovi---------------------------------------------- 
                 call pitzer (phase,gamma(1:nc,ivol),             &
                              gamma(nc+1:nc+nx,ivol),             &
                              cnew(1:nc,ivol),cx(1:nx,ivol),      &
                              nc,nx,ilog)
               else
!c  for free species
                 do ic=1,nc
                     gamma(ic,ivol) = acoff(cnew(1,ivol),         &
                                      cx(1,ivol),                 &
                                      sionnew(ivol),chargec(ic),  &
                                      dhac(ic),dhbc(ic),          &
                                      dhad(tid),dhbd(tid),        &
                                      adav,bdav,acth2omin,nc,     &
                                      nx,namec(ic),namec,         &
                                      ic,issit,                   &
                                      asit,basit,coepsil,         &
                                      iasit,jasit)
                 end do

!c  for aqueous complexes

                 do ix=1,nx
                    gamma(nc+ix,ivol) = acoff(cnew(1,ivol),       &
                                        cx(1,ivol),               &
                                        sionnew(ivol),chargex(ix),&
                                        dhax(ix),dhbx(ix),        &
                                        dhad(tid),dhbd(tid),      &
                                        adav,bdav,acth2omin,      &
                                        nc,nx,namex(ix),namec,    &
                                        nc+ix, issit,             &
                                        asit,basit,coepsil,       &
                                        iasit,jasit)
                 end do

               end if       
          
            end if
      
!c  equilibrium redox reactions, compute concentrations of dependent
!c  species of redox couples with incremented free species
!c  concentrations

            if (redox_equil.and.nr.gt.0) then
              do ir=1,nr
                ic = n+ir
                call secspec(cinc(:,tid),cinc(ic,tid),eqr(ir,tid),    &
                gamma(1,ivol),gamma(ic,ivol),xnur,iarc,jarc,nc,ir)
              end do
            end if

!c  compute aqueous complex concentrations with incremented free
!c  species concentrations

            do ix=1,nx
              call secspec(cinc(:,tid),cxinc(ix,tid),eqx(ix,tid),     &
              gamma(1,ivol),gamma(nc+ix,ivol),xnux,iax,jax,nc,ix)
            end do

!c  compute total aqueous component concentrations with incremented
!c  free species concentrations

            if (analyt_deriv_rt) then
              call atotconc(cnew(1,ivol),cx(1,ivol),jbl,tid)      
            else
              call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl,tid,0)
            end if

!c  compress total aqueous component concentration vector in case
!c  of redox equilibrium reactions

            if (redox_equil.and.nr.gt.0) then
              call comptotc(dtotc(:,tid))
            end if

!c  modify current column of jacobian matrix

            do ibl=1,n            !loop over rows (block matrix)

              if (kaobl(ibl,jbl).ne.0) then          !skip zero entries
              
              
!cprovi-------------------------------------------------------------------
!cprovi Bubbles use component dependent diff coefficient if speciifed
!cprovi-------------------------------------------------------------------
                if (diff_coff) then
                  bdyinfrt_da = bdyinfrt_da_ic(jbl)
                end if
!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
!cprovi-------------------------------------------------------------------
!c  - derivative of total mass flux across boundary

                if (density_dependence) then
                    dtotcflux(ibl) = ddbdflux(ivol) * dtotc(ibl,tid)
                else
                    dtotcflux(ibl) = bdryflux(ivol) * dtotc(ibl,tid)
                end if
              end if              !skip zero entries
            end do                !loop over components

!c  - get pointer for global block matrix

            ldiag = lart(idiag)  !diagonal pointer - global block matrix
            do ibl=1,n           !loop over rows of block matrix

!c  - skip zero entries, here only mobile species are considered,
!c    kaobl has to be used therefore to skip zero entries
!c    the pointer i2 jhas to be computed using kadbl nevertheless

              if (kaobl(ibl,jbl).ne.0) then           !skip zero entries

!c  - get pointer for assembly in n-d scalar matrix

                i2 = kart(ldiag+kadbl(ibl,jbl)-1)

                if (component_type(ibl).eq.'aqueous') then
                  art(i2) = art(i2) - cnew(jbl,ivol) * dtotcflux(ibl)
                end if

              end if                !skip zero entries
            end do                  !loop over rows of block matrix

!c  "unshift" free species concentration of current column

            cinc(jbl,tid) = cnew(jbl,ivol) 

          end do                    !loop over columns of block matrix


!c ----------------------------------------------------------------------
!c  Point (well) and Cauchy type boundary conditions 
!c  -> specified advective flux for aqueous phase
!c     modify rhs-vector only
!c
!c  Modified to consider temporal switch in flow boundary condition from
!c  inflow to outflow: Henry variable density problem & pumping well
!c 
!c  Requires replacement of third type reactive transport boundary condition
!c  with second type boundary conditions if outflow occurs at the boundary
!c ----------------------------------------------------------------------

        elseif ((btypert(ivol).eq.'third').or.    &
                (btypert(ivol).eq.'third-evap').or.  &
                (btypert(ivol).eq.'point')) then

#ifdef DEBUG
          if(info_debug > 20) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then
              write(idbg, *) "--> brt inoutflow-c ", inoutflow
            end if
          end if
#endif
          
          if (evaporation) then
            ibvs = ivol2bvs(ivol)
            if(ibvs > 0) then
              if (btypevs(ibvs)=='atmospheric') then 
                area_ivol=bcondvs(ibvs)
                !cprovi---------------------------------------------------
                !cprovi Change the inflow/for m3/day
                !cprovi---------------------------------------------------
                call jacbevap(ivol,' ',totwflux_atm,tothflux_atm) 
                inoutflow = totwflux_atm*area_ivol/ref_dens
                if (inoutflow<r0) then
                  inoutflow=r0
                end if
              else
                if (density_dependence) then
                  inoutflow = ddbdflux(ivol)          
                else
                  inoutflow = bdryflux(ivol)          
                end if 
              end if
            end if
          else
            if (density_dependence) then
              inoutflow = ddbdflux(ivol)          
            else
              inoutflow = bdryflux(ivol)
            end if
          end if

#ifdef DEBUG
          if(info_debug > 20) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then
              if (density_dependence) then
                write(idbg, *)                                    &
                    "--> brt inoutflow ", inoutflow,              &
                    "ddbdflux(ivol) ", ddbdflux(ivol),            &
                    "bdryflux(ivol) ", bdryflux(ivol),            &
                    "density_dependence ",density_dependence
              end if
              write(idbg, *)                                      &
                  "--> brt bcondrt_a 1 to n ", bcondrt_a(1:n,ibrt)              
            end if
          end if
#endif

          if (b_fluxd_bcond(ivol)) then

            so_av=dmin1(r1, sonew(ivol))
!cprovi-------------------------------------------------------------          
!cprovi Compute diffusive fluxes only when the boundary condition
!cprovi for flow is different than atmospheric 
!cprovi-------------------------------------------------------------      

            if (.not.diff_coff) then
              diff_eff = r0
              diff_loc = r0
              if (type_diff_coeff == 0) then
                diff_loc = diff_a
              else if (type_diff_coeff > 0) then
                idim = diff_brt_dim(ibrt)
                if (idim == 1) then
                  diff_loc = diff_a_tensor%xx
                else if (idim == 2) then
                  diff_loc = diff_a_tensor%yy
                else if (idim == 3) then
                  diff_loc = diff_a_tensor%zz
                end if
              end if
              diff_eff = diffcoff(diff_loc,sanew(ivol),pornew(ivol),    &
                                  tortuosity_corr,assigned_tau,         &
                                  tau(ivol)*tau_fac(ivol),              &
                                  type_tortuosity,marchies(ivol),       &
                                  so_av,tor_corr_a_mq,tor_corr_b_mq)
              bdyinfrt_da = diff_eff * bdycrt_d(ibrt)
              if (b_water_freezing) then
                if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                  bdyinfrt_da = bdyinfrt_da*frozen_diff_a
                end if
              end if

#ifdef DEBUG
              if(info_debug > 20) then
                if(ivol_gbl == ivol_track .or. ivol_track == 0) then 
                  write(idbg, *)                                       &
                  "--> aq bdyinfrt_da - ibrt ", bdyinfrt_da, ibrt,     &
                  " diff_eff ", diff_eff, " bdycrt_d ", bdycrt_d(ibrt)
                end if
              end if
#endif

            else
              do ic = 1,nc
                diff_eff = r0
                diff_loc = r0
                if (type_diff_ic_coeff == 0) then
                  diff_loc = diff_ic(ic)
                else if (type_diff_ic_coeff > 0) then
                  idim = diff_brt_dim(ibrt)
                  if (idim == 1) then
                    diff_loc = diff_ic_tensor(ic)%xx
                  else if (idim == 2) then
                    diff_loc = diff_ic_tensor(ic)%yy
                  else if (idim == 3) then
                    diff_loc = diff_ic_tensor(ic)%zz 
                  end if
                end if
                diff_eff = diffcoff(diff_loc,sanew(ivol),pornew(ivol), &
                                    tortuosity_corr,assigned_tau,      &
                                    tau(ivol)*tau_fac(ivol),           &
                                    type_tortuosity,marchies(ivol),    &
                                    so_av,tor_corr_a_mq,tor_corr_b_mq)
                bdyinfrt_da_ic(ic) = diff_eff * bdycrt_d(ibrt)
                if (b_water_freezing) then
                  if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                    bdyinfrt_da_ic(ic) = bdyinfrt_da_ic(ic)*frozen_diff_a
                  end if
                end if
              end do
            end if
          else
            if (diff_coff) then
              bdyinfrt_da_ic(1:nc) = r0
            else
              bdyinfrt_da = r0
            end if
          end if 


!c  third type boundary condition: mass influx at boundary

          if (inoutflow>r0) then

!c  modify rhs-vector

              istart = (ivol-1)*n+1           !pointer - first row
              iend = ivol*n                   !pointer - last row

              ic = 0
              do irow = istart,iend           !loop over rows
                ic = ic+1
                if (component_type(ic).eq.'aqueous') then
!c  calculate boundary flux vector
                  if (b_fluxd_bcond(ivol)) then
                    if (diff_coff) then
                      bdyinfrt_da = bdyinfrt_da_ic(ic)
                    end if
                    totcflux(ic) = inoutflow*bcondrt_a(ic,ibrt)+       &
                                   fluxd(totcnew(ic,ivol),             & ! diffusive
                                         bcondrt_a(ic,ibrt),           &
                                         bdyinfrt_da)
                  else
                    totcflux(ic) = inoutflow*bcondrt_a(ic,ibrt)
                  end if

                  brt(irow) = brt(irow) + totcflux(ic)
                end if
              end do
              
#ifdef DEBUG
              if(info_debug > 20) then
                if(ivol_gbl == ivol_track .or. ivol_track == 0) then 
                  write(idbg, *)                                      &
                  "--> brt third inoutflow > 0, istart, iend, brt ",  &
                  istart, iend, brt(istart:iend)
                end if
              end if
#endif

          elseif (inoutflow<=r0) then 

!c  treat as Neumann type boundary condition
!c  advective mass flux across outflow boundary
!c  modify rhs-vector and Jacobian matrix

              istart = (ivol-1)*n+1           !pointer - first row
              iend = ivol*n                   !pointer - last row

              ic = 0
              do irow = istart,iend           !rows (global scalar matrix)
                ic = ic+1
                if (component_type(ic).eq.'aqueous') then
!c  calculate boundary flux vector
                  if (btypert(ivol).eq.'third-evap') then             !evaporation type, mass is retained
                    totcflux(ic) = inoutflow * r0
                  else
                    if (b_fluxd_bcond(ivol)) then
                      if (diff_coff) then
                        bdyinfrt_da = bdyinfrt_da_ic(ic)
                      end if
                      totcflux(ic) = inoutflow*totcnew(ic,ivol) +      &
                                     fluxd(totcnew(ic,ivol),           & ! diffusive
                                           bcondrt_a(ic,ibrt),         &
                                           bdyinfrt_da)
                    else
                      totcflux(ic) = inoutflow*totcnew(ic,ivol)
                    end if
                  end if
                  brt(irow) = brt(irow) + totcflux(ic)

#ifdef DEBUG
                  if(info_debug > 20) then
                    if(ivol_gbl == ivol_track .or. ivol_track == 0) then
                      write(idbg, *)                                      &
                      "--> brt third inoutflow <= 0 aqueous, ",           &
                      "irow, brt ", irow, brt(irow)
                    end if
                  end if
#endif
                end if
              end do

              idiag = iavs(ivol)        !diagonal pointer - block matrix

!c  compute derivatives of total mass flux across boundary

!c  temporary storage for free species concentrations

              do ic=1,nc
                cinc(ic,tid) = cnew(ic,ivol)
              end do

              do jbl=1,n                !loop over columns of block matrix

!c  compute increment for numerical differentiation

                drtinc = dinc_rt*cnew(jbl,ivol)

!c  increment free species concentration for current column

                cinc(jbl,tid) = cnew(jbl,ivol)+drtinc

!c  recompute activity coefficients

                if (update_activity(tid).eq.'double_update') then

!cprovi----------------------------------------------       
                  if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andr�s Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi Cuidado, las componentes pueden no ser acuosas
!cprovi preguntarle a Uli 
!cprovi---------------------------------------------- 
                    call pitzer (phase,gamma(1:nc,ivol),       &
                           gamma(nc+1:nc+nx,ivol),             &
                           cnew(1:nc,ivol),cx(1:nx,ivol),      &
                           nc,nx,ilog)
                  else
!c  for free species
                    do ic=1,nc
                      gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),   &
                                             sionnew(ivol),chargec(ic), &
                                             dhac(ic),dhbc(ic),         &
                                             dhad(tid),dhbd(tid),       &
                                             adav,bdav,acth2omin,       &
                                             nc,nx,namec(ic),namec,     &
                                             ic,issit,                  &
                                             asit,basit,coepsil,        &
     &                                       iasit,jasit)
                    end do

!c  for aqueous complexes
                    do ix=1,nx
                      gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol),&
                                              sionnew(ivol),chargex(ix),&
                                              dhax(ix),dhbx(ix),        &
                                              dhad(tid),dhbd(tid),      &
                                              adav,bdav,acth2omin,      &
                                              nc,nx,namex(ix),namec,    &
                                              nc+ix,issit,              &
                                              asit,basit,coepsil,       &
                                              iasit,jasit)
                    end do
                  
                  end if
!cprovi----------------------------------------------------------------
!cprovi----------------------------------------------------------------
                end if

!c  equilibrium redox reactions, compute concentrations of dependent
!c  species of redox couples with incremented free species
!c  concentrations

                if (redox_equil.and.nr.gt.0) then
                  do ir=1,nr
                    ic = n+ir
                    call secspec(cinc(:,tid),cinc(ic,tid),eqr(ir,tid),&
                    gamma(1,ivol),gamma(ic,ivol),xnur,iarc,jarc,nc,ir)
                  end do
                end if

!c  compute aqueous complex concentrations with incremented free
!c  species concentrations

                do ix=1,nx
                  call secspec(cinc(:,tid),cxinc(ix,tid),eqx(ix,tid), &
                  gamma(1,ivol),gamma(nc+ix,ivol),xnux,iax,jax,nc,ix)
                end do

!c  compute total aqueous component concentrations with incremented
!c  free species concentrations

                if (analyt_deriv_rt) then
                  call atotconc(cnew(1,ivol),cx(1,ivol),jbl,tid)
                else
                  call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl,tid,0)
                end if

!c  compress total aqueous component concentration vector in case
!c  of redox equilibrium reactions

                if (redox_equil.and.nr.gt.0) then
                  call comptotc(dtotc(:,tid))
                end if

!c  modify current column of jacobian matrix

                do ibl=1,n            !loop over rows (block matrix)

                  if (kaobl(ibl,jbl).ne.0) then          !skip zero entries

!c  - derivative of total mass flux across boundary
!c  - update on May 28, 2019, DSU
!c  - for influx, advective component is constant, no influence
!c  - for outflux, advective component varies
                    if (btypert(ivol).eq.'third-evap' .and.            &
                        component_type(ibl).eq.'aqueous') then
                      dtotcflux(ibl) = r0                            !mass is retained
                    else
                      if (b_fluxd_bcond(ivol)) then
                        if (diff_coff) then
                          bdyinfrt_da = bdyinfrt_da_ic(ibl)
                        end if
                        dtotcflux(ibl) = inoutflow * dtotc(ibl,tid) +  &
                                         fluxd(dtotc(ibl,tid),r0,      & !diffusive
                                               bdyinfrt_da)
                      else
                        dtotcflux(ibl) = inoutflow * dtotc(ibl,tid)
                      end if
                    end if

                  end if              !skip zero entries
                end do                !loop over components

!c  - get pointer for global block matrix

                ldiag = lart(idiag)  !diagonal pointer - global block matrix
                do ibl=1,n           !loop over rows of block matrix

!c  - skip zero entries, here only mobile species are considered,
!c    kaobl has to be used therefore to skip zero entries
!c    the pointer i2 jhas to be computed using kadbl nevertheless

                  if (kaobl(ibl,jbl).ne.0) then           !skip zero entries

!c  - get pointer for assembly in n-d scalar matrix

                    i2 = kart(ldiag+kadbl(ibl,jbl)-1)

                    if (component_type(ibl).eq.'aqueous') then
                      art(i2) = art(i2) - cnew(jbl,ivol)          &
     &                           * dtotcflux(ibl)
                    end if

                  end if                !skip zero entries
                end do                  !loop over rows of block matrix

!c  "unshift" free species concentration of current column

                cinc(jbl,tid) = cnew(jbl,ivol) 

              end do                    !loop over columns of block matrix

          end if  !if (bdryflux(ivol) .gt. r0
!cprovi-------------
        !  end if  !density_dependence

!c ----------------------------------------------------------------------
!c  mixed boundary condition: 
!c  -> specified advective flux and free diffusive flux across 
!c     boundary for aqueous phase and gaseous phase
!c     modify rhs-vector and Jacobian matrix
!c ----------------------------------------------------------------------
        elseif (btypert(ivol).eq.'mixed' .or. btypert(ivol).eq.'mixed-evap') then
!cprovi-----------------------------------------------------------------
!cprovi calculate boundary influence coeffcient for diffusive
!cprovi mass flux across boundary
!cprovi-------------------------------------------------------------   
          compute_diff = b_fluxd_bcond(ivol)
          if (evaporation) then
            ibvs = ivol2bvs(ivol)
            !cprovi--------------------------------------------------
            !cprovi Check the boundary index for flow
            !cprovi--------------------------------------------------
            if(ibvs > 0) then
              if (btypevs(ibvs)=='atmospheric') then 
                   !cprovi---------------------------------------------------
                   !cprovi If the boundary condition for flow was defined 
                   !cprovi as atmospheric, then not compute the diffusive 
                   !cprovi fluxes
                   !cprovi---------------------------------------------------
                   compute_diff = .false.
                   area_ivol=bcondvs(ibvs)
                   !cprovi---------------------------------------------------
                   !cprovi Change the inflow/for m3/day
                   !cprovi---------------------------------------------------
                   call jacbevap(ivol,' ',totwflux_atm,tothflux_atm)                    
                   inoutflow = totwflux_atm*area_ivol/ref_dens
                   !cprovi---------------------------------------------------
                   !cprovi Set to zero when the flow>0 
                   !cprovi---------------------------------------------------
                   if (inoutflow<r0) then
                     inoutflow = r0
                   end if
                   
              else
                if (density_dependence) then
                  inoutflow = ddbdflux(ivol)          
                else
                  inoutflow = bdryflux(ivol)          
                end if
              end if
            end if
          else
            if (density_dependence) then
              inoutflow = ddbdflux(ivol)          
            else
              inoutflow = bdryflux(ivol)          
            end if
          end if  ! evaporation
         
          so_av=dmin1(r1, sonew(ivol))
         
!cprovi-------------------------------------------------------------          
!cprovi Compute diffusive fluxes only when the boundary condition
!cprovi for flow is different than atmospheric 
!cprovi-------------------------------------------------------------      
          if (compute_diff) then
            if (.not.diff_coff) then
              diff_eff = r0
              diff_loc = r0
              if (type_diff_coeff == 0) then
                diff_loc = diff_a
              else if (type_diff_coeff > 0) then
                idim = diff_brt_dim(ibrt)
                if (idim == 1) then
                  diff_loc = diff_a_tensor%xx
                else if (idim == 2) then
                  diff_loc = diff_a_tensor%yy
                else if (idim == 3) then
                  diff_loc = diff_a_tensor%zz
                end if
              end if
              diff_eff = diffcoff(diff_loc,sanew(ivol),pornew(ivol),    &
                                  tortuosity_corr,assigned_tau,         &
                                  tau(ivol)*tau_fac(ivol),              &
                                  type_tortuosity,marchies(ivol),       &
                                  so_av,tor_corr_a_mq,tor_corr_b_mq)
              bdyinfrt_da = diff_eff * bdycrt_d(ibrt)
              if (b_water_freezing) then
                if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                  bdyinfrt_da = bdyinfrt_da*frozen_diff_a
                end if
              end if
            else
              do ic = 1,nc
                diff_eff = r0
                diff_loc = r0
                if (type_diff_ic_coeff == 0) then
                  diff_loc = diff_ic(ic)
                else if (type_diff_ic_coeff > 0) then
                  idim = diff_brt_dim(ibrt)
                  if (idim == 1) then
                    diff_loc = diff_ic_tensor(ic)%xx
                  else if (idim == 2) then
                    diff_loc = diff_ic_tensor(ic)%yy
                  else if (idim == 3) then
                    diff_loc = diff_ic_tensor(ic)%zz 
                  end if
                end if
                diff_eff = diffcoff(diff_loc,sanew(ivol),pornew(ivol), &
                                    tortuosity_corr,assigned_tau,      &
                                    tau(ivol)*tau_fac(ivol),           &
                                    type_tortuosity,marchies(ivol),    &
                                    so_av,tor_corr_a_mq,tor_corr_b_mq)
                bdyinfrt_da_ic(ic) = diff_eff * bdycrt_d(ibrt)
                if (b_water_freezing) then
                  if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                    bdyinfrt_da_ic(ic) = bdyinfrt_da_ic(ic)*frozen_diff_a
                  end if
                end if
              end do
            end if
          else
            if (diff_coff) then
              bdyinfrt_da_ic(1:nc) = r0
            else
              bdyinfrt_da = r0
            end if
          end if   ! compute_diff
!cprovi-------------------------------------------------------------          
!cprovi gaseous phase
!cprovi-------------------------------------------------------------
          if (ng>0) then
            diff_eff = diffcoff_g(diff_g, sgnew(ivol),pornew(ivol),   &
                                tortuosity_corr,assigned_tau_gas,     &
                                taugas(ivol)*tau_fac(ivol),           &
                                type_tortuosity,marchies(ivol),       &
                                gas_tortuosity,so_av,                 &
                                tor_corr_a_mq,tor_corr_b_mq)
            bdyinfrt_dg = diff_eff * bdycrt_d(ibrt)

            if (b_water_freezing) then
              if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                bdyinfrt_dg = bdyinfrt_dg*frozen_diff_g
              end if
            end if              
            
            !variables for gas transport
            if(gas_advection .or. dgm .or. maxwell) then
                
                gsatijbrt = sgnew(ivol)
                gporijbrt = pornew(ivol)*sgnew(ivol)
                tauijbrt  = diff_eff / gporijbrt !/ diff_g
                
!c              total concentration of gas components at the boundary node
                call totconcg(gbrt,totgnew_brt)           
                
!c-------------------------------------------------------------------------
!c              calculate gas properties + molar fractions

                mdens_g_ivol  = gasm(ng, gnew(1,ivol))            ! gas molar dens
                mdens_g_brt   = gasm(ng, gbrt(1,ibrt))            ! gas molar dens               

                do ig=1,ng
                    gmfrac_ivol(ig) = gnew(ig,ivol) / mdens_g_ivol  ! molar fractions
                                                                    ! gas species
                    gmfrac_brt(ig)  = gbrt(ig,ibrt) / mdens_g_brt   ! molar fractions
                                                                    ! gas species
                enddo
         
                do ic=1,n
                    totgmfrac_ivol(ic) = totgnew(ic,ivol) /           &
                                         mdens_g_ivol               ! gas molar frac for components
                                                            
                    totgmfrac_brt(ic)  = totgnew_brt(ic)  /           &
                                         mdens_g_brt                ! gas molar frac for components
                enddo
      
                !gpivol_ivol = gasp_m(mdens_g_ivol,ivol)             ! gas pressure
                !gdens_ivol  = gasd_m(mdens_g_ivol,gmfrac_ivol)      ! gas density
                !gvisc_ivol  = gasv(gmfrac_ivol)                     ! gas viscosity

                gpivol_ivol = gpivol(ivol)                          ! gas pressure
                gdens_ivol  = gdens(ivol)                           ! gas density
                gvisc_ivol  = gvisc(ivol)                           ! gas viscosity

                gpivol_brt  = gasp_m(mdens_g_brt,ivol)              ! gas pressure
                gdens_brt   = gasd_m(mdens_g_brt,gmfrac_ivol)       ! gas density
                gvisc_brt   = gasv(gmfrac_brt)                      ! gas viscosity 

!c           decide on the upstream node
                if (spt_weight.eq.'upstream') then
            
                    call giups_brt(gpivol_ivol   , gpivol_brt  ,      &
                                   zg(ivol)      , zgbrt(ibrt) ,      &
                                   gdens_ivol    , gdens_brt   ,      &
                                   iupsgbrt(ibrt), gacc)
                endif
!c-------------------------------------------------------------------------
            
!c              calculate gas properties at interface according to weighting scheme
#ifdef USG
              if (discretization_type > 0 .and. is_cell_based_relp) then

                !c modify relpgij externally
                relpgij = 0.0d0
                do icell = 1, node_num_cells(ivol)
                  relpgij = relpgij + relpermg(node_cells(icell,ivol))
                end do
                relpgij = relpgij / node_num_cells(ivol)

                relpgi = relpgij
                relpgj = relpgij

              else
#endif
                relpgi = relpermg(ivol)
                relpgj = relpermg(ivol)
#ifdef USG
              end if
#endif

              call wgprop(totgnew(1,ivol),totgnew_brt,totgij   ,       &
                      gnew(:,ivol)   ,gbrt(:,ibrt)   ,gij      ,       &
                      gmfrac_ivol    ,gmfrac_brt     ,gmfracij ,       &
                      relpgi         ,relpgj         ,relpgij  ,       &
                      gdens_ivol     ,gdens_brt      ,densgij  ,       &
                      gvisc_ivol     ,gvisc_brt      ,viscgij  ,       &
                      gpivol_ivol    ,gpivol_brt     ,gpij     ,       &
                      zg(ivol)       ,zgbrt(ibrt)    ,                 &
                      spt_weight     ,iupsgbrt(ibrt) ,                 &
                      nc             ,ng             ,gacc     )

            end if
            
!c --------- DGM module ---------------------------------------------------------
!c           solve A F = B
!c           computes fluxes F of all gas components at current c.v. interphase
          
            if (dgm) then
            
              call dgm_fluxdg (gnew(1,ivol)     ,gbrt(1,ibrt)   ,      &
                               gij              ,gmfracij       ,      &
                               zg(ivol)         ,zgbrt(ibrt)    ,      &
                               densgij          ,gpij           ,      &
                               tkel(ivol)       ,permbrt(ibrt)  ,      &
                               relpgij          ,tauijbrt       ,      &
                               gporijbrt        ,dijbrt(ibrt)   ,      &
                               rverysmall       ,                      &
                               ludecomp         ,                      &
                               fmat             ,ipvt           ,      &
                               dgm_gflux        ,neflux         )
            
!c --------- Maxwell Stefan module ----------------------------------------------

            else if (maxwell) then
            
              call ms_fluxdg (gnew(1,ivol)      ,gbrt(1,ibrt)   ,      &
                              gij               ,gmfracij       ,      &
                              zg(ivol)          ,zgbrt(ibrt)    ,      &
                              densgij           ,gpij           ,      &
                              tkel(ivol)        ,tauijbrt       ,      &
                              gporijbrt         ,dijbrt(ibrt)   ,      &
                              rverysmall        ,                      &
                              ludecomp          ,                      &
                              fmat              ,                      &
                              ipvt              ,equimolar      ,      &
                              ms_gflux          ,neflux         )
            
            endif
            
          end if

!c  modify rhs-vector

          do ic = 1,n
!cprovi--------------------------------------------------------          
!cprovi Bubbles use component dependent diff coefficient if 
!cprovi speciifed
!cprovi-------------------------------------------------------
            if (diff_coff) then
              bdyinfrt_da = bdyinfrt_da_ic(ic)
            end if
!cprovi-------------------------------------------------------
!cprovi aqueous phase - compute advective and diffusive
!cprovi flux across boundary
!cprovi-------------------------------------------------------
            if (inoutflow > r0) then

              if (b_fluxd_bcond(ivol)) then
                totcflux(ic) = inoutflow * bcondrt_a(ic,ibrt) +       & ! advective
                               fluxd(totcnew(ic,ivol),                & ! diffusive
                                     bcondrt_a(ic,ibrt),              &
                                     bdyinfrt_da)
              else
                totcflux(ic) = inoutflow * bcondrt_a(ic,ibrt)           ! advective
              end if

            elseif (inoutflow<=r0) then
              if (b_fluxd_bcond(ivol)) then
                totcflux(ic) = inoutflow * totcnew(ic,ivol) +         & ! advective
                               fluxd(totcnew(ic,ivol),                & ! diffusive
                                     bcondrt_a(ic,ibrt),              &
                                     bdyinfrt_da)
              else
                totcflux(ic) = inoutflow * totcnew(ic,ivol)             ! advective
              end if
            end if
!cprovi--------------------------------------------------------           
#ifdef DEBUG
          if(info_debug > 10) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then 
                write(idbg, *)                                        &
                "--> ivol ", ivol, " ibrt ", ibrt, " ic ", ic,        &
                " inoutflow, bcondrt_a(ic,ibrt), totcflux(ic), ",     &
                "totcnew(ic,ivol), bcondrt_a(ic,ibrt), bdyinfrt_da",  &
                inoutflow, bcondrt_a(ic,ibrt), totcflux(ic),          &
                totcnew(ic,ivol), bcondrt_a(ic,ibrt), bdyinfrt_da
              end if
          end if
#endif

!cdsy----------------------------------------------------------
!cdsu    gaseous phase - compute advective flux across boundary

!cprovi  gaseous phase - compute diffusive flux across boundary
!cprovi--------------------------------------------------------
            if (ng>0) then
                
#ifdef DEBUG
              if(info_debug > 10) then
                if(ivol_gbl == ivol_track .or. ivol_track == 0) then 
                  write(idbg, *) "--> ic, totgflux(ic)",  ic, totgflux(ic)
                end if
              end if
#endif
              
              totgflux(ic) = r0
                
!c            advective flux
              if (gas_advection) then

                if (gsatijbrt.gt.gsatmin) then
                
                  totgflux(ic) = fluxvg(gpivol_ivol ,gpivol_brt  ,    &
                                        zg(ivol)    ,zgbrt(ibrt) ,    &
                                        totgij(ic)  ,relpgij     ,    &
                                        densgij     ,viscgij     ,    &
                                        cinfvs_gbrt(ibrt)        ,    &
                                        gas_gravity ,gacc)
                endif

              endif ! gas advection
              
!c             diffusive flux - ficks law / dgm / stefan-maxwell

              if ((.not.dgm).and.(.not.maxwell)) then

                if (blanc_diff_g) then
!c               diffusion coefficient calc'd with LeBlanc's law
                  cinfrt = bdyinfrt_dg * gasdiff2                      &
                                      ( gmfrac_ivol     ,gmfrac_brt  , &
                                        gpivol_ivol     ,gpivol_brt  , &
                                        zg(ivol)        ,zgbrt(ibrt) , &
                                        gdens_ivol      ,gdens_brt   , &
                                        ic              ,              &
                                        iupsgbrt(ibrt)  ,spt_weight  )

                else 
!c                single constant diffusion
                  cinfrt = bdyinfrt_dg
                endif    

!c diffusion expressed in terms of concentration gradients
                totgflux(ic) = totgflux(ic)                            &
                             + fluxd(totgnew(ic,ivol),                 &   !diffusive flux
                                     bcondrt_g(ic,ibrt),               &
                                     cinfrt)                               !bdyinfrt_dg
     
                     
!c ------- DGM module -----------------------------------------------------------

              else if (dgm) then
 
!c               check if there is gas phase
                if (gporijbrt.lt.rverysmall) then
!c               no gas phase 
                else
                  totgflux(ic) = totgflux(ic)                          &
                               + diff_eff                              &
                               * dijbrt(ibrt)                          &
                               * dgm_gflux(ic)
!     &                         / tauijbrt
!     &                         / gporijbrt

                endif

!c ------- Maxwell Stefan module -------------------------------------------------

              else if (maxwell) then

!c               check if there is gas phase
                if (gporijbrt.lt.rverysmall) then
!c                no gas phase 
                else
                  totgflux(ic) = totgflux(ic)                          &
                               + diff_eff                              &
                               * dijbrt(ibrt)                          &
                               * ms_gflux(ic)
!     &                         / tauijbrt
!     &                         / gporijbrt
                endif

              end if                 

    
#ifdef DEBUG
              if(info_debug > 10) then
                if(ivol_gbl == ivol_track .or. ivol_track == 0) then 
                  write(idbg, *)                                      &
                  "--> totgflux(ic), totgnew(ic,ivol), ",             &
                  "bcondrt_g(ic,ibrt), bdyinfrt_dg",                  &
                  totgflux(ic), totgnew(ic,ivol), bcondrt_g(ic,ibrt), &
                  bdyinfrt_dg
                end if
              end if
#endif
              
            end if

          end do

!c  modify rhs-vector and Jacobian matrix

          istart = (ivol-1)*n+1           !pointer - first row
          iend = ivol*n                   !pointer - last row

          ic = 0
          do irow = istart,iend           !loop over rows

           ic = ic+1                      !pointer to primary unknown

!c  aqueous phase

            if (component_type(ic).eq.'aqueous') then
              if (btypert(ivol).eq.'mixed-evap' .and. totcflux(ic) < r0) then
                !c 'mixed-evap' boundary, no mass out for aqueous phase
              else
                brt(irow) = brt(irow) + totcflux(ic)
              end if
            end if
#ifdef DEBUG
            if(info_debug > 20) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then 
                write(idbg, *)                                        &
                  "--> irow, ic, brt(irow), totcflux(ic)",            &
                  irow, ic, brt(irow), totcflux(ic)
              end if
            end if
#endif

!c  gaseous phase

            if (ng.gt.0) then
              brt(irow) = brt(irow) + totgflux(ic)
            end if
            
#ifdef DEBUG
            if(info_debug > 20) then
              if(ivol_gbl == ivol_track .or. ivol_track == 0) then 
                write(idbg, *)                                        &
                  "--> irow, ic, brt(irow), totgflux(ic)",            &
                  irow, ic, brt(irow), totgflux(ic)
              end if
            end if 
#endif

          end do                           !loop over rows

#ifdef DEBUG
          if(info_debug > 20) then
            if(ivol_gbl == ivol_track .or. ivol_track == 0) then 
              write(idbg, *)                                          &
              "--> right hand side: istart, iend ",  istart, iend
              write(idbg, *) " --> right hand side vector: ",         &
              brt(istart:iend)
            end if
          end if
#endif

!c  modify Jacobian matrix

!c  compute derivatives of total mass flux across boundary

          idiag = iavs(ivol)        !diagonal pointer - block matrix

!c  temporary storage for free species concentrations

          do ic=1,nc
            cinc(ic,tid) = cnew(ic,ivol)
          end do

          do jbl=1,n                !loop over columns of block matrix

!c  compute increment for numerical differentiation

            drtinc = dinc_rt*cnew(jbl,ivol)

!c  increment free species concentration for current column

            cinc(jbl,tid) = cnew(jbl,ivol)+drtinc

!c  recompute activity coefficients

            if (update_activity(tid).eq.'double_update') then
!cprovi----------------------------------------------       
              if (ispitzer) then
!cprovi----------------------------------------------        
!cprovi it was added by Sergio Andr�s Bea Jofr?
!cprovi Compute activity coefficients from
!cprovi Pitzer equations 
!cprovi Cuidado, las componentes pueden no ser acuosas
!cprovi preguntarle a Uli 
!cprovi---------------------------------------------- 
                call pitzer (phase,gamma(1:nc,ivol),           &
                             gamma(nc+1:nc+nx,ivol),           &
                             cnew(1:nc,ivol),cx(1:nx,ivol),    &
                             nc,nx,ilog)
              else
!c  for free species
                do ic=1,nc
                     gamma(ic,ivol) = acoff(cnew(1,ivol),cx(1,ivol),&
                                      sionnew(ivol),chargec(ic),    &
                                      dhac(ic),dhbc(ic),            &
                                      dhad(tid),dhbd(tid),          &
                                      adav,bdav,acth2omin,nc,       &
                                      nx,namec(ic),namec,ic,        &
                                      issit,asit,basit,coepsil,     &
                                      iasit,jasit)
                end do

!c  for secondary aqueous species

                do ix=1,nx
                  gamma(nc+ix,ivol) = acoff(cnew(1,ivol),cx(1,ivol),&
                                      sionnew(ivol),chargex(ix),    &
                                      dhax(ix),dhbx(ix),            &
                                      dhad(tid),dhbd(tid),          &
                                      adav,bdav,acth2omin,nc,       &
                                      nx,namex(ix),namec,           &
                                      nc+ix,issit,asit,basit,       &
                                      coepsil,iasit,jasit)
                end do

              end if
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------
!cprovi------------------------------------------------------------
            end if

!c  equilibrium redox reactions, compute concentrations of dependent
!c  species of redox couples with incremented free species
!c  concentrations

            if (redox_equil.and.nr.gt.0) then
              do ir=1,nr
                ic = n+ir
                call secspec(cinc(:,tid),cinc(ic,tid),eqr(ir,tid),    &
                gamma(1,ivol),gamma(ic,ivol),xnur,iarc,jarc,nc,ir)
              end do
            end if

!c  compute aqueous complex concentrations with incremented free
!c  species concentrations

            do ix=1,nx
              call secspec(cinc(:,tid),cxinc(ix,tid),eqx(ix,tid),     &
              gamma(1,ivol),gamma(nc+ix,ivol),xnux,iax,jax,nc,ix)
            end do

!c  compute derivative of total aqueous component concentrations 

            if (analyt_deriv_rt) then
              call atotconc(cnew(1,ivol),cx(1,ivol),jbl,tid)
            else
              call dtotconc(cnew(1,ivol),cx(1,ivol),drtinc,jbl,tid,0)
            end if

!c  compress total aqueous component concentration vector in case
!c  of redox equilibrium reactions

            if (redox_equil.and.nr.gt.0) then
              call comptotc(dtotc(:,tid))
            end if

!c  compute derivative of total gaseous component concentrations

            if (ng.ne.0) then

!c  compute gas concentrations with incremented free species
!c  concentrations

              do ig = 1,ng
                call gasconc(cinc(:,tid),gamma(1,ivol),ginc(ig,tid),  &
                     ig,tkel(ivol),tid)
              end do

!c  compute derivatives of total gaseous component concentrations

              call dtotcong(gnew(1,ivol),ginc(:,tid),dtotg(:,tid),xnug,      &
                            drtinc,iaga,jaga,nc,ng,jbl,namec)

!c  compress derivative of total gaseous component concentration
!c  vector in case of redox equilibrium reactions

              if (redox_equil.and.nr.gt.0) then
                call comptotc(dtotg(:,tid))
              end if

            end if

!c  compute numerical derivatives for each gas wrt primary unknown incremented
            if (ng.gt.0 .and. (gas_advection.or.dgm.or.maxwell)) then
            
              do ig = 1,ng
                dg(ig) = (ginc(ig,tid) - gnew(ig,ivol)) / drtinc
              end do
              
              dgpivol  = gasp(ng,dg,ivol)          
              dmdens_i = gasm(ng,dg)
              ddens_i  = gasd_m(dmdens_i,gmfrac(:,ivol)) 
              
!c  for dgm module calculations:
!c  calculate gas molar densities and mole fractions
              mdens_g_inc = gasm(ng,ginc(:,tid))                    !gas molar density
        
               do ig=1,ng
                dgmfrac(ig) = (ginc(ig,tid)/mdens_g_inc-gmfrac(ig,ivol))/  &
                               drtinc
              enddo
    
!             calculate gas properties at interface according to weighting scheme
#ifdef USG
              if (discretization_type > 0 .and. is_cell_based_relp) then

                !c modify relpgij externally
                relpgij = 0.0d0
                do icell = 1, node_num_cells(ivol)
                  relpgij = relpgij + relpermg(node_cells(icell,ivol))
                end do
                relpgij = relpgij / node_num_cells(ivol)

                relpgi = relpgij
                relpgj = relpgij

              else
#endif
                relpgi = relpermg(ivol)
                relpgj = relpermg(ivol)
#ifdef USG
              end if
#endif

              call wgpropd(totgnew(1,ivol),totgnew_brt   ,totgij   ,   &
                           relpgi         ,relpgj        ,relpgij  ,   &
                           gdens_ivol     ,gdens_brt     ,densgij  ,   &
                           gvisc_ivol     ,gvisc_brt     ,viscgij  ,   &
                           gpivol_ivol    ,gpivol_brt    ,gpij     ,   &
                           zg(ivol)       ,zgbrt(ibrt)   ,             &
                           spt_weight     ,iupsgbrt(ibrt),wfac     ,   &
                           nc             ,ng            ,gacc     )
               
!c ----- DGM module -------------------------------------------------------------
!c           solve A dF/dy = dB/dy - dA/dy F
!c           calculates derivatives of fluxes for current c.v. interphase
          
              if (dgm) then
              
                call dgm_dfluxdg (gnew(1,ivol)      ,gbrt(1,ibrt)  ,   &
                                  dg                ,dgmfrac       ,   &
                                  zg(ivol)          ,zgbrt(ibrt)   ,   &
                                  densgij           ,gpij          ,   &
                                  tkel(ivol)        ,relpgij       ,   &
                                  tauijbrt          ,gporijbrt     ,   &
                                  dijbrt(ibrt)      ,rverysmall    ,   &
                                  wfac              ,ipvt          ,   &
                                  ludecomp          ,fmat          ,   &
                                  dgm_dgflux    )
              
              endif

!c ----- Maxwell Stefan module --------------------------------------------------
!c           solve A dF/dy = dB/dy - dA/dy F
!c           calculates derivatives of fluxes for current c.v. interphase
          
              if (maxwell) then
              
                do i=1,ng-1
                  do j=1,ng-1
                    lumat2(i,j)=ludecomp(i,j)
                  enddo
                enddo
                
                call ms_dfluxdg  (gnew(1,ivol),gbrt(1,ibrt),           &
                                    dg          ,dgmfrac     ,         &
                                    zg(ivol)    ,zgbrt(ibrt) ,         &
                                    densgij     ,gpij        ,         &
                                    tkel(ivol)  ,tauijbrt    ,         &
                                    gporijbrt   ,dijbrt(ibrt),         &
                                    rverysmall  ,wfac        ,         &
                                    ipvt        ,equimolar   ,         &
                                    lumat2      ,fmat        ,         &
                                    ms_gflux    ,ms_dgflux   )
              
              endif
              
            endif

!c  modify current column of Jacobian matrix

            do ibl=1,n            !loop over rows (block matrix)

              if (kaobl(ibl,jbl).ne.0) then          !skip zero entries

!c  - derivative of total mass flux across boundary
!c  - aqueous phase (advective component is constant and has 
!c                   therefore no influence)
!c  - update on May 28, 2019, DSU
!c  - for influx, advective component is constant,
!c  - for outflux, advective component varies
                if (inoutflow > r0) then                                 !influx
                  if (b_fluxd_bcond(ivol)) then 
                    if (diff_coff) then
                      bdyinfrt_da = bdyinfrt_da_ic(ibl)
                    end if                
                    dtotcflux(ibl) = fluxd(dtotc(ibl,tid),r0,          & !diffusive
                                           bdyinfrt_da)
                  else
                    dtotcflux(ibl) = r0
                  end if
                else if (inoutflow <= r0) then                           !outflux
                  if (btypert(ivol).eq.'mixed-evap' .and.              &
                      component_type(ibl).eq.'aqueous') then             !mixed-evap, mass is retained
                    dtotcflux(ibl) = r0
                  else
                    if (b_fluxd_bcond(ivol)) then
                      if (diff_coff) then
                        bdyinfrt_da = bdyinfrt_da_ic(ibl)
                      end if                     
                      dtotcflux(ibl) = inoutflow * dtotc(ibl,tid) +    & !advective
                                       fluxd(dtotc(ibl,tid),r0,        & !diffusive
                                             bdyinfrt_da)
                    else
                      dtotcflux(ibl) = inoutflow * dtotc(ibl,tid)        !advective
                    end if
                  end if
                end if

!c  - gaseous phase

                if (ng.ne.0) then
                    
                  dgflux = r0  
                    
                  if (gas_advection) then
                   
                    if (gsatijbrt.gt.gsatmin) then
        
                      dgflux = dfluxvg(totgij(ibl)  ,dtotg(ibl,tid),    &
                                       gpivol_ivol  ,gpivol_brt    ,    &
                                       dgpivol      ,                   &
                                       zg(ivol)     ,zgbrt(ibrt)   ,    &
                                       densgij      ,ddens_i       ,    &
                                       viscgij      ,relpgij       ,    &
                                       cinfvs_gbrt(ibrt), wfac     ,    &
                                       gas_gravity, gacc           )
                    
                    endif
      
                  endif ! gas advection
                    
!c--------ficks law, business as usual------------------------------------   

                  if ((.not.dgm).and.(.not.maxwell)) then

                    if (blanc_diff_g) then
!c                   diffusion coefficient calc'd with LeBlanc's law
                      cinfrt = bdyinfrt_dg * gasdiff2                  &  
                                           (gmfrac_ivol   ,gmfrac_brt ,&
                                            gpivol_ivol   ,gpivol_brt ,&
                                            zg(ivol)      ,zgbrt(ibrt),&
                                            gdens_ivol    ,gdens_brt  ,&
                                            ic            ,            &
                                            iupsgbrt(ibrt),spt_weight )
                    else 
!c                     single constant diffusion
                      cinfrt = bdyinfrt_dg
                    endif 

!c diffusive as function of concentration gradients 
                     dgflux = dgflux                                    &
                           - fluxd (dtotg(ibl,tid),r0,                 &! diffusive flux
                                    cinfrt)                             ! bdyinfrt_dg
                  
!c ----- DGM module -------------------------------------------------------------
                
                  else if (dgm) then
                      
!c                   check if there is gas phase
                    if (gporijbrt.lt.rverysmall) then
!c                   no gas phase 
                    else
                      dgflux = dgflux                                  &
                             + diff_eff                                &
                             * dijbrt(ibrt)                            &
                             * dgm_dgflux(ibl)
!     &                       / tauijbrt
!     &                       / gporijbrt
                    endif

!c ------------------------------------------------------------------------------
!c ----- Maxwell Stefan module --------------------------------------------------
                
                  else if (maxwell) then

!c                   check if there is gas phase
                    if (gporijbrt.lt.rverysmall) then
!c                   no gas phase 
                    else
                      dgflux = dgflux                                  &
                             + diff_eff                                &
                             * dijbrt(ibrt)                            &
                             * ms_dgflux(ibl)
!     &                       / tauijbrt
!     &                       / gporijbrt
                    endif

                  end if 
                 
                  dtotgflux(ibl) = -dgflux
                  
                end if
  
              end if              !skip zero entries
            end do                !loop over components

!c  - get pointer for global block matrix

            ldiag = lart(idiag)  !diagonal pointer - global block matrix
            do ibl=1,n           !loop over rows of block matrix

!c  - skip zero entries, here only mobile species are considered,
!c    kaobl has to be used therefore to skip zero entries
!c    the pointer i2 has to be computed using kadbl nevertheless

              if (kaobl(ibl,jbl).ne.0) then           !skip zero entries

!c  - get pointer for assembly in n-d scalar matrix

                i2 = kart(ldiag+kadbl(ibl,jbl)-1)

                if (component_type(ibl).eq.'aqueous') then
                  art(i2) = art(i2) - cnew(jbl,ivol) * dtotcflux(ibl)
                end if

                if (ng.gt.0) then
                  art(i2) = art(i2) - cnew(jbl,ivol) * dtotgflux(ibl)
                end if

              end if                !skip zero entries
            end do                  !loop over rows of block matrix

!c  "unshift" free species concentration of current column

            cinc(jbl,tid) = cnew(jbl,ivol) 

          end do                    !loop over columns of block matrix

        end if                       !boundary types
       
!   10 continue       

      end do                        !loop - boundary control volumes 
      
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif      

!cdbg
#ifdef DEBUG
      info_debug = 0
      if (info_debug.gt.0) then
        irow = 0
        do ivol=1,nngl
          do ic=1,n
            irow = irow+1
            write(idbg,'(a,2x,a,i5,i5,a,1pe15.6e3)')                   &
                  namec(ic),'b(',ivol,ic,') = ',brt(irow)/cvol(ivol)
          end do
        end do
        do ivol=1,nngl
          do ic = 1,n
            irow=(ivol-1)*n+ic
            istart = iart(irow)
            iend   = iart(irow+1)-1            
            write(idbg,*) iart(irow)
            i2 = 0
            do i1 = istart,iend
              i2 = i2+1
              if (i2.gt.n) then
                i2 = i2-n
              end if
              icol = jart(i1)
              write(idbg,'(a,2x,a,2x,a,i5,i5,a,1pe15.6e3)')           &
                    namec(ic),namec(i2),'a(',irow,icol,') = ',        &
                                 art(i1)/cvol(ivol)
            end do
          end do
        end do
        write(idbg,*)
      end if

      if (info_debug.gt.1) then
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
#endif
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------
      call memory_monitor(-sizeof(bdyinfrt_da_ic),'bdyinfrt_da_ic',.true.)
      deallocate(bdyinfrt_da_ic)
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------
!cprovi--------------------------------------------------------------------------      
      return
      end
