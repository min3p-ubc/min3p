!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 786 $
!> $Author: dsu $
!> $Date: 2021-01-06 21:41:32 -0800 (Wed, 06 Jan 2021) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/xyzcoord.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine xyzcoord
!c -------------------
!c
!c compute spatial increments for x,y and z-direction
!c and calculate xyz-coordinates of control volume centroids
!c
!c half-cells:
!c
!c         delx(1)   delx(2)    delx(3) 
!c         *-----------*------------*  ------- y_max(nyy)
!c         |     |            |     |
!c         |     |            |     |  dely(3)      generated for 1D, 2D
!c         |------------------------|               and 3D grids 
!c         |     |            |     |
!c         |     |            |     |
!c x_4,y_4 *     |     *      |     *  dely(2)
!c         |     |            |     |
!c         |     |            |     |
!c         |------------------------|
!c         |     |            |     |
!c         |     |            |     |  dely(1)
!c         |     |            |     |
!c         *-----------*------------*  ------- y_min(1)
!c        x_1,y_1     x_2,y_2      x_3,y_3 
!c        x_min(1)                 x_max(nxx)
!c
!c
!c full-cells:
!c
!c      delx(1)     delx(2)      delx(3) 
!c   --------------------------------------  ---- y_max(nyy)
!c   |           |            |           |
!c   | x_7       | x_8        | x_9       |
!c   | y_7 *     | y_8 *      | y_9 *     |  dely(3)
!c   |           |            |           |
!c   |           |            |           |  generated for 1D, 2D
!c   |------------------------------------|  and 3D grids 
!c   |           |            |           |
!c   | x_4       | x_5        | x_6       |
!c   | y_4 *     | y_5 *      | y_6 *     |  dely(2)
!c   |           |            |           |
!c   |           |            |           |
!c   |------------------------------------|
!c   |           |            |           |
!c   | x_1       | x_2        | x_3       |
!c   | y_1 *     | y_2 *      | y_3 *     |  dely(1)
!c   |           |            |           | 
!c   |           |            |           |
!c   --------------------------------------  ---- y_min(1)
!c   
!c   |                                    |
!c   x_min(1)                             x_max(nxx)
!c
!c written by:      Uli Mayer - June 10, 96 
!c
!c last modified:   Uli Mayer - November 27, 96
!c
!c                  Danyang Su - March. 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed:   -
!c
!c common:   
!c gen.f:    real*8:
!c           -------
!c           delx(nvx)          = spatial increment in x-direction    * +
!c           dely(nvy)          = spatial increment in y-direction    * +
!c           delz(nvz)          = spatial increment in z-direction    * +
!c           dimcv(3,nn)        = dimension of control volumes        * +
!c           elevmax            = max. elevation of solution domain   * +
!c           xg(nn)             = spatial coordinates in x-direction  * +
!c           yg(nn)             = spatial coordinates in y-direction  * +
!c           zg(nn)             = spatial coordinates in z-direction  * +
!c           xmax(nxx)          = max. coordinate of discretization   + -
!c                                interval in x-direction
!c           xmin(nxx)          = min. coordinate of discretization   + -
!c                                interval in x-direction
!c           ymax(nyy)          = max. coordinate of discretization   + -
!c                                interval in y-direction
!c           ymin(nyy)          = min. coordinate of discretization   + -
!c                                interval in y-direction
!c           zmax(nzz)          = max. coordinate of discretization   + -
!c                                interval in z-direction
!c           zmin(nzz)          = min. coordinate of discretization   + -
!c                                interval in z-direction
!c
!c           integer*4:
!c           ----------
!c           nn                 = total number of control volumes     + -
!c           nxx                = number of intervals in x-direction  + -
!c           nyy                = number of intervals in y-direction  + -
!c           nzz                = number of intervals in z-direction  + -
!c           nvix(nxx)          = number of control volumes in        + -
!c                                x-direction (intervals)
!c           nviy(nyy)          = number of control volumes in        + -
!c                                y-direction (intervals)
!c           nviz(nzz)          = number of control volumes in        + -
!c                                z-direction (intervals)
!c           nvx                = number of control volumes in        + -
!c                                x-direction
!c           nvy                = number of control volumes in        + -
!c                                y-direction
!c           nvz                = number of control volumes in        + -
!c                                z-direction
!c
!c           logical:
!c           --------
!c           half_cells         = .true.  -> half cells on boundary   + -
!c
!c local:    real*8:
!c           -------
!c           delxx              = spatial increment in x-direction 
!c                                (temporary)
!c           delyy              = spatial increment in y-direction 
!c                                (temporary)
!c           delzz              = spatial increment in z-direction 
!c                                (temporary)
!c           r1                 = constant
!c           rhalf              = constant
!c
!c           integer*4:
!c           ----------
!c           ixx                = counter (number of intervals in
!c                                x-direction)
!c           iyy                = counter (number of intervals in
!c                                y-direction)
!c           izz                = counter (number of intervals in
!c                                z-direction)
!c           ivx                = counter (number of control
!c                                volumes in x-direction)
!c           ivy                = counter (number of control
!c                                volumes in y-direction)
!c           ivz                = counter (number of control
!c                                volumes in z-direction)
!c           ivol               = pointer (current control volume)
!c           istart             = pointer
!c           iend               = pointer
!c
!c external: -
!c ----------------------------------------------------------------------
 
      subroutine xyzcoord(discrete_type)

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
#ifdef OPENMP
      use omp_lib 
#endif 

#ifdef PETSC
      use solver_dd, only: solver_dd_mapping_set,                &
                                 solver_dd_coordinates_set,            &
                                 solver_dd_coordinates_get
#endif

      implicit none
      
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
      
      integer :: discrete_type
      integer :: info_debug
      integer :: ixx, iyy, izz, ivx, ivy, ivz, istart, iend, ivol   
      real*8 :: delxx, delyy, delzz
#ifdef PETSC
      real*8 :: elevmax_gbl
      PetscErrorCode :: ierrcode
#endif

      real*8, parameter :: rhalf = 0.5d0, r1 = 1.0d0
     
      info_debug = 0
      istart = 0
      iend = 0
      elevmax = -1.0d+300

!c  compute spatial increments in x, y and z-direction 
!c  (constant for each direction)
!c  allow also 1D and 2D-discretizations

      if (half_cells) then        !half cells on boundary

!c  x-direction
        if (nvxgbl.gt.1) then         
          do ixx=1,nxx            !loop over intervals
            if (ixx.eq.1) then    !pointers to increments
              istart = 1
              iend = nvix(ixx)
            else 
              istart = iend+1
              iend = iend+nvix(ixx)
            end if

!c  calculate spatial increment

            if ((istart.eq.1).and.(iend.eq.nvxgbl)) then !only one interval
              delxx = dabs(xmax(ixx)-xmin(ixx))           &
     &              / float(nvix(ixx)-1)
            elseif ((istart.eq.1).or.(iend.eq.nvxgbl)) then       !boundary
              delxx = dabs(xmax(ixx)-xmin(ixx))           &
     &              / (float(nvix(ixx)-1)+rhalf)
            else                                               !interior
              delxx = dabs(xmax(ixx)-xmin(ixx))/float(nvix(ixx)) 
            end if

            do ivx=istart,iend    !loop over increments in interval

              if ((ivx.eq.1).or.(ivx.eq.nvxgbl)) then
                delx(ivx) = rhalf*delxx             !boundary
              else
                delx(ivx) = delxx                   !interior
              end if

            end do                !loop over increments in interval
          end do                  !loop over intervals
        elseif (nvxgbl.eq.1) then
          delx(1) = r1
        end if
        

!c  y-direction
        if (nvygbl.gt.1) then         
          do iyy=1,nyy            !loop over intervals
            if (iyy.eq.1) then    !pointers to increments
              istart = 1
              iend = nviy(iyy)
            else 
              istart = iend+1
              iend = iend+nviy(iyy)
            end if

!c  calculate spatial increment

            if ((istart.eq.1).and.(iend.eq.nvygbl)) then !only one interval
              delyy = dabs(ymax(iyy)-ymin(iyy))               &
     &              / float(nviy(iyy)-1)  
            elseif ((istart.eq.1).or.(iend.eq.nvygbl)) then       !boundary
              delyy = dabs(ymax(iyy)-ymin(iyy))               &
     &              / (float(nviy(iyy)-1)+rhalf)
            else                                               !interior
              delyy = dabs(ymax(iyy)-ymin(iyy))/float(nviy(iyy))
            end if

            do ivy=istart,iend    !loop over increments in interval

              if ((ivy.eq.1).or.(ivy.eq.nvygbl)) then
                dely(ivy) = rhalf*delyy             !boundary
              else
                dely(ivy) = delyy                   !interior
              end if

            end do                !loop over increments in interval
          end do                  !loop over intervals
        elseif (nvygbl.eq.1) then
          dely(1) = r1
        end if

!c  z-direction
        if (nvzgbl.gt.1) then         
          do izz=1,nzz            !loop over intervals
            if (izz.eq.1) then    !pointers to increments
              istart = 1
              iend = nviz(izz)
            else 
              istart = iend+1
              iend = iend+nviz(izz)
            end if

!c  calculate spatial increment

            if ((istart.eq.1).and.(iend.eq.nvzgbl)) then !only one interval
              delzz = dabs(zmax(izz)-zmin(izz))               &
     &              / float(nviz(izz)-1)
            elseif ((istart.eq.1).or.(iend.eq.nvzgbl)) then       !boundary
              delzz = dabs(zmax(izz)-zmin(izz))               &
     &              / (float(nviz(izz)-1)+rhalf)
            else                                               !interior
              delzz = dabs(zmax(izz)-zmin(izz))/float(nviz(izz)) 
            end if

            do ivz=istart,iend    !loop over increments in interval

              if ((ivz.eq.1).or.(ivz.eq.nvzgbl)) then
                delz(ivz) = rhalf*delzz             !boundary
              else
                delz(ivz) = delzz                   !interior
              end if

            end do                !loop over increments in interval
          end do                  !loop over intervals
        elseif (nvzgbl.eq.1) then
          delz(1) = r1
        end if

      else                        !full cells on boundary

!c  x-direction
        if (nvxgbl.gt.1) then         
          do ixx=1,nxx            !loop over intervals
            if (ixx.eq.1) then    !pointers to increments
              istart = 1
              iend = nvix(ixx)
            else 
              istart = iend+1
              iend = iend+nvix(ixx)
            end if
            delxx = dabs(xmax(ixx)-xmin(ixx))/float(nvix(ixx))  
            do ivx=istart,iend    !loop over increments in interval
              delx(ivx) = delxx   
            end do                
          end do                  !loop over intervals
        elseif (nvxgbl.eq.1) then
          delx(1) = r1
        end if

!c  y-direction
        if (nvygbl.gt.1) then         
          do iyy=1,nyy            !loop over intervals
            if (iyy.eq.1) then    !pointers to increments
              istart = 1
              iend = nviy(iyy)
            else 
              istart = iend+1
              iend = iend+nviy(iyy)
            end if
            delyy = dabs(ymax(iyy)-ymin(iyy))/float(nviy(iyy))  
            do ivy=istart,iend    !loop over increments in interval
              dely(ivy) = delyy   
            end do                
          end do                  !loop over intervals
        elseif (nvygbl.eq.1) then
          dely(1) = r1
        end if

!c  z-direction
        if (nvzgbl.gt.1) then         
          do izz=1,nzz            !loop over intervals
            if (izz.eq.1) then    !pointers to increments
              istart = 1
              iend = nviz(izz)
            else 
              istart = iend+1
              iend = iend+nviz(izz)
            end if
            delzz = dabs(zmax(izz)-zmin(izz))/float(nviz(izz))  
            do ivz=istart,iend    !loop over increments in interval
              delz(ivz) = delzz   
            end do                
          end do                  !loop over intervals
        elseif (nvzgbl.eq.1) then
          delz(1) = r1
        end if
      end if                      !(half_cells)

!c  calculate coordinates
      do ivx = 1,nvxgbl            !number of control volumes in x

        if (half_cells) then    !half cells on boundary

          ixx = 1
          if (ivx.eq.1) then
            xglat(ivx) = xmin(ixx)
          elseif (ivx.eq.2.and.nvxgbl.eq.2) then
            xglat(ivx) = xglat(ivx-1)+delx(ivx-1)+delx(ivx)
          elseif (ivx.eq.2.and.nvxgbl.gt.2) then
            xglat(ivx) = xglat(ivx-1)+delx(ivx-1)+rhalf*delx(ivx)
          elseif ((ivx.gt.2).and.(ivx.lt.nvxgbl)) then
            xglat(ivx) = xglat(ivx-1)+rhalf*(delx(ivx-1)+delx(ivx))
          elseif (ivx.eq.nvxgbl) then
            xglat(ivx) = xglat(ivx-1)+rhalf*delx(ivx-1)+delx(ivx)
          end if

        else                      !full cells on boundary
      
          ixx = 1
          if (ivx.eq.1) then
            if (nvxgbl.gt.1) then
              xglat(ivx) = xmin(ixx)+rhalf*delx(ivx)
            else
              xglat(ivx) = xmin(ixx)
            end if
          elseif (ivx.gt.1) then
            xglat(ivx) = xglat(ivx-1)+rhalf*(delx(ivx-1)+delx(ivx))
          end if
  
        end if                    !half_cells
#ifdef DEBUG
        if(info_debug > 0) then
            write(idbg,'(a,1x,i6,1x,a,1x,1pe15.6e3)') "ivx",ivx,       &
                  "xglat",xglat(ivx)
        end if
#endif
      end do                      !number of increments in x

      do ivy = 1,nvygbl            !number of control volumes in y

        if (half_cells) then    !half cells on boundary

          iyy = 1
          if (ivy.eq.1) then
            yglat(ivy) = ymin(iyy)
          elseif (ivy.eq.2.and.nvygbl.eq.2) then
            yglat(ivy) = yglat(ivy-1)+dely(ivy-1)+dely(ivy)
          elseif (ivy.eq.2.and.nvygbl.gt.2) then
            yglat(ivy) = yglat(ivy-1)+dely(ivy-1)+rhalf*dely(ivy)
          elseif ((ivy.gt.2).and.(ivy.lt.nvygbl)) then
            yglat(ivy) = yglat(ivy-1)+rhalf*(dely(ivy-1)+dely(ivy))
          elseif (ivy.eq.nvygbl) then
            yglat(ivy) = yglat(ivy-1)+rhalf*dely(ivy-1)+dely(ivy)
          end if

        else                      !full cells on boundary

          iyy = 1
          if (ivy.eq.1) then
            if (nvygbl.gt.1) then
              yglat(ivy) = ymin(iyy)+rhalf*dely(ivy)
            else
              yglat(ivy) = ymin(iyy)
            end if
          elseif (ivy.gt.1) then
            yglat(ivy) = yglat(ivy-1)+rhalf*(dely(ivy-1)+dely(ivy))
          end if

        end if                    !half_cells
#ifdef DEBUG
        if(info_debug > 0) then
            write(idbg,'(a,1x,i6,1x,a,1x,1pe15.6e3)') "ivy",ivy,       &
                  "yglat",yglat(ivy)
        end if
#endif
      end do                      !number of increments in y 


      do ivz = 1,nvzgbl            !number of control volumes in z

        if (half_cells) then    !half cells on boundary

          izz = 1
          if (ivz.eq.1) then
            zglat(ivz) = zmin(izz)
          elseif (ivz.eq.2.and.nvzgbl.eq.2) then
            zglat(ivz) = zglat(ivz-1)+delz(ivz-1)*delz(ivz)
          elseif (ivz.eq.2.and.nvzgbl.gt.2) then
            zglat(ivz) = zglat(ivz-1)+delz(ivz-1)+rhalf*delz(ivz)
          elseif ((ivz.gt.2).and.(ivz.lt.nvzgbl)) then
            zglat(ivz) = zglat(ivz-1) + rhalf*(delz(ivz-1)+delz(ivz))
          elseif (ivz.eq.nvzgbl) then
            zglat(ivz) = zglat(ivz-1)+rhalf*delz(ivz-1)+delz(ivz)
          end if

        else                      !full cells on boundary
      
          izz = 1
          if (ivz.eq.1) then
            if (nvzgbl.gt.1) then
              zglat(ivz) = zmin(izz)+rhalf*delz(ivz)
            else
              zglat(ivz) = zmin(izz)
            end if
          elseif (ivz.gt.1) then
            zglat(ivz) = zglat(ivz-1) + rhalf*(delz(ivz-1)+delz(ivz))
          end if

        end if                    !half_cells
#ifdef DEBUG
        if(info_debug > 0) then
            write(idbg,'(a,1x,i6,1x,a,1x,1pe15.6e3)') "ivz",ivz,       &
                  "zglat",zglat(ivz)
        end if
#endif
      end do                      !number of increments in z


      if(discrete_type > 0) then
        return
      end if

      ivol = 0
      do ivz = nvzgls,nvzgle                !number of control volumes in z
        do ivy = nvygls,nvygle              !number of control volumes in y 
          do ivx = nvxgls,nvxgle            !number of control volumes in x

            ivol = ivol+1           !pointer to current control volume
            
            xg(ivol) = xglat(ivx)
            yg(ivol) = yglat(ivy)
            zg(ivol) = zglat(ivz)
#ifdef DEBUG
            if(info_debug > 0) then
                write(idbg,'(a,1x,i6,3(1x,a,1x,1pe15.6e3))')           &
                      "local ivol", ivol, "xg", xg(ivol),              &
                      "yg", yg(ivol), "zg", zg(ivol)
            end if
#endif
          end do                      !number of increments in x
        end do                        !number of increments in y
      end do                          !number of increments in z
      
#ifdef PETSC
      !Set local to global mapping
      call solver_dd_mapping_set
      !Set DMDA coordinates
      call solver_dd_coordinates_set
      !Check and get DMDA coordinates
      call solver_dd_coordinates_get
#endif
      
     
      
!c  assign control volume dimensions
      ivol = 0
      do ivz = nvzgls,nvzgle
        do ivy = nvygls,nvygle
          do ivx = nvxgls,nvxgle

            ivol = ivol+1
            dimcv(1,ivol) = delx(ivx)  !x-direction
            dimcv(2,ivol) = dely(ivy)  !y-direction
            dimcv(3,ivol) = delz(ivz)  !z-direction

          end do
        end do
      end do

!c  compute maximum elevation of solution domain
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_xyzcoord_1)                     &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol)                                               &
    !$omp reduction(max:elevmax)
    !$omp do schedule(static)
#endif 
      do ivol = 1,nngl 
!#ifdef PETSC
!        if(node_idx_lg2l(ivol) < 0) then
!            cycle
!        end if
!#endif
          
        if (zg(ivol).gt.elevmax) then
          elevmax = zg(ivol)
        end if
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

#ifdef PETSC
      call MPI_Allreduce(elevmax, elevmax_gbl, 1, MPI_REAL8, MPI_MAX,  &
                         Petsc_Comm_World, ierrcode)
      CHKERRQ(ierrcode)
      elevmax = elevmax_gbl
#endif
 
!cdbg
!c     do ivx=1,nvx
!c       write(igen,'(a,1x,i6,1x,a,f10.3)')                           &
!c             'ivx = ',ivx,'delx = ',delx(ivx)
!c     end do
!c     do ivy=1,nvy
!c       write(igen,'(a,1x,i6,1x,a,f10.3)')                           &
!c             'ivy = ',ivy,'dely = ',dely(ivy)
!c     end do
!c     do ivz=1,nvz
!c       write(igen,'(a,1x,i6,1x,a,f10.3)')                           &
!c             'ivz = ',ivz,'delz = ',delz(ivz)
!c     end do
!c     do ivol=1,nngl
!c       write(igen,'(a,1x,i6,1x,3(a,f10.3,1x))')                     &
!c             'ivol = ',ivol,'xg = ',xg(ivol),'yg = ',yg(ivol),      &
!c             'zg = ',zg(ivol)
!c     end do
!c     do ivol=1,nngl
!c       write(igen,'(3(a,f10.5))')' dimcv(1,ivol) = ',dimcv(1,ivol), &
!c                                 ' dimcv(2,ivol) = ',dimcv(2,ivol), &
!c                                 ' dimcv(3,ivol) = ',dimcv(3,ivol)
!c     end do
!c     close(igen)
!c     stop
!cdbg
      return
      end
