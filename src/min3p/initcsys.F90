!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initcsys.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initcsys
!c -------------------
!c
!c define geochemical system
!c
!c written by:      Uli Mayer - May 12, 96
!c
!c last modified:   Tom Henderson - August 30, 2003
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c 
!c                                                                    I O
!c passed: -
!c
!c common: 
!c gen.f:    integer*4:
!c           ----------
!c           icnv               = unit number, data conversion        + -
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           idbg               = unit number, debugging file         + -
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, log book               + -
!c           itmp               = unit number, temporary storage      + -
!c           icdbs              = unit number, database for
!c                                             components
!c           igdbs              = unit number, database gases         + -
!c           imdbs              = unit number, database for minerals  + -
!c           ipsp               = unit number, list of possible       + -
!c                                             secondary aqueous 
!c                                             species, gases and 
!c                                             minerals
!c           isdbs              = unit number, database for sorbed    + -
!c                                             species 
!c           irdbs              = unit number, database for redox     + -
!c                                             couples
!c           ixdbs              = unit number, database for           + -
!c                                             aqueous complexes
!c           l_dbs_dir          = length of string for database       * +
!c                                directory
!c           n                  = number of primary unknowns          * +
!c
!c           logical:
!c           --------
!c           full_path          = .true.  -> path for database        * +
!c                                           specified in problem
!c                                           specific input file
!c
!c           character:
!c           ----------
!c           dbs_dir            = database directory                  * +
!c           section_header     = section header                      * +
!c
!c chem.f:   real*8:
!c           -------
!c           scalfac_aq(naq)    = scaling factors for intra-aqueous   * +
!c                                kinetic reactions
!c           tempc              = temperature [deg C]                 * +
!c           tempk              = temperature [deg K]                 * +
!c           tempcs             = standard temperature [deg C]        * +
!c           tempks             = standard temperature [deg K]        * +
!c           tconv              = temperature correction factor       + -
!c 
!c           integer*4:
!c           ---------- 
!c           iaic(nsites)       = pointer array for compressed        * +
!c                                storage of surface site data
!c           iais(nc)           = row pointer array for compressed    * +
!c                                storage of surface site data
!c           l_nameanc(nc)      = length of names of sorbed           * + 
!c                                components (non-competitive
!c                                sorption)
!c           l_nameaq(naq)      = length of names of intra-aqueous    * +
!c                                kinetic reactions
!c           l_namec(nc)        = length of component names           * +
!c           l_nameg(ng)        = length of names of gases            * +
!c           l_namem(nm)        = length of mineral names             * +
!c           l_namemx(nmx)      = length of names of excluded         * +
!c                                minerals
!c           l_namesb(nsb)      = length of names of sorbed species   * +
!c           l_namesb_ion(nsb_ion)      = length of names of sorbed   * +
!c                                        species of ion-exchange
!c           l_namesb_surf(nsb_surf)    = length of names of sorbed   * +
!c                                        species of surface-complex
!c           l_namer(nr)        = length of names of redox couples    * +
!c           l_namerp(nr)       = length of names of primary          * +
!c                                components of redox couples
!c           l_namers(nr)       = length of names of secondary        * +
!c                                components of redox couples
!c           l_namex(nx)        = length of names of secondary        * +
!c                                aqueous species
!c           nanc               = number of sorbed species            * +
!c                                non-competitive sorption
!c           naq                = number of intra-aqueous kinetic     * +
!c                                reactions
!c           nbio               = number of biomass components        * +
!c           nc                 = number of components including h2o  * +
!c           ng                 = number of gases                     * +
!c           nlinear            = number of linear sorption reactions * +
!c           nm                 = number of minerals                  * +
!c           nmx                = number of excluded minerals         * +
!c           nsb                = number of sorbed species            * +
!c           nsb_ion            = number of sorbed species            * +
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            * +
!c                                (surface-complex)
!c           nsites             = number of surface sites             * +
!c           nr                 = number of redox couples             * + 
!c           nx                 = number of secondary aqueous species * +
!c
!c           logical:
!c           --------
!c           compute_alkalinity = .true.  -> calculate alkalinity     * +
!c           linear_sorption    = .true.  -> components undergoing    * +
!c                                           linear sorption are 
!c                                           present
!c           new_database       = .true.  -> use new database format  * +
!c           noncompetitive_sorption = logical array for activation   * +  
!c                                     of noncompetitive sorption
!c                                     reactions
!c           ph_output          = .true.  -> output of pH             * +
!c           pe_output          = .true.  -> output of pe and Eh      * +
!c           search_database    = .true.  -> search database for      * +
!c                                           all secondary species
!c                                           possible and list in
!c                                           file prefix_o.psp
!c           temp_corr          = .true.  -> specify constant         * +
!c                                           temperature
!c                                .false. -> use standard
!c                                           temperature
!c           temp_field         = .true.  -> nodal temperatures       * +
!c
!c           character:
!c           ----------
!c           component_type(nc) = 'aqueous' = aqueous component       * +
!c                                'surface' = surface site
!c                                'biomass' = biomass
!c           input_units        = 'mol/l'                             * +
!c                                'mmol/l'
!c                                'mg/l'
!c                                'g/l'
!c           isotherm_type(nc)  = definition of sorption isotherm     * +   
!c                                'none' = no sorption
!c                                'linear' = linear adsorption
!c                                'freundlich' = Freundlich isotherm
!c                                'langmuir' = Langmuir isotherm
!c           nameanc(nc)        = names of sorbed species             * +
!c                                (non-competitive sorption)
!c           nameaq(naq)        = names of intra-aqueous kinetic      * +
!c                                reactions
!c           namec(nc)          = component names                     * +
!c           nameg(ng)          = names of gases                      * +
!c           namem(nm)          - mineral names                       * +
!c           namemx(nm)         = names of excluded minerals          * +
!c           namesb(nsb)        = names of sorbed species             * +
!c           namesb_ion(nsb_ion)= names of sorbed species             * +
!c                                (ion-exchange)
!c           namesb_surf(nsb_surf)= names of sorbed species           * +
!c                                  (surface-complex)
!c           namer(nr)          = names of redox couples              * +
!c           namerp(nr)         = names of primary components of      * +
!c                                redox couples
!c           namers(nr)         = names of secondary components of    * +
!c                                redox couples
!c           namex(nx)          = names of secondary aqueous species  * +
!c           output_unit_sb     = output unit for surface species     * +
!c           output_unit_sb_ion = output unit for sorption            * +
!c                                reactions of ion-exchange
!c           output_unit_sb_surf= output unit for sorption            * +
!c                                reactions of surface-complex
!c           redox_master       = 'o2(aq)'                            * +
!c                                'h2(aq)'
!c                                'e-1'
!c           sorption_group     = 'ion-exchange'                      * +
!c                                'surface-complexation'
!c                                'undefined'
!c           sorption_type      = 'gaines-thomas'                     * +
!c                                'gapon'
!c           sorption_type_ion  = 'gaines-thomas'                     * +
!c                                'gapon'
!c           sorption_type_surf = 'surface-complex'                   * +
!c                                'constant-capacitance'
!c
!c bbls.f      integer
!c          --------
!c           gas_pair(ng)       = component or species number for
!c                               gas pair for each gas
!c
!c              logical
!c          --------
!c           gas_bubbles        =.true. -> gas phase saturation is calculated      
!c                                    below the water table
!c             gas_species(ng,nx)    =.true.-> species ix has a common 
!c                                    component with gas ig 
!c
!c             character
!c          ---------
!c             pair_type(ng)        = type for each gas pair
!c                                  "component"
!c                                  'species"
!c
!c
!c local:    real*8:
!c           -------
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           ianc               = counter (non-competitive sorption)
!c           iaq                = counter (intra-aqueous kinetic 
!c                                         reactions)
!c           ic                 = counter (components)
!c           idummy             = integer dummy variable
!c           ig                 = counter (gases)
!c           ix                 = counter (secondary aqueous species)
!c           im                 = counter (minerals)
!c           imx                = counter (excluded minerals)
!c           isb                = counter (sorbed species)
!c           isites             = counter (surface sites)
!c           ilinear            = counter (linear sorption reactions)
!c           ir                 = counter (redox couples)
!c           l_string           = length of text string
!c           nna                = number of non-aqueous components
!c
!c           logical:
!c           --------
!c           found              = .true.  -> found component
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c           name               = name of component
!c           pair                = name of component paired with each gas
!c
!c external: findstrg  = find text string in file
!c           mem_nc    = allocate memory for one-dimensional arrays
!c                       of size n and nc
!c           mem_naq   = allocate memory for one-dimensional arrays
!c                       of size naq and related arrays
!c           mem_ng    = allocate memory for one-dimensional arrays
!c                       of size ng and related arrays
!c           mem_nm    = allocate memory for one-dimensional arrays
!c                       of size nm and related arrays
!c           mem_nmx   = allocate memory for one-dimensional arrays
!c                       of size nmx and related arrays
!c           mem_nr    = allocate memory for one-dimensional arrays
!c                       of size nr and related arrays
!c           mem_nsb   = allocate memory for one-dimensional arrays
!c                       of size nsb and related arrays
!c           mem_nx    = allocate memory for one-dimensional arrays
!c                       of size nx and related arrays
!c             mem_bbls  = allocate memory for one-dimensional arrays
!c                       for bubble problem, size = nc
!c           opndbfls  = open data base files
!c           sortcomp  = sort components and construct ordering vector
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           readcomp  = read database for components and assign
!c                       to permanent storage
!c           readint   = read database for intra-aqueous kinetic
!c                       reactions and assign to permanent storage
!c           readsspc  = read database for secondary aqueous
!c                       species and assign to permanent storage
!c           readgses  = read database for gases and
!c                       assign to permanent storage
!c           readmin   = read database for minerals and assign
!c                       to permanent storage
!c           readminx  = read database for excluded minerals and 
!c                       assign to permanent storage
!c           readmin_new  = read database for minerals and assign
!c                       to permanent storage (new database format)
!c           readminx_new  = read database for excluded minerals and 
!c                       assign to permanent storage (new database
!c                       format
!c           readsorb  = read database for sorbed species and 
!c                       assign to permanent storage
!c           readredx  = read database for redox couples and assign
!c                       to permanent storage
!c           readredx_new  = read database for redox couples and 
!c                       assign to permanent storage (new database 
!c                       format)
!c             assnpair  = assigns pair_type and component/species
!c                          number to each gas pair
!c ----------------------------------------------------------------------
 
      subroutine initcsys
#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif 
      use parm
      use gen
      use chem
      use bbls
      use geometry_definition
      use nobleGasIngrowth
      use file_utility, only : replacecharacter, readnextline
      use mip_bubble, only : mip_mt_enable
#ifdef INTEL
      use ifport
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
      external findstrg, mem_naq, mem_nc, mem_ng, mem_nm, mem_nmx,    &
               mem_nr, mem_nsb, mem_nx, mem_bbls,                     &
               assnpair, opndbfls, sortcomp, readint,                 &
               readbloc, readcomp, readsorb, readsspc, readgses,      &
               readmin, readmin_new, readminx, readminx_new,          &
               readredx, readredx_new

      logical found_section, found_subsection, found, bflag, flag_stop
      logical found_surface_complex, found_ion_exchange, istat_bool,  &
              multisite_ion_exchange
      character*16 :: dbs_names(13)
      character*72 :: subsection, name, string, pair, dummy      
      character*1024 :: strbuffer      

      real*8, parameter :: r1 = 1.0d0, r86400 = 86400d0
      
      integer :: l_string, l_string2, ic, idummy, ir, ix, ig, ierrcd,  &
                 ilinear, ianc, isb, nss_counter, jsb, itemp, isites,  &
                 im, iaq, ierr, imx, i1, nmp, im2, i, ipts, npts,      &
                 istat, idbs, idbs_in, ntemp,                          &
                 ingi, ingre, inge, ingnce, ingnpre, bitngre
      real*8 :: alpha, rhalftime, rdummy

#ifdef PETSC
      PetscErrorCode :: ierrcode
#endif      

      ierrcd = 0

      search_database = .true.   !hardwired for now

!c  read database directory, number and names of chemical species 
!c  from input file and write to temporary storage 
   
      section_header = 'geochemical system'
      call readbloc (idat,itmp,section_header,found_section,.true.)

!c  define length of section header

      l_string = index(section_header,'  ')-1
      if (l_string.eq.-1.or.l_string.gt.72) then
         l_string=72
      end if

!c  terminate program if section header not found

      if (.not.found_section) then
        if (rank == 0) then  
          write(ilog,*) 'SIMULATION TERMINATED'
          write(ilog,*) 'error reading input file'
          write(ilog,*) 'section "',section_header(:l_string),'" missing'
          close(ilog)
        end if
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if

!c  define defaults for geochemical system

      compute_alkalinity = .false.
      full_path = .false.
      dbs_dir = 'default'
      input_units = 'moles/l'
      redox_master = 'o2(aq)'
      naq = 0
      nx = 0
      nna = 0
      nm = 0
      nr = 0
      ng = 0
      nmx = 0
      nsites = 0
      nbio = 0
      
!c_bubbles - initailize gas_bubbles

      gas_bubbles = .false.

!c_trap - initailize trap_bubbles

      trap_bubbles = .false.

!c  noble gas ingrowth
      b_use_ngi = .false.

!c  read in parameters for geochemical system

      if (found_section) then

!c  database directory - old definition

        subsection = 'define database directory'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 1
          read(itmp,*,err=999,end=999) dbs_dir
          !replace '\' with '/'
          call replacecharacter(dbs_dir,achar(92),achar(47))
        end if

!cprovi---------------------------------------------------
!c  database directory - new definition

        subsection = 'database directory'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          full_path = .true.
          ierrcd = 2
          read(itmp,*,err=999,end=999) dbs_dir
          !replace '\' with '/'
          call replacecharacter(dbs_dir,achar(92),achar(47))
        end if

!cdsu use backup database prefix.dbs (rename prefix_o.dbs to prefix.dbs).   
        use_dbs_bk = .false.     
        subsection = 'use database backup'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          use_dbs_bk = .true.
          inquire(file=prefix(:l_prfx)//'.dbs',exist=bflag)

          if (bflag) then
            full_path = .true. 
            dbs_dir = 'database.backup'
            inquire(file=trim(dbs_dir),exist=bflag)

            if (.not.bflag) then
              flag_stop = .false.
              if (rank == 0) then
#ifdef INTEL
                istat_bool = system('mkdir '//trim(dbs_dir))
                if (.not. istat_bool) then
                  flag_stop = .true.
                  write(*,*) 'Error to create database folder ',trim(dbs_dir)
                  write(ilog,*) 'Error to create database folder ',trim(dbs_dir)
                end if
#else
                call system('mkdir '//trim(dbs_dir), status=istat)
                if (istat /= 0) then
                  flag_stop = .true.
                  write(*,*) 'Error to create database folder ',trim(dbs_dir)
                  write(ilog,*) 'Error to create database folder ',trim(dbs_dir)
                end if
#endif
                
              end if
#ifdef PETSC
              call MPI_BCAST(flag_stop, 1, MPI_LOGICAL, 0, Petsc_Comm_World, &
                             ierrcode)
              CHKERRQ(ierrcode)
#endif
              if (flag_stop) then
                goto 999
              end if
            end if            

            if (rank == 0) then
              idbs_in = lun_get()
              idbs = lun_get()

              open(idbs_in,file=prefix(:l_prfx)//'.dbs',status='old',err=999)

              dbs_names(1) = 'comp.dbs'
              dbs_names(2) = 'complex.dbs'
              dbs_names(3) = 'gases.dbs'
              dbs_names(4) = 'sit.dbs'
              dbs_names(5) = 'mineral.dbs'
              dbs_names(6) = 'mineral(x).dbs'
              dbs_names(7) = 'redox.dbs'
              dbs_names(8) = 'redoxh2.dbs'
              dbs_names(9) = 'redoxe.dbs'
              dbs_names(10) = 'sorption.dbs'
              dbs_names(11) = 'aqueousphase.dat'
              dbs_names(12) = 'pitzer.xml'
              dbs_names(13) = 'noblegases.dbs'

              do i = 1, size(dbs_names)

                bflag = .true.

                rewind(idbs_in)
                do while(readnextline(idbs_in,strbuffer,lowercase=.false.,           &
                         withcomment=.true.,original=.true.))

                  if (index(strbuffer,trim(dbs_names(i))//': start of') > 0) then

                    bflag = .false.

                    if (trim(dbs_names(i)).eq.'mineral(x).dbs') then
                      open(idbs,file=trim(dbs_dir)//'/mineral.dbs',&
                           status='unknown',form='formatted',access='append')
                    else
                      open(idbs,file=trim(dbs_dir)//'/'//trim(dbs_names(i)), &
                           status='unknown',form='formatted')
                    end if
                    do while(readnextline(idbs_in,strbuffer,lowercase=.false.,       &
                             withcomment=.true., original=.true.))
                      if (index(strbuffer,trim(dbs_names(i))//': end of') > 0) then
                        !skip writing 'end' when loop over minerals since 'end' will be
                        !added when loop over excluded minerals.
                        if(i < 5) then
                          write(idbs,'(a)') 'end'
                        else if (i > 5 .and. i < 11) then
                          write(idbs,'(a)') "'end'"
                        end if
                        exit
                      else
                        write(idbs,'(a)') trim(strbuffer)
                      end if
                    end do
                    close(idbs)
                  end if
                end do

                if (bflag) then
                  if (i == 6) then
                    open(idbs,file=trim(dbs_dir)//'/mineral.dbs',&
                         status='unknown',form='formatted',access='append')
                  else
                    open(idbs,file=trim(dbs_dir)//'/'//trim(dbs_names(i)), &
                         status='unknown',form='formatted')
                  end if
                  
                  if(i < 5) then
                    write(idbs,'(a)') 'end'
                  else if (i > 5 .and. i < 11) then
                    write(idbs,'(a)') "'end'"
                  end if
                  close(idbs)
                end if

              end do
                
              close(idbs_in)
              call lun_free(idbs_in)
              call lun_free(idbs)
            end if
          else
            if (rank == 0) then 
              write(*,*) 'Error: database back ',prefix(:l_prfx)//'.dbs is missing'
              write(ilog,*) 'Error: database back ',prefix(:l_prfx)//'.dbs is missing'
            end if
            goto 999
          end if
        end if




!cprovi---------------------------------------------------
!cproci It was added by Sergio Andrï¿½s Bea Jofr?
!cprovi               18/01/2009 
!cprovi---------------------------------------------------
        subsection = 'use pitzer model' 
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          ispitzer=.true.
          subsection = 'use macinnes convention'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            ismacinnes=.true.
          else
            ismacinnes=.false.
          end if
        else
          ispitzer=.false.
          ismacinnes=.false.  
        end if
!cprovi---------------------------------------------------
!cproci It was added by M. Xie for using SIT model
!cprovi               07/03/2018 
!cprovi---------------------------------------------------
        subsection = 'use sit model' 
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          issit = .true.
         else
          issit = .false.
        end if

!c  define database format

        subsection = 'use new database format'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          new_database = .true.
        else
          new_database = .false.
        end if
        
        subsection = 'use space delimiter in database'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          space_delimiter_dbs = .true.
        else
          space_delimiter_dbs = .false.
        end if

!cdsu  use compatible bubble gas database where temperature dependent 
!cdsu  solubility coefficients are placed after gram formula weight 
!cdsu  so that when gas bubble is deactivated, no modification 
!cdsu  in the database is required 
        subsection = 'compatible bubble gas database'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          compatible_bubble_dbs = .true.
        else
          compatible_bubble_dbs = .false.
        end if    


!c       settings for alkalinity calculations

        subsection = 'compute alkalinity'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          compute_alkalinity = .true.
        end if
        
!c  read setting of exponent n for reaction rate law
        subsection = 'consider exponent n for reaction rate law'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
            b_ratelaw_exponent_n = .true.
            if (rank == 0 .and. b_enable_output) then
              write (ilog, '(a)') 'consider exponent n for reaction rate law: true'
            end if
        else
            b_ratelaw_exponent_n = .false.
            if (rank == 0 .and. b_enable_output) then
              write (ilog, '(a)') 'consider exponent n for reaction rate law: false'
            end if
        end if

!c  input units

        subsection = 'define input units'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 3
          read(itmp,*,err=999,end=999) input_units
        end if

!c  set default parameters for temperature
        
        tempc = tempcs
        tempk = tempks
        temp_corr = .false.
        temp_field = .false.
        sorption_group = 'undefined'

!c  temperature

        subsection = 'define temperature'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 4
          read(itmp,*,err=999,end=999) tempc
          tempk = tempc + tconv
          temp_corr = .true.
        end if

!c  temperature field 
 
        subsection = 'define temperature field'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          temp_corr = .true.
          temp_field = .true.
        end if

!c  reverse enthalpy change due to the code and database change
        subsection = 'reverse enthalpy change'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          dhc_reverse = .true.
        else
          dhc_reverse = .false.
        end if  

!c  redox master variable

        subsection = 'define redox master variable'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 5
          read(itmp,*,err=999,end=999) redox_master
        end if

!c  define length of string for database directory

        l_dbs_dir=index(dbs_dir,' ')-1

!c  open database files

        call opndbfls(redox_master,search_database)

!c  ---------------------------------------------------------------------
!c  initialize chemical system for primary unknowns
!c  read number of components excluding h2o

        subsection = 'components'

        call findstrg(subsection,itmp,found_subsection)

        if (.not.found_subsection) then

          l_string = index(subsection,' ')-1
          if (l_string.eq.-1.or.l_string.gt.72) then
             l_string=72
          end if
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "',trim(section_header),'"'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        elseif (found_subsection) then
          
          ierrcd = 6
          read(itmp,*,err=999,end=999) n

        end if            !(subsection)
        
!c  read number of biomass components

        subsection = 'biomass components'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          ierrcd = 7
          read(itmp,*,err=999,end=999) nbio

        end if               !(subsection)
        

!c  read number of non-aqueous components

        subsection = 'non-aqueous components'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          ierrcd = 8
          read(itmp,*,err=999,end=999) nna

        end if               !(subsection)

       
!c  read number of surface complexation sites 
!c  (alternative for non-aqueous components)

        subsection = 'surface complexation sites'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          ierrcd = 9
          read(itmp,*,err=999,end=999) nna

        end if               !(subsection)

!c  number of components including biomass and surface compelxation sites

        n = n+nbio+nna


!c  number of components including h2o

        nc=n+1
 
!c  allocate memory for one-dimensional arrays of size n and nc

        call mem_nc

!c  include h2o as component 

        namec(nc) = 'h2o'

!c  set defaults for component types

        do ic = 1,nc
          component_type(ic) = 'aqueous'
        end do

!c  read aqueous component names

        subsection = 'components'

        call findstrg(subsection,itmp,found_subsection)

        ierrcd = 10
        read(itmp,*,err=999,end=999) idummy
        idummy = idummy   !avoid error messages

        ierrcd = 11
        do ic=1,n-nbio-nna
          read(itmp,*,err=999,end=999) namec(ic)
        end do

!c  read biomass component names

        subsection = 'biomass components'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          
          ierrcd = 12
          read(itmp,*,err=999,end=999) idummy
          idummy = idummy   !avoid error messages

          ierrcd = 13
          do ic=n-nbio-nna+1,n-nna
            read(itmp,*,err=999,end=999) namec(ic)
            component_type(ic) = 'biomass'
          end do
          
        end if
        
!c  read names of non-aqueous components and define number of 
!c  surface sites

        subsection = 'non-aqueous components'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          ierrcd = 14
          read(itmp,*,err=999,end=999) idummy

          do ic=n-nna+1,n

            ierrcd = 15
            read(itmp,*,err=999,end=999) namec(ic), component_type(ic)

            if (component_type(ic).eq.'surface') then
              nsites = nsites+1
            end if

          end do

        end if
!c  read names of surface complexation sites and define number of 
!c  surface sites
!c  (alternative for non-aqueous components)

        subsection = 'surface complexation sites'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          ierrcd = 16
          read(itmp,*,err=999,end=999) idummy

          do ic=n-nna+1,n

            ierrcd = 17
            read(itmp,*,err=999,end=999) namec(ic), component_type(ic)
 
            if (component_type(ic).eq.'surface') then
              nsites = nsites+1
            end if

          end do

        end if
        
!c ----------------------------------------------------------------------
!c  read number of redox couples
  
        subsection = 'redox couples'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          ierrcd = 18
          read(itmp,*,err=999,end=999) nr

!c  allocate memory for one-dimensional arrays of size nr and
!c  related arrays

          call mem_nr

!c  read names of primary and secondary components of redox couple
   
          do ir=1,nr
            ierrcd = 19
            read(itmp,*,err=999,end=999) namerp(ir), namers(ir)
          end do

!c  define length of primary and secondary components of redox couples

          do ir = 1,nr
            l_namerp(ir) = index(namerp(ir),' ')-1
            if (l_namerp(ir).eq.-1.or.l_namerp(ir).gt.72) then
              l_namerp(ir) = 72
            end if
            l_namers(ir) = index(namers(ir),' ')-1
            if (l_namers(ir).eq.-1.or.l_namers(ir).gt.72) then
              l_namers(ir) = 72
            end if
          end do

!c  assign name to redox couple and define length of name

          do ir = 1,nr
            namer(ir) = namerp(ir)(:l_namerp(ir))//'/'//  &
     &                  namers(ir)(:l_namers(ir))
            l_namer(ir) = l_namerp(ir)+l_namers(ir)+1
          end do

        end if                !(subsection)

!c  sort components in consideration of oxidation-reduction reactions
!c  amd construct ordering vector

        call sortcomp(idbg,ilog)

!c  define length of component names

        do ic = 1,nc
          l_namec(ic) = index(namec(ic),' ')-1
          if (l_namec(ic).eq.-1.or.l_namec(ic).gt.72) then
            l_namec(ic) = 72
          end if
        end do

!c ----------------------------------------------------------------------
!c  read number of secondary aqueous species

        subsection = 'secondary aqueous species'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
      
          ierrcd = 20
          read(itmp,*,err=999,end=999) nx

        end if 

!c  allocate memory for one-dimensional arrays of size nx and related
!c  arrays
        call mem_nx

        if (found_subsection) then

!c  read names of aqueous complexes

          do ix=1,nx
            ierrcd = 21
            read(itmp,*,err=999,end=999) namex(ix)
          end do

!c  define length of names of secondary aqueous species

          do ix = 1,nx
            l_namex(ix) = index(namex(ix),' ')-1
            if (l_namex(ix).eq.-1.or.l_namex(ix).gt.72) then
              l_namex(ix) = 72
            end if
          end do

        end if                         !(found_subsection)
        
!c_bubbles Determine if bubble formation is required

        subsection = 'bubble formation'
        
        call findstrg(subsection,itmp,found_subsection)
        
        if (found_subsection) then
          gas_bubbles = .true.
        end if

!c_trap Determine if bubble entrapment is required
        if (gas_bubbles) then
          subsection = 'trap bubbles'
          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            trap_bubbles = .true.
          end if
        end if

!c  define 1st order aqueous decay
          b_use_aq_decay = .false.
          
          aqdecayconst = 0.0d0

          subsection = 'components decay half life'          
          call findstrg(subsection,itmp,b_use_aq_decay)

          if (.not.b_use_aq_decay) then
            subsection = 'components decay half-life'
            call findstrg(subsection,itmp,b_use_aq_decay)
          end if

          if (.not.b_use_aq_decay) then
            subsection = 'components decay half time'
            call findstrg(subsection,itmp,b_use_aq_decay)
          end if

          if (.not.b_use_aq_decay) then
            subsection = 'components decay half-time'
            call findstrg(subsection,itmp,b_use_aq_decay)
          end if

          if (b_use_aq_decay) then
            do ic=1,n-nbio-nna
              ierrcd = 22
              read(itmp,*,err=999,end=999) rhalftime           !unit of half life time is second
              aqdecayconst(ic) = 0.69314718d0/rhalftime        !unit is s^-1
            end do
          end if

          if (.not. b_use_aq_decay) then
            subsection = 'components decay rate constant'          
            call findstrg(subsection,itmp,b_use_aq_decay)

            if (b_use_aq_decay) then
              do ic=1,n-nbio-nna
                ierrcd = 23
                read(itmp,*,err=999,end=999) aqdecayconst(ic)
              end do
            end if            
          end if
          
          if (b_use_aq_decay) then
            do ic=1,n-nbio-nna
              aqdecayconst(ic) = aqdecayconst(ic)*r86400      !convert unit to day^-1
            end do   
          end if        

!c ----------------------------------------------------------------------
!c  read number of gaseous species

        subsection = 'gases'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
      
          ierrcd = 24
          read(itmp,*,err=999,end=999) ng

!c  allocate memory for one-dimensional arrays of size ng and related
!c  arrays

          call mem_ng

!c_bubbles If gas_bubbles is true then read gas names and
!c_bubbles pairs and call mem_bbls
       
          if (gas_bubbles .or. mip_mt_enable) then
!c_bubbles allocate memory for one-dimensional arrays for bubble 
!c_bubbles problem
            call mem_bbls
            gas_species = .false.
            update_component = .false.

            do ig=1,ng
!c_bubbles read gas names and gas pair
              ierrcd = 25
              read(itmp,*,err=999,end=999) nameg(ig), pair

!c_bubbles Look for 'pair' in components then species
              call assnpair(pair, ig)            
            end do
!c  If gas_bubbles is false then just read names of gaseous species
          else 
            do ig=1,ng
              ierrcd = 26
              read(itmp,*,err=999,end=999) nameg(ig)
            end do
          end if

!c  define length of names of gases

          do ig = 1,ng
            l_nameg(ig) = index(nameg(ig),' ')-1
            if (l_nameg(ig).eq.-1.or.l_nameg(ig).gt.72) then
              l_nameg(ig) = 72
            end if
          end do

!c  define 1st order gas decay
          b_use_gas_decay = .false.
          
          if (ng > 0) then
            gasdecayconst = 0.0d0

            subsection = 'gases decay half-life'          
            call findstrg(subsection,itmp,b_use_gas_decay)

            if (.not.b_use_gas_decay) then
              subsection = 'gases decay half time'          
              call findstrg(subsection,itmp,b_use_gas_decay)
            end if

            if (b_use_gas_decay) then
              do ig=1,ng
                ierrcd = 27
                read(itmp,*,err=999,end=999) rhalftime
                gasdecayconst(ig) = 0.69314718d0/rhalftime
              end do
            end if

            if (.not. b_use_gas_decay) then
              subsection = 'gases decay rate constant'          
              call findstrg(subsection,itmp,b_use_gas_decay)

              if (b_use_gas_decay) then
                do ig=1,ng
                  ierrcd = 28
                  read(itmp,*,err=999,end=999) gasdecayconst(ig)
                end do
              end if
            
            end if          
          end if
          
          if (b_use_gas_decay) then
            do ig=1,ng
              gasdecayconst(ig) = gasdecayconst(ig)*r86400
            end do   
          end if

        else

          call mem_ng

        end if             !(found_subsection)

!c ----------------------------------------------------------------------
!c  initialize logical array for non-competitive sorption
        noncompetitive_sorption = .false.
        linear_sorption = .false.
        do ic = 1,nc
          isotherm_type(ic) = 'none'
        end do

!c  read number of components undergoing linear sorption
        subsection = 'linear sorption'
   
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          noncompetitive_sorption = .true.
          linear_sorption = .true.

!c  allocate memory for non-competitive sorption reactions

          call mem_nsb

!c  number of components undergoing linear sorption
          ierrcd = 29
          read(itmp,*,err=999,end=999) nlinear

          if (nlinear <= 0) then
            linear_sorption = .false.
          end if

!c  read names of components undergoing linear sorption and update 
!c  isotherm array

          do ilinear=1,nlinear
            
            found = .false.
            ierrcd = 30
            read(itmp,*,err=999,end=999) name
                      
            do ic = 1,nc
              if (name.eq.namec(ic)) then
                isotherm_type(ic) = 'linear'
                found = .true.
              end if
            end do

!c  terminate simulation, if specified component not part
!c  of current dataset

            l_string = index(subsection,' ')-1
            if (l_string.eq.-1.or.l_string.gt.72) then
              l_string=72
            end if
            if (.not.found) then
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error reading input file'
                write(ilog,*) 'section "',trim(section_header),'"'
                write(ilog,*) 'subsection ',trim(subsection)
                write(ilog,*) 'erroneous component definition'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop
            end if
          end do
        end if

!c  define first order decay for sorbed components
        if (noncompetitive_sorption) then
          sorptiondecayconst = 0.0d0

          subsection = 'linear sorption decay half time'
        
          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            b_use_sorption_decay = .true.
            do ic=1,nc-1
              ierrcd = 31
              read(itmp,*,err=999,end=999) rhalftime
              sorptiondecayconst(ic) = 0.69314718d0/rhalftime
            end do
          end if

          if (.not. b_use_sorption_decay) then
            subsection = 'linear sorption decay rate constant'
        
            call findstrg(subsection,itmp,found_subsection)

            if (found_subsection) then
              b_use_sorption_decay = .true.
              do ic=1,nc-1
                ierrcd = 32
                read(itmp,*,err=999,end=999) sorptiondecayconst(ic)
              end do
            end if
          
          end if        
       
          if (b_use_sorption_decay) then
            do ic=1,nc-1
              sorptiondecayconst(ic) = sorptiondecayconst(ic)*r86400
            end do   
          end if          
        end if

!c  define number and assign names for sorbed components 
!c  (non-competitive sorption)

        if (noncompetitive_sorption) then      
          ianc = 0
          do ic = 1,nc
            if (isotherm_type(ic).ne.'none') then
              ianc = ianc+1
              nameanc(ianc) = namec(ic)
              l_nameanc(ianc) = l_namec(ic)
            end if
          end do
          nanc = ianc
        end if

!c ----------------------------------------------------------------------
!c  read number of sorbed species

        nsb_surf = 0
        nsb_ion = 0

        subsection = 'sorbed species'        

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
      
          ierrcd = 33
          read(itmp,*,err=999,end=999) nsb_ion
          
          nsb_surf = nsb_ion

!c  allocate memory for one-dimensional arrays of size nsb and related
!c  arrays

          call mem_nsb

!c  read names of sorbed species

          do isb=1,nsb_ion
            ierrcd = 34
            read(itmp,*,err=999,end=999) namesb_ion(isb)
          end do
          namesb_surf(1:nsb_surf) = namesb_ion(1:nsb_ion)

!c  define length of names of sorbed species

          do isb = 1,nsb_ion
            l_namesb_ion(isb) = index(namesb_ion(isb),' ')-1
            if (l_namesb_ion(isb).eq.-1.or.l_namesb_ion(isb).gt.72) then
              l_namesb_ion(isb) = 72
            end if
          end do
          
          l_namesb_surf(1:nsb_surf) = l_namesb_ion(1:nsb_ion)

!cmx  Check sorbed species input file: no sorbed species then no sorbed sites
          if (nsb_ion .eq. 0) then
            if (nsites_ion > 1) then
              if (rank == 0) then
                write(ilog,*) 'error reading input file'
                write(ilog,*) 'subsection "',trim(subsection), '" missing or with error'
              end if
              ierrcd = 35
              goto 999
            end if
            nsites_ion = 0
          end if
                    
!cmx  Find the number of sorbed species (nss) on each ion exchange site-type
          do isb=1, nsites_ion
              nss_counter = 0
              do jsb = 1, nsb_ion 
                  if (isb .eq. idx_nsites_ion(jsb)) then
                      nss_counter = nss_counter +1
                  end if
              end do
              nss_onIsite_ion(isb) = nss_counter
          end do
 
!cmx  Find the index of sorbed species (ss) on each ion exchange site-type
          do isb=1, nsites_ion
              nss_counter = 0
              do jsb = 1, nsb_ion 
                  if (isb .eq. idx_nsites_ion(jsb)) then
                      nss_counter = nss_counter +1
                      idx_ss2isite_ion(isb,nss_counter)=jsb
                  end if
              end do
          end do

        end if
        
        
!c ----------------------------------------------------------------------
!c  read number of sorbed species of surface-complex and ion-exchange

        found_surface_complex = .false.
        found_ion_exchange = .false.
        multisite_ion_exchange = .false.

        subsection = 'sorbed species of surface-complex'
        
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
            
          found_surface_complex = .true.
          ierrcd = 36
          read(itmp,*,err=999,end=999) nsb_surf
          
        end if
        
        subsection = 'sorbed species of ion-exchange'
        
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
            
          found_ion_exchange = .true.
          ierrcd = 37
          read(itmp,*,err=999,end=999) nsb_ion
          
        end if 

!c  read number of surface sites of ion-exchange   !CMX
        subsection = 'surface sites of ion-exchange'
        
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
            
          found_ion_exchange = .true.
          ierrcd = 38
          read(itmp,*,err=999,end=999) nsites_ion

         if ((nsb_ion < 1 .and. nsites_ion > 1) .or. nsites_ion < 1)  then
          
              l_string = index(subsection,' ')-1
              if (l_string.eq.-1.or.l_string.gt.72) then
              l_string=72
              end if
              
              if (rank == 0) then
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error reading input file'
                write(ilog,*) 'subsection "',trim(subsection), '" missing or with error'
                write(ilog,*) 'sorbed species for ion exchange not specified'
                write(ilog,*) 'surface sites for ion exchange not less than 1'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop          

         end if

        end if

!c ----------------------------------------------------------------------
!c  read number of sorbed species of surface-complex and ion-exchange
        if (found_surface_complex .or. found_ion_exchange) then
            
!c  allocate memory for one-dimensional arrays of size nsb and related
!c  arrays
          call mem_nsb

!c  read names of sorbed species of surface-complex

          subsection = 'sorbed species of surface-complex'
          
          call findstrg(subsection,itmp,found_subsection)
          
          if (found_subsection) then
            ierrcd = 39
            read(itmp,*,err=999,end=999) nsb_surf
            
            do isb=1,nsb_surf
              ierrcd = 40
              read(itmp,*,err=999,end=999) namesb_surf(isb)
            end do

!c  define length of names of sorbed species of surface-complex

            do isb = 1,nsb_surf
              l_namesb_surf(isb) = index(namesb_surf(isb),' ')-1
              if (l_namesb_surf(isb).eq.-1.or.l_namesb_surf(isb).gt.72) then
                l_namesb_surf(isb) = 72
              end if
            end do

          end if

!c  read names of sorbed species of ion-exchange

        subsection = 'sorbed species of ion-exchange'
        
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then            
          ierrcd = 41
          read(itmp,*,err=999,end=999) nsb_ion
          
!c  read names of sorbed species of ion-exchange

          do isb=1,nsb_ion
            ierrcd = 42
            read(itmp,*,err=999,end=999) namesb_ion(isb)
          end do

!c  define length of names of sorbed species of ion-exchange

          do isb = 1,nsb_ion
            l_namesb_ion(isb) = index(namesb_ion(isb),' ')-1
            if (l_namesb_ion(isb).eq.-1.or.l_namesb_ion(isb).gt.72) then
              l_namesb_ion(isb) = 72
            end if
          end do
          
        end if


!c  read names of sorbed species of ion-exchange

        subsection = 'surface sites of ion-exchange'
        
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then 
          ierrcd = 43    
          read(itmp,*,err=999,end=999) nsites_ion
     
          itemp = 0
         
          if (nsites_ion .gt. 1) then
            multisite_ion_exchange = .true.
            do isb=1,nsites_ion
              ierrcd = 44
              read(itmp,*,err=999,end=999) namesb_sites_ion(isb)
              !!! if (TRIM(namesb_sites_ion(isb))='-PS')
              l_string = index(namesb_sites_ion(isb),' ')-1
              if (l_string.eq.-1.or.l_string.gt.72) then
              l_string=72
              itemp = itemp + 1
              end if
            end do
            
            l_string = index(namesb_sites_ion(nsites_ion),'sorbed species of ion-exchange')-1
            
            if (itemp > 0 .or. l_string >= 0) then
              if (rank == 0) then 
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error reading input file'
                write(ilog,*) 'subsection "',trim(subsection), '" missing or with error'
                write(ilog,*) 'sorbed species for ion exchange not specified'
                write(ilog,*) 'surface sites for ion exchange not less than 1'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop 
            end if

            !c  define length of names of surface sites of ion-exchange

            do isb = 1,nsites_ion
              l_namesb_nsites_ion(isb) = index(namesb_sites_ion(isb),' ')-1
              if (l_namesb_nsites_ion(isb).eq.-1.or.l_namesb_nsites_ion(isb).gt.72) then
                l_namesb_nsites_ion(isb) = 72
              end if
            end do
          
          end if    
        end if
      end if
        
!c  Find the site index of each sorbed species for multisite ionic excahnge 
!c  and store them in idx_nsites_ion(nsites_ion).
!c  It is assumed that the name of sites contains '-' and '('. The site name in 
!c  the name of the sorbed species is located between '-' and '(' from the back.
!cmx  Example 'cs-FES(na)' is associated with site '-FES'.
      if (nsb_ion >0) then
        if (multisite_ion_exchange) then
          do isb = 1,nsb_ion
              l_string = index(namesb_ion(isb),'-', BACK=.true.)
              l_string2 = index(namesb_ion(isb),'(', BACK=.true.)-1
              string = namesb_ion(isb)(l_string:l_string2)
              
              itemp = 0
              do jsb = 1,nsites_ion
                  l_string = index(string,' ')
                  l_string2 = index(namesb_sites_ion(jsb),' ')
                  
                  if (l_string .eq. l_string2) then
                      l_string = index(namesb_sites_ion(jsb), string)-1
                      if (l_string .eq. 0) then
                        idx_nsites_ion(isb) = jsb
                        itemp = itemp +1
                      end if
                  end if
              end do
              
              if (itemp .eq. 0 .or. itemp>2) then
                if (rank == 0) then  
                  write(ilog,*) 
                  write(ilog,*) 'Error reading site index from sorbed species in'
                  write(ilog,*) 'subsection ''sorbed species of ion-exchange'', missing or with error'
                  write(ilog,*) 'check the names of surface sites and/or sorbed species!'
                  write(ilog,*) 
                  close(ilog)
                end if
#ifdef PETSC
                call petsc_mpi_finalize
#endif
                stop 
              end if
              
          end do
        end if
 
!cmx  Find the number of sorbed species (nss) on each ion exchange site-type
          do isb=1, nsites_ion
              nss_counter = 0
              do jsb = 1, nsb_ion 
                  if (isb .eq. idx_nsites_ion(jsb)) then
                      nss_counter = nss_counter +1
                  end if
              end do
              nss_onIsite_ion(isb) = nss_counter
          end do
          
!cmx  Find the index of sorbed species (ss) on each ion exchange site-type
          do isb=1, nsites_ion
              nss_counter = 0
              do jsb = 1, nsb_ion 
                  if (isb .eq. idx_nsites_ion(jsb)) then
                      nss_counter = nss_counter +1
                      idx_ss2isite_ion(isb,nss_counter)=jsb
                  end if
              end do
          end do
        
        end if      !multisite_ion_exchange
        
            
 
!c  optional definition of sorption convention
            
      if (nsb_ion > 0 .or. nsb_surf > 0) then
     
        subsection = 'use concentrations in cation-exchange'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          isactcexch=.false. 

        else

          isactcexch=.true. 

        end if             !(found_subsection) 

        subsection = 'define sorption type'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          ierrcd = 45
          read(itmp,*,err=999,end=999) sorption_type

        else

          sorption_type = 'gaines-thomas'

        end if             !(found_subsection)
         
        subsection = 'define sorption type of surface-complex'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          ierrcd = 46
          read(itmp,*,err=999,end=999) sorption_type_surf

        else

          sorption_type_surf = 'surface-complex'

        end if             !(found_subsection)
         
         
   ! User specified unit for the output of the SCM sorbed species concentration
         
        if (sorption_type_surf .eq. 'surface-complex') then
          subsection = 'specify output unit for SCM sorbed species concentration'
          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            ierrcd = 47
            read(itmp,*,err=999,end=999) output_unit_sb_surf
                                  
            if ((trim(output_unit_sb_surf) .ne. 'mol/L H2O') .and.&
                (trim(output_unit_sb_surf) .ne. 'mol/L bulk')) then
                l_string = index(subsection,' ')-1
              if (rank == 0) then  
                write(ilog,*) 'SIMULATION TERMINATED'
                write(ilog,*) 'error reading input file'
                write(ilog,*) 'subsection "',trim(subsection), '"'
                write(ilog,*) 'The specified SCM sepcies unit: ''', &
                              trim(output_unit_sb_surf),            &
                              '''is not valid.'
                write(ilog,*) 'This should be ''mol/L H2O'' or ''mol/L bulk''.'
              end if
              ierrcd = 48  
              goto 999
            end if
                 
          else

            output_unit_sb_surf = 'mol/L H2O'

          end if             !(found_subsection)

        end if               !sorption_type_surf
         
        subsection = 'define sorption type of ion-exchange'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          ierrcd = 49
          read(itmp,*,err=999,end=999) sorption_type_ion

        else

          sorption_type_ion = 'gaines-thomas'

        end if             !(found_subsection)

!c  set default to surface complexation, if nsites > 0, and type 
!c  is set to gapon or gaines-thomas

        if (nsites.gt.0.and.(sorption_type.eq.'gaines-thomas'.or.   &
          sorption_type.eq.'gapon')) then
          sorption_type = 'surface-complex'
        end if
          
          
!c  define sorption group

        if (sorption_type.eq.'gaines-thomas') then
          sorption_group = 'ion-exchange'
        elseif (sorption_type.eq.'gapon') then
          sorption_group = 'ion-exchange'
        elseif (sorption_type.eq.'surface-complex') then
          sorption_group = 'surface-complexation'
        elseif (sorption_type.eq.'constant-capacitance') then
          sorption_group = 'surface-complexation'
        !elseif (sorption_type.eq.'surface-complex and ion-exchange') then
        !  sorption_group = 'surface-complex and ion-exchange'
        end if
         
        if(.not. found_surface_complex .and. .not. found_ion_exchange) then
          if (sorption_group.eq.'ion-exchange') then
            nsb_surf = 0
            !release the pre-allocated memory for surface-complex variables
          elseif (sorption_group.eq.'surface-complexation') then
            nsb_ion = 0
            !release the pre-allocated memory for ion-exchange variables
          end if
        end if
         
        if (nsb_ion.gt.0.and.nsb_surf.gt.0) then
          sorption_group = 'surface-complex and ion-exchange'
        end if

        if ((sorption_group.eq. 'surface_complexation' .or.       &
            (sorption_group.eq.'surface-complex and ion-exchange'  &
             .and. nsb_surf > 0)).and.nsites.eq.0 .and. nsites_ion.eq.0) then

          subsection = 'non-aqueous components'
          l_string = index(subsection,' ')-1
          if (l_string.eq.-1.or.l_string.gt.72) then
              l_string=72
          end if
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            write(ilog,*) 'no surface sites specified'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

!c  define output unit for surface species

        if (sorption_group.eq.'ion-exchange') then
          output_unit_sb_ion = 'meq/100g'
        !elseif (sorption_group.eq.'surface-complexation') then       !removed as user defined
        !  output_unit_sb_surf = 'mol/L h2o'
        elseif (sorption_group.eq.'surface-complex and ion-exchange') then
          output_unit_sb_ion = 'meq/100g'
 !MX      output_unit_sb_surf = 'mol/L h2o'
        end if

!c  define compressed data structure for surface sites

        if (sorption_group.eq.'surface-complexation' .or.         &
           (sorption_group.eq.'surface-complex and ion-exchange' &
            .and. nsb_surf > 0)) then

          isites = 0

          do ic = 1,nc

            if (component_type(ic).eq.'surface') then
              isites = isites+1
              iais(ic) = isites
              iaic(isites) = ic
            end if

          end do
#ifdef DEBUG
          do ic = 1,nc
            isites = iais(ic)
            write(idbg,"(i8, 1x, a, 1x, a, i8)") ic,namec(ic),component_type(ic),isites
          end do
#endif

#ifdef DEBUG
          do isites = 1,nsites
            ic = iaic(isites)
            write(idbg,"(i8,1x,a,1x,a,i8)") isites,namec(ic),component_type(ic),ic
          end do
#endif

        end if

      end if               !(nsb.gt.0)
        
      if (nsb_surf < 1 .and. nsites > 0) then
          
          l_string = index(subsection,' ')-1
          if (l_string.eq.-1.or.l_string.gt.72) then
          l_string=72
          end if
          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'subsection "',trim(subsection), '" missing'
            write(ilog,*) 'surface complexes not specified'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop          

      end if
        
        !write(*,*) "sorption_group ", trim(sorption_group)
        !write(*,*) "nsb_surf ", nsb_surf, " nsb_ion ", nsb_ion
        
!c ----------------------------------------------------------------------
!c  read number of minerals 
 
        subsection = 'minerals'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
      
          ierrcd = 50
          read(itmp,*,err=999,end=999) nm
 
!c  allocate memory for one-dimensional arrays of size nm and
!c  related arrays

          call mem_nm

!c  read mineral names
 
          do im = 1,nm
            ierrcd = 51
            read(itmp,*,err=999,end=999) namem(im)
          end do

!c  define length of mineral names

          do im = 1,nm
            l_namem(im) = index(namem(im),' ')-1
            if (l_namem(im).eq.-1.or.l_namem(im).gt.72) then
              l_namem(im) = 72
            end if
          end do
 
        end if              !(found_subsection)
        
        if (nm > 0) then
          subsection = 'mineral water removal coefficient'
          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then 
            water_removal = .true.  
            do im = 1,nm
              ierrcd = 52
              read(itmp,*,err=999,end=999) rwaterremovalcoeff(im)
            end do
          end if              !(found_subsection)  
        else
          water_removal = .false.  
        end if

!c  read scaling factors for mineral reactivity

        subsection = 'scaling factors of mineral reactivity'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          do im = 1,nm
            ierrcd = 53
            read(itmp,*,err=999,end=999) scalfac_min(im)
          end do

        end if

!c ----------------------------------------------------------------------
!c  read number of intra-aqueous kinetic reactions

        subsection = 'intra-aqueous kinetic reactions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          ierrcd = 54
          read(itmp,*,err=999,end=999) naq

!c  allocate memory for one-dimensional arrays of size naq and
!c  related arrays

          call mem_naq

!c  read names of intra-aqueous kinetic reactions
   
          do iaq=1,naq
            ierrcd = 55
            read(itmp,*,err=999,end=999) nameaq(iaq)
          end do

!c  define length of names of intra-aqueous kinetic reactions

          do iaq = 1,naq
            l_nameaq(iaq) = index(nameaq(iaq),' ')-1
            if (l_nameaq(iaq).eq.-1.or.l_nameaq(iaq).gt.72) then
              l_nameaq(iaq) = 72
            end if
          end do

        end if

!c  read scaling factors for intra-aqueous kinetic reactions

        subsection = 'scaling for intra-aqueous kinetic reactions'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then

          do iaq = 1,naq
            ierrcd = 56
            read(itmp,*,err=999,end=999) scalfac_aq(iaq)
          end do

        else

          do iaq = 1,naq
            scalfac_aq(iaq) = r1
          end do

        end if

! prc ---------------------------------------------------------------
! prc allocating the vectors for diffusion coefficients for components 
! prc including h2o (mdiff_ic) and secondary aqueous species (mdiff_ix)
! prc ---------------------------------------------------------------        
        
        if (multi_diff) then          !CMX
          allocate (mdiff_ic(nc), stat = ierr)
          mdiff_ic = 0.0d0
          call checkerr(ierr,'mdiff_ic',ilog)
          call memory_monitor(sizeof(mdiff_ic),'mdiff_ic',.true.)
          
          allocate (mdiff_ix(nx), stat = ierr)
          mdiff_ix = 0.0d0
          call checkerr(ierr,'mdiff_ix',ilog)
          call memory_monitor(sizeof(mdiff_ix),'mdiff_ix',.true.)

          allocate (mdiff_ic_tensor(nc), stat = ierr)
          mdiff_ic_tensor = tensor_zero
          call checkerr(ierr,'mdiff_ic_tensor',ilog)
          call memory_monitor(sizeof(mdiff_ic_tensor),'mdiff_ic_tensor',.true.)

          allocate (mdiff_ix_tensor(nx), stat = ierr)
          mdiff_ix_tensor = tensor_zero
          call checkerr(ierr,'mdiff_ix_tensor',ilog)
          call memory_monitor(sizeof(mdiff_ix_tensor),'mdiff_ix_tensor',.true.)
        end if
! prc ---------------------------------------------------------------
!c ----------------------------------------------------------------------
!c  read database for components, secondary aqueous species, redox 
!c  couples, gases, sorbed species, minerals and intra-aqueous 
!c  kinetic reactions, search database for possible secondary aqueous species
 
        call readcomp(icdbs,ilog,idbg)

        call readsspc(ixdbs,ipsp,ilog,idbg,igen)

        if (nr.gt.0) then
          if (new_database) then
              call readredx_new(irdbs,ilog,idbg)
          else
            call readredx(irdbs,ilog,idbg)
          end if
        end if

        if (ng.gt.0) then
          call readgses(igdbs,ipsp,ilog,idbg,igen)
        end if

        if (nsb_ion.gt.0.or.nsb_surf.gt.0) then
          call readsorb(isdbs,ipsp,ilog,idbg,igen)
        end if

        if (nm.gt.0) then
          if (new_database) then
              call readmin_new(imdbs,ilog,idbg,igen,icnv)
          else
              call readmin(imdbs,ilog,idbg,icnv)
          end if
        end if

        if (naq.gt.0) then
          if (new_database) then
              call readint_new(irdbs,ilog,idbg)
          else
              call readint(irdbs,ilog,idbg)
          end if
        end if
        
        if (issit) then
            call readsit(isitdbs,ilog,idbg)
        end if
        

!c ----------------------------------------------------------------------
!c  read number of excluded minerals

        subsection = 'excluded minerals'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
      
          ierrcd = 57
          read(itmp,*,err=999,end=999) nmx

!c  allocate memory for one-dimensional arrays of size nmx and
!c  related arrays

          call mem_nmx

!c  read mineral names

          do imx = 1,nmx
            ierrcd = 58
            read(itmp,*,err=999,end=999) namemx(imx)
          end do

!c  define length of names of excluded minerals

          do imx = 1,nmx
            l_namemx(imx) = index(namemx(imx),' ')-1
            if (l_namemx(imx).eq.-1.or.l_namemx(imx).gt.72) then
              l_namemx(imx) = 72
            end if
          end do

        end if             !(found_subsection)
      
!c  search mineral database and read data for specified excluded minerals

        if (nmx .gt. 0) then  ! THH Aug 30, 2003 edit
          if (new_database) then
            call readminx_new(imdbs,ipsp,ilog,idbg,igen)           
          else
            call readminx(imdbs,ipsp,ilog,idbg)
          end if
        end if

!c  close file containing possible secondary aqueous species, 
!c  gases and minerals

        close(ipsp)
        call lun_free(ipsp)

!c  define default for pointer array for mineralogical parameters

        if (nm.gt.0) then

          do im = 1,nm
            iamp(im) = im
            jamp(im) = im
          end do
          iamp(nm+1) = nm+1

        end if

!c  optional input section to allow the combined use and update
!c  of reactive surface area and volume fractions

        subsection = 'combine mineralogical parameters'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
     
!c  define mapping 

          do im = 1,nm
            ierrcd = 59
            read(itmp,*,err=999,end=999) namet(im)
          end do
     
!c  define pointer arrays

          iamp(1) = 1
          do im = 1,nm
            i1 = iamp(im)
            if (namet(im).eq.namem(im)) then
              nmp = 0
              do im2 = 1,nm
                if (namet(im2).eq.namem(im)) then
                  jamp(i1+nmp) = im2
                  nmp = nmp+1 
                end if
              end do
              iamp(im+1) = iamp(im)+nmp 
            elseif (namet(im).ne.namem(im)) then
              iamp(im+1) = iamp(im) 
            end if
          end do

        end if              !(found_subsection)


!c  sung-wook      
!c  optional input section to allow update od reactive
!c  surface area by mineral precipitation
        if (nm > 0) then
          sur_prec=.false.
          alph_prec=0
        end if

        subsection = 'surface precipitates'

        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
        
          ierrcd = 60
          read(itmp,*,err=999,end=999) npts
     
!c  define mapping 
          do ipts = 1,npts
            ierrcd = 61
            read(itmp,*,err=999,end=999) dummy, alpha
            do im=1,nm
                if(namem(im).eq.dummy) then
                    sur_prec(im)=.true.
                    alph_prec(im)=alpha
                end if
            end do                    
          end do
    
        end if              !(found_subsection)

!cdsu  keyword to activate noble gas ingrowth module
        ngi = 0
        b_use_ngi = .false.

        subsection = 'noble gas ingrowth'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          ierrcd = 62
          read(itmp,*,err=999,end=999) ngi

          if (ngi > 0) then
            b_use_ngi = .true.
          end if
        end if

!cdsu  read noble gas isotopes to be considered

        if (b_use_ngi) then
          call mem_ngi

          subsection = 'noble gas ingrowth'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            read(itmp,*,err=999,end=999) rdummy
            do ingi = 1, ngi
              read(itmp,*,err=999,end=999) name_ngi(ingi)
            end do
          end if

!c  noble gas ingrowth related database
          call readnoblegases

!c  noble gas ingrowth related data from input file
          index_uiso = 0
          b_combine_238u_235u = .false.
          subsection = 'noble gas ingrowth - radioelements'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            read(itmp,*,err=999,end=999) ngre_i
            !c check if radioelements have 235u and 238u but no 235u+238u or 238u+235u
            bitngre = 0
            do i = 1, ngre_i
              read(itmp,*,err=999,end=999) name
              if (trim(name).eq.'235u') then
                bitngre = ibset(bitngre,0)
                index_uiso(1) = i
              else if (trim(name).eq.'238u') then
                bitngre = ibset(bitngre,1)
                index_uiso(2) = i
              else if (trim(name).eq.'235u+238u' .or. &
                       trim(name).eq.'238u+235u') then
                bitngre = ibset(bitngre,2)
                index_uiso(3) = i
              end if
            end do
            if (bitngre.eq.3) then
              ngre_i = ngre_i + 1
              b_combine_238u_235u = .true.
              index_uiso(3) = ngre_i
            end if
          end if

          subsection = 'noble gas ingrowth - elements'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            read(itmp,*,err=999,end=999) nge_i
          end if

          subsection = 'noble gas ingrowth - neutron capture elements'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            read(itmp,*,err=999,end=999) ngnce_i
          end if

!c  noble gas ingrowth related variable index
          call mem_ngi_idx

          subsection = 'noble gas ingrowth - radioelements'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            read(itmp,*,err=999,end=999) rdummy

            if (b_combine_238u_235u) then
              do i = 1, ngre_i-1
                read(itmp,*,err=999,end=999) name_ngre_i(i)
              end do
              name_ngre_i(ngre_i) = '238u+235u'
            else
              do i = 1, ngre_i
                read(itmp,*,err=999,end=999) name_ngre_i(i)
                if (trim(name_ngre_i(i)).eq.'235u+238u') then
                  name_ngre_i(i) = '238u+235u'
                end if
              end do
            end if

            do i = 1, ngre_i
              do ingre = 1, ngre
                if (trim(name_ngre_i(i)) .eq. trim(noble_gas_re(ingre)%name)) then
                  idx_ngre_i2d(i) = ingre
                  idx_ngre_d2i(ingre) = i
                end if
              end do

              do ingnpre = 1, ngnpre
                if (trim(name_ngre_i(i)) .eq. trim(noble_gas_npre(ingnpre)%name)) then
                  idx_ngnpre_i2d(i) = ingnpre
                  idx_ngnpre_d2i(ingnpre) = i
                end if
              end do
            end do
          end if

          subsection = 'noble gas ingrowth - elements'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            read(itmp,*,err=999,end=999) rdummy
            do i = 1, nge_i
              read(itmp,*,err=999,end=999) name_nge_i(i)
              do inge = 1, nge
                if (trim(name_nge_i(i)) .eq. trim(name_nge(inge))) then
                  idx_nge_i2d(i) = inge
                  idx_nge_d2i(inge) = i
                end if
              end do
            end do
          end if

          subsection = 'noble gas ingrowth - neutron capture elements'
          call findstrg(subsection,itmp,found_subsection)
          if (found_subsection) then
            read(itmp,*,err=999,end=999) rdummy
            do i = 1, ngnce_i
              read(itmp,*,err=999,end=999) name_ngnce_i(i)
              do ingnce = 1, ngnce
                if (trim(name_ngnce_i(i)) .eq. trim(name_ngnce(ingnce))) then
                  idx_ngnce_i2d(i) = ingnce
                  idx_ngnce_d2i(ingnce) = i
                end if
              end do
            end do
          end if

!c  add all radioelements parameters, this is only needed to calculate concentration of 
!c  radioelements that are not used in noble gas ingrowth
          call readnoblegases_re_i

!c  check noble gas ingrowth related variables
          call check_ngi_variables

        end if

      end if                !(found_section)

      if (b_enable_output .and. b_enable_output_gen) then

!c ----------------------------------------------------------------------
!c  write number and names of chemical species to generic output file
 
        write(igen,'(/72a)')('-',i=1,72)
        write(igen,'(a)') section_header(:l_string)
        write(igen,'(72a/)')('-',i=1,72)
 
!c  output database to generic output file

        write(igen,'(2a)') 'database: ',dbs_dir
        if (redox_master.eq.'e-1') then
          write(igen,'(a)') 'redox master variable: e-1'
        elseif (redox_master.eq.'o2(aq)') then
          write(igen,'(a)') 'redox master variable: o2(aq)'
        elseif (redox_master.eq.'h2(aq)') then
          write(igen,'(a)') 'redox master variable: h2(aq)'
        end if
        write(igen,'(2a)') 'input units: ',input_units
        if (.not.temp_field) then
          write(igen,'(a,f6.2,a/)') 'temperature = ',tempc,' deg C'
        end if

!c  write number of components to generic output file

        write(igen,'(a,i10/)')  &
          'number of components:                           = ', nc           
 
!c  write component names to generic output file
 
        write(igen,'(a)')'aqueous components:'
        write(igen,'(a)')'-------------------'
        do ic=1,nc 
          if (component_type(ic).eq.'aqueous') then
            write(igen,'(a72)') namec(ic)
          end if
        end do
      
!c  write biomass component names to generic output file

        if (nbio.gt.0) then
        
          write(igen,'(/a)')'biomass components:'
          write(igen,'(a)')'-------------------'
          do ic=1,nc 
            if (component_type(ic).eq.'biomass') then
              write(igen,'(a72)') namec(ic)
            end if
          end do
        
        end if

!c  write names of surface complexation sites to generic output file
      
        if (nna.gt.0) then

          write(igen,'(/a)')'non-aqueous components:'
          write(igen,'(a)')'-----------------------'
          do ic=1,nc 
            if (component_type(ic).eq.'surface') then
              write(igen,'(a72)') namec(ic)
            end if
          end do

        end if

!c  write number of redox couples to generic output file

        if (nr.gt.0) then

          write(igen,'(/a,i10/)')   &
            'number of redox couples:                        = ', nr           

!c  write names of redox couples to generic output file
 
          write(igen,'(a)')'redox couples:'
          write(igen,'(a)')'--------------'
          do ir=1,nr 
            write(igen,'(a)') namer(ir)(:l_namer(ir))
          end do
 
        end if             !(nr.gt.0)
 
!c  write number of intra-aqueous kinetic reactions to generic 
!c  output file

        if (naq.gt.0) then

          write(igen,'(/a,i10/)')   &
            'number of intra-aqueous kinetic reactions       = ', naq

!c  write names of intra-aqueous kinetic reactions to generic 
!c  output file

          write(igen,'(a)')'intra-aqueous kinetic reactions:'
          write(igen,'(a)')'--------------------------------'
          write(igen,'(a)')'name            scaling factor'
          do iaq=1,naq
            write(igen,'(a12,1x,1pe15.6e3)') nameaq(iaq),scalfac_aq(iaq)
          end do

        end if             !(naq.gt.0)

!c  write number of aqueous complexes to generic output file
 
        if (nx.gt.0) then

          write(igen,'(/a,i10/)')   &
            'number of aqueous complexes:                    = ', nx           
 
!c  write names of aqueous complexes to generic output file
 
          write(igen,'(a)')'aqueous complexes:'
          write(igen,'(a)')'------------------'
          do ix=1,nx
            write(igen,'(a72)') namex(ix)
          end do

        end if
 
!c  write number of gases to generic output file 
 
        if (ng.gt.0) then
          write(igen,'(/a,i10/)')   &
            'number of gases:                                = ', ng           

!c  write names of gases to generic output file 
!c_bubbles If gas_bubles is true then write gases, gas pair
    
          if (gas_bubbles .or. mip_mt_enable) then

            if (gas_bubbles) then
              write(igen,'(a/)') 'gas bubble formation'
            else
              write(igen,'(a/)') 'MIP bubble formation'
            end if
            write(igen,'(a8,a12,a12)')' gas: ','gas pair'
            write(igen,'(a8,a12,a12)')'------','---------'
            do ig = 1,ng
              i = gas_pair(ig)
              write(igen,'(a12,a12,a12)') nameg(ig),namec(i)
            end do
!c_bubbles Else just write names of gases
          else
            write(igen,'(a)')'gases:'
            write(igen,'(a)')'------'
            do ig = 1,ng
              write(igen,'(a72)') nameg(ig)
            end do        
          end if 
        end if
 
!c  write names of species undergoing sorption to generic output file

        if (noncompetitive_sorption) then
      
          write(igen,'(/2a)')'components undergoing ',  &
                             'non-competitive adsorption:'
          write(igen,'(2a)')'------------------------', &
                            '--------------------------'
      
          do ic = 1,nc
            if (isotherm_type(ic).ne.'none') then
                write(igen,'(a12,1x,a)') namec(ic), isotherm_type(ic)
              end if
          end do
      
        end if
        
        if (nsb_ion.gt.0.or.nsb_surf.gt.0) then

!c  write number of sorbed species to generic output file

          write(igen,'(/a,i10/)')                                        &
                'number of sorbed species:                       = ',    &
                nsb_ion+nsb_surf+nsites
      
!c  write names of sorbed species to generic output file

          write(igen,'(a)')'sorbed species:'
          write(igen,'(a)')'---------------'
          if (sorption_group.eq.'surface-complexation'.or.(nsb_surf.gt.0 .and. &
              sorption_group.eq.'surface-complex and ion-exchange')) then
            do isites = 1,nsites
              ic = iaic(isites)
              write(igen,'(a72)') namec(ic)
            end do
          end if
            
          do isb = 1,nsb_ion
            write(igen,'(a72)') namesb_ion(isb)
          end do
        
          do isb = 1,nsb_surf
            write(igen,'(a72)') namesb_surf(isb)
          end do

        end if

!c  write number of minerals to generic output file 
 
        if (nm.gt.0) then

          write(igen,'(/a,i10/)')   &
            'number of minerals:                             = ', nm           
 
!c  write mineral names to generic output file 
 
          write(igen,'(a)')'minerals:'
          write(igen,'(a)')'---------'
          do im = 1,nm
            write(igen,'(a72)') namem(im)
          end do

        end if

!c  write number of excluded minerals to generic output file 
 
        if (nmx.gt.0) then

          write(igen,'(/a,i10/)')   &
            'number of excluded minerals:                    = ', nmx

!c  write names of excluded minerals to generic output file

          write(igen,'(a)')'excluded minerals:'
          write(igen,'(a)')'------------------'
          do imx = 1,nmx
            write(igen,'(a72)') namemx(imx)
          end do

        end if
      
      end if    !output to gen file

!cdsu search for gas pair and assign value for gas_pair
      if (ng > 0) then
        if (gas_bubbles .or. mip_mt_enable) then
          call assngasspc
        end if
      end if

!c  set logical variables for output of master variables

      ph_output = .false.
      pe_output = .false.
      do ic = 1,nc-1
        if (namec(ic).eq.'h+1') then
          ph_output = .true.
        end if
        if (redox_master.eq.'o2(aq)'.and.namec(ic).eq.'o2(aq)'.or.    &
     &      redox_master.eq.'h2(aq)'.and.namec(ic).eq.'h2(aq)'.or.    &
     &      redox_master.eq.'e-1'.and.namec(ic).eq.'e-1') then
          pe_output = .true.
        end if
      end do 

      goto 1000

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

1000  return
      end
