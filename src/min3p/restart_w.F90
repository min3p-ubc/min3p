!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 875 $
!> $Author: dsu $
!> $Date: 2024-01-21 12:55:48 -0800 (Sun, 21 Jan 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/restart_w.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine restrat_w
!c --------------------
!c
!c write data for restart option
!c
!c written by:      Rich Amos - November 27, 2005
!c
!c last modified:   Sergi Molins - Jan 30, 2007
!c                  bubbles are out
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common:
!c
!c
!c gen.f:    real*8:
!c           -------
!c           uvsold(nn)         = solution vector (old time level)    * +
!c           uvsnew(nn)         = solution vector (new time level)    + -
!c           sanew(nn)          = aqueous phase saturation            + -
!c                                - new time level
!c           saold(nn)          = aqueous phase saturation            * +
!c                                - old time level
!c           sgnew(nn)          = gaseous phase saturation            * +
!c                                - new time level
!c           sgold(nn)          = gaseous phase saturation            * +
!c                                - old time level
!c           c(nc,nn)           = concentrations of free species      * +
!c                                - old time level [moles/l water]
!c           cnew(nc,nn)        = concentrations of free species      + -
!c                                - new time level [moles/l water]
!c           cec_g(nn)          = cation exchange capacity [meq/100g] + -
!c                                - global system
!c           cx(nx,nn)          = concentrations of secondary aqueous + -
!c                                species [moles/l water]
!c           distcoff_rt(nc,nn) = sorption distribution coefficient   + -
!c                                [-], [l bulk/l bulk]
!c                                - reactive transport
!c           gamma(nc+nx,nn)    = activity coefficients of aqueous    + -
!c                                species [-]
!c           phi(nm,nn)         = mineral volume fractions            + -
!c           phiold(nm,nn)      = mineral volume fractions            + -
!c                                - old time level
!c           sionold(nn)        = ionic strength of solution          * +
!c                                - old time level
!c           sionnew(nn)        = ionic strength of solution          + -
!c                                - new time level
!c           tkel(nn)           = nodal temperatures in Kelvin        + -
!c           totaold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                non-competitive sorption 
!c                                - old time level [moles/l bulk]
!c           totanew(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                non-competitive sorption
!c                                - new time level [moles/l bulk]
!c           totcold(n,nn)      = total aqueous component             * +
!c                                concentrations
!c                                - old time level [moles/l water]
!c           totcnew(n,nn)      = total aqueous component             + -
!c                                concentrations
!c                                - new time level [moles/l water]
!c           totgold(n,nn)      = total gaseous component             * +
!c                                concentrations
!c                                - old time level [moles/l air]
!c           totgnew(n,nn)      = total gaseous component             + -
!c                                concentrations
!c                                - new time level [moles/l air]
!c           totsold(n,nn)      = total sorbed component              * +
!c                                concentrations
!c                                - old time level [moles/l bulk]
!c           totsold_ion(n,nn)  = total sorbed component              * +
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsold_surf(n,nn) = total sorbed component              * +
!c                                concentrations 
!c                                - old time level [moles/l bulk]
!c                                (surface-complex)
!c           totsnew(n,nn)      = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c           totsnew_ion(n,nn)  = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (ion-exchange)
!c           totsnew_surf(n,nn) = total sorbed component              + -
!c                                concentrations
!c                                - new time level [moles/l bulk]
!c                                (surface-complex)
!c           cmold(nm,nn)       = mineral concentrations              * +
!c                                - old time level [moles/l bulk]]
!c           cmnew(nm,nn)       = mineral concentrations              + -
!c                                - new time level [moles/l bulk]
!c           gold(ng,nn)        = gas concentrations                  * +
!c                                - old time level [moles / l air]    
!c           gnew(ng,nn)        = gas concentrations                  + -
!c                                - new time level [moles / l air]
!c           perm_fac(nn)       = scaling factor for permeability     + +
!c                                as a function of porosity changes
!c           pornew(nn)         = porosity                            + +
!c
!c           integer*4:
!c           ----------
!c           idbg               = unit number - debugging information + -
!c           n                  = number of components excluding h2o  + -
!c                                equals number of unknowns per
!c                                control volume
!c           nn                 = total number of control volumes     + -
!c
!c           logical:
!c           --------
!c           reactive_transport = .true.  -> perform reactive         + -
!c                                           transport simulation
!c           transient_flow     = .true.  -> .not.steady_flow,        + -
!c                                        -> transient flow
!c           update_porosity    = .true.  -> update porosity as       + -
!c                                           a result of dissolution-
!c                                           precipitation reactions
!c           update_permeability= .true.  -> update permeability as   + -
!c                                           a function of porosity
!c           varsat_flow        = .true.  -> perform flow simulation  + -
!c                                           simulation
!c
!c chem.f:   real*8:
!c           -------
!c           csb(nsb)           = concentrations of sorbed species    * *
!c                                - new time level
!c           csb_ion(nsb_ion,nthreads)
!c                              = concentrations of sorbed species    * *
!c                                - new time level (ion-exchange)
!c           csb_surf(nsb_surf,nthreads) 
!c                              = concentrations of sorbed species    * *
!c                                - new time level (surface-complex)
!c           chargesb(nsb)      = charge of sorbed species            + -
!c           chargesb_ion(nsb_ion)   = charge of sorbed species       + -
!c                                     (ion-exchange)
!c           chargesb_surf(nsb_surf) = charge of sorbed species       + -
!c                                     (surface-complex)
!c           eqsb(nsb)          = equilibrium constants for           + -
!c                                sorbed species
!c           eqsb_ion(nsb_ion,nthreads)  
!c                              = equilibrium constants for           + -
!c                                sorbed species (ion-exchange)
!c           eqsb_surf(nsb_surf,nthreads)
!c                              = equilibrium constants for           + -
!c                                sorbed species (surface-complex)
!c           rhobulk            = dry bulk density of porous medium   + -
!c           temp_field         = .true.  -> nodal temperatures       + -
!c           xnusb(nsb*nc)      = stoichiometric coefficient matrix   + -
!c                                for formation of sorbed species
!c                                from components
!c           xnusb_ion(nsb_ion*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (ion-exchange)
!c           xnusb_surf(nsb_surf*nc)= stoichiometric coefficient matrix + -
!c                                for formation of sorbed species
!c                                from components (surface-complex)
!c
!c           integer*4:
!c           ----------
!c           iamp(nm+1)         = pointer array for distribution      + -
!c                                and combination of mineralogical
!c                                parameters
!c           iasb(nsb+1)        = row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           iasb_ion(nsb_ion+1)= row pointer array to                + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           iasb_surf(nsb_surf+1)= row pointer array to              + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           jamp(nm)           = pointer array for distribution      + -
!c                                and combination of mineralogical
!c                                parameters
!c           jasb(nsb*nc)       = column pointer array to             + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c           jasb_ion(nsb_ion*nc)= column pointer array to            + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (ion-exchange)
!c           jasb_surf(nsb_surf*nc)= column pointer array to          + -
!c                                stoichiometric coefficients of
!c                                components in sorbed species
!c                                (surface-complex)
!c           nc                 = number of components                + -
!c                                (including h2o)
!c           ng                 = number of gases                     + -
!c           nm                 = number of minerals                  + -
!c           nr                 = number of redox couples             + -
!c           nsb                = number of sorbed species            + -
!c           nsb_ion            = number of sorbed species            + -
!c                                (ion-exchange)
!c           nsb_surf           = number of sorbed species            + -
!c                                (surface-complex)
!c
!c           logical:
!c           --------
!c           noncompetitive_sorption = logical array for activation   + -   
!c                                     of noncompetitive sorption
!c                                     reactions
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c           sorption_group     = 'ion-exchange'                      + -
!c                                'surface-complexation'
!c                                'undefined'
!c           sorption_type      = 'gaines-thomas'                     + -
!c                                'gapon'
!c           update_activity(nthreads)
!c                              = 'no_update' -> unity activity       + -
!c                                 coefficients
!c                                'time_lagged' -> update activity
!c                                 coefficients after each time step
!c                                'double_update' -> double update
!c                                 of activity coefficients during
!c                                 Newton iterations
!c
!c
!c local:    real*8:
!c           -------
!c           por_diff           = porosity difference between time 
!c                                steps
!c           r0                 = constant
!c           r1                 = constant
!c
!c           integer*4:
!c           ----------
!c           i1                 = counter
!c           ic                 = counter (components)
!c           ig                 = counter (gases)
!c           im                 = counter (minerals)
!c           im2                = counter (minerals)
!c           isb                = counter (sorbed species)
!c           ivol               = counter (control volumes)
!c
!c external: infcvs    = compute influence coefficients (variably
!c                       saturated flow)
!c           sorbspc   = compute concentrations of sorbed species
!c           tcorr     = temperature correction for debye-huckel,
!c                       equilibrium and rate constants
!c           totcona   = compute total sorbed component
!c                       concentrations (non-competitive sorption)
!c           totconc   = compute total aqueous component
!c                       concentrations based on concentrations
!c                       of free species and secondary aqueous
!c                       species
!c           totconcg  = compute total gaseous component
!c                       concentrations based on concentrations
!c                       of gases
!c           totsorb   = compute total sorbed component 
!c                       concentrations [moles/l bulk]
!c ----------------------------------------------------------------------

      subroutine restart_w

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use chem
      use phys
      use dens 
      use bbls
      use biol
      use file_unit, only : get_lun_min_used, get_lun_max_used,        &
                            get_file_opened
      use mip_bubble, only : mip_mt_enable, mip_sg, mip_g, mip_d,      &
                             mip_pw, mip_te, mip_tt, mip_pg, mip_pgt,  &
                             mip_cw, mip_ct
      use module_binary_mpiio, only :  binary_file_open,               &
                                       restart_binary_write_header,    &
                                       binary_write_data,              &
                                       binary_file_close,              &
                                       binary_subarray_init_restart

#ifdef USG
      use usg_mesh_data
#ifdef PETSC_HDF
      use hdf5
      use hdf5_usg
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
#endif

      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif

#ifdef USG
#ifdef PETSC_HDF
      integer :: hdf5_ierr                   ! HDF5 error code
      integer(HID_T) :: file_id              ! File identifier
      integer(HID_T) :: group_id             ! Group identifier
      integer(HID_T) :: plist_id             ! Property list identifier
#endif
#endif
      
      integer :: ibu1, ibu2, ivol, ic, ig, im, izn, ierr,              &
                 ilun, ilun_min, ilun_max
      
      character(256) :: str_restart_folder, str_path      
      character(5) :: strtmp,strdata
      integer :: islash, islash2
      real*8, allocatable :: realbuffer_irsrt(:)

      integer :: nvars_irsrt,ivars_irsrt,ivol_l
#ifdef PETSC
      integer(kind=MPI_OFFSET_KIND) :: offset_irsrt, offset_irsrt_temp

#else
      integer*8 :: offset_irsrt, offset_irsrt_temp

#endif

      real*8, parameter :: r0=0.0d0, r1=1.0d0, r2=2.0d0, r10=1.0d01,   &
                           r20=2.0d01
      
      external :: checkerr

!c increment restart counter

      rsrt_cnt=rsrt_cnt+1
      ibu1=backup_frequency
      ibu2=backup_frequency*2

!c  write time data to restart file

      islash = index(prefix(:l_prfx),achar(92), back=.true.)  !achar(92) = "\"
      islash2 = index(prefix(:l_prfx),achar(47), back=.true.) !achar(47) = "/"
      islash = max(islash,islash2)
      if(islash > 0) then
          str_restart_folder = prefix(:islash)
      else
          str_restart_folder = ""
      end if

      if (rsrt_cnt.eq.ibu1.or.rsrt_cnt.eq.ibu2) then

        !c flush buffer data back to file
        if (.not. b_disable_flush) then
          ilun_min = get_lun_min_used()
          ilun_max = get_lun_max_used()
          do ilun = ilun_min, ilun_max
            if (get_file_opened(ilun)) then
              call flush(ilun)
            end if
          end do
        end if

        if (rsrt_cnt.eq.ibu1) then
          !irsrt=198
          strtmp = '.tmp1'
        else if (rsrt_cnt.eq.ibu2) then
          !irsrt=199
          strtmp = '.tmp2'
        end if
      
#ifdef USG
#ifdef PETSC
        !c unstructured grid parallel binary output
        if (discretization_type > 0 .and. b_binary_restart_write) then
          b_distributed_restart_write = .false.
        end if
#endif
#endif

        if((.not.b_binary_restart_write) .or. b_distributed_restart_write) then
          str_path = trim(str_restart_folder)//'restart'//             &
                     trim(str_rank)//strtmp
        else
          str_path = trim(str_restart_folder)//'restart'//strtmp
        end if
      
        if (b_binary_restart_write) then
#ifdef USG
#ifdef PETSC_HDF
          if (discretization_type > 0) then

            !c initialize fortran interface
            call h5open_f(hdf5_ierr)

            !c setup file access property list with parallel I/O access
            call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, hdf5_ierr)
            call h5pset_fapl_mpio_f(plist_id, Petsc_Comm_World,        &
                                  MPI_INFO_NULL, hdf5_ierr)
            !c create the file collectively
            call h5fcreate_f(trim(str_path), H5F_ACC_TRUNC_F, file_id, &
                             hdf5_ierr, access_prp = plist_id)

            !c write attribute
            call hdf5_usg_write_attribute(file_id,.true.)

            !c create and open a group
            call h5gcreate_f(file_id,"results",group_id,hdf5_ierr,     &
                             OBJECT_NAMELEN_DEFAULT_F)

          else
#endif
#endif
            if (b_distributed_restart_write) then
              irsrt = lun_get()
              call binary_file_open(Petsc_Comm_Self,irsrt,             &
                           trim(str_path),.false.)
            else
              call binary_file_open(Petsc_Comm_World,irsrt,            &
                           trim(str_path),.true.)
            end if
            offset_irsrt = 0
#ifdef USG
#ifdef PETSC_HDF
          end if
#endif
#endif
        else
          irsrt = lun_get()
          open(irsrt,file=trim(str_path),status='unknown',             &
               form='formatted')
        end if
      
        if (b_binary_restart_write) then
          if (discretization_type == 0) then
            if (b_distributed_restart_write) then
              call restart_binary_write_header(Petsc_Comm_Self,irsrt,    &
                           offset_irsrt,.false.,time_io,delt_rt,delt_vs, &
                           time_bcvs,igstime,nprcs)
            else
              call restart_binary_write_header(Petsc_Comm_World,irsrt,   &
                           offset_irsrt,.true.,time_io,delt_rt,delt_vs,  &
                           time_bcvs,igstime,nprcs)
            end if
          end if
        else
          write(irsrt,'(4e22.14,I5.2,I8)', ADVANCE='no')                 &
                time_io,delt_rt,delt_vs,time_bcvs,igstime,nprcs
        end if

        if (b_binary_restart_write) then
          !calculate the number variables to write  
          nvars_irsrt = 0
          if (varsat_flow.and.transient_flow) then
            nvars_irsrt = nvars_irsrt + 3
          end if
        
          if (heat_transport) then
            nvars_irsrt = nvars_irsrt + 1
          end if
        
          if (density_dependence) then
            nvars_irsrt = nvars_irsrt + 2
          end if
        
          if (update_viscosity.or.update_viscosity_temp) then
            nvars_irsrt = nvars_irsrt + 1
          end if
        
          if (trap_bubbles) then
            nvars_irsrt = nvars_irsrt + 2  
          end if
        
          if (reactive_transport) then
            nvars_irsrt = nvars_irsrt + 2*n + 1
            if (noncompetitive_sorption) then
              nvars_irsrt = nvars_irsrt + n
            end if
            if (ng.gt.0) then
              nvars_irsrt = nvars_irsrt + n + ng
            end if
            if (nsb_ion.gt.0) then
              nvars_irsrt = nvars_irsrt + n
            end if
            if (nsb_surf.gt.0) then
              nvars_irsrt = nvars_irsrt + n
            end if
            if (nm>0.or.update_porosity_flow) then
              nvars_irsrt = nvars_irsrt + 2*nm + 2
            end if
            if (mip_mt_enable .and. ng.gt.0) then
              nvars_irsrt = nvars_irsrt + 3*ng + 7
            end if
          end if 
        
          if (b_distributed_restart_write) then
            allocate(realbuffer_irsrt(nvars_irsrt*nngl), stat = ierr)
            call checkerr(ierr,'realbuffer_irsrt',ilog)
            call memory_monitor(sizeof(realbuffer_irsrt),'realbuffer_irsrt',.true.)
          else
            if (discretization_type > 0) then
              allocate(realbuffer_irsrt(nvars_irsrt*nngl), stat = ierr)
              call checkerr(ierr,'realbuffer_irsrt',ilog)
              call memory_monitor(sizeof(realbuffer_irsrt),'realbuffer_irsrt',.true.)
            else
              allocate(realbuffer_irsrt(nvars_irsrt*nn), stat = ierr)
              call checkerr(ierr,'realbuffer_irsrt',ilog)
              call memory_monitor(sizeof(realbuffer_irsrt),'realbuffer_irsrt',.true.)
            end if
          end if

          realbuffer_irsrt = 0.0d0
        
          ivars_irsrt = 0
        
        end if

        ivol_l = 0
      
        do ivol=1,nngl
          
!c  skip ghost nodes
#ifdef PETSC
          if(b_binary_restart_write) then

            if ((.not.b_distributed_restart_write) .and.               &
                 node_idx_lg2l(ivol) < 0 .and.                         &
                 discretization_type == 0) then
              cycle
            end if 

            ivol_l = ivol_l + 1
            ivars_irsrt = (ivol_l-1)*nvars_irsrt
          end if
#endif

          if (.not. b_binary_restart_write) then 
            write(irsrt,'(/,a)') 'dummy'
            backspace(irsrt) 
          end if  

          izn = mpropvs(ivol)

!c  variably saturated flow
          if (varsat_flow.and.transient_flow) then

            if (b_binary_restart_write) then              
              realbuffer_irsrt(ivars_irsrt+1:ivars_irsrt+3) =          &
                         (/uvsold(ivol),saold(ivol),sgold(ivol)/)
              ivars_irsrt = ivars_irsrt + 3
            else
              write(irsrt,'(3e22.14)', ADVANCE='no') uvsold(ivol),     &
                    saold(ivol),sgold(ivol)
            end if

          end if
!cprovi------------------------------------------------------------
!cprovi If energy balance is solved, then write the temperatures
!cprovi------------------------------------------------------------          
          if (heat_transport) then
            if (b_binary_restart_write) then
              realbuffer_irsrt(ivars_irsrt+1) = tempold(ivol)
              ivars_irsrt = ivars_irsrt + 1
            else
              write(irsrt,'(1e22.14)', ADVANCE='no') tempold(ivol)
            end if
          end if
!cprovi------------------------------------------------------------
!cprovi It was added fir the driven density version 
!cprovi------------------------------------------------------------          
          if (density_dependence) then 
            if (b_binary_restart_write) then
              realbuffer_irsrt(ivars_irsrt+1:ivars_irsrt+2) =          &
                         (/densold(ivol),tds_old(ivol)/)
              ivars_irsrt = ivars_irsrt + 2
            else
              write(irsrt,'(2e22.14)', ADVANCE='no') densold(ivol),    &
                                                     tds_old(ivol)
            end if
              
          end if
!cprovi------------------------------------------------------------
!cprovi If viscosity is updated 
!cprovi------------------------------------------------------------    
          if (update_viscosity.or.update_viscosity_temp) then
            if (b_binary_restart_write) then
              realbuffer_irsrt(ivars_irsrt+1) = viscosity(ivol)
              ivars_irsrt = ivars_irsrt + 1
            else
              write(irsrt,'(1e22.14)', ADVANCE='no') viscosity(ivol)
            end if
          end if
        
!cprovi------------------------------------------------------------
!cprovi If gas bubbles and trap bubbles
!cprovi------------------------------------------------------------ 
          if (trap_bubbles) then
            if (b_binary_restart_write) then              
              realbuffer_irsrt(ivars_irsrt+1) = sgt_old(ivol)
              if(big_bub_old(ivol)) then
                realbuffer_irsrt(ivars_irsrt+2) = 1.0d0
              else
                realbuffer_irsrt(ivars_irsrt+2) = -1.0d0  
              end if
              ivars_irsrt = ivars_irsrt + 2
            else
              if(big_bub_old(ivol)) then
                write(irsrt,'(2e22.14)', ADVANCE='no') sgt_old(ivol),1.0d0
              else
                write(irsrt,'(2e22.14)', ADVANCE='no') sgt_old(ivol),-1.0d0  
              end if
            end if 
          end if
!cprovi------------------------------------------------------------    
!cprovi------------------------------------------------------------    
!cprovi------------------------------------------------------------    
!c  reactive transport 

          if (reactive_transport) then

            if (b_binary_restart_write) then 
              realbuffer_irsrt(ivars_irsrt+1) = sionold(ivol)
              ivars_irsrt = ivars_irsrt + 1
              do ic = 1,n
                realbuffer_irsrt(ivars_irsrt+2*ic-1) = c(ic,ivol)
                realbuffer_irsrt(ivars_irsrt+2*ic) = totcold(ic,ivol)
              end do
              ivars_irsrt = ivars_irsrt + 2*n
            else
              write(irsrt,'(1e22.14)', ADVANCE='no') sionold(ivol)
              do ic = 1,n
                write(irsrt,'(2e22.14)', ADVANCE='no') c(ic,ivol),     &
                                                       totcold(ic,ivol)
              end do
            end if

            if (noncompetitive_sorption) then
              if (b_binary_restart_write) then 
                do ic = 1,n
                  realbuffer_irsrt(ivars_irsrt+ic) = totaold(ic,ivol)
                end do
                ivars_irsrt = ivars_irsrt + n
              else
                do ic = 1,n
                  write(irsrt,'(1e22.14)', ADVANCE='no')totaold(ic,ivol)
                end do
              end if
            end if
          

!c  gaseous phase
!c  -------------

            if (ng.gt.0) then
            
              if (b_binary_restart_write) then 
                do ic = 1,n
                  realbuffer_irsrt(ivars_irsrt+ic) = totgold(ic,ivol)
                end do
                ivars_irsrt = ivars_irsrt + n
              else
                do ic = 1,n
                  write(irsrt,'(1e22.14)', ADVANCE='no')totgold(ic,ivol)
                end do
              end if

!c  reassign gas concentrations for next time level
              if (b_binary_restart_write) then
                do ig = 1,ng
                  realbuffer_irsrt(ivars_irsrt+ig) = gold(ig,ivol)
                end do
                ivars_irsrt = ivars_irsrt + ng
              else                
                do ig = 1,ng
                  write(irsrt,'(1e22.14)', ADVANCE='no')gold(ig,ivol)
                end do
              end if

            end if

!c  sorbed phase
!c  ------------
!c  redox equilibrium reactions

            if (nsb_ion.gt.0) then 
              if (b_binary_restart_write) then
                do ic = 1,n
                  realbuffer_irsrt(ivars_irsrt+ic) = totsold_ion(ic,ivol)
                end do
                ivars_irsrt = ivars_irsrt + n
              else
                do ic = 1,n
                  write(irsrt,'(1e22.14)', ADVANCE='no')               &
                        totsold_ion(ic,ivol)
                end do
              end if
            end if 
          
            if (nsb_surf.gt.0) then 
              if (b_binary_restart_write) then
                do ic = 1,n
                  realbuffer_irsrt(ivars_irsrt+ic) = totsold_surf(ic,ivol)
                end do
                ivars_irsrt = ivars_irsrt + n
              else
                do ic = 1,n
                  write(irsrt,'(1e22.14)',ADVANCE='no')                &
                        totsold_surf(ic,ivol)
                end do
              end if
            end if 

!c  mineral phase and porosity-permeability changes
!c  -----------------------------------------------
!c  reassign mineral concentrations for next time level and update
!c  porosity and permeability, if required

            if (nm>0.or.update_porosity_flow) then
              if (b_binary_restart_write) then
                do im=1,nm
                  realbuffer_irsrt(ivars_irsrt+2*im-1) = cmold(im,ivol)
                  realbuffer_irsrt(ivars_irsrt+2*im) = phiold(im,ivol)                              
                end do 
                ivars_irsrt = ivars_irsrt + 2*nm
                realbuffer_irsrt(ivars_irsrt+1) = porold(ivol)
                realbuffer_irsrt(ivars_irsrt+2) = perm_fac(ivol)
                ivars_irsrt = ivars_irsrt + 2
              else
                do im=1,nm
                  write(irsrt,'(2e22.14)', ADVANCE='no') cmold(im,ivol), &
                                                         phiold(im,ivol)                                      
                end do                                                   
                write(irsrt,'(2e22.14)', ADVANCE='no') porold(ivol),     &
                                                       perm_fac(ivol)
              end if

            end if

            if (mip_mt_enable) then
              if (b_binary_restart_write) then
                realbuffer_irsrt(ivars_irsrt+1) = mip_sg(ivol)
                realbuffer_irsrt(ivars_irsrt+2) = mip_g(ivol)
                realbuffer_irsrt(ivars_irsrt+3) = mip_d(ivol)
                realbuffer_irsrt(ivars_irsrt+4) = mip_pw(ivol)
                realbuffer_irsrt(ivars_irsrt+5) = mip_te(ivol)
                realbuffer_irsrt(ivars_irsrt+6) = mip_tt(ivol)
                realbuffer_irsrt(ivars_irsrt+7) = mip_pgt(ivol)
                realbuffer_irsrt(ivars_irsrt+8:ivars_irsrt+7+ng) =       &
                           mip_pg(:,ivol)  
                realbuffer_irsrt(ivars_irsrt+8+ng:ivars_irsrt+7+2*ng) =  &
                           mip_cw(:,ivol)               
                realbuffer_irsrt(ivars_irsrt+8+2*ng:ivars_irsrt+7+3*ng) =&
                           mip_ct(:,ivol) 
                ivars_irsrt = ivars_irsrt + 7 + 3*ng              
                
              else
                write(irsrt,'(e22.14,2i4,7e22.14)', ADVANCE='no')        &
                      mip_sg(ivol), mip_g(ivol), mip_d(ivol),            &
                      mip_pw(ivol), mip_te(ivol), mip_tt(ivol),          &
                      mip_pgt(ivol)
                do ig = 1, ng
                  write(irsrt,'(1e22.14)',ADVANCE='no')  mip_pg(ig,ivol)
                end do
                do ig = 1, ng
                  write(irsrt,'(1e22.14)',ADVANCE='no')  mip_cw(ig,ivol)
                end do
                do ig = 1, ng
                  write(irsrt,'(1e22.14)',ADVANCE='no')  mip_ct(ig,ivol)
                end do
              end if
            end if

          end if             !reactive_transport

        end do   !ivol
      
        if(b_binary_restart_write) then
#ifdef USG
#ifdef PETSC_HDF
          if (discretization_type > 0) then
            !c write each variable in the restart file to a single dataset
            !c this could support when different number of processors are used
            !c in restarting
            allocate(realbuffer(nngl), stat = ierr)
            call checkerr(ierr,'realbuffer',ilog)
            realbuffer = 0.0d0
            call memory_monitor(sizeof(realbuffer),'realbuffer',.true.)

            do ivars_irsrt = 1, nvars_irsrt
              write(strdata,'(i0)') ivars_irsrt
              do ivol=1,nngl
                realbuffer(ivol) = realbuffer_irsrt(ivars_irsrt+         &
                                                   (ivol-1)*nvars_irsrt)
              end do
              call hdf5_usg_write_group_data_1d(group_id,trim(strdata),  &
                      num_nodes_loc,num_nodes_gbl,offset_nodes,realbuffer) 
            end do

            call memory_monitor(-sizeof(realbuffer),'realbuffer',.true.)
            deallocate(realbuffer) 

            !c alternative function, restart reading part should be changed
            !c write local owned dataset only
            !call hdf5_usg_write_group_data_vec(group_id,"restart",       &
            !          nvars_irsrt,num_nodes_loc,num_nodes_gbl,           &
            !          offset_nodes,realbuffer_irsrt)

            !c write local owned dataset with ghost nodes
            !call hdf5_usg_write_group_data_vec(group_id,"restart",       &
            !          nvars_irsrt,num_nodes,num_nodes_with_ghost_gbl,    &
            !          offset_nodes_with_ghost,realbuffer_irsrt)
          else
#endif
#endif
            if (b_distributed_restart_write) then
              call binary_write_data(irsrt,ivars_irsrt,realbuffer_irsrt, &
                                     offset_irsrt,.false.)
            else
              call binary_subarray_init_restart(nvars_irsrt,             &
                          b_mpiarray_irsrt_init,                         &
                          mpiarray_filetype_irsrt,                       &
                          mpiarray_sizes_gbl_irsrt,                      &
                          mpiarray_sizes_sub_irsrt,                      &
                          mpiarray_starts_sub_irsrt)

              call binary_write_data(irsrt,ivars_irsrt,realbuffer_irsrt, &
                                     offset_irsrt,mpiarray_filetype_irsrt)
            end if
#ifdef USG
#ifdef PETSC_HDF
          end if
#endif
#endif
        end if
      
        if (b_binary_restart_write) then
          call memory_monitor(-sizeof(realbuffer_irsrt),'realbuffer_irsrt',.true.)
          deallocate(realbuffer_irsrt)
        end if

        if (rsrt_cnt.eq.ibu2) then
          rsrt_cnt=0
        end if

        if(b_binary_restart_write) then
#ifdef USG
#ifdef PETSC_HDF
          if (discretization_type > 0) then
            !c close group
            call h5gclose_f(group_id,hdf5_ierr)

            !c close file
            call h5pclose_f(plist_id, hdf5_ierr)
            call h5fclose_f(file_id, hdf5_ierr)

            !c close FORTRAN interface
            call h5close_f(hdf5_ierr)
          else
#endif
#endif
            call binary_file_close(irsrt,.not.b_distributed_restart_write)
            if (b_distributed_restart_write) then
              call lun_free(irsrt)
            end if
#ifdef USG
#ifdef PETSC_HDF
          end if
#endif
#endif

        else
          close(irsrt)
          call lun_free(irsrt)
        end if

!cdsu appended restart data for specific cases
!cdsu only the master processor needs to write the appended restart data.
        if (rank == 0) then
          str_path = trim(str_restart_folder)//'restart.append'//strtmp
        
          irsrt = lun_get()        
          open(irsrt,file=trim(str_path),status='unknown',form='formatted')

          if ((passive_uptake .or. root_uptake) .and. nrcm_tz > 0) then
            write(irsrt,ascii_fmt) totrcm_c(:)
            write(irsrt,ascii_fmt) totrcm_m(:)
            write(irsrt,ascii_fmt) totrcm_c_tz(:)
            write(irsrt,ascii_fmt) totrcm_m_tz(:)
            write(irsrt,ascii_fmt) totrcm_c_nz(:,:)
            write(irsrt,ascii_fmt) totrcm_c_ave1st(:,:)
          end if 

          close(irsrt)
          call lun_free(irsrt)
        end if
!cdsu end of appended restart data
 
      end if

      return
      end
