!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 878 $
!> $Author: dsu $
!> $Date: 2024-02-14 20:08:49 -0800 (Wed, 14 Feb 2024) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/initpppm.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine initpppm
!c -------------------
!c
!c physical parameters for porous medium
!c
!c written by:      Uli Mayer - May 13, 96
!c
!c last modified:   Uli Mayer - November 25, 96
!c                  Sergi Molins - May 15, 2006
!c                                 read oil saturation from file
!c                                 account for decrease in porosity 
!c                                 according to oil sat
!c
!c
!c                  Danyang Su - Sept. 10, 2018
!c                  Unstructured grid and HPC capabilities
!c
!c            Celine Blitz Frayret (CBF) for Frederic Gerard, December 14, 2018 
!c            Calculate and store zone volume in array
!c
!c
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   -
!c
!c common: 
!c parm.f:   -
!c
!c gen.f:    real*8:
!c           -------
!c           pornew(nn)         = porosity                            * +
!c           por_init(nn)       = initial porosity                    * +
!c           xg(nn)             = spatial coordinates in x-direction  + -
!c           yg(nn)             = spatial coordinates in y-direction  + -
!c           zg(nn)             = spatial coordinates in z-direction  + -
!c
!c           integer*4:
!c           ----------
!c           icnv               = unit number, data conversion and    + -
!c                                             temporary storage
!c           idat               = unit number, run specific input     + -
!c                                             file
!c           igen               = unit number, generic output file    + -
!c           ilog               = unit number, logbook                + -
!c           itmp               = unit number, temporary storage      + -
!c           l_zone_name        = length of zone name                 * +
!c           mpropvs(nn)        = pointer array for allocation of     * +
!c                                material properties
!c           nn                 = number of control volumes           + -
!c
!c           logical:
!c           --------
!c           reactive_transport = .true.  -> perform reactive         + -
!c                                           transport simulation
!c           varsat_flow        = .true.  -> perform flow simulation  + -
!c
!c           character:
!c           ----------
!c           section_header     = section header                      * +
!c           zone_name          = name of zone                        * +
!c
!c phys.f:   real*8:
!c           -------
!c           porz(nzn)          = porosity                            * +
!c           pvol(nzn)          = volume of property zone              * + 
!c                  (used for evaporation)  CBF
!c
!c           integer*4:
!c           ----------
!c           mprop_name(nzn)    = name of material property zone      * +
!c           nzn                = number of material property zones   * +
!c
!c local:    real*8:
!c           -------
!c           r1                 = constant
!c           tiny               = small increment
!c           xpmin              = min. x-coordinate of property zone
!c           xpmax              = max. x-coordinate of property zone
!c           ypmin              = min. y-coordinate of property zone
!c           ypmax              = max. y-coordinate of property zone
!c           zpmin              = min. z-coordinate of property zone
!c           zpmax              = max. z-coordinate of property zone
!c
!c           integer*4:
!c           ----------
!c           izn                = counter (material property zones)
!c           ivol               = counter (control volumes)
!c           l_string           = length of text string
!c           nntemp             = counter (control volumes
!c                                possessing material properties)
!c
!c           logical:
!c           --------
!c           found_section      = .true.  -> section header was
!c                                           found in input file
!c           found_subsection   = .true.  -> subsection header was
!c                                           found in input file
!c
!c           character:
!c           ----------
!c           subsection         = name of subsection in input file
!c
!c external: findstrg  = find text string in file
!c           findzone  = find zone in input section
!c           mem_mat   = allocate memory for physical parameters 
!c                       in material property zones
!c           readbloc  = read section of input file and write to
!c                       temporary file
!c           readzone  = read zone in section of input file and 
!c                       write to temporary file
!c ----------------------------------------------------------------------
 
      subroutine initpppm

#ifdef PETSC
#include <petscversion.h>
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 8)
#include <petsc/finclude/petscsys.h>
      use petscsys
#endif
#endif

      use parm
      use gen
      use phys
      use dens, only : density_dependence
      use file_unit, only : lun_get, lun_free
      use file_utility, only : read_vtk_data_from_file
#ifdef OPENMP
      use omp_lib 
#endif
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
#ifdef USG
      use geometry
      use usg_mesh_data, only : nodes, cell_type, CellCenter,          &
                                layer_nodes_top, node_to_layer_node,   &
                                cell_projection, num_cells,            &
                                is_boundary_node, is_boundary_cell

      use read_zone_usg, only : read_zone_usg_input, type_extent_zone, &
                                type_extent_zone_box,                  &
                                type_flux_direction, flux_direction
#endif
      implicit none
#ifdef PETSC
#if (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 6 && PETSC_VERSION_MINOR < 8)
#include <petsc/finclude/petscsys.h>
#elif (PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR < 6)
#include <finclude/petscsys.h>
#endif
#endif
      
      real*8 :: tauloc, taugasloc, rdummy, xpmin, xpmax, ypmin, ypmax, &
                zpmin, zpmax, apertureLoc
      
      real*8 :: porc_tot, porc_tot_gbl, por_init_ave_gbl, porc_k1, porc_ecg,   &
                depth, alpha, lamda, kbks_1, kfks_1

      integer :: i, ivol, ivolgbl, icell, izn, iaca, l_string, nntemp,         &
                 igso, nwarns, nerrs, ierrcd, fracFlowTypeLoc

#ifdef PETSC
      integer :: nntemp_gbl, nwarns_gbl, nerrs_gbl
      PetscErrorCode :: ierrcode
#endif

#ifdef USG
      logical :: bfound
      character*72 :: subcommand
      character*2048 :: strbuffer2048
#endif

      external findstrg, findzone, mem_mat, readbloc, readzone
#ifdef USG
      external outputaca_usg
#endif
      
      logical :: found_section, found_subsection
      logical :: aca_field, fracture_aperture_field, assigned_aperture,&
                 fracture_flow_type_field, assigned_fracture_flow_type
      type(point) :: aca_zone                 !unit: radian
      character*72 :: subsection
      character*1 :: cdummy
      character*256 :: strbuffer
      character*12 :: strFracFlowTypeLoc
      real(8) :: marchieloc
      
      integer :: iskip, nskip

      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0, tiny = 1.0d-6,      &
                           r180 = 180.0d0, pi=3.14159265359d0
    
!c  set default

      ierrcd = 0
      porosity_field = .false.
      tortuosity_field = .false.
      tortuosity_field_gas = .false.
      assigned_aperture = .false.
      fracture_aperture_field = .false.  
      assigned_fracture_flow_type = .false.    
      fracture_flow_type_field = .false.
      
      aca_field = .false.
      tauloc=r1
      taugasloc=r1
      marchieloc = r1
    
      if (varsat_flow.or.reactive_transport) then
    
!c  initialize number of control volumes with assigned material properties

        nntemp = 0

!c  read physical parameters for porous medium and write to temporary file
   
        section_header = 'physical parameters - porous medium'
        call readbloc (idat,itmp,section_header,found_section,.true.)
 
!c  define length of section header

        l_string = index(section_header,'  ')-1
        if (l_string.eq.-1.or.l_string.gt.72) then
           l_string=72
        end if

!c  terminate program if section header not found
        if (.not.found_section) then
          if (rank == 0) then  
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "',section_header(:l_string),    &
     &                    '" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop
        end if

!c  write physical parameters for porous medium to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(/72a)')('-',i=1,72)
          write(igen,'(a)') section_header(:l_string)
          write(igen,'(72a/)')('-',i=1,72)
        end if

!c  read number of material property zones

        read(itmp,*,err=991,end=991) nzn            !number of zones

!c  write number of material property zones to generic output file
        if (b_enable_output .and. b_enable_output_gen) then
          write(igen,'(a,i10)')                                     &
     &    'number of material property zones               = ',nzn
        end if

!c  apply material property rotation for full tensor representation
        useAnisoCorr = .false.
        subsection = 'anisotropic correction'
        call findstrg(subsection,itmp,found_subsection)
        if (found_subsection) then
          useAnisoCorr = .true.
        end if
    
!c  allocate memory for physical parameters in material property
!c  zones
 
        call mem_mat

        property_iflag = 0

#ifdef USG
        if (discretization_type > 0) then
          property_cell_iflag = 0
        end if
#endif

        do izn = 1,nzn

!c  read porosity field from file
          subsection = 'read porosity field from file'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            ipor = lun_get()

            open(ipor,file=prefix(:l_prfx)//'.por',status='unknown',  &
                 form='formatted')
            
            porosity_field = .true.
    
!c  read porosities

            read(ipor,*,err=992,end=992) cdummy
            read(ipor,*,err=992,end=992) cdummy
            read(ipor,*,err=992,end=992) cdummy

#ifdef USG
            if (discretization_type > 0) then
              do ivolgbl = 1,nngbl
#ifdef PETSC
                if (ibits(usg_mesh_ordering,0,2) == 3) then
                  ivol = node_idx_g2lg(node_idx_g2g_invord(ivolgbl))
                else
                  ivol = node_idx_g2lg(ivolgbl)
                end if
#else
                if (ibits(usg_mesh_ordering,0,2) == 3) then
                  ivol = node_idx_g2g_invord(ivolgbl)
                else
                  ivol = ivolgbl
                end if
#endif
                if (ivol > 0) then
                  read(ipor,*,err=992,end=992) rdummy, rdummy,rdummy,  &
                                               por_init(ivol)
                else
                  read(ipor,*,err=992,end=992) rdummy
                end if
              end do
            end if
#endif
            if (discretization_type == 0) then
              nskip = 0
              do ivol = 1,nngl
#ifdef PETSC
                do iskip = 1, node_idx_lg2g(ivol) - nskip -1
                    read(ipor,*,end=992,err=992) rdummy
                end do
                nskip = node_idx_lg2g(ivol)
#endif
                read(ipor,*,err=992,end=992) rdummy, rdummy,rdummy,    &
                                             por_init(ivol)
              end do
            end if

            close(ipor)
            call lun_free(ipor)
                
          end if

#ifdef USG
!c  read porosity field from file
          subsection = 'read porosity field from vtk file'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            ipor = lun_get()
            if ((read_spatial_master_proc .and. rank == 0) .or.        &
                .not.read_spatial_master_proc) then
              open(ipor,file=prefix(:l_prfx)//'.por.vtk',              &
                   status='unknown',form='formatted')
            else
              call lun_free(ipor)
              ipor = 0
            end if

            porosity_field = .true.

!c  read porosities
            call read_vtk_data_from_file(ipor,'porosity',bfound,por_init)
            if (bfound) then
              if (rank == 0 .and. b_enable_output) then
                write(*,'(a)') 'read porosity from vtk file: done'
                write(ilog,'(a)') 'read porosity from vtk file: done'
              end if
            end if

            if (ipor > 0) then
              close(ipor)
              call lun_free(ipor)
            end if

          end if
#endif
        
!c  read tortuosity field from file

          subsection = 'read tortuosity field from file'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

             itor = lun_get()

             open(itor,file=prefix(:l_prfx)//'.tor',status='unknown', &
                  form='formatted')
            
            tortuosity_field = .true.
    
!c  read tortuosities

            read(itor,*,err=993,end=993) cdummy
            read(itor,*,err=993,end=993) cdummy
            read(itor,*,err=993,end=993) cdummy
#ifdef USG
            if (discretization_type > 0) then
              do ivolgbl = 1,nngbl
#ifdef PETSC
                if (ibits(usg_mesh_ordering,0,2) == 3) then
                  ivol = node_idx_g2lg(node_idx_g2g_invord(ivolgbl))
                else
                  ivol = node_idx_g2lg(ivolgbl)
                end if
#else
                if (ibits(usg_mesh_ordering,0,2) == 3) then
                  ivol = node_idx_g2g_invord(ivolgbl)
                else
                  ivol = ivolgbl
                end if
#endif
                if (ivol > 0) then
                  read(itor,*,err=993,end=993) rdummy, rdummy,rdummy,  &
                                               tau(ivol)
                else
                  read(itor,*,err=993,end=993) rdummy
                end if
              end do
            end if
#endif
            if (discretization_type == 0) then
              nskip = 0
              do ivol = 1,nngl
#ifdef PETSC
                do iskip = 1, node_idx_lg2g(ivol) - nskip -1
                  read(itor,*,end=993,err=993) rdummy
                end do
                nskip = node_idx_lg2g(ivol)
#endif
                read(itor,*,err=993,end=993) rdummy, rdummy,rdummy,    &
                                             tau(ivol)
              end do
            end if

            close(itor)
            call lun_free(itor)
                
          end if

#ifdef USG
!c  read tortuosity field from vtk file

          subsection = 'read tortuosity field from vtk file'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            itor = lun_get()
            if ((read_spatial_master_proc .and. rank == 0) .or.        &
                .not.read_spatial_master_proc) then
              open(itor,file=prefix(:l_prfx)//'.tor.vtk',              &
                   status='unknown',form='formatted')
            else
              call lun_free(itor)
              itor = 0
            end if

            tortuosity_field = .true.

!c  read tortuosities
            call read_vtk_data_from_file(itor,'tau',bfound,tau)
            if (bfound) then
              if (rank == 0 .and. b_enable_output) then
                write(*,'(a)') 'read tortuosity from vtk file: done'
                write(ilog,'(a)') 'read tortuosity from vtk file: done'
              end if
            end if

            if (itor > 0) then
              close(itor)
              call lun_free(itor)
            end if

          end if
#endif

!c  read anisotropic correction angles (alpha(Z-axis), beta(Y-axis), gamma(X-axis)) from file

          subsection = 'read anisotropic correction angles from file'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            iaca = lun_get()

            open(iaca,file=prefix(:l_prfx)//'.aca',status='unknown',   &
                 form='formatted')
            
            aca_field = .true.
    
!c  read tortuosities

            read(iaca,*,err=993,end=993) cdummy
            read(iaca,*,err=993,end=993) cdummy
            read(iaca,*,err=993,end=993) cdummy
#ifdef USG
            if (discretization_type > 0) then
              do ivolgbl = 1,nngbl
#ifdef PETSC
                if (ibits(usg_mesh_ordering,0,2) == 3) then
                  ivol = node_idx_g2lg(node_idx_g2g_invord(ivolgbl))
                else
                  ivol = node_idx_g2lg(ivolgbl)
                end if
#else
                if (ibits(usg_mesh_ordering,0,2) == 3) then
                  ivol = node_idx_g2g_invord(ivolgbl)
                else
                  ivol = ivolgbl
                end if
#endif
                if (ivol > 0) then
                  read(iaca,*,err=993,end=993) rdummy,rdummy,rdummy,   &
                       aca_vol(ivol)%z,aca_vol(ivol)%y,aca_vol(ivol)%x

                  !c convert to radian
                  aca_vol(ivol)%x = aca_vol(ivol)%x*(pi/r180)
                  aca_vol(ivol)%y = aca_vol(ivol)%y*(pi/r180)
                  aca_vol(ivol)%z = aca_vol(ivol)%z*(pi/r180)
                else
                  read(iaca,*,err=993,end=993) rdummy
                end if
              end do
            end if
#endif
            if (discretization_type == 0) then
              nskip = 0
              do ivol = 1,nngl
#ifdef PETSC
                do iskip = 1, node_idx_lg2g(ivol) - nskip -1
                  read(iaca,*,end=993,err=993) rdummy
                end do
                nskip = node_idx_lg2g(ivol)
#endif
                read(iaca,*,err=993,end=993) rdummy,rdummy,rdummy,     &
                     aca_vol(ivol)%z,aca_vol(ivol)%y,aca_vol(ivol)%x
                !c convert to radian
                aca_vol(ivol)%x = aca_vol(ivol)%x*(pi/r180)
                aca_vol(ivol)%y = aca_vol(ivol)%y*(pi/r180)
                aca_vol(ivol)%z = aca_vol(ivol)%z*(pi/r180)
              end do
            end if

            close(iaca)
            call lun_free(iaca)
                
          end if

#ifdef USG
!c  read anisotropic correction angles from vtk file

          subsection = 'read anisotropic correction angles from vtk file'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            iaca = lun_get()
            if ((read_spatial_master_proc .and. rank == 0) .or.        &
                .not.read_spatial_master_proc) then
              open(iaca,file=prefix(:l_prfx)//'.aca.vtk',              &
                   status='unknown',form='formatted')
            else
              call lun_free(iaca)
              iaca = 0
            end if

            aca_field = .true.

!c  read anisotropic correction angles (alpha(Z-axis), beta(Y-axis), gamma(X-axis)) from vtk file
            call read_vtk_data_from_file(iaca,'aca',bfound,aca_vol,.true.)
            if (bfound) then
              !c convert to radian
              do ivol = 1, nngl
                aca_vol(ivol)%x = aca_vol(ivol)%x*(pi/r180)
                aca_vol(ivol)%y = aca_vol(ivol)%y*(pi/r180)
                aca_vol(ivol)%z = aca_vol(ivol)%z*(pi/r180)
              end do

              if (rank == 0 .and. b_enable_output) then
                write(*,'(a)') 'read anisotropic correction angles from vtk file: done'
                write(ilog,'(a)') 'read anisotropic correction angles from vtk file: done'
              end if
            end if

            if (iaca > 0) then
              close(iaca)
              call lun_free(iaca)
            end if

          end if
#endif

!c  read gas tortuosity field from file

          subsection = 'read gas tortuosity field from file'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

             itor = lun_get()

             open(itor,file=prefix(:l_prfx)//'.torgas',status='unknown',     &
     &            form='formatted')

            tortuosity_field_gas = .true.

!c  read tortuosities

            read(itor,*,err=993,end=993) cdummy
            read(itor,*,err=993,end=993) cdummy
            read(itor,*,err=993,end=993) cdummy
#ifdef USG
            if (discretization_type > 0) then
              do ivolgbl = 1,nngbl
#ifdef PETSC
                if (ibits(usg_mesh_ordering,0,2) == 3) then
                  ivol = node_idx_g2lg(node_idx_g2g_invord(ivolgbl))
                else
                  ivol = node_idx_g2lg(ivolgbl)
                end if
#else
                if (ibits(usg_mesh_ordering,0,2) == 3) then
                  ivol = node_idx_g2g_invord(ivolgbl)
                else
                  ivol = ivolgbl
                end if
#endif
                if (ivol > 0) then
                  read(itor,*,err=993,end=993) rdummy, rdummy,rdummy,  &
                                               taugas(ivol)
                else
                  read(itor,*,err=993,end=993) rdummy
                end if
              end do
            end if
#endif
            if (discretization_type == 0) then
              nskip = 0
              do ivol = 1,nngl
#ifdef PETSC
                do iskip = 1, node_idx_lg2g(ivol) - nskip -1
                  read(itor,*,end=993,err=993) rdummy
                end do
                nskip = node_idx_lg2g(ivol)
#endif
                read(itor,*,err=993,end=993) rdummy, rdummy,rdummy,    &
                                             taugas(ivol)
              end do
            end if

            close(itor)
            call lun_free(itor)

          end if

#ifdef USG
!c  read gas tortuosity field from vtk file

          subsection = 'read gas tortuosity field from vtk file'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            itor = lun_get()
            if ((read_spatial_master_proc .and. rank == 0) .or.        &
                .not.read_spatial_master_proc) then
              open(itor,file=prefix(:l_prfx)//'.torgas.vtk',           &
                   status='unknown',form='formatted')
            else
              call lun_free(itor)
              itor = 0
            end if

            tortuosity_field_gas = .true.

!c  read tortuosities
            call read_vtk_data_from_file(itor,'tau',bfound,taugas)
            if (bfound) then
              if (rank == 0 .and. b_enable_output) then
                write(*,'(a)') 'read gas tortuosity from vtk file: done'
                write(ilog,'(a)') 'read gas tortuosity from vtk file: done'
              end if
            end if

            if (itor > 0) then
              close(itor)
              call lun_free(itor)
            end if

          end if
#endif

!c  read fracture parameters 
          subsection = 'read fracture parameters from file'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then

            assigned_aperture = .true.
            assigned_fracture_flow_type = .true.

            ifrac = lun_get()

            open(ifrac,file=prefix(:l_prfx)//'.frac',status='unknown',  &
                 form='formatted')

            fracture_aperture_field = .true.
            fracture_flow_type_field = .true.

!c  read fracture aperture

            read(ifrac,*,err=993,end=993) cdummy
            read(ifrac,*,err=993,end=993) cdummy
            read(ifrac,*,err=993,end=993) cdummy
#ifdef USG
            if (discretization_type > 0) then
              do ivolgbl = 1,nngbl
#ifdef PETSC
                if (ibits(usg_mesh_ordering,0,2) == 3) then
                  ivol = node_idx_g2lg(node_idx_g2g_invord(ivolgbl))
                else
                  ivol = node_idx_g2lg(ivolgbl)
                end if
#else
                if (ibits(usg_mesh_ordering,0,2) == 3) then
                  ivol = node_idx_g2g_invord(ivolgbl)
                else
                  ivol = ivolgbl
                end if
#endif
                if (ivol > 0) then
                  read(ifrac,*,err=993,end=993) rdummy, rdummy,rdummy,  &
                      aperture(ivol), fractureFlowType(ivol)
                else
                  read(ifrac,*,err=993,end=993) rdummy
                end if
              end do
            end if
#endif
            if (discretization_type == 0) then
              nskip = 0
              do ivol = 1,nngl
#ifdef PETSC
                do iskip = 1, node_idx_lg2g(ivol) - nskip -1
                  read(ifrac,*,end=993,err=993) rdummy
                end do
                nskip = node_idx_lg2g(ivol)
#endif
                read(ifrac,*,err=993,end=993) rdummy, rdummy,rdummy,    &
                    aperture(ivol), fractureFlowType(ivol)
              end do
            end if

            close(ifrac)
            call lun_free(ifrac)

          end if
#ifdef USG
!c  read fracture parameters from vtk file

          subsection = 'read fracture parameters from vtk file'

          call findstrg(subsection,itmp,found_subsection)

          if (found_subsection) then
            ifrac = lun_get()

            if ((read_spatial_master_proc .and. rank == 0) .or.        &
                .not.read_spatial_master_proc) then
              open(ifrac,file=prefix(:l_prfx)//'.frac.vtk',              &
                   status='unknown',form='formatted')
            else
              call lun_free(ifrac)
              ifrac = 0
            end if

!c  read fracture aperture
            call read_vtk_data_from_file(ifrac,'aperture',bfound,aperture)
            if (bfound) then
              assigned_aperture = .true.
              fracture_aperture_field = .true.
              if (rank == 0 .and. b_enable_output) then
                write(*,'(a)') 'read fracture aperture from vtk file: done'
                write(ilog,'(a)') 'read fracture aperture from vtk file: done'
              end if              
            end if

!c  read fracture flow type
            call read_vtk_data_from_file(ifrac,'flow_type',bfound,fractureFlowType)
            if (bfound) then
              assigned_fracture_flow_type = .true.
              fracture_flow_type_field = .true.
              if (rank == 0 .and. b_enable_output) then
                write(*,'(a)') 'read fracture flow type from vtk file: done'
                write(ilog,'(a)') 'read fracture flow type from vtk file: done'
              end if
            end if

            if (ifrac > 0) then
              close(ifrac)
              call lun_free(ifrac)
            end if

          end if
#endif

!c  read physical parameters for porous medium

          subsection = 'number and name of zone'

          call findzone(subsection,itmp,found_subsection,izn,         &
     &                  zone_name)

          if (found_subsection) then

            call readzone(itmp,icnv,ilog,zone_name,found_subsection)

          else
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error in input file'
              write(ilog,*) 'section "',section_header(:l_string),'"'
              write(ilog,*) 'zone number "',izn, '" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop

          end if

          mprop_name(izn) = zone_name

!c  define length of zone name

          l_zone_name = index(zone_name,'  ')-1
          if (l_zone_name.lt.0.or.l_zone_name.gt.72) then
            l_zone_name = 72
          end if

!c  read porosity from input file

        if (.not.porosity_field) then        
          read(icnv,*,err=994,end=994) porz(izn)
        else
          !c assign an average value to porz based on porosity distribution
          porc_tot = 0.0d0
          do ivol = 1,nngl
#ifdef PETSC
            if (node_idx_lg2l(ivol) < 0) then
              cycle
            end if
#endif
            porc_tot = porc_tot + por_init(ivol)*cvol(ivol)
          end do

#ifdef PETSC
          call MPI_Allreduce(porc_tot, porc_tot_gbl,1,MPI_REAL8,       &
                             MPI_SUM,Petsc_Comm_World,ierrcode)
          CHKERRQ(ierrcode)
          porc_tot = porc_tot_gbl
#endif
          porz(izn) = porc_tot / cvol_tot              
        end if
        
!c  read aqueous tortuosity from input file

        if (.not.tortuosity_field.and.assigned_tau) then        
          read(icnv,*,err=994,end=994) tauloc              
        end if
        
!c  read gas tortuosity from input file
        if (.not.tortuosity_field_gas.and.assigned_tau_gas) then
          if (gas_tortuosity == 'same as aqueous') then
            taugasloc = tauloc
          else
            read(icnv,*,err=994,end=994) taugasloc
          end if
        end if


!c  read tortuosity update factor, alpha
        if (assign_marchies) then            
          read(icnv,*,err=994,end=994) marchieloc            
        end if

!c  read fracture aperture
        subsection = 'fracture aperture'
        call findstrg(subsection,icnv,found_subsection)
        if (found_subsection) then
          assigned_aperture = .true.
          read(icnv,*,err=994,end=994) apertureLoc
        else
          assigned_aperture = .false.
        end if

!cdsu fracture flow type, e.g., darcy flow, cublic law flow
        fracFlowTypeLoc = 0
        subsection = 'fracture flow type'
        call findstrg(subsection,icnv,found_subsection)
        if (found_subsection) then
          ierrcd = 8
          read(icnv,*,err=999,end=999) strFracFlowTypeLoc

          assigned_fracture_flow_type = .true.

          if (trim(strFracFlowTypeLoc) == 'darcy') then
            fracFlowTypeLoc = 0
          else if (trim(strFracFlowTypeLoc) == 'cubic law') then
            fracFlowTypeLoc = 1
          else
            if (rank == 0) then
              write(*,'(2a)') 'Error: unknown fracture flow type, ',   &
                    'should be darcy or cubic law'
              write(ilog,'(2a)') 'Error: unknown fracture flow type, ',&
                    'should be darcy or cubic law'
            end if
            goto 999
          end if
        end if

!c  read mechanical parameters
        subsection = 'mechanical parameters'
        call findstrg(subsection,icnv,found_subsection)
        if (found_subsection) then
          read(icnv,*,err=994,end=994) modulus_young(izn)   !Young's modulus E in the unit of [Pa]
          read(icnv,*,err=994,end=994) modulus_grain(izn)   !Mineral grain modulus Ks for the rock formation [Pa]
          read(icnv,*,err=994,end=994) modulus_fluid(izn)   !Pore fluid modulus Kf for the rock formation [Pa]
          read(icnv,*,err=994,end=994) poisson_ratio(izn)   !Poisson's ratio Î½ in the unit of [-]
          read(icnv,*,err=994,end=994) compressibility(izn) !coefficient of vertical compressibility beta [Pa^-1]
          read(icnv,*,err=994,end=994) density_rock(izn)    !density of rock in the unit of [kg/m^3]
          read(icnv,*,err=994,end=994) density_fluid(izn)   !density of fluid in the unit of [kg/m^3]
          !Note: Density here is used for porosity calculation over depth change only. 
          !It is actually also a variable changed over depth, but used as a constant here.
          modulus_bulk(izn) = modulus_young(izn)/(3.0d0-6.0d0*poisson_ratio(izn))
        end if

!c  apply porosity change over depth based on Bahr et al 2001 model.
        subsection = 'calculate porosity'
        call findstrg(subsection,icnv,found_subsection)
        if (found_subsection) then          
          porosity_mech_cal(izn) = .true.
        else
          porosity_mech_cal(izn) = .false.
        end if

!c  calculate Skempton's coefficient [-] based on hydromechanical parameters.
        subsection = 'calculate skempton coefficient'
        call findstrg(subsection,icnv,found_subsection)
        if (found_subsection) then          
          skempton_mech_cal(izn) = .true.
        else
          skempton_mech_cal(izn) = .false.
        end if

!c  calculate specific storage coefficient based on hydromechanical parameters.
        subsection = 'calculate specific storage coefficient'
        call findstrg(subsection,icnv,found_subsection)
        if (found_subsection) then          
          storcoeff_mech_cal(izn) = .true.
        else
          storcoeff_mech_cal(izn) = .false.
        end if  
        
!c  calculate one-dimensional loading efficiency coefficient based on hydromechanical parameters.
        !c subsection = 'calculate loading efficiency coefficient'
        subsection = 'calculate loading factor'
        call findstrg(subsection,icnv,found_subsection)
        if (found_subsection) then          
          loadingfactor_mech_cal(izn) = .true.
        else
          loadingfactor_mech_cal(izn) = .false.
!c  read user specified loading factor
          subsection = 'user specified loading factor'
          call findstrg(subsection,icnv,found_subsection)
          if (found_subsection) then
            loadingfactor_specified(izn) = .true.
            read(icnv,*,err=994,end=994) loading_factor_zn(izn)   !1D loading factor, can either be user specified or 
                                                                  !calculated based on mechanical parameters
          end if
        end if

!c  read yaw (about z axis), pitch (about y axis) and roll (about x axis) angles, 
!c  read in degree, converted to radian
        if (useAnisoCorr .and. .not. aca_field) then
          subsection = 'anisotropic correction angles'
          call findstrg(subsection,icnv,found_subsection)
          if (found_subsection) then
            read(icnv,*,err=994,end=994) aca_zone%z,      &     !alpha, about z axis
                                         aca_zone%y,      &     !beta, about y axis
                                         aca_zone%x             !gamma, about x axis
            !c convert to radian
            aca_zone%x = aca_zone%x*(pi/r180)
            aca_zone%y = aca_zone%y*(pi/r180)
            aca_zone%z = aca_zone%z*(pi/r180)
          else
            if (rank == 0) then
              write(ilog,*) 'SIMULATION TERMINATED'
              write(ilog,*) 'error reading rotation angles'
              write(ilog,*) 'section "',trim(section_header),'"'
              write(ilog,*) 'zone "', trim(zone_name),'"'
              write(ilog,*) 'subsection "',trim(subsection),'" missing'
              close(ilog)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop
          end if
        end if

!c  read coordinates delineating zone
        type_extent_zone = -1
        type_extent_zone_box = -1

        subsection = 'extent of zone'

        call findstrg(subsection,icnv,found_subsection)

        if (found_subsection) then

          type_extent_zone = 0
          ierrcd = 1
          read(icnv,*,err=999,end=999) xpmin,xpmax,ypmin,ypmax,   &
                                       zpmin,zpmax

        end if

#ifdef USG
        call read_zone_usg_input(icnv)
        if (type_extent_zone_box > 0) then
          ierrcd = 2
          read(icnv,*,err=999,end=999) xpmin,xpmax,ypmin,ypmax,   &
                                       zpmin,zpmax
        end if
#endif

        !c check if x dimension is valid
        if (.not.btest(cell_projection,0)) then
          xpmin = -1.0d300
          xpmax = 1.0d300
        end if
      
        !c check if y dimension is valid
        if (.not.btest(cell_projection,1)) then
          ypmin = -1.0d300
          ypmax = 1.0d300
        end if
      
        !c check if z dimension is valid
        if (.not.btest(cell_projection,2)) then
          zpmin = -1.0d300
          zpmax = 1.0d300
        end if

!c  write error information if 'extent of zone' is missing
        if (type_extent_zone < 0) then

          if (rank == 0) then
            write(ilog,*) 'SIMULATION TERMINATED'
            write(ilog,*) 'error reading input file'
            write(ilog,*) 'section "',trim(section_header),'"'
            write(ilog,*) 'zone "', trim(zone_name),'"'
            write(ilog,*) 'subsection "',trim(subsection),'" missing'
            close(ilog)
          end if
#ifdef PETSC
          call petsc_mpi_finalize
#endif
          stop

        end if

        xpmin = xpmin-tiny
        xpmax = xpmax+tiny
        ypmin = ypmin-tiny
        ypmax = ypmax+tiny
        zpmin = zpmin-tiny
        zpmax = zpmax+tiny


! CBF calculate and store zone volume in array to calculate evaporation and transpiration flux

          pvol(izn)=(xpmax-xpmin)*(ypmax-xpmin)*(zpmax-zpmin)    !CBF
 
!c  assign physical parameters to global system
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nngl > numofloops_thred_initpppm_1)                     &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(ivol)                                               &
    !$omp reduction(+:nntemp)
    !$omp do schedule(static)
#endif
          do ivol = 1,nngl                  !loop over control volumes

            if (((type_extent_zone==0.or.type_extent_zone_box>0) .and. &
                (xg(ivol).gt.xpmin).and.(xg(ivol).lt.xpmax) .and.      &
                (yg(ivol).gt.ypmin).and.(yg(ivol).lt.ypmax) .and.      &
                (zg(ivol).gt.zpmin).and.(zg(ivol).lt.zpmax)) .or.      &
                (type_extent_zone>0 .and. node_iflags(ivol)>=0 .and.   &
                ibits(type_extent_zone,0,1)==0)) then

#ifdef USG
              if (discretization_type > 0 .and. type_extent_zone_box > 0) then
                if ((btest(type_extent_zone_box,1) .and.               &
                     .not. is_boundary_node(ivol)) .or.                &
                    (btest(type_extent_zone_box,2) .and.               &
                     is_boundary_node(ivol))) then
                  cycle
                end if
              end if
#endif

              property_iflag(ivol) = property_iflag(ivol) + 1

              if (porosity_field) then
                pornew(ivol) = por_init(ivol)
                porold(ivol) = por_init(ivol)
              else
                
                !c apply porosity change over depth based on Bahr et al. 2001.
                !c Bahr, D.B., E.W.H. Hutton, J.P.M. Syvitski and L.F. Pratson. 2001. 
                !c Exponential approximations to compacted sediment porosity profiles. 
                !c Computers & Geosciences , 27, 691-700
#ifdef USG
                if (b_use_layered_mesh .and. porosity_mech_cal(izn)) then
                  depth = layer_nodes_top(node_to_layer_node(ivol))%z-nodes(ivol)%z
                  porc_k1 = (r1 - porz(izn))/porz(izn)
                  porc_ecg = exp(-compressibility(izn)*gacc*depth*     &
                                (density_rock(izn)-density_fluid(izn)))
                  pornew(ivol) = porc_ecg/(porc_ecg+porc_k1)
                else
#endif
                  pornew(ivol) = porz(izn)
#ifdef USG
                end if
#endif
              end if
              !c the porosity threshold is initialized only if reactive transport is used.
              if (reactive_transport) then
                if (pornew(ivol) < por_thresh_min) then
                  pornew(ivol) = por_thresh_min
                else if (pornew(ivol) > por_thresh_max) then
                  pornew(ivol) = por_thresh_max
                end if
              end if

              porold(ivol) = pornew(ivol)
              por_init(ivol) = pornew(ivol)

              if (skempton_mech_cal(izn) .or.                        &
                  storcoeff_mech_cal(izn) .or.                       &
                  loadingfactor_mech_cal(izn)) then
                kbks_1 = r1/modulus_bulk(izn) - r1/modulus_grain(izn)
                kfks_1 = r1/modulus_fluid(izn) - r1/modulus_grain(izn)
                alpha = r1 - modulus_bulk(izn)/modulus_grain(izn)                 
                if (storcoeff_mech_cal(izn)) then
                  lamda = 2.0d0*alpha*(r1-2.0d0*poisson_ratio(izn))/ &
                          (3.0d0*(r1-poisson_ratio(izn)))

                  !c Note: density dependent flow use pressure [Pa] as the unit of unknowns
                  !c while non-density dependent flow use head [m water] as the unit of unknowns.
                  !c There is internal conversion for storage coefficient.
                  if (density_dependence) then
                    stor(ivol) = kbks_1*(r1-lamda)+kfks_1*pornew(ivol)
                  else
                    stor(ivol) = (kbks_1*(r1-lamda)+kfks_1*pornew(ivol))*&
                                 density_fluid(izn)*gacc
                  end if

                end if 
                if (compute_ice_sheet_loading) then
                  if (skempton_mech_cal(izn)) then
                    skempton(ivol) = kbks_1/(kbks_1+pornew(ivol)*kfks_1)
                    !c The original code use skempton as loading coefficient by applying scaling factor.
                    !c Generally this is acceptable as 1D loading efficiency is proportional to the Skempton coefficient.
                    !c Here when loading efficiency coefficient is considered, the loading efficiency coefficient factor
                    !c equals to loading efficiency coefficient divided by skemptons's coefficient 
                    if (loadingfactor_mech_cal(izn)) then
                      loading_factor(ivol) = (r1+poisson_ratio(izn))/&
                        (3.0d0*(r1-poisson_ratio(izn))-2.0d0*alpha*  &
                        skempton(ivol)*(r1-2.0d0*poisson_ratio(izn)))
                    end if
                  end if
                end if                
              end if

              !c user specified zone dependent loading factor
              if (compute_ice_sheet_loading) then
                if (loadingfactor_specified(izn)) then
                  loading_factor(ivol) = loading_factor_zn(izn)
                end if
              end if

              if (assigned_tau.and..not.tortuosity_field) then
               tau(ivol) = tauloc
              end if
              if (assigned_tau_gas.and..not.tortuosity_field_gas) then
                taugas(ivol) = taugasloc
              end if

              if (assign_marchies) then
                marchies(ivol) = marchieloc
              end if

              if (useAnisoCorr .and. .not. aca_field) then
                aca_vol(ivol) = aca_zone
              end if

              if (assigned_aperture .and. .not.fracture_aperture_field) then
                aperture(ivol) = apertureLoc
              end if

              if (assigned_fracture_flow_type .and. .not.fracture_flow_type_field) then
                fractureFlowType(ivol) = fracFlowTypeLoc
              end if

#ifdef PETSC
              if(node_idx_lg2l(ivol) > 0) then
                nntemp = nntemp+1
              end if
#else
              nntemp = nntemp+1
#endif
              mpropvs(ivol) = izn     !allocate material properties

            end if       !(zg(ivol).gt.zpmin).and.(zg(ivol).lt.zpmax)
                         !(yg(ivol).gt.ypmin).and.(yg(ivol).lt.ypmax)
                         !(xg(ivol).gt.xpmin).and.(xg(ivol).lt.xpmax)
          end do                          !loop over control volumes
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!c  output anisotropic correction angles to file
#ifdef USG
          if (b_enable_output .and. useAnisoCorr) then
            call outputaca_usg
          end if
#endif

          if (gas_tortuosity.eq.'same as aqueous') then
            taugas = tau
          end if

#ifdef USG
!c  assign physical parameters to global system
          if (discretization_type > 0) then
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (num_cells > numofloops_thred_initpppm_1)                &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private(icell)
    !$omp do schedule(static)
#endif
            do icell = 1,num_cells                  !loop over cells

              if (((type_extent_zone==0.or.type_extent_zone_box>0).and.&
                  (CellCenter(icell)%x.gt.xpmin).and.                  &
                  (CellCenter(icell)%x.lt.xpmax) .and.                 &
                  (CellCenter(icell)%y.gt.ypmin).and.                  &
                  (CellCenter(icell)%y.lt.ypmax) .and.                 &
                  (CellCenter(icell)%z.gt.zpmin).and.                  &
                  (CellCenter(icell)%z.lt.zpmax)) .or.                 &
                  (type_extent_zone>0 .and. cell_iflags(icell)>=0 .and.&
                  ibits(type_extent_zone,0,1) == 1)) then

#ifdef USG
                if (discretization_type > 0 .and. type_extent_zone_box > 0) then
                  if ((btest(type_extent_zone_box,1) .and.             &
                       .not. is_boundary_cell(icell)) .or.             &
                      (btest(type_extent_zone_box,2) .and.             &
                       is_boundary_cell(icell))) then
                    cycle
                  end if
                end if
#endif

                property_cell_iflag(icell) = property_cell_iflag(icell) + 1

                mpropvs_cell(icell) = izn     !allocate material properties

                

              end if

            end do                      !loop over cells
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif
          end if
#endif

          if (b_enable_output .and. b_enable_output_gen) then
            write(igen,'(/a,i0,a,1x,a)') 'material property zone ',    &
                                          izn,':',                     &
                                          zone_name(:l_zone_name)
            write(igen,'(72a)')('-',i=1,72)
            write(igen,'(a,1pe15.6e3)')                                &
            'porosity                                        = ', porz(izn)
            if (assigned_tau) then  
              write(igen,'(a,1pe15.6e3)')                              &
            'tortuosity of aqueous phase                     = ', tauloc
              if (tauloc .gt. 1.0) then
                write(igen,'(2a)')                                     &
                '!!! Warning: tortuosity is greater than 1.0 in zone:',&
                zone_name(:l_zone_name)
              end if
            end if
            if (assign_marchies) then
               write(igen,'(a,1pe15.6e3)')                             &
            'tortuosity update factor, alpha                 = ', marchieloc 
            end if
            if (assigned_tau_gas) then
              write(igen,'(a,1pe15.6e3)')                              &
            'tortuosity of gas phase                         = ', taugasloc
              if (tauloc .gt. 1.0) then
                write(igen,'(2a)')                                     &
                '!!! Warning: tortuosity is greater than 1.0 in zone:',&
                zone_name(:l_zone_name)
              end if
            end if
          end if
        end do                     !loop over property zones

!c  check if all material properties have been set
        nwarns = 0
        nerrs = 0
        do ivol = 1, nngl
          if (property_iflag(ivol) == 0) then
            nerrs = nerrs + 1
          else if (property_iflag(ivol) > 1) then
            nwarns = nwarns + 1
          end if
        end do

!c  check if material properties have been assigned correctly
        if (b_enable_output .and. rank == 0) then
          write(igen,'(a)') "check control volume: material property"
        end if
#ifdef PETSC
        call MPI_Allreduce(nerrs, nerrs_gbl,1,MPI_INTEGER4,MPI_SUM,    &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        nerrs = nerrs_gbl
#endif
        if (nerrs > 0) then
          if (rank == 0) then
            write(ilog,'(a,1x,i8,1x,a)')                               &
                  "Error: material property is not set for ",nerrs,    &
                  "control volumes"
            write(igen,'(a,1x,i8,1x,a)')                               &
                  "Error: material property is not set for ",nerrs,    &
                  "control volumes"
          end if
          ierrcd = 3
          goto 999
        end if

#ifdef PETSC
        call MPI_Allreduce(nwarns, nwarns_gbl,1,MPI_INTEGER4,MPI_SUM,  &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        nwarns = nwarns_gbl
#endif
        if (nwarns > 0) then
          if (rank == 0) then
            write(ilog,'(a,1x,i8,1x,a)')                               &
                  "Warning: material property is reset for ",nwarns,   &
                  "control volumes"
            write(igen,'(a,1x,i8,1x,a)')                               &
                  "Warning: material property is reset for ",nwarns,   &
                  "control volumes"
          end if
        end if  

#ifdef USG
        if (discretization_type > 0 .and. is_cell_based_perm_cond) then
          nwarns = 0
          nerrs = 0
          do icell = 1, num_cells
            if (property_cell_iflag(icell) == 0) then
              nerrs = nerrs + 1
            else if (property_cell_iflag(icell) > 1) then
              nwarns = nwarns + 1
            end if
          end do
        end if

!c  check if material properties have been assigned correctly
        if (b_enable_output .and. rank == 0) then
          write(igen,'(/a)') "check mesh cell: material property"
        end if
#ifdef PETSC
        call MPI_Allreduce(nerrs, nerrs_gbl,1,MPI_INTEGER4,MPI_SUM,    &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        nerrs = nerrs_gbl
#endif
        if (nerrs > 0) then
          if (rank == 0) then
            write(ilog,'(a,1x,i8,1x,a)')                               &
                  "Error: material property is not set for ",nerrs,    &
                  "cells"
            write(igen,'(a,1x,i8,1x,a)')                               &
                  "Error: material property is not set for ",nerrs,    &
                  "cells"
          end if
          ierrcd = 4
          goto 999
        end if

#ifdef PETSC
        call MPI_Allreduce(nwarns, nwarns_gbl,1,MPI_INTEGER4,MPI_SUM,  &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        nwarns = nwarns_gbl
#endif
        if (nwarns > 0) then
          if (rank == 0) then
            write(ilog,'(a,1x,i8,1x,a)')                               &
                  "Warning: material property is reset for ",nwarns,   &
                  "control volumes"
            write(igen,'(a,1x,i8,1x,a)')                               &
                  "Warning: material property is reset for ",nwarns,   &
                  "control volumes"
          end if
        end if        
#endif
   

#ifdef PETSC
        call MPI_Allreduce(nntemp, nntemp_gbl,1,MPI_INTEGER4,MPI_SUM,  &
                           Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        nntemp = nntemp_gbl
#endif

        if (nntemp.gt.nngbl) then

          if (rank == 0) then  
            write(ilog,*)
            write(ilog,'(a)')  &                 !screen or logbook
                  'warning ...........'
            write(ilog,'(a,1x,i0,1x,a)')                                &
                  'porous medium properties have been assigned to',     &
                   nntemp,' control volumes'
            write(ilog,'(a,1x,i0)')                                     &
                  'the actual number of control volumes is only',nngbl
            write(ilog,'(/72a)')('-',i=1,72)
          end if

        elseif (nntemp.lt.nngbl) then
            
          if (rank == 0) then
            write(ilog,'(2a,i0)') 'the number of control volumes with',&
                  ' material property is ',nntemp
            write(ilog,'(a,i0)')                                       &
                  'the actual number of control volumes is ',nngbl
            write(ilog,'(a)') 'please check the material properties zone'
          end if
          ierrcd = 5
          goto 999
        end if                             !(nntemp.....)
        
!c ----- added: oil saturation

        oil_saturation = .false.
!c  read oil saturation field from file
        subsection = 'read oil saturation field from file'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          oil_saturation = .true.
          if(rank == 0 .and. b_enable_output) then
            write(ilog,*) 'reading oil saturation field from file'
            write(ilog,'(/72a)')('-',i=1,72)
          end if
          igso = lun_get()

          open(igso,file=prefix(:l_prfx)//'.gso',status='unknown',     &
               form='formatted')

!c  read oil saturation
          read(igso,*,err=995,end=995) cdummy
          read(igso,*,err=995,end=995) cdummy
          read(igso,*,err=995,end=995) cdummy
#ifdef USG
          if (discretization_type > 0) then
            do ivolgbl = 1,nngbl
#ifdef PETSC
              if (ibits(usg_mesh_ordering,0,2) == 3) then
                ivol = node_idx_g2lg(node_idx_g2g_invord(ivolgbl))
              else
                ivol = node_idx_g2lg(ivolgbl)
              end if
#else
              if (ibits(usg_mesh_ordering,0,2) == 3) then
                ivol = node_idx_g2g_invord(ivolgbl)
              else
                ivol = ivolgbl
              end if
#endif
              if (ivol > 0) then
                read(igso,*,err=995,end=995) rdummy, rdummy, rdummy,   &
                                             sonew(ivol)
              else
                read(igso,*,err=995,end=995) rdummy
              end if
            end do
          end if
#endif
          if (discretization_type == 0) then
            nskip = 0
            do ivol = 1,nngl
#ifdef PETSC
              do iskip = 1, node_idx_lg2g(ivol) - nskip -1
                ierrcd = 6
                read(igso,*,end=999,err=999) rdummy
              end do
              nskip = node_idx_lg2g(ivol)
#endif
              read(igso,*,err=995,end=995) rdummy, rdummy, rdummy,     &
                                           sonew(ivol)
            end do
          end if

          close (igso)
          call lun_free(igso)

!c  account for decreased porosity due to presence of oil
          do ivol = 1,nngl
            pornew(ivol) = pornew(ivol) - sonew(ivol) * pornew(ivol)
            porold(ivol) = pornew(ivol)
          enddo
                
        end if

#ifdef USG
!c  read oil saturation field from file
        subsection = 'read oil saturation field from vtk file'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          oil_saturation = .true.
          if(rank == 0 .and. b_enable_output) then
            write(ilog,*) 'reading oil saturation field from vtk file'
            write(ilog,'(/72a)')('-',i=1,72)
          end if
          
          igso = lun_get()
          if ((read_spatial_master_proc .and. rank == 0) .or.          &
            .not.read_spatial_master_proc) then
            open(igso,file=prefix(:l_prfx)//'.gso.vtk',                &
                 status='unknown',form='formatted')
          else
            call lun_free(igso)
            igso = 0
          end if


!c  read oil saturation
          call read_vtk_data_from_file(igso,'sonew',bfound,sonew)
          if (bfound) then
            if (rank == 0 .and. b_enable_output) then
              write(*,'(a)') 'read oil saturation from vtk file: done'
              write(ilog,'(a)') 'read oil saturation from vtk file: done'
            end if
          end if

          if (igso > 0) then
            close (igso)
            call lun_free(igso)
          end if

!c  account for decreased porosity due to presence of oil
          do ivol = 1,nngl
            pornew(ivol) = pornew(ivol) - sonew(ivol) * pornew(ivol)
            porold(ivol) = pornew(ivol)
          enddo

        end if
#endif

!c ----- end oil saturation
!c ----- added: read porosity
!c  read oil saturation field from file

        subsection = 'read So field from file - no feedback on sat'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (rank == 0 .and. b_enable_output) then  
            write(ilog,*)                                              &
                  'reading So field from file - no feedback on sat'
          end if
          igso = lun_get()
          open(igso,file=prefix(:l_prfx)//'.gso',status='unknown',     &
               form='formatted')

!c  read oil saturation
        read(igso,*,err=995,end=995) cdummy
          read(igso,*,err=995,end=995) cdummy
          read(igso,*,err=995,end=995) cdummy
#ifdef USG
          if (discretization_type > 0) then
            do ivolgbl = 1,nngbl
#ifdef PETSC
              if (ibits(usg_mesh_ordering,0,2) == 3) then
                ivol = node_idx_g2lg(node_idx_g2g_invord(ivolgbl))
              else
                ivol = node_idx_g2lg(ivolgbl)
              end if
#else
              if (ibits(usg_mesh_ordering,0,2) == 3) then
                ivol = node_idx_g2g_invord(ivolgbl)
              else
                ivol = ivolgbl
              end if
#endif
              if (ivol > 0) then
                read(igso,*,err=995,end=995) rdummy, rdummy, rdummy,   &
                                             sonew(ivol)
              else
                read(igso,*,err=995,end=995) rdummy
              end if
            end do
          end if
#endif
          if (discretization_type == 0) then
            nskip = 0
            do ivol = 1,nngl
#ifdef PETSC
              do iskip = 1, node_idx_lg2g(ivol) - nskip -1
                ierrcd = 7
                read(igso,*,end=999,err=999) rdummy
              end do
              nskip = node_idx_lg2g(ivol)
#endif
              read(igso,*,err=995,end=995) rdummy, rdummy, rdummy,     &
                                           sonew(ivol)
            end do
          end if

          close (igso)
          call lun_free(igso)

!c  account for decreased porosity due to presence of oil
          do ivol=1,nngl
            pornew(ivol) = pornew(ivol) - sonew(ivol) * pornew(ivol)
            porold(ivol) = pornew(ivol)
          enddo
                
        end if

#ifdef USG
!c  read oil saturation field from file

        subsection = 'read So field from vtk file - no feedback on sat'
        call findstrg(subsection,itmp,found_subsection)

        if (found_subsection) then
          if (rank == 0 .and. b_enable_output) then
            write(ilog,*)                                              &
                  'reading So field from vtk file - no feedback on sat'
          end if

          igso = lun_get()
          if ((read_spatial_master_proc .and. rank == 0) .or.          &
              .not.read_spatial_master_proc) then
            open(igso,file=prefix(:l_prfx)//'.gso.vtk',                &
                 status='unknown',form='formatted')
          else
            call lun_free(igso)
            igso = 0
          end if

!c  read oil saturation
          call read_vtk_data_from_file(igso,'sonew',bfound,sonew)
          if (bfound) then
            if (rank == 0 .and. b_enable_output) then
              write(*,'(a)') 'read oil saturation from vtk file: done'
              write(ilog,'(a)') 'read oil saturation from vtk file: done'
            end if
          end if

          if (igso > 0) then
            close (igso)
            call lun_free(igso)
          end if

!c  account for decreased porosity due to presence of oil
          do ivol=1,nngl
            pornew(ivol) = pornew(ivol) - sonew(ivol) * pornew(ivol)
            porold(ivol) = pornew(ivol)
          enddo

        end if
#endif

!c ----- end read porosity

!cdsu calculate average porosity of the whole domain
        por_init_ave = 0.0d0
        do ivol=1,nngl
#ifdef PETSC
          if (node_idx_lg2l(ivol) < 0) then
            cycle
          end if
#endif
          por_init_ave = por_init_ave + pornew(ivol)*cvol(ivol)
        end do

#ifdef PETSC
        call MPI_Allreduce(por_init_ave, por_init_ave_gbl,1,MPI_REAL8, &
                           MPI_SUM,Petsc_Comm_World,ierrcode)
        CHKERRQ(ierrcode)
        por_init_ave = por_init_ave_gbl
#endif
        por_init_ave = por_init_ave/cvol_tot

      else
!cdsu  set porosity por = 1 for batch problems
!cdsu  not required any more
        !porz = r1
        por_init_ave = r1 
      end if

      goto 1000

991   continue
      backspace(itmp)
      read(itmp,'(a)') strbuffer
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,'(2a)') 'error reading in itemp data: ',trim(strbuffer)
        write(*,*) 'SIMULATION TERMINATED'
        write(*,'(2a)') 'error reading in itemp data: ',trim(strbuffer)
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

992   continue
      backspace(ipor)
      read(ipor,'(a)') strbuffer
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,'(2a)') 'error reading in ipor data: ',trim(strbuffer)
        write(*,*) 'SIMULATION TERMINATED'
        write(*,'(2a)') 'error reading in ipor data: ',trim(strbuffer)
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

993   continue
      backspace(itor)
      read(itor,'(a)') strbuffer
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,'(2a)') 'error reading in itor data: ',trim(strbuffer)
        write(*,*) 'SIMULATION TERMINATED'
        write(*,'(2a)') 'error reading in itor data: ',trim(strbuffer)
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

994   continue
      backspace(icnv)
      read(icnv,'(a)') strbuffer
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,'(2a)') 'error reading in icnv data: ',trim(strbuffer)
        write(*,*) 'SIMULATION TERMINATED'
        write(*,'(2a)') 'error reading in icnv data: ',trim(strbuffer)
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop
      
995   continue
      backspace(igso)
      read(igso,'(a)') strbuffer
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,'(2a)') 'error reading nodal oil saturation data: ',&
                           trim(strbuffer)
        write(*,*) 'SIMULATION TERMINATED'
        write(*,'(2a)') 'error reading nodal oil saturation data: ',   &
                         trim(strbuffer)
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

999   continue
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,*) 'error reading input file, error code ', ierrcd
        write(ilog,*) 'section "',section_header(:l_string),'"'
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop


1000  return
      end
