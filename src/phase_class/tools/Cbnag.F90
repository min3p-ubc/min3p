!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 221 $
!> $Author: dsu $
!> $Date: 2014-08-05 14:29:49 -0700 (Tue, 05 Aug 2014) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/phase_class/tools/Cbnag.F90 $
!---------------------------------------------------------------------
!********************************************************************!


      SUBROUTINE F06AAZ (SRNAME, INFO) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.                              
!     MARK 15 REVISED. IER-915 (APR 1991).                              
!     .. Scalar Arguments ..   

      IMPLICIT NONE
      
      INTEGER INFO 
      CHARACTER(13) SRNAME 
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  F06AAZ  is an error handler for the Level 2 BLAS routines.           
!                                                                       
!  It is called by the Level 2 BLAS routines if an input parameter is   
!  invalid.                                                             
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  SRNAME - CHARACTER*13.                                               
!           On entry, SRNAME specifies the name of the routine which    
!           called F06AAZ.                                              
!                                                                       
!  INFO   - INTEGER.                                                    
!           On entry, INFO specifies the position of the invalid        
!           parameter in the parameter-list of the calling routine.     
!                                                                       
!                                                                       
!  Auxiliary routine for Level 2 Blas.                                  
!                                                                       
!  Written on 20-July-1986.                                             
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER IERR, IFAIL 
      CHARACTER(4) VARBNM 
!     .. Local Arrays ..                                                
      CHARACTER(80) REC (1) 
!     .. External Functions ..                                          
      INTEGER P01ACF 
      EXTERNAL P01ACF 
!     ..                                                                
!     .. Executable Statements ..                                       
      WRITE (REC (1), 99999) SRNAME, INFO 
      IF (SRNAME (1:3) .EQ.'F06') THEN 
         IERR = - 1 
      VARBNM = '    ' 
      ELSE 
         IERR = - INFO 
         VARBNM = 'INFO' 
      ENDIF 
      IFAIL = 0 
      IFAIL = P01ACF (IFAIL, IERR, SRNAME (1:6), VARBNM, 1, REC) 
!                                                                       
      RETURN 
!                                                                       
99999 FORMAT ( ' ** On entry to ', A13, ' parameter number ', I2,       &
     &         ' had an illegal value' )                                
!                                                                       
!     End of F06AAZ.                                                    
!                                                                       
      END SUBROUTINE F06AAZ                         
                                                                        
                                                                        
                                                                        
      SUBROUTINE F07ADY (N, A, LDA, K1, K2, IPIV, INCX) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.                              
!     ENTRY             DLASWP(N,A,LDA,K1,K2,IPIV,INCX)                 
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DLASWP performs a series of row interchanges on the matrix A.        
!  One row interchange is initiated for each of rows K1 through K2 of A.
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.                       
!                                                                       
!  A       (input/output) REAL array, dimension (LDA,N)                 
!          On entry, the matrix of column dimension N to which the row  
!          interchanges will be applied.                                
!          On exit, the permuted matrix.                                
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.                        
!                                                                       
!  K1      (input) INTEGER                                              
!          The first element of IPIV for which a row interchange will   
!          be done.                                                     
!                                                                       
!  K2      (input) INTEGER                                              
!          The last element of IPIV for which a row interchange will    
!          be done.                                                     
!                                                                       
!  IPIV    (input) INTEGER array, dimension( M*abs(INCX) )              
!          The vector of pivot indices.  Only the elements in positions 
!          K1 through K2 of IPIV are accessed.                          
!          IPIV(K) = L implies rows K and L are to be interchanged.     
!                                                                       
!  INCX    (input) INTEGER                                              
!          The increment between succesive values of IPIV.  If IPIV     
!          is negative, the pivots are applied in reverse order.        
!                                                                       
!                                                                       
!  -- LAPACK auxiliary routine (adapted for NAG Library)                
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University  

      IMPLICIT NONE
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INCX, K1, K2, LDA, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ) 
      INTEGER IPIV ( * ) 
!     .. Local Scalars ..                                               
      INTEGER I, IP, IX 
!     .. External Subroutines ..                                        
      EXTERNAL DSWAP 
!     .. Executable Statements ..                                       
!                                                                       
!     Interchange row I with row IPIV(I) for each of rows K1 through K2.
!                                                                       
      IF (INCX.EQ.0) RETURN 
      IF (INCX.GT.0) THEN 
         IX = K1 
      ELSE 
         IX = 1 + (1 - K2) * INCX 
      ENDIF 
      IF (INCX.EQ.1) THEN 
         DO 20 I = K1, K2 
            IP = IPIV (I) 
            IF (IP.NE.I) CALL DSWAP (N, A (I, 1), LDA, A (IP, 1),       &
            LDA)                                                        
   20    END DO 
      ELSEIF (INCX.GT.1) THEN 
         DO 40 I = K1, K2 
            IP = IPIV (IX) 
            IF (IP.NE.I) CALL DSWAP (N, A (I, 1), LDA, A (IP, 1),       &
            LDA)                                                        
            IX = IX + INCX 
   40    END DO 
      ELSEIF (INCX.LT.0) THEN 
         DO 60 I = K2, K1, - 1 
            IP = IPIV (IX) 
            IF (IP.NE.I) CALL DSWAP (N, A (I, 1), LDA, A (IP, 1),       &
            LDA)                                                        
            IX = IX + INCX 
   60    END DO 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F07ADY (DLASWP)                                            
!                                                                       
      END SUBROUTINE F07ADY                         
                                                                        
                                                                        
      SUBROUTINE F07BDF (M, N, KL, KU, AB, LDAB, IPIV, INFO) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.   

      IMPLICIT NONE
      
!     .. Entry Points ..                                                
      ENTRY DGBTRF (M, N, KL, KU, AB, LDAB, IPIV, INFO) 
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DGBTRF computes an LU factorization of a real m-by-n band matrix A   
!  using partial pivoting with row interchanges.                        
!                                                                       
!  This is the blocked version of the algorithm, calling Level 3 BLAS.  
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M >= 0.                 
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N >= 0.              
!                                                                       
!  KL      (input) INTEGER                                              
!          The number of subdiagonals within the band of A.  KL >= 0.   
!                                                                       
!  KU      (input) INTEGER                                              
!          The number of superdiagonals within the band of A.  KU >= 0. 
!                                                                       
!  AB      (input/output) REAL array, dimension (LDAB,N)                
!          On entry, the matrix A in band storage, in rows KL+1 to      
!          2*KL+KU+1; rows 1 to KL of the array need not be set.        
!          The j-th column of A is stored in the j-th column of the     
!          array AB as follows:                                         
!          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)   
!                                                                       
!          On exit, details of the factorization: U is stored as an     
!          upper triangular band matrix with KL+KU superdiagonals in    
!          rows 1 to KL+KU+1, and the multipliers used during the       
!          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.       
!          See below for further details.                               
!                                                                       
!  LDAB    (input) INTEGER                                              
!          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.   
!                                                                       
!  IPIV    (output) INTEGER array, dimension (min(M,N))                 
!          The pivot indices; for 1 <= i <= min(M,N), row i of the      
!          matrix was interchanged with row IPIV(i).                    
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          < 0: if INFO = -i, the i-th argument had an illegal value    
!          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization 
!               has been completed, but the factor U is exactly         
!               singular, and division by zero will occur if it is used 
!               to solve a system of equations.                         
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The band storage scheme is illustrated by the following example, when
!  M = N = 6, KL = 2, KU = 1:                                           
!                                                                       
!  On entry:                       On exit:                             
!                                                                       
!      *    *    *    +    +    +       *    *    *   u14  u25  u36     
!      *    *    +    +    +    +       *    *   u13  u24  u35  u46     
!      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56     
!     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66     
!     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *      
!     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *      
!                                                                       
!  Array elements marked * are not used by the routine; elements marked 
!  + need not be set on entry, but are required by the routine to store 
!  elements of U because of fill-in resulting from the row interchanges.
!                                                                       
!  -- LAPACK routine (adapted for NAG Library)                          
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
      INTEGER NBMAX, LDWORK 
      PARAMETER (NBMAX = 64, LDWORK = NBMAX + 1) 
!     .. Scalar Arguments ..                                            
      INTEGER INFO, KL, KU, LDAB, M, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION AB (LDAB, * ) 
      INTEGER IPIV ( * ) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION TEMP 
      INTEGER I, I2, I3, II, IP, J, J2, J3, JB, JJ, JM, JP, JU, K2, KM, &
      KV, NB, NW                                                        
!     .. Local Arrays ..                                                
      DOUBLEPRECISION WORK13 (LDWORK, NBMAX), WORK31 (LDWORK, NBMAX) 
!     .. External Functions ..                                          
      INTEGER IDAMAX 
      EXTERNAL IDAMAX 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ, F07ADY, F07BDZ, F07ZAZ, DCOPY, DGEMM, DGER,      &
      DSCAL, DSWAP, DTRSM                                               
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX, MIN 
!     .. Executable Statements ..                                       
!                                                                       
!     KV is the number of superdiagonals in the factor U, allowing for  
!     fill-in                                                           
!                                                                       
      KV = KU + KL 
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (M.LT.0) THEN 
         INFO = - 1 
      ELSEIF (N.LT.0) THEN 
         INFO = - 2 
      ELSEIF (KL.LT.0) THEN 
         INFO = - 3 
      ELSEIF (KU.LT.0) THEN 
         INFO = - 4 
      ELSEIF (LDAB.LT.KL + KV + 1) THEN 
         INFO = - 6 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F07BDF/DGBTRF', - INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF (M.EQ.0.OR.N.EQ.0) RETURN 
!                                                                       
!     Determine the block size for this environment                     
!                                                                       
      CALL F07ZAZ (1, 'F07BDF', NB, 0) 
!                                                                       
!     The block size must not exceed the limit set by the size of the   
!     local arrays WORK13 and WORK31.                                   
!                                                                       
      NB = MIN (NB, NBMAX) 
!                                                                       
      IF (NB.LE.1.OR.NB.GT.KL) THEN 
!                                                                       
!        Use unblocked code                                             
!                                                                       
         CALL F07BDZ (M, N, KL, KU, AB, LDAB, IPIV, INFO) 
      ELSE 
!                                                                       
!        Use blocked code                                               
!                                                                       
!        Zero the superdiagonal elements of the work array WORK13       
!                                                                       
         DO 40 J = 1, NB 
            DO 20 I = 1, J - 1 
               WORK13 (I, J) = ZERO 
   20       END DO 
   40    END DO 
!                                                                       
!        Zero the subdiagonal elements of the work array WORK31         
!                                                                       
         DO 80 J = 1, NB 
            DO 60 I = J + 1, NB 
               WORK31 (I, J) = ZERO 
   60       END DO 
   80    END DO 
!                                                                       
!        Gaussian elimination with partial pivoting                     
!                                                                       
!        Set fill-in elements in columns KU+2 to KV to zero             
!                                                                       
         DO 120 J = KU + 2, MIN (KV, N) 
            DO 100 I = KV - J + 2, KL 
               AB (I, J) = ZERO 
  100       END DO 
  120    END DO 
!                                                                       
!        JU is the index of the last column affected by the current     
!        stage of the factorization                                     
!                                                                       
         JU = 1 
!                                                                       
         DO 360 J = 1, MIN (M, N), NB 
            JB = MIN (NB, MIN (M, N) - J + 1) 
!                                                                       
!           The active part of the matrix is partitioned                
!                                                                       
!              A11   A12   A13                                          
!              A21   A22   A23                                          
!              A31   A32   A33                                          
!                                                                       
!           Here A11, A21 and A31 denote the current block of JB columns
!           which is about to be factorized. The number of rows in the  
!           partitioning are JB, I2, I3 respectively, and the numbers   
!           of columns are JB, J2, J3. The superdiagonal elements of A13
!           and the subdiagonal elements of A31 lie outside the band.   
!                                                                       
            I2 = MIN (KL - JB, M - J - JB + 1) 
            I3 = MIN (JB, M - J - KL + 1) 
!                                                                       
!           J2 and J3 are computed after JU has been updated.           
!                                                                       
!           Factorize the current block of JB columns                   
!                                                                       
            DO 160 JJ = J, J + JB - 1 
!                                                                       
!              Set fill-in elements in column JJ+KV to zero             
!                                                                       
               IF (JJ + KV.LE.N) THEN 
                  DO 140 I = 1, KL 
                     AB (I, JJ + KV) = ZERO 
  140             END DO 
               ENDIF 
!                                                                       
!              Find pivot and test for singularity. KM is the number of 
!              subdiagonal elements in the current column.              
!                                                                       
               KM = MIN (KL, M - JJ) 
               JP = IDAMAX (KM + 1, AB (KV + 1, JJ), 1) 
               IPIV (JJ) = JP + JJ - J 
               IF (AB (KV + JP, JJ) .NE.ZERO) THEN 
                  JU = MAX (JU, MIN (JJ + KU + JP - 1, N) ) 
                  IF (JP.NE.1) THEN 
!                                                                       
!                    Apply interchange to columns J to J+JB-1           
!                                                                       
                     IF (JP + JJ - 1.LT.J + KL) THEN 
!                                                                       
                        CALL DSWAP (JB, AB (KV + 1 + JJ - J, J),        &
                        LDAB - 1, AB (KV + JP + JJ - J, J), LDAB - 1)   
                     ELSE 
!                                                                       
!                       The interchange affects columns J to JJ-1 of A31
!                       which are stored in the work array WORK31       
!                                                                       
                        CALL DSWAP (JJ - J, AB (KV + 1 + JJ - J, J),    &
                        LDAB - 1, WORK31 (JP + JJ - J - KL, 1), LDWORK) 
                        CALL DSWAP (J + JB - JJ, AB (KV + 1, JJ),       &
                        LDAB - 1, AB (KV + JP, JJ), LDAB - 1)           
                     ENDIF 
                  ENDIF 
!                                                                       
!                 Compute multipliers                                   
!                                                                       
                  CALL DSCAL (KM, ONE / AB (KV + 1, JJ), AB (KV + 2, JJ)&
                  , 1)                                                  
!                                                                       
!                 Update trailing submatrix within the band and within  
!                 the current block. JM is the index of the last column 
!                 which needs to be updated.                            
!                                                                       
                  JM = MIN (JU, J + JB - 1) 
                  IF (JM.GT.JJ) CALL DGER (KM, JM - JJ, - ONE, AB (KV + &
                  2, JJ), 1, AB (KV, JJ + 1), LDAB - 1, AB (KV + 1, JJ +&
                  1), LDAB - 1)                                         
               ELSE 
!                                                                       
!                 If pivot is zero, set INFO to the index of the pivot  
!                 unless a zero pivot has already been found.           
!                                                                       
                  IF (INFO.EQ.0) INFO = JJ 
               ENDIF 
!                                                                       
!              Copy current column of A31 into the work array WORK31    
!                                                                       
               NW = MIN (JJ - J + 1, I3) 
               IF (NW.GT.0) CALL DCOPY (NW, AB (KV + KL + 1 - JJ + J,   &
               JJ), 1, WORK31 (1, JJ - J + 1), 1)                       
  160       END DO 
            IF (J + JB.LE.N) THEN 
!                                                                       
!              Apply the row interchanges to the other blocks.          
!                                                                       
               J2 = MIN (JU - J + 1, KV) - JB 
               J3 = MAX (0, JU - J - KV + 1) 
!                                                                       
!              Use F07ADY to apply the row interchanges to A12, A22, and
!              A32.                                                     
!                                                                       
               CALL F07ADY (J2, AB (KV + 1 - JB, J + JB), LDAB - 1, 1,  &
               JB, IPIV (J), 1)                                         
!                                                                       
!              Adjust the pivot indices.                                
!                                                                       
               DO 180 I = J, J + JB - 1 
                  IPIV (I) = IPIV (I) + J - 1 
  180          END DO 
!                                                                       
!              Apply the row interchanges to A13, A23, and A33          
!              columnwise.                                              
!                                                                       
               K2 = J - 1 + JB + J2 
               DO 220 I = 1, J3 
                  JJ = K2 + I 
                  DO 200 II = J + I - 1, J + JB - 1 
                     IP = IPIV (II) 
                     IF (IP.NE.II) THEN 
                        TEMP = AB (KV + 1 + II - JJ, JJ) 
                        AB (KV + 1 + II - JJ, JJ) = AB (KV + 1 + IP -   &
                        JJ, JJ)                                         
                        AB (KV + 1 + IP - JJ, JJ) = TEMP 
                     ENDIF 
  200             END DO 
  220          END DO 
!                                                                       
!              Update the relevant part of the trailing submatrix       
!                                                                       
               IF (J2.GT.0) THEN 
!                                                                       
!                 Update A12                                            
!                                                                       
                  CALL DTRSM ('Left', 'Lower', 'No transpose', 'Unit',  &
                  JB, J2, ONE, AB (KV + 1, J) , LDAB - 1, AB (KV + 1 -  &
                  JB, J + JB) , LDAB - 1)                               
!                                                                       
                  IF (I2.GT.0) THEN 
!                                                                       
!                    Update A22                                         
!                                                                       
                     CALL DGEMM ('No transpose', 'No transpose', I2, J2,&
                     JB, - ONE, AB (KV + 1 + JB, J) , LDAB - 1, AB (KV +&
                     1 - JB, J + JB) , LDAB - 1, ONE, AB (KV + 1, J +   &
                     JB) , LDAB - 1)                                    
                  ENDIF 
!                                                                       
                  IF (I3.GT.0) THEN 
!                                                                       
!                    Update A32                                         
!                                                                       
                     CALL DGEMM ('No transpose', 'No transpose', I3, J2,&
                     JB, - ONE, WORK31, LDWORK, AB (KV + 1 - JB, J + JB)&
                     , LDAB - 1, ONE, AB (KV + KL + 1 - JB, J + JB) ,   &
                     LDAB - 1)                                          
                  ENDIF 
               ENDIF 
!                                                                       
               IF (J3.GT.0) THEN 
!                                                                       
!                 Copy the lower triangle of A13 into the work array    
!                 WORK13                                                
!                                                                       
                  DO 260 JJ = 1, J3 
                     DO 240 II = JJ, JB 
                        WORK13 (II, JJ) = AB (II - JJ + 1, JJ + J + KV -&
                        1)                                              
  240                END DO 
  260             END DO 
!                                                                       
!                 Update A13 in the work array                          
!                                                                       
                  CALL DTRSM ('Left', 'Lower', 'No transpose', 'Unit',  &
                  JB, J3, ONE, AB (KV + 1, J) , LDAB - 1, WORK13,       &
                  LDWORK)                                               
!                                                                       
                  IF (I2.GT.0) THEN 
!                                                                       
!                    Update A23                                         
!                                                                       
                     CALL DGEMM ('No transpose', 'No transpose', I2, J3,&
                     JB, - ONE, AB (KV + 1 + JB, J) , LDAB - 1, WORK13, &
                     LDWORK, ONE, AB (1 + JB, J + KV) , LDAB - 1)       
                  ENDIF 
!                                                                       
                  IF (I3.GT.0) THEN 
!                                                                       
!                    Update A33                                         
!                                                                       
                     CALL DGEMM ('No transpose', 'No transpose', I3, J3,&
                     JB, - ONE, WORK31, LDWORK, WORK13, LDWORK, ONE, AB &
                     (1 + KL, J + KV) , LDAB - 1)                       
                  ENDIF 
!                                                                       
!                 Copy the lower triangle of A13 back into place        
!                                                                       
                  DO 300 JJ = 1, J3 
                     DO 280 II = JJ, JB 
                        AB (II - JJ + 1, JJ + J + KV - 1) = WORK13 (II, &
                        JJ)                                             
  280                END DO 
  300             END DO 
               ENDIF 
            ELSE 
!                                                                       
!              Adjust the pivot indices.                                
!                                                                       
               DO 320 I = J, J + JB - 1 
                  IPIV (I) = IPIV (I) + J - 1 
  320          END DO 
            ENDIF 
!                                                                       
!           Partially undo the interchanges in the current block to     
!           restore the upper triangular form of A31 and copy the upper 
!           triangle of A31 back into place                             
!                                                                       
            DO 340 JJ = J + JB - 1, J, - 1 
               JP = IPIV (JJ) - JJ + 1 
               IF (JP.NE.1) THEN 
!                                                                       
!                 Apply interchange to columns J to JJ-1                
!                                                                       
                  IF (JP + JJ - 1.LT.J + KL) THEN 
!                                                                       
!                    The interchange does not affect A31                
!                                                                       
                     CALL DSWAP (JJ - J, AB (KV + 1 + JJ - J, J),       &
                     LDAB - 1, AB (KV + JP + JJ - J, J), LDAB - 1)      
                  ELSE 
!                                                                       
!                    The interchange does affect A31                    
!                                                                       
                     CALL DSWAP (JJ - J, AB (KV + 1 + JJ - J, J),       &
                     LDAB - 1, WORK31 (JP + JJ - J - KL, 1), LDWORK)    
                  ENDIF 
               ENDIF 
!                                                                       
!              Copy the current column of A31 back into place           
!                                                                       
               NW = MIN (I3, JJ - J + 1) 
               IF (NW.GT.0) CALL DCOPY (NW, WORK31 (1, JJ - J + 1),     &
               1, AB (KV + KL + 1 - JJ + J, JJ), 1)                     
  340       END DO 
  360    END DO 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F07BDF (DGBTRF)                                            
!                                                                       
      END SUBROUTINE F07BDF                         
                                                                        
                                                                        
                                                                        
      SUBROUTINE F07BDZ (M, N, KL, KU, AB, LDAB, IPIV, INFO) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.                              
!     ENTRY             DGBTF2(M,N,KL,KU,AB,LDAB,IPIV,INFO)             
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DGBTF2 computes an LU factorization of a real m-by-n band matrix A   
!  using partial pivoting with row interchanges.                        
!                                                                       
!  This is the unblocked version of the algorithm, calling Level 2 BLAS.
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M >= 0.                 
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N >= 0.              
!                                                                       
!  KL      (input) INTEGER                                              
!          The number of subdiagonals within the band of A.  KL >= 0.   
!                                                                       
!  KU      (input) INTEGER                                              
!          The number of superdiagonals within the band of A.  KU >= 0. 
!                                                                       
!  AB      (input/output) REAL array, dimension (LDAB,N)                
!          On entry, the matrix A in band storage, in rows KL+1 to      
!          2*KL+KU+1; rows 1 to KL of the array need not be set.        
!          The j-th column of A is stored in the j-th column of the     
!          array AB as follows:                                         
!          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)   
!                                                                       
!          On exit, details of the factorization: U is stored as an     
!          upper triangular band matrix with KL+KU superdiagonals in    
!          rows 1 to KL+KU+1, and the multipliers used during the       
!          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.       
!          See below for further details.                               
!                                                                       
!  LDAB    (input) INTEGER                                              
!          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.   
!                                                                       
!  IPIV    (output) INTEGER array, dimension (min(M,N))                 
!          The pivot indices; for 1 <= i <= min(M,N), row i of the      
!          matrix was interchanged with row IPIV(i).                    
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          < 0: if INFO = -i, the i-th argument had an illegal value    
!          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization 
!               has been completed, but the factor U is exactly         
!               singular, and division by zero will occur if it is used 
!               to solve a system of equations.                         
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The band storage scheme is illustrated by the following example, when
!  M = N = 6, KL = 2, KU = 1:                                           
!                                                                       
!  On entry:                       On exit:                             
!                                                                       
!      *    *    *    +    +    +       *    *    *   u14  u25  u36     
!      *    *    +    +    +    +       *    *   u13  u24  u35  u46     
!      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56     
!     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66     
!     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *      
!     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *      
!                                                                       
!  Array elements marked * are not used by the routine; elements marked 
!  + need not be set on entry, but are required by the routine to store 
!  elements of U, because of fill-in resulting from the row             
!  interchanges.                                                        
!                                                                       
!  -- LAPACK routine (adapted for NAG Library)                          
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!                                                                       
!  =====================================================================

      IMPLICIT NONE
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
!     .. Scalar Arguments ..                                            
      INTEGER INFO, KL, KU, LDAB, M, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION AB (LDAB, * ) 
      INTEGER IPIV ( * ) 
!     .. Local Scalars ..                                               
      INTEGER I, J, JP, JU, KM, KV 
!     .. External Functions ..                                          
      INTEGER IDAMAX 
      EXTERNAL IDAMAX 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ, DGER, DSCAL, DSWAP 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX, MIN 
!     .. Executable Statements ..                                       
!                                                                       
!     KV is the number of superdiagonals in the factor U, allowing for  
!     fill-in.                                                          
!                                                                       
      KV = KU + KL 
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (M.LT.0) THEN 
         INFO = - 1 
      ELSEIF (N.LT.0) THEN 
         INFO = - 2 
      ELSEIF (KL.LT.0) THEN 
         INFO = - 3 
      ELSEIF (KU.LT.0) THEN 
         INFO = - 4 
      ELSEIF (LDAB.LT.KL + KV + 1) THEN 
         INFO = - 6 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F07BDZ/DGBTF2', - INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF (M.EQ.0.OR.N.EQ.0) RETURN 
!                                                                       
!     Gaussian elimination with partial pivoting                        
!                                                                       
!     Set fill-in elements in columns KU+2 to KV to zero.               
!                                                                       
      DO 40 J = KU + 2, MIN (KV, N) 
         DO 20 I = KV - J + 2, KL 
            AB (I, J) = ZERO 
   20    END DO 
   40 END DO 
!                                                                       
!     JU is the index of the last column affected by the current stage  
!     of the factorization.                                             
!                                                                       
      JU = 1 
!                                                                       
      DO 80 J = 1, MIN (M, N) 
!                                                                       
!        Set fill-in elements in column J+KV to zero.                   
!                                                                       
         IF (J + KV.LE.N) THEN 
            DO 60 I = 1, KL 
               AB (I, J + KV) = ZERO 
   60       END DO 
         ENDIF 
!                                                                       
!        Find pivot and test for singularity. KM is the number of       
!        subdiagonal elements in the current column.                    
!                                                                       
         KM = MIN (KL, M - J) 
         JP = IDAMAX (KM + 1, AB (KV + 1, J), 1) 
         IPIV (J) = JP + J - 1 
         IF (AB (KV + JP, J) .NE.ZERO) THEN 
            JU = MAX (JU, MIN (J + KU + JP - 1, N) ) 
!                                                                       
!           Apply interchange to columns J to JU.                       
!                                                                       
            IF (JP.NE.1) CALL DSWAP (JU - J + 1, AB (KV + JP, J),       &
            LDAB - 1, AB (KV + 1, J), LDAB - 1)                         
!                                                                       
            IF (KM.GT.0) THEN 
!                                                                       
!              Compute multipliers.                                     
!                                                                       
               CALL DSCAL (KM, ONE / AB (KV + 1, J), AB (KV + 2, J),    &
               1)                                                       
!                                                                       
!              Update trailing submatrix within the band.               
!                                                                       
               IF (JU.GT.J) CALL DGER (KM, JU - J, - ONE, AB (KV + 2, J)&
               , 1, AB (KV, J + 1), LDAB - 1, AB (KV + 1, J + 1),       &
               LDAB - 1)                                                
            ENDIF 
         ELSE 
!                                                                       
!           If pivot is zero, set INFO to the index of the pivot        
!           unless a zero pivot has already been found.                 
!                                                                       
            IF (INFO.EQ.0) INFO = J 
         ENDIF 
   80 END DO 
      RETURN 
!                                                                       
!     End of F07BDZ (DGBTF2)                                            
!                                                                       
      END SUBROUTINE F07BDZ                         
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F07BEF (TRANS, N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB,&
      INFO)                                                             
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.   

      IMPLICIT NONE

!     .. Entry Points ..                                                
      ENTRY DGBTRS (TRANS, N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB,     &
      INFO)                                                             
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DGBTRS solves a system of linear equations                           
!     A * X = B  or  A' * X = B                                         
!  with a general band matrix A using the LU factorization computed     
!  by F07BDF.                                                           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  TRANS   (input) CHARACTER*1                                          
!          Specifies the form of the system of equations.               
!          = 'N':  A * X = B  (No transpose)                            
!          = 'T':  A'* X = B  (Transpose)                               
!          = 'C':  A'* X = B  (Conjugate transpose = Transpose)         
!                                                                       
!  N       (input) INTEGER                                              
!          The order of the matrix A.  N >= 0.                          
!                                                                       
!  KL      (input) INTEGER                                              
!          The number of subdiagonals within the band of A.  KL >= 0.   
!                                                                       
!  KU      (input) INTEGER                                              
!          The number of superdiagonals within the band of A.  KU >= 0. 
!                                                                       
!  NRHS    (input) INTEGER                                              
!          The number of right hand sides, i.e., the number of columns  
!          of the matrix B.  NRHS >= 0.                                 
!                                                                       
!  AB      (input) REAL array, dimension (LDAB,N)                       
!          Details of the LU factorization of the band matrix A, as     
!          computed by F07BDF.  U is stored as an upper triangular band 
!          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and   
!          the multipliers used during the factorization are stored in  
!          rows KL+KU+2 to 2*KL+KU+1.                                   
!                                                                       
!  LDAB    (input) INTEGER                                              
!          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.   
!                                                                       
!  IPIV    (input) INTEGER array, dimension (N)                         
!          The pivot indices; for 1 <= i <= N, row i of the matrix was  
!          interchanged with row IPIV(i).                               
!                                                                       
!  B       (input/output) REAL array, dimension (LDB,NRHS)              
!          On entry, the right hand side vectors B for the system of    
!          linear equations.                                            
!          On exit, the solution vectors, X.                            
!                                                                       
!  LDB     (input) INTEGER                                              
!          The leading dimension of the array B.  LDB >= max(1,N).      
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          < 0: if INFO = -k, the k-th argument had an illegal value    
!                                                                       
!  -- LAPACK routine (adapted for NAG Library)                          
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!                                                                       
!  =====================================================================
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER INFO, KL, KU, LDAB, LDB, N, NRHS 
      CHARACTER TRANS 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION AB (LDAB, * ), B (LDB, * ) 
      INTEGER IPIV ( * ) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION T 
      INTEGER I, J, KD, L, LM 
      LOGICAL LNOTI, NOTRAN 
!     .. External Functions ..                                          
      DOUBLEPRECISION DDOT 
      EXTERNAL DDOT 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ, DAXPY, DTBSV 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX, MIN 
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
                                                                        
!      write(150,*)'n,kl,ku,nrhs,ldab,ipiv,ldb',n,kl,ku,nrhs,ldab,ipiv,l
!      write(150,*)'n,kl,ku,nrhs,ldab,ldb',n,kl,ku,nrhs,ldab,ldb        
                                                                        
                                                                        
      INFO = 0 
      NOTRAN = (TRANS.EQ.'N'.OR.TRANS.EQ.'n') 
      IF (.NOT.NOTRAN.AND..NOT. (TRANS.EQ.'T'.OR.TRANS.EQ.'t')          &
      .AND..NOT. (TRANS.EQ.'C'.OR.TRANS.EQ.'c') ) THEN                  
         INFO = - 1 
      ELSEIF (N.LT.0) THEN 
         INFO = - 2 
      ELSEIF (KL.LT.0) THEN 
         INFO = - 3 
      ELSEIF (KU.LT.0) THEN 
         INFO = - 4 
      ELSEIF (NRHS.LT.0) THEN 
         INFO = - 5 
      ELSEIF (LDAB.LT. (2 * KL + KU + 1) ) THEN 
         INFO = - 7 
      ELSEIF (LDB.LT.MAX (1, N) ) THEN 
         INFO = - 10 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F07BEF/DGBTRS', - INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF (N.EQ.0.OR.NRHS.EQ.0) RETURN 
!                                                                       
      KD = KU + KL + 1 
      LNOTI = KL.GT.0 
!                                                                       
      IF (NOTRAN) THEN 
!                                                                       
!        Solve  A*X = B.                                                
!                                                                       
         DO 40 I = 1, NRHS 
!                                                                       
!           Solve L*X = B, overwriting B with X.                        
!                                                                       
!           L is represented as a product of permutations and unit lower
!           triangular matrices L = P(1) * L(1) * ... * P(n-1) * L(n-1),
!           where each transformation L(i) is a rank-one modification of
!           the identity matrix.                                        
!                                                                       
            IF (LNOTI) THEN 
               DO 20 J = 1, N - 1 
                  LM = MIN (KL, N - J) 
                  L = IPIV (J) 
!PROVA                  WRITE(6,*) ' I,L,IPIV(J),J',I,L,IPIV(J),J       
                  T = B (L, I) 
                  IF (L.NE.J) THEN 
                     B (L, I) = B (J, I) 
                     B (J, I) = T 
                  ENDIF 
                  CALL DAXPY (LM, - T, AB (KD+1, J), 1, B (J + 1, I),   &
                  1)                                                    
   20          END DO 
            ENDIF 
!                                                                       
!           Solve U*X = B, overwriting B with X.                        
!                                                                       
            CALL DTBSV ('Upper', 'No transpose', 'Non-unit', N, KL + KU,&
            AB, LDAB, B (1, I) , 1)                                     
   40    END DO 
!                                                                       
      ELSE 
!                                                                       
!        Solve A'*X = B.                                                
!                                                                       
         DO 80 I = 1, NRHS 
!                                                                       
!           Solve U'*X = B, overwriting B with X.                       
!                                                                       
            CALL DTBSV ('Upper', 'Transpose', 'Non-unit', N, KL + KU,   &
            AB, LDAB, B (1, I) , 1)                                     
!                                                                       
!           Solve L'*X = B, overwriting B with X.                       
!                                                                       
            IF (LNOTI) THEN 
               DO 60 J = N - 1, 1, - 1 
                  LM = MIN (KL, N - J) 
                  B (J, I) = B (J, I) - DDOT (LM, AB (KD+1, J), 1, B (J &
                  + 1, I), 1)                                           
                  L = IPIV (J) 
                  IF (L.NE.J) THEN 
                     T = B (L, I) 
                     B (L, I) = B (J, I) 
                     B (J, I) = T 
                  ENDIF 
   60          END DO 
            ENDIF 
   80    END DO 
      ENDIF 
      RETURN 
!                                                                       
!     End of F07BEF (DGBTRS)                                            
!                                                                       
      END SUBROUTINE F07BEF                         
                                                                        
                                                                        
      SUBROUTINE F07ZAZ (ISPEC, NAME, IVAL, RWFLAG) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.                              
!                                                                       
!  -- NAG version of LAPACK auxiliary routine ILAENV                    
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  F07ZAZ sets or returns problem-dependent                             
!  parameters for the local environment. See                            
!  ISPEC for a description of the parameters.                           
!                                                                       
!  The problem-dependent parameters are contained                       
!  in the integer array IPARMS, and the value with                      
!  index ISPEC is set or copied to IVAL.                                
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  ISPEC (input) INTEGER                                                
!     Specifies the parameter to be set or                              
!     returned by F07ZAZ.                                               
!     = 1: the optimal blocksize; if this value                         
!          is 1, an unblocked algorithm will give                       
!          the best performance.                                        
!     = 2: the minimum block size for which the                         
!          block routine should be used; if the                         
!          usable block size is less than this                          
!          value, an unblocked routine should be                        
!          used.                                                        
!     = 3: the crossover point (in a block                              
!          routine, for N less than this value,                         
!          an unblocked routine should be used)                         
!                                                                       
!  NAME  (input) CHARACTER*(*)                                          
!     The name of the calling subroutine.                               
!                                                                       
!  IVAL  (input/output) INTEGER                                         
!     the value of the parameter set or returned.                       
!                                                                       
!  FLAG  (input) INTEGER                                                
!     = 0: F07ZAZ returns in IVAL the value of                          
!          the parameter specified by ISPEC.                            
!     = 1: F07ZAZ sets the parameter specified                          
!          by ISPEC to the value in IVAL.                               
!                                                                       
!  ==============================================     

      IMPLICIT NONE
!                                                                       
!     .. Parameters ..                                                  
      INTEGER NSPECS, NCODES, MAXIC 
      PARAMETER (NSPECS = 3, NCODES = 17, MAXIC = 28) 
!     .. Scalar Arguments ..                                            
      INTEGER ISPEC, IVAL, RWFLAG 
      CHARACTER ( * ) NAME 
!     .. Local Scalars ..                                               
      INTEGER ICODE 
!     .. Local Arrays ..                                                
      INTEGER IPARMS (NSPECS, NCODES), POINT (MAXIC) 
!     .. External Functions ..                                          
      INTEGER F07ZAY 
      EXTERNAL F07ZAY 
!     .. Save statement ..                                              
      SAVE IPARMS, POINT 
!     .. Data statements ..                                             
      DATA IPARMS (1, 1), IPARMS (2, 1), IPARMS (3, 1) / 1, 0, 0 / 
      DATA IPARMS (1, 2), IPARMS (2, 2), IPARMS (3, 2) / 1, 1, 0 / 
      DATA IPARMS (1, 3), IPARMS (2, 3), IPARMS (3, 3) / 1, 0, 0 / 
      DATA IPARMS (1, 4), IPARMS (2, 4), IPARMS (3, 4) / 1, 1, 0 / 
      DATA IPARMS (1, 5), IPARMS (2, 5), IPARMS (3, 5) / 1, 0, 0 / 
      DATA IPARMS (1, 6), IPARMS (2, 6), IPARMS (3, 6) / 1, 0, 0 / 
      DATA IPARMS (1, 7), IPARMS (2, 7), IPARMS (3, 7) / 1, 0, 0 / 
      DATA IPARMS (1, 8), IPARMS (2, 8), IPARMS (3, 8) / 1, 0, 0 / 
      DATA IPARMS (1, 9), IPARMS (2, 9), IPARMS (3, 9) / 1, 0, 0 / 
      DATA IPARMS (1, 10), IPARMS (2, 10), IPARMS (3, 10) / 1, 0, 0 / 
      DATA IPARMS (1, 11), IPARMS (2, 11), IPARMS (3, 11) / 1, 0, 0 / 
      DATA IPARMS (1, 12), IPARMS (2, 12), IPARMS (3, 12) / 1, 0, 0 / 
      DATA IPARMS (1, 13), IPARMS (2, 13), IPARMS (3, 13) / 1, 1, 0 / 
      DATA IPARMS (1, 14), IPARMS (2, 14), IPARMS (3, 14) / 1, 1, 0 / 
      DATA IPARMS (1, 15), IPARMS (2, 15), IPARMS (3, 15) / 1, 1, 0 / 
      DATA IPARMS (1, 16), IPARMS (2, 16), IPARMS (3, 16) / 1, 0, 0 / 
      DATA IPARMS (1, 17), IPARMS (2, 17), IPARMS (3, 17) / 1, 0, 0 / 
      DATA POINT / 1, 2, 3, 4, 5, 0, 6, 0, 7, 8, 9, 10, 11, 0, 12, 0,   &
      13, 0, 14, 0, 0, 0, 15, 0, 0, 16, 0, 17 /                         
!     .. Executable Statements ..                                       
!                                                                       
!     Convert the NAG name to an integer code.                          
      ICODE = F07ZAY (NAME) 
!                                                                       
      IF (ISPEC.LT.1.OR.ISPEC.GT.NSPECS) THEN 
!        Invalid value for ISPEC                                        
         IVAL = - 1 
      ELSEIF (ICODE.EQ.0) THEN 
!        Invalid value for NAME                                         
         IVAL = - 2 
      ELSEIF (POINT (ICODE) .EQ.0) THEN 
!        Invalid value for NAME                                         
         IVAL = - 2 
      ELSEIF (RWFLAG.EQ.0) THEN 
!        Read the value of a parameter                                  
         IVAL = IPARMS (ISPEC, POINT (ICODE) ) 
      ELSE 
!        Set the value of a parameter                                   
         IPARMS (ISPEC, POINT (ICODE) ) = IVAL 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F07ZAZ                                                     
!                                                                       
      END SUBROUTINE F07ZAZ                         
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
      INTEGER FUNCTION P01ACF (IFAIL, IERROR, SRNAME, VARBNM, NREC, REC) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.                              
!                                                                       
!     P01ACF is the error-handling routine for the F06 AND F07          
!     Chapters of the NAG Fortran Library. It is a slightly modified    
!     version of P01ABF.                                                
!                                                                       
!     P01ACF either returns the value of IERROR through the routine     
!     name (soft failure), or terminates execution of the program       
!     (hard failure). Diagnostic messages may be output.                
!                                                                       
!     If IERROR = 0 (successful exit from the calling routine),         
!     the value 0 is returned through the routine name, and no          
!     message is output                                                 
!                                                                       
!     If IERROR is non-zero (abnormal exit from the calling routine),   
!     the action taken depends on the value of IFAIL.                   
!                                                                       
!     IFAIL =  1: soft failure, silent exit (i.e. no messages are       
!                 output)                                               
!     IFAIL = -1: soft failure, noisy exit (i.e. messages are output)   
!     IFAIL =-13: soft failure, noisy exit but standard messages from   
!                 P01ACF are suppressed                                 
!     IFAIL =  0: hard failure, noisy exit                              
!                                                                       
!     For compatibility with certain routines included before Mark 12   
!     P01ACF also allows an alternative specification of IFAIL in which 
!     it is regarded as a decimal integer with least significant digits 
!     cba. Then                                                         
!                                                                       
!     a = 0: hard failure  a = 1: soft failure                          
!     b = 0: silent exit   b = 1: noisy exit                            
!                                                                       
!     except that hard failure now always implies a noisy exit.         
!                                                                       
!     S.Hammarling, M.P.Hooper and J.J.du Croz, NAG Central Office.     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER IERROR, IFAIL, NREC 
      CHARACTER ( * ) SRNAME, VARBNM 
!     .. Array Arguments ..                                             
      CHARACTER ( * ) REC ( * ) 
!     .. Local Scalars ..                                               
      INTEGER I, NERR, VARLEN 
      CHARACTER(72) MESS 
!     .. External Subroutines ..                                        
      EXTERNAL P01ABZ, X04AAF, X04BAF 
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS, LEN, MOD 
!     .. Executable Statements ..                                       
      IF (IERROR.NE.0) THEN 
         VARLEN = 0 
         DO 20 I = LEN (VARBNM), 1, - 1 
            IF (VARBNM (I:I) .NE.' ') THEN 
               VARLEN = I 
               GOTO 40 
            ENDIF 
   20    END DO 
   40    CONTINUE 
!        Abnormal exit from calling routine                             
         IF (IFAIL.EQ. - 1.OR.IFAIL.EQ.0.OR.IFAIL.EQ. - 13.OR. (        &
         IFAIL.GT.0.AND.MOD (IFAIL / 10, 10) .NE.0) ) THEN              
!           Noisy exit                                                  
            CALL X04AAF (0, NERR) 
            DO 60 I = 1, NREC 
               CALL X04BAF (NERR, REC (I) ) 
   60       END DO 
            IF (IFAIL.NE. - 13) THEN 
               IF (VARLEN.NE.0) THEN 
                  WRITE (MESS, FMT = 99999) SRNAME, VARBNM (1:VARLEN),  &
                  IERROR                                                
               ELSE 
                  WRITE (MESS, FMT = 99998) SRNAME 
               ENDIF 
               CALL X04BAF (NERR, MESS) 
               IF (ABS (MOD (IFAIL, 10) ) .NE.1) THEN 
!                 Hard failure                                          
      CALL X04BAF (NERR, ' ** NAG hard failure - execution terminated') 
                  CALL P01ABZ 
               ELSE 
!                 Soft failure                                          
      CALL X04BAF (NERR, ' ** NAG soft failure - control returned') 
               ENDIF 
            ENDIF 
         ENDIF 
      ENDIF 
      P01ACF = IERROR 
      RETURN 
!                                                                       
99999 FORMAT (' ** ABNORMAL EXIT from NAG Library routine ',A,': ',A,   &
     &       ' =',I6)                                                   
99998 FORMAT (' ** ABNORMAL EXIT from NAG Library routine ',A) 
      END FUNCTION P01ACF                           
                                                                        
                                                                        
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
                                                                        
      INTEGER FUNCTION F07ZAY (NAME) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.                              
!                                                                       
!     F07ZAY returns a unique positive integer code                     
!     corresponding to a six-letter NAG routine name                    
!     given in NAME. If NAME is not recognised, 0                       
!     is returned.                                                      
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER(6) NAME 
!     .. Local Scalars ..                                               
      INTEGER J, K 
      CHARACTER NAME4, NAME5 
!     .. Executable Statements ..                                       
!                                                                       
      NAME4 = NAME (4:4) 
      NAME5 = NAME (5:5) 
!                                                                       
      IF (NAME4.EQ.'A') THEN 
         J = 0 
      ELSEIF (NAME4.EQ.'B') THEN 
         J = 1 
      ELSEIF (NAME4.EQ.'F') THEN 
         J = 2 
      ELSEIF (NAME4.EQ.'H') THEN 
         J = 3 
      ELSEIF (NAME4.EQ.'M') THEN 
         J = 4 
      ELSEIF (NAME4.EQ.'N') THEN 
         J = 5 
      ELSEIF (NAME4.EQ.'T') THEN 
         J = 6 
      ELSE 
         J = - 1 
      ENDIF 
!                                                                       
      IF (NAME5.EQ.'D') THEN 
         K = 0 
      ELSEIF (NAME5.EQ.'J') THEN 
         K = 1 
      ELSEIF (NAME5.EQ.'R') THEN 
         K = 2 
      ELSEIF (NAME5.EQ.'W') THEN 
         K = 3 
      ELSE 
         K = - 1 
      ENDIF 
!                                                                       
      IF (J.LT.0.OR.K.LT.0.OR.NAME (1:3) .NE.'F07') THEN 
         F07ZAY = 0 
      ELSE 
!        F07ZAY is in the range 1-28.                                   
         F07ZAY = 1 + 4 * J + K 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
      END FUNCTION F07ZAY                           
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE P01ABZ 
!     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.                       
!                                                                       
!     Terminates execution when a hard failure occurs.                  
!                                                                       
!     ******************** IMPLEMENTATION NOTE ********************     
!     The following STOP statement may be replaced by a call to an      
!     implementation-dependent routine to display a message and/or      
!     to abort the program.                                             
!     *************************************************************  
      IMPLICIT NONE
!     .. Executable Statements ..                                       
      STOP 
      END SUBROUTINE P01ABZ                         
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE X04AAF (I, NERR) 
!     MARK 7 RELEASE. NAG COPYRIGHT 1978                                
!     MARK 7C REVISED IER-190 (MAY 1979)                                
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     MARK 14 REVISED. IER-829 (DEC 1989).                              
!     IF I = 0, SETS NERR TO CURRENT ERROR MESSAGE UNIT NUMBER          
!     (STORED IN NERR1).                                                
!     IF I = 1, CHANGES CURRENT ERROR MESSAGE UNIT NUMBER TO            
!     VALUE SPECIFIED BY NERR.        

      IMPLICIT NONE
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER I, NERR 
!     .. Local Scalars ..                                               
      INTEGER NERR1 
!     .. Save statement ..                                              
      SAVE NERR1 
!     .. Data statements ..                                             
      DATA NERR1 / 6 / 
!     .. Executable Statements ..                                       
      IF (I.EQ.0) NERR = NERR1 
      IF (I.EQ.1) NERR1 = NERR 
      RETURN 
      END SUBROUTINE X04AAF                         
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE X04BAF (NOUT, REC) 
!     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.                       
!                                                                       
!     X04BAF writes the contents of REC to the unit defined by NOUT.    
!                                                                       
!     Trailing blanks are not output, except that if REC is entirely    
!     blank, a single blank character is output.                        
!     If NOUT.lt.0, i.e. if NOUT is not a valid Fortran unit identifier,
!     then no output occurs.        

      IMPLICIT NONE
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER NOUT 
      CHARACTER ( * ) REC 
!     .. Local Scalars ..                                               
      INTEGER I 
!     .. Intrinsic Functions ..                                         
      INTRINSIC LEN 
!     .. Executable Statements ..                                       
      IF (NOUT.GE.0) THEN 
!        Remove trailing blanks                                         
         DO 20 I = LEN (REC), 2, - 1 
            IF (REC (I:I) .NE.' ') GOTO 40 
   20    END DO 
!        Write record to external file                                  
   40    WRITE (NOUT, FMT = 99999) REC (1:I) 
      ENDIF 
      RETURN 
!                                                                       
99999 FORMAT (A) 
      END SUBROUTINE X04BAF                         
                                                                        
                                                                        
                                                                        
      SUBROUTINE F06ECF (N, ALPHA, X, INCX, Y, INCY) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.     

      IMPLICIT NONE
!     .. Entry Points ..                                                
      ENTRY DAXPY (N, ALPHA, X, INCX, Y, INCY) 
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION ALPHA 
      INTEGER INCX, INCY, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION X ( * ), Y ( * ) 
!     ..                                                                
!                                                                       
!  F06ECF performs the operation                                        
!                                                                       
!     y := alpha*x + y                                                  
!                                                                       
!                                                                       
!  Nag Fortran 77 version of the Blas routine DAXPY.                    
!  Nag Fortran 77 O( n ) basic linear algebra routine.                  
!                                                                       
!  -- Written on 3-September-1982.                                      
!     Sven Hammarling, Nag Central Office.                              
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ZERO 
      PARAMETER (ZERO = 0.0D+0) 
!     .. Local Scalars ..                                               
      INTEGER I, IX, IY 
!     ..                                                                
!     .. Executable Statements ..                                       
      IF (N.GT.0) THEN 
         IF (ALPHA.NE.ZERO) THEN 
            IF ( (INCX.EQ.INCY) .AND. (INCX.GT.0) ) THEN 
               DO 10, IX = 1, 1 + (N - 1) * INCX, INCX 
                  Y (IX) = ALPHA * X (IX) + Y (IX) 
   10          END DO 
            ELSE 
               IF (INCY.GE.0) THEN 
                  IY = 1 
               ELSE 
                  IY = 1 - (N - 1) * INCY 
               ENDIF 
               IF (INCX.GT.0) THEN 
                  DO 20, IX = 1, 1 + (N - 1) * INCX, INCX 
                     Y (IY) = ALPHA * X (IX) + Y (IY) 
                     IY = IY + INCY 
   20             END DO 
               ELSE 
                  IX = 1 - (N - 1) * INCX 
                  DO 30, I = 1, N 
                     Y (IY) = ALPHA * X (IX) + Y (IY) 
                     IX = IX + INCX 
                     IY = IY + INCY 
   30             END DO 
               ENDIF 
            ENDIF 
         ENDIF 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06ECF. ( DAXPY )                                          
!                                                                       
      END SUBROUTINE F06ECF                         
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F06PKF (UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) 
!     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.                             
!     .. Entry Points ..               

      IMPLICIT NONE
      
      ENTRY DTBSV (UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) 
!     .. Scalar Arguments ..                                            
      INTEGER INCX, K, LDA, N 
      CHARACTER(1) DIAG, TRANS, UPLO 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), X ( * ) 
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DTBSV  solves one of the systems of equations                        
!                                                                       
!     A*x = b,   or   A'*x = b,                                         
!                                                                       
!  where b and x are n element vectors and A is an n by n unit, or      
!  non-unit, upper or lower triangular band matrix, with ( k + 1 )      
!  diagonals.                                                           
!                                                                       
!  No test for singularity or near-singularity is included in this      
!  routine. Such tests must be performed before calling this routine.   
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  UPLO   - CHARACTER*1.                                                
!           On entry, UPLO specifies whether the matrix is an upper or  
!           lower triangular matrix as follows:                         
!                                                                       
!              UPLO = 'U' or 'u'   A is an upper triangular matrix.     
!                                                                       
!              UPLO = 'L' or 'l'   A is a lower triangular matrix.      
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  TRANS  - CHARACTER*1.                                                
!           On entry, TRANS specifies the equations to be solved as     
!           follows:                                                    
!                                                                       
!              TRANS = 'N' or 'n'   A*x = b.                            
!                                                                       
!              TRANS = 'T' or 't'   A'*x = b.                           
!                                                                       
!              TRANS = 'C' or 'c'   A'*x = b.                           
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  DIAG   - CHARACTER*1.                                                
!           On entry, DIAG specifies whether or not A is unit           
!           triangular as follows:                                      
!                                                                       
!              DIAG = 'U' or 'u'   A is assumed to be unit triangular.  
!                                                                       
!              DIAG = 'N' or 'n'   A is not assumed to be unit          
!                                  triangular.                          
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry, N specifies the order of the matrix A.            
!           N must be at least zero.                                    
!           Unchanged on exit.                                          
!                                                                       
!  K      - INTEGER.                                                    
!           On entry with UPLO = 'U' or 'u', K specifies the number of  
!           super-diagonals of the matrix A.                            
!           On entry with UPLO = 'L' or 'l', K specifies the number of  
!           sub-diagonals of the matrix A.                              
!           K must satisfy  0 .le. K.                                   
!           Unchanged on exit.                                          
!                                                                       
!  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).             
!           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )  
!           by n part of the array A must contain the upper triangular  
!           band part of the matrix of coefficients, supplied column by 
!           column, with the leading diagonal of the matrix in row      
!           ( k + 1 ) of the array, the first super-diagonal starting at
!           position 2 in row k, and so on. The top left k by k triangle
!           of the array A is not referenced.                           
!           The following program segment will transfer an upper        
!           triangular band matrix from conventional full matrix storage
!           to band storage:                                            
!                                                                       
!                 DO 20, J = 1, N                                       
!                    M = K + 1 - J                                      
!                    DO 10, I = MAX( 1, J - K ), J                      
!                       A( M + I, J ) = matrix( I, J )                  
!              10    CONTINUE                                           
!              20 CONTINUE                                              
!                                                                       
!           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )  
!           by n part of the array A must contain the lower triangular  
!           band part of the matrix of coefficients, supplied column by 
!           column, with the leading diagonal of the matrix in row 1 of 
!           the array, the first sub-diagonal starting at position 1 in 
!           row 2, and so on. The bottom right k by k triangle of the   
!           array A is not referenced.                                  
!           The following program segment will transfer a lower         
!           triangular band matrix from conventional full matrix storage
!           to band storage:                                            
!                                                                       
!                 DO 20, J = 1, N                                       
!                    M = 1 - J                                          
!                    DO 10, I = J, MIN( N, J + K )                      
!                       A( M + I, J ) = matrix( I, J )                  
!              10    CONTINUE                                           
!              20 CONTINUE                                              
!                                                                       
!           Note that when DIAG = 'U' or 'u' the elements of the array A
!           corresponding to the diagonal elements of the matrix are not
!           referenced, but are assumed to be unity.                    
!           Unchanged on exit.                                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program. LDA must be at least          
!           ( k + 1 ).                                                  
!           Unchanged on exit.                                          
!                                                                       
!  X      - DOUBLE PRECISION array of dimension at least                
!           ( 1 + ( n - 1 )*abs( INCX ) ).                              
!           Before entry, the incremented array X must contain the n    
!           element right-hand side vector b. On exit, X is overwritten 
!           with the solution vector x.                                 
!                                                                       
!  INCX   - INTEGER.                                                    
!           On entry, INCX specifies the increment for the elements of  
!           X. INCX must not be zero.                                   
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 2 Blas routine.                                                
!                                                                       
!  -- Written on 22-October-1986.                                       
!     Jack Dongarra, Argonne National Lab.                              
!     Jeremy Du Croz, Nag Central Office.                               
!     Sven Hammarling, Nag Central Office.                              
!     Richard Hanson, Sandia National Labs.                             
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ZERO 
      PARAMETER (ZERO = 0.0D+0) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION TEMP 
      INTEGER I, INFO, IX, J, JX, KPLUS1, KX, L 
      LOGICAL NOUNIT 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX, MIN 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (.NOT. (UPLO.EQ.'U'.OR.UPLO.EQ.'u') .AND..NOT. (               &
      UPLO.EQ.'L'.OR.UPLO.EQ.'l') ) THEN                                
         INFO = 1 
      ELSEIF (.NOT. (TRANS.EQ.'N'.OR.TRANS.EQ.'n') .AND..NOT. (         &
      TRANS.EQ.'T'.OR.TRANS.EQ.'t') .AND..NOT. (                        &
      TRANS.EQ.'C'.OR.TRANS.EQ.'c') ) THEN                              
         INFO = 2 
      ELSEIF (.NOT. (DIAG.EQ.'U'.OR.DIAG.EQ.'u') .AND..NOT. (           &
      DIAG.EQ.'N'.OR.DIAG.EQ.'n') ) THEN                                
         INFO = 3 
      ELSEIF (N.LT.0) THEN 
         INFO = 4 
      ELSEIF (K.LT.0) THEN 
         INFO = 5 
      ELSEIF (LDA.LT. (K + 1) ) THEN 
         INFO = 7 
      ELSEIF (INCX.EQ.0) THEN 
         INFO = 9 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F06PKF/DTBSV ', INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF (N.EQ.0) RETURN 
!                                                                       
      NOUNIT = (DIAG.EQ.'N'.OR.DIAG.EQ.'n') 
!                                                                       
!     Set up the start point in X if the increment is not unity. This   
!     will be  ( N - 1 )*INCX  too small for descending loops.          
!                                                                       
      IF (INCX.LE.0) THEN 
         KX = 1 - (N - 1) * INCX 
      ELSEIF (INCX.NE.1) THEN 
         KX = 1 
      ENDIF 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed by sequentially with one pass through A.                 
!                                                                       
      IF ( (TRANS.EQ.'N'.OR.TRANS.EQ.'n') ) THEN 
!                                                                       
!        Form  x := inv( A )*x.                                         
!                                                                       
         IF ( (UPLO.EQ.'U'.OR.UPLO.EQ.'u') ) THEN 
            KPLUS1 = K + 1 
            IF (INCX.EQ.1) THEN 
               DO 20, J = N, 1, - 1 
                  IF (X (J) .NE.ZERO) THEN 
                     L = KPLUS1 - J 
                     IF (NOUNIT) X (J) = X (J) / A (KPLUS1, J) 
                     TEMP = X (J) 
                     DO 10, I = J - 1, MAX (1, J - K), - 1 
                        X (I) = X (I) - TEMP * A (L + I, J) 
   10                END DO 
                  ENDIF 
   20          END DO 
            ELSE 
               KX = KX + (N - 1) * INCX 
               JX = KX 
               DO 40, J = N, 1, - 1 
                  KX = KX - INCX 
                  IF (X (JX) .NE.ZERO) THEN 
                     IX = KX 
                     L = KPLUS1 - J 
                     IF (NOUNIT) X (JX) = X (JX) / A (KPLUS1, J) 
                     TEMP = X (JX) 
                     DO 30, I = J - 1, MAX (1, J - K), - 1 
                        X (IX) = X (IX) - TEMP * A (L + I, J) 
                        IX = IX - INCX 
   30                END DO 
                  ENDIF 
                  JX = JX - INCX 
   40          END DO 
            ENDIF 
         ELSE 
            IF (INCX.EQ.1) THEN 
               DO 60, J = 1, N 
                  IF (X (J) .NE.ZERO) THEN 
                     L = 1 - J 
                     IF (NOUNIT) X (J) = X (J) / A (1, J) 
                     TEMP = X (J) 
                     DO 50, I = J + 1, MIN (N, J + K) 
                        X (I) = X (I) - TEMP * A (L + I, J) 
   50                END DO 
                  ENDIF 
   60          END DO 
            ELSE 
               JX = KX 
               DO 80, J = 1, N 
                  KX = KX + INCX 
                  IF (X (JX) .NE.ZERO) THEN 
                     IX = KX 
                     L = 1 - J 
                     IF (NOUNIT) X (JX) = X (JX) / A (1, J) 
                     TEMP = X (JX) 
                     DO 70, I = J + 1, MIN (N, J + K) 
                        X (IX) = X (IX) - TEMP * A (L + I, J) 
                        IX = IX + INCX 
   70                END DO 
                  ENDIF 
                  JX = JX + INCX 
   80          END DO 
            ENDIF 
         ENDIF 
      ELSE 
!                                                                       
!        Form  x := inv( A')*x.                                         
!                                                                       
         IF ( (UPLO.EQ.'U'.OR.UPLO.EQ.'u') ) THEN 
            KPLUS1 = K + 1 
            IF (INCX.EQ.1) THEN 
               DO 100, J = 1, N 
                  TEMP = X (J) 
                  L = KPLUS1 - J 
                  DO 90, I = MAX (1, J - K), J - 1 
                     TEMP = TEMP - A (L + I, J) * X (I) 
   90             END DO 
                  IF (NOUNIT) TEMP = TEMP / A (KPLUS1, J) 
                  X (J) = TEMP 
  100          END DO 
            ELSE 
               JX = KX 
               DO 120, J = 1, N 
                  TEMP = X (JX) 
                  IX = KX 
                  L = KPLUS1 - J 
                  DO 110, I = MAX (1, J - K), J - 1 
                     TEMP = TEMP - A (L + I, J) * X (IX) 
                     IX = IX + INCX 
  110             END DO 
                  IF (NOUNIT) TEMP = TEMP / A (KPLUS1, J) 
                  X (JX) = TEMP 
                  JX = JX + INCX 
                  IF (J.GT.K) KX = KX + INCX 
  120          END DO 
            ENDIF 
         ELSE 
            IF (INCX.EQ.1) THEN 
               DO 140, J = N, 1, - 1 
                  TEMP = X (J) 
                  L = 1 - J 
                  DO 130, I = MIN (N, J + K), J + 1, - 1 
                     TEMP = TEMP - A (L + I, J) * X (I) 
  130             END DO 
                  IF (NOUNIT) TEMP = TEMP / A (1, J) 
                  X (J) = TEMP 
  140          END DO 
            ELSE 
               KX = KX + (N - 1) * INCX 
               JX = KX 
               DO 160, J = N, 1, - 1 
                  TEMP = X (JX) 
                  IX = KX 
                  L = 1 - J 
                  DO 150, I = MIN (N, J + K), J + 1, - 1 
                     TEMP = TEMP - A (L + I, J) * X (IX) 
                     IX = IX - INCX 
  150             END DO 
                  IF (NOUNIT) TEMP = TEMP / A (1, J) 
                  X (JX) = TEMP 
                  JX = JX - INCX 
                  IF ( (N - J) .GE.K) KX = KX - INCX 
  160          END DO 
            ENDIF 
         ENDIF 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06PKF (DTBSV ).                                           
!                                                                       
      END SUBROUTINE F06PKF                         
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F06EDF (N, ALPHA, X, INCX) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.  

      IMPLICIT NONE
!     .. Entry Points ..                                                
      ENTRY DSCAL (N, ALPHA, X, INCX) 
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION ALPHA 
      INTEGER INCX, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION X ( * ) 
!     ..                                                                
!                                                                       
!  F06EDF performs the operation                                        
!                                                                       
!     x := alpha*x                                                      
!                                                                       
!                                                                       
!  Nag Fortran 77 version of the Blas routine DSCAL.                    
!  Nag Fortran 77 O( n ) basic linear algebra routine.                  
!                                                                       
!  -- Written on 26-November-1982.                                      
!     Sven Hammarling, Nag Central Office.                              
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
!     .. Local Scalars ..                                               
      INTEGER IX 
!     ..                                                                
!     .. Executable Statements ..                                       
      IF (N.GT.0) THEN 
         IF (ALPHA.EQ.ZERO) THEN 
            DO 10, IX = 1, 1 + (N - 1) * INCX, INCX 
               X (IX) = ZERO 
   10       END DO 
         ELSEIF (ALPHA.EQ. ( - ONE) ) THEN 
            DO 20, IX = 1, 1 + (N - 1) * INCX, INCX 
               X (IX) = - X (IX) 
   20       END DO 
         ELSEIF (ALPHA.NE.ONE) THEN 
            DO 30, IX = 1, 1 + (N - 1) * INCX, INCX 
               X (IX) = ALPHA * X (IX) 
   30       END DO 
         ENDIF 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06EDF. ( DSCAL )                                          
!                                                                       
      END SUBROUTINE F06EDF                         
                                                                        
      SUBROUTINE F06EFF (N, X, INCX, Y, INCY) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.     

      IMPLICIT NONE
!     .. Entry Points ..                                                
      ENTRY DCOPY (N, X, INCX, Y, INCY) 
!     .. Scalar Arguments ..                                            
      INTEGER INCX, INCY, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION X ( * ), Y ( * ) 
!     ..                                                                
!                                                                       
!  F06EFF performs the operation                                        
!                                                                       
!     y := x                                                            
!                                                                       
!                                                                       
!  Nag Fortran 77 version of the Blas routine DCOPY.                    
!  Nag Fortran 77 O( n ) basic linear algebra routine.                  
!                                                                       
!  -- Written on 26-November-1982.                                      
!     Sven Hammarling, Nag Central Office.                              
!                                                                       
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER I, IX, IY 
!     ..                                                                
!     .. Executable Statements ..                                       
      IF (N.GT.0) THEN 
         IF ( (INCX.EQ.INCY) .AND. (INCY.GT.0) ) THEN 
            DO 10, IY = 1, 1 + (N - 1) * INCY, INCY 
               Y (IY) = X (IY) 
   10       END DO 
         ELSE 
            IF (INCX.GE.0) THEN 
               IX = 1 
            ELSE 
               IX = 1 - (N - 1) * INCX 
            ENDIF 
            IF (INCY.GT.0) THEN 
               DO 20, IY = 1, 1 + (N - 1) * INCY, INCY 
                  Y (IY) = X (IX) 
                  IX = IX + INCX 
   20          END DO 
            ELSE 
               IY = 1 - (N - 1) * INCY 
               DO 30, I = 1, N 
                  Y (IY) = X (IX) 
                  IY = IY + INCY 
                  IX = IX + INCX 
   30          END DO 
            ENDIF 
         ENDIF 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06EFF. ( DCOPY )                                          
!                                                                       
      END SUBROUTINE F06EFF                         
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F06EGF (N, X, INCX, Y, INCY) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.  

      IMPLICIT NONE
!     .. Entry Points ..                                                
      ENTRY DSWAP (N, X, INCX, Y, INCY) 
!     .. Scalar Arguments ..                                            
      INTEGER INCX, INCY, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION X ( * ), Y ( * ) 
!     ..                                                                
!                                                                       
!  F06EGF performs the operations                                       
!                                                                       
!     temp := x,   x := y,   y := temp.                                 
!                                                                       
!                                                                       
!  Nag Fortran 77 version of the Blas routine DSWAP.                    
!  Nag Fortran 77 O( n ) basic linear algebra routine.                  
!                                                                       
!  -- Written on 26-November-1982.                                      
!     Sven Hammarling, Nag Central Office.                              
!                                                                       
!                                                                       
!     .. Local Scalars ..                                               
      DOUBLEPRECISION TEMP 
      INTEGER I, IX, IY 
!     ..                                                                
!     .. Executable Statements ..                                       
      IF (N.GT.0) THEN 
         IF ( (INCX.EQ.INCY) .AND. (INCY.GT.0) ) THEN 
            DO 10, IY = 1, 1 + (N - 1) * INCY, INCY 
               TEMP = X (IY) 
               X (IY) = Y (IY) 
               Y (IY) = TEMP 
   10       END DO 
         ELSE 
            IF (INCX.GE.0) THEN 
               IX = 1 
            ELSE 
               IX = 1 - (N - 1) * INCX 
            ENDIF 
            IF (INCY.GT.0) THEN 
               DO 20, IY = 1, 1 + (N - 1) * INCY, INCY 
                  TEMP = X (IX) 
                  X (IX) = Y (IY) 
                  Y (IY) = TEMP 
                  IX = IX + INCX 
   20          END DO 
            ELSE 
               IY = 1 - (N - 1) * INCY 
               DO 30, I = 1, N 
                  TEMP = X (IX) 
                  X (IX) = Y (IY) 
                  Y (IY) = TEMP 
                  IY = IY + INCY 
                  IX = IX + INCX 
   30          END DO 
            ENDIF 
         ENDIF 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06EGF. ( DSWAP )                                          
!                                                                       
      END SUBROUTINE F06EGF                         
                                                                        
                                                                        
                                                                        
                                                                        
      INTEGER FUNCTION F06JLF (N, X, INCX) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.                              
!     .. Entry Points ..                                                
      INTEGER IDAMAX 
      ENTRY IDAMAX (N, X, INCX) 
!     .. Scalar Arguments ..                                            
      INTEGER INCX, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION X ( * ) 
!     ..                                                                
!                                                                       
!  F06JLF returns the smallest value of i such that                     
!                                                                       
!     abs( x( i ) ) = max( abs( x( j ) ) )                              
!                      j                                                
!                                                                       
!                                                                       
!  Nag Fortran 77 version of the Blas routine IDAMAX.                   
!  Nag Fortran 77 O( n ) basic linear algebra routine.                  
!                                                                       
!  -- Written on 31-May-1983.                                           
!     Sven Hammarling, Nag Central Office.                              
!                                                                       
!                                                                       
!     .. Local Scalars ..                                               
      DOUBLEPRECISION XMAX 
      INTEGER I, IMAX, IX 
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
      IF (N.GT.0) THEN 
         IMAX = 1 
         IF (N.GT.1) THEN 
            XMAX = ABS (X (1) ) 
            IX = 1 
            DO 10, I = 2, N 
               IX = IX + INCX 
               IF (XMAX.LT.ABS (X (IX) ) ) THEN 
                  XMAX = ABS (X (IX) ) 
                  IMAX = I 
               ENDIF 
   10       END DO 
         ENDIF 
      ELSE 
         IMAX = 0 
      ENDIF 
!                                                                       
      F06JLF = IMAX 
      RETURN 
!                                                                       
!     End of F06JLF. ( IDAMAX )                                         
!                                                                       
      END FUNCTION F06JLF                           
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F06PMF (M, N, ALPHA, X, INCX, Y, INCY, A, LDA) 
!     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.            

      IMPLICIT NONE
!     .. Entry Points ..                                                
      ENTRY DGER (M, N, ALPHA, X, INCX, Y, INCY, A, LDA) 
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION ALPHA 
      INTEGER INCX, INCY, LDA, M, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), X ( * ), Y ( * ) 
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DGER   performs the rank 1 operation                                 
!                                                                       
!     A := alpha*x*y' + A,                                              
!                                                                       
!  where alpha is a scalar, x is an m element vector, y is an n element 
!  vector and A is an m by n matrix.                                    
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  M      - INTEGER.                                                    
!           On entry, M specifies the number of rows of the matrix A.   
!           M must be at least zero.                                    
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry, N specifies the number of columns of the matrix A.
!           N must be at least zero.                                    
!           Unchanged on exit.                                          
!                                                                       
!  ALPHA  - DOUBLE PRECISION.                                           
!           On entry, ALPHA specifies the scalar alpha.                 
!           Unchanged on exit.                                          
!                                                                       
!  X      - DOUBLE PRECISION array of dimension at least                
!           ( 1 + ( m - 1 )*abs( INCX ) ).                              
!           Before entry, the incremented array X must contain the m    
!           element vector x.                                           
!           Unchanged on exit.                                          
!                                                                       
!  INCX   - INTEGER.                                                    
!           On entry, INCX specifies the increment for the elements of  
!           X. INCX must not be zero.                                   
!           Unchanged on exit.                                          
!                                                                       
!  Y      - DOUBLE PRECISION array of dimension at least                
!           ( 1 + ( n - 1 )*abs( INCY ) ).                              
!           Before entry, the incremented array Y must contain the n    
!           element vector y.                                           
!           Unchanged on exit.                                          
!                                                                       
!  INCY   - INTEGER.                                                    
!           On entry, INCY specifies the increment for the elements of  
!           Y. INCY must not be zero.                                   
!           Unchanged on exit.                                          
!                                                                       
!  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).             
!           Before entry, the leading m by n part of the array A must   
!           contain the matrix of coefficients. On exit, A is           
!           overwritten by the updated matrix.                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program. LDA must be at least          
!           max( 1, m ).                                                
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 2 Blas routine.                                                
!                                                                       
!  -- Written on 22-October-1986.                                       
!     Jack Dongarra, Argonne National Lab.                              
!     Jeremy Du Croz, Nag Central Office.                               
!     Sven Hammarling, Nag Central Office.                              
!     Richard Hanson, Sandia National Labs.                             
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ZERO 
      PARAMETER (ZERO = 0.0D+0) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION TEMP 
      INTEGER I, INFO, IX, J, JY, KX 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (M.LT.0) THEN 
         INFO = 1 
      ELSEIF (N.LT.0) THEN 
         INFO = 2 
      ELSEIF (INCX.EQ.0) THEN 
         INFO = 5 
      ELSEIF (INCY.EQ.0) THEN 
         INFO = 7 
      ELSEIF (LDA.LT.MAX (1, M) ) THEN 
         INFO = 9 
      ENDIF 
      IF (INFO.NE.0) THEN 
      CALL F06AAZ ('F06PMF/DGER  ', INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ( (M.EQ.0) .OR. (N.EQ.0) .OR. (ALPHA.EQ.ZERO) ) RETURN 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
      IF (INCY.GT.0) THEN 
         JY = 1 
      ELSE 
         JY = 1 - (N - 1) * INCY 
      ENDIF 
      IF (INCX.EQ.1) THEN 
         DO 20, J = 1, N 
            IF (Y (JY) .NE.ZERO) THEN 
               TEMP = ALPHA * Y (JY) 
               DO 10, I = 1, M 
                  A (I, J) = A (I, J) + X (I) * TEMP 
   10          END DO 
            ENDIF 
            JY = JY + INCY 
   20    END DO 
      ELSE 
         IF (INCX.GT.0) THEN 
            KX = 1 
         ELSE 
            KX = 1 - (M - 1) * INCX 
         ENDIF 
         DO 40, J = 1, N 
            IF (Y (JY) .NE.ZERO) THEN 
               TEMP = ALPHA * Y (JY) 
               IX = KX 
               DO 30, I = 1, M 
                  A (I, J) = A (I, J) + X (IX) * TEMP 
                  IX = IX + INCX 
   30          END DO 
            ENDIF 
            JY = JY + INCY 
   40    END DO 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06PMF (DGER  ).                                           
!                                                                       
      END SUBROUTINE F06PMF                         
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F06YAF (TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB,&
      BETA, C, LDC)                                                     
!     MARK 14 RELEASE. NAG COPYRIGHT 1989.                              
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DGEMM  performs one of the matrix-matrix operations                  
!                                                                       
!     C := alpha*op( A )*op( B ) + beta*C,                              
!                                                                       
!  where  op( X ) is one of                                             
!                                                                       
!     op( X ) = X   or   op( X ) = X',                                  
!                                                                       
!  alpha and beta are scalars, and A, B and C are matrices, with op( A )
!  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  TRANSA - CHARACTER*1.                                                
!           On entry, TRANSA specifies the form of op( A ) to be used in
!           the matrix multiplication as follows:                       
!                                                                       
!              TRANSA = 'N' or 'n',  op( A ) = A.                       
!                                                                       
!              TRANSA = 'T' or 't',  op( A ) = A'.                      
!                                                                       
!              TRANSA = 'C' or 'c',  op( A ) = A'.                      
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  TRANSB - CHARACTER*1.                                                
!           On entry, TRANSB specifies the form of op( B ) to be used in
!           the matrix multiplication as follows:                       
!                                                                       
!              TRANSB = 'N' or 'n',  op( B ) = B.                       
!                                                                       
!              TRANSB = 'T' or 't',  op( B ) = B'.                      
!                                                                       
!              TRANSB = 'C' or 'c',  op( B ) = B'.                      
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  M      - INTEGER.                                                    
!           On entry,  M  specifies  the number  of rows  of the  matrix
!           op( A )  and of the  matrix  C.  M  must  be at least  zero.
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry,  N  specifies the number  of columns of the matrix
!           op( B ) and the number of columns of the matrix C. N must be
!           at least zero.                                              
!           Unchanged on exit.                                          
!                                                                       
!  K      - INTEGER.                                                    
!           On entry,  K  specifies  the number of columns of the matrix
!           op( A ) and the number of rows of the matrix op( B ). K must
!           be at least  zero.                                          
!           Unchanged on exit.                                          
!                                                                       
!  ALPHA  - REAL            .                                           
!           On entry, ALPHA specifies the scalar alpha.                 
!           Unchanged on exit.                                          
!                                                                       
!  A      - REAL             array of DIMENSION ( LDA, ka ), where ka is
!           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.        
!           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
!           part of the array  A  must contain the matrix  A,  otherwise
!           the leading  k by m  part of the array  A  must contain  the
!           matrix A.                                                   
!           Unchanged on exit.                                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program. When  TRANSA = 'N' or 'n' then
!           LDA must be at least  max( 1, m ), otherwise  LDA must be at
!           least  max( 1, k ).                                         
!           Unchanged on exit.                                          
!                                                                       
!  B      - REAL             array of DIMENSION ( LDB, kb ), where kb is
!           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.        
!           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
!           part of the array  B  must contain the matrix  B,  otherwise
!           the leading  n by k  part of the array  B  must contain  the
!           matrix B.                                                   
!           Unchanged on exit.                                          
!                                                                       
!  LDB    - INTEGER.                                                    
!           On entry, LDB specifies the first dimension of B as declared
!           in the calling (sub) program. When  TRANSB = 'N' or 'n' then
!           LDB must be at least  max( 1, k ), otherwise  LDB must be at
!           least  max( 1, n ).                                         
!           Unchanged on exit.                                          
!                                                                       
!  BETA   - REAL            .                                           
!           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
!           supplied as zero then C need not be set on input.           
!           Unchanged on exit.                                          
!                                                                       
!  C      - REAL             array of DIMENSION ( LDC, n ).             
!           Before entry, the leading  m by n  part of the array  C must
!           contain the matrix  C,  except when  beta  is zero, in which
!           case C need not be set on entry.                            
!           On exit, the array  C  is overwritten by the  m by n  matrix
!           ( alpha*op( A )*op( B ) + beta*C ).                         
!                                                                       
!  LDC    - INTEGER.                                                    
!           On entry, LDC specifies the first dimension of C as declared
!           in  the  calling  (sub)  program.   LDC  must  be  at  least
!           max( 1, m ).                                                
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 3 Blas routine.                                                
!                                                                       
!  -- Written on 8-February-1989.                                       
!     Jack Dongarra, Argonne National Laboratory.                       
!     Iain Duff, AERE Harwell.                                          
!     Jeremy Du Croz, Numerical Algorithms Group Ltd.                   
!     Sven Hammarling, Numerical Algorithms Group Ltd.                  
!                                                                       
!        
      IMPLICIT NONE 
!     .. Entry Points ..                                                
      ENTRY DGEMM (TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA,&
      C, LDC)                                                           
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION ALPHA, BETA 
      INTEGER K, LDA, LDB, LDC, M, N 
      CHARACTER(1) TRANSA, TRANSB 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), B (LDB, * ), C (LDC, * ) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION TEMP 
      INTEGER I, INFO, J, L, NCOLA, NROWA, NROWB 
      LOGICAL NOTA, NOTB 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     .. Executable Statements ..                                       
!                                                                       
!     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
!     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
!     and  columns of  A  and the  number of  rows  of  B  respectively.
!                                                                       
      NOTA = (TRANSA.EQ.'N'.OR.TRANSA.EQ.'n') 
      NOTB = (TRANSB.EQ.'N'.OR.TRANSB.EQ.'n') 
      IF (NOTA) THEN 
         NROWA = M 
         NCOLA = K 
      ELSE 
         NROWA = K 
         NCOLA = M 
      ENDIF 
      IF (NOTB) THEN 
         NROWB = K 
      ELSE 
         NROWB = N 
      ENDIF 
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF ( (.NOT.NOTA) .AND. (.NOT. (TRANSA.EQ.'C'.OR.TRANSA.EQ.'c') )  &
      .AND. (.NOT. (TRANSA.EQ.'T'.OR.TRANSA.EQ.'t') ) ) THEN            
         INFO = 1 
      ELSEIF ( (.NOT.NOTB) .AND. (.NOT. (TRANSB.EQ.'C'.OR.TRANSB.EQ.'c')&
      ) .AND. (.NOT. (TRANSB.EQ.'T'.OR.TRANSB.EQ.'t') ) ) THEN          
         INFO = 2 
      ELSEIF (M.LT.0) THEN 
         INFO = 3 
      ELSEIF (N.LT.0) THEN 
         INFO = 4 
      ELSEIF (K.LT.0) THEN 
         INFO = 5 
      ELSEIF (LDA.LT.MAX (1, NROWA) ) THEN 
         INFO = 8 
      ELSEIF (LDB.LT.MAX (1, NROWB) ) THEN 
         INFO = 10 
      ELSEIF (LDC.LT.MAX (1, M) ) THEN 
         INFO = 13 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F06YAF/DGEMM ', INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ( (M.EQ.0) .OR. (N.EQ.0) .OR. ( ( (ALPHA.EQ.ZERO) .OR. (K.EQ.0)&
      ) .AND. (BETA.EQ.ONE) ) ) RETURN                                  
!                                                                       
!     And if  alpha.eq.zero.                                            
!                                                                       
      IF (ALPHA.EQ.ZERO) THEN 
         IF (BETA.EQ.ZERO) THEN 
            DO 40 J = 1, N 
               DO 20 I = 1, M 
                  C (I, J) = ZERO 
   20          END DO 
   40       END DO 
         ELSE 
            DO 80 J = 1, N 
               DO 60 I = 1, M 
                  C (I, J) = BETA * C (I, J) 
   60          END DO 
   80       END DO 
         ENDIF 
         RETURN 
      ENDIF 
!                                                                       
!     Start the operations.                                             
!                                                                       
      IF (NOTB) THEN 
         IF (NOTA) THEN 
!                                                                       
!           Form  C := alpha*A*B + beta*C.                              
!                                                                       
            DO 180 J = 1, N 
               IF (BETA.EQ.ZERO) THEN 
                  DO 100 I = 1, M 
                     C (I, J) = ZERO 
  100             END DO 
               ELSEIF (BETA.NE.ONE) THEN 
                  DO 120 I = 1, M 
                     C (I, J) = BETA * C (I, J) 
  120             END DO 
               ENDIF 
               DO 160 L = 1, K 
                  IF (B (L, J) .NE.ZERO) THEN 
                     TEMP = ALPHA * B (L, J) 
                     DO 140 I = 1, M 
                        C (I, J) = C (I, J) + TEMP * A (I, L) 
  140                END DO 
                  ENDIF 
  160          END DO 
  180       END DO 
         ELSE 
!                                                                       
!           Form  C := alpha*A'*B + beta*C                              
!                                                                       
            DO 240 J = 1, N 
               DO 220 I = 1, M 
                  TEMP = ZERO 
                  DO 200 L = 1, K 
                     TEMP = TEMP + A (L, I) * B (L, J) 
  200             END DO 
                  IF (BETA.EQ.ZERO) THEN 
                     C (I, J) = ALPHA * TEMP 
                  ELSE 
                     C (I, J) = ALPHA * TEMP + BETA * C (I, J) 
                  ENDIF 
  220          END DO 
  240       END DO 
         ENDIF 
      ELSE 
         IF (NOTA) THEN 
!                                                                       
!           Form  C := alpha*A*B' + beta*C                              
!                                                                       
            DO 340 J = 1, N 
               IF (BETA.EQ.ZERO) THEN 
                  DO 260 I = 1, M 
                     C (I, J) = ZERO 
  260             END DO 
               ELSEIF (BETA.NE.ONE) THEN 
                  DO 280 I = 1, M 
                     C (I, J) = BETA * C (I, J) 
  280             END DO 
               ENDIF 
               DO 320 L = 1, K 
                  IF (B (J, L) .NE.ZERO) THEN 
                     TEMP = ALPHA * B (J, L) 
                     DO 300 I = 1, M 
                        C (I, J) = C (I, J) + TEMP * A (I, L) 
  300                END DO 
                  ENDIF 
  320          END DO 
  340       END DO 
         ELSE 
!                                                                       
!           Form  C := alpha*A'*B' + beta*C                             
!                                                                       
            DO 400 J = 1, N 
               DO 380 I = 1, M 
                  TEMP = ZERO 
                  DO 360 L = 1, K 
                     TEMP = TEMP + A (L, I) * B (J, L) 
  360             END DO 
                  IF (BETA.EQ.ZERO) THEN 
                     C (I, J) = ALPHA * TEMP 
                  ELSE 
                     C (I, J) = ALPHA * TEMP + BETA * C (I, J) 
                  ENDIF 
  380          END DO 
  400       END DO 
         ENDIF 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06YAF (DGEMM ).                                           
!                                                                       
      END SUBROUTINE F06YAF                         
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F06YJF (SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, &
      B, LDB)                                                           
!     MARK 14 RELEASE. NAG COPYRIGHT 1989.                              
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DTRSM  solves one of the matrix equations                            
!                                                                       
!     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,                  
!                                                                       
!  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
!  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
!                                                                       
!     op( A ) = A   or   op( A ) = A'.                                  
!                                                                       
!  The matrix X is overwritten on B.                                    
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  SIDE   - CHARACTER*1.                                                
!           On entry, SIDE specifies whether op( A ) appears on the left
!           or right of X as follows:                                   
!                                                                       
!              SIDE = 'L' or 'l'   op( A )*X = alpha*B.                 
!                                                                       
!              SIDE = 'R' or 'r'   X*op( A ) = alpha*B.                 
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  UPLO   - CHARACTER*1.                                                
!           On entry, UPLO specifies whether the matrix A is an upper or
!           lower triangular matrix as follows:                         
!                                                                       
!              UPLO = 'U' or 'u'   A is an upper triangular matrix.     
!                                                                       
!              UPLO = 'L' or 'l'   A is a lower triangular matrix.      
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  TRANSA - CHARACTER*1.                                                
!           On entry, TRANSA specifies the form of op( A ) to be used in
!           the matrix multiplication as follows:                       
!                                                                       
!              TRANSA = 'N' or 'n'   op( A ) = A.                       
!                                                                       
!              TRANSA = 'T' or 't'   op( A ) = A'.                      
!                                                                       
!              TRANSA = 'C' or 'c'   op( A ) = A'.                      
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  DIAG   - CHARACTER*1.                                                
!           On entry, DIAG specifies whether or not A is unit triangular
!           as follows:                                                 
!                                                                       
!              DIAG = 'U' or 'u'   A is assumed to be unit triangular.  
!                                                                       
!              DIAG = 'N' or 'n'   A is not assumed to be unit          
!                                  triangular.                          
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  M      - INTEGER.                                                    
!           On entry, M specifies the number of rows of B. M must be at 
!           least zero.                                                 
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry, N specifies the number of columns of B.  N must be
!           at least zero.                                              
!           Unchanged on exit.                                          
!                                                                       
!  ALPHA  - REAL            .                                           
!           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
!           zero then  A is not referenced and  B need not be set before
!           entry.                                                      
!           Unchanged on exit.                                          
!                                                                       
!  A      - REAL             array of DIMENSION ( LDA, k ), where k is m
!           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
!           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
!           upper triangular part of the array  A must contain the upper
!           triangular matrix  and the strictly lower triangular part of
!           A is not referenced.                                        
!           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
!           lower triangular part of the array  A must contain the lower
!           triangular matrix  and the strictly upper triangular part of
!           A is not referenced.                                        
!           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
!           A  are not referenced either,  but are assumed to be  unity.
!           Unchanged on exit.                                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
!           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
!           then LDA must be at least max( 1, n ).                      
!           Unchanged on exit.                                          
!                                                                       
!  B      - REAL             array of DIMENSION ( LDB, n ).             
!           Before entry,  the leading  m by n part of the array  B must
!           contain  the  right-hand  side  matrix  B,  and  on exit  is
!           overwritten by the solution matrix  X.                      
!                                                                       
!  LDB    - INTEGER.                                                    
!           On entry, LDB specifies the first dimension of B as declared
!           in  the  calling  (sub)  program.   LDB  must  be  at  least
!           max( 1, m ).                                                
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 3 Blas routine.                                                
!                                                                       
!                                                                       
!  -- Written on 8-February-1989.                                       
!     Jack Dongarra, Argonne National Laboratory.                       
!     Iain Duff, AERE Harwell.                                          
!     Jeremy Du Croz, Numerical Algorithms Group Ltd.                   
!     Sven Hammarling, Numerical Algorithms Group Ltd.                  
!                 
      IMPLICIT NONE
!                                                                       
!     .. Entry Points ..                                                
      ENTRY DTRSM (SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B,    &
      LDB)                                                              
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION ALPHA 
      INTEGER LDA, LDB, M, N 
      CHARACTER(1) DIAG, SIDE, TRANSA, UPLO 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), B (LDB, * ) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION TEMP 
      INTEGER I, INFO, J, K, NROWA 
      LOGICAL LSIDE, NOUNIT, UPPER 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      LSIDE = (SIDE.EQ.'L'.OR.SIDE.EQ.'l') 
      IF (LSIDE) THEN 
         NROWA = M 
      ELSE 
         NROWA = N 
      ENDIF 
      NOUNIT = (DIAG.EQ.'N'.OR.DIAG.EQ.'n') 
      UPPER = (UPLO.EQ.'U'.OR.UPLO.EQ.'u') 
!                                                                       
      INFO = 0 
      IF ( (.NOT.LSIDE) .AND. (.NOT. (SIDE.EQ.'R'.OR.SIDE.EQ.'r') ) )   &
      THEN                                                              
         INFO = 1 
      ELSEIF ( (.NOT.UPPER) .AND. (.NOT. (UPLO.EQ.'L'.OR.UPLO.EQ.'l') ) &
      ) THEN                                                            
         INFO = 2 
      ELSEIF ( (.NOT. (TRANSA.EQ.'N'.OR.TRANSA.EQ.'n') ) .AND. (.NOT. ( &
      TRANSA.EQ.'T'.OR.TRANSA.EQ.'t') ) .AND. (.NOT. (                  &
      TRANSA.EQ.'C'.OR.TRANSA.EQ.'c') ) ) THEN                          
         INFO = 3 
      ELSEIF ( (.NOT. (DIAG.EQ.'U'.OR.DIAG.EQ.'u') ) .AND. (.NOT. (     &
      DIAG.EQ.'N'.OR.DIAG.EQ.'n') ) ) THEN                              
         INFO = 4 
      ELSEIF (M.LT.0) THEN 
         INFO = 5 
      ELSEIF (N.LT.0) THEN 
         INFO = 6 
      ELSEIF (LDA.LT.MAX (1, NROWA) ) THEN 
         INFO = 9 
      ELSEIF (LDB.LT.MAX (1, M) ) THEN 
         INFO = 11 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F06YJF/DTRSM ', INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF (N.EQ.0) RETURN 
!                                                                       
!     And when  alpha.eq.zero.                                          
!                                                                       
      IF (ALPHA.EQ.ZERO) THEN 
         DO 40 J = 1, N 
            DO 20 I = 1, M 
               B (I, J) = ZERO 
   20       END DO 
   40    END DO 
         RETURN 
      ENDIF 
!                                                                       
!     Start the operations.                                             
!                                                                       
      IF (LSIDE) THEN 
         IF ( (TRANSA.EQ.'N'.OR.TRANSA.EQ.'n') ) THEN 
!                                                                       
!           Form  B := alpha*inv( A )*B.                                
!                                                                       
            IF (UPPER) THEN 
               DO 120 J = 1, N 
                  IF (ALPHA.NE.ONE) THEN 
                     DO 60 I = 1, M 
                        B (I, J) = ALPHA * B (I, J) 
   60                END DO 
                  ENDIF 
                  DO 100 K = M, 1, - 1 
                     IF (B (K, J) .NE.ZERO) THEN 
                        IF (NOUNIT) B (K, J) = B (K, J) / A (K, K) 
                        DO 80 I = 1, K - 1 
                           B (I, J) = B (I, J) - B (K, J) * A (I, K) 
   80                   END DO 
                     ENDIF 
  100             END DO 
  120          END DO 
            ELSE 
               DO 200 J = 1, N 
                  IF (ALPHA.NE.ONE) THEN 
                     DO 140 I = 1, M 
                        B (I, J) = ALPHA * B (I, J) 
  140                END DO 
                  ENDIF 
                  DO 180 K = 1, M 
                     IF (B (K, J) .NE.ZERO) THEN 
                        IF (NOUNIT) B (K, J) = B (K, J) / A (K, K) 
                        DO 160 I = K + 1, M 
                           B (I, J) = B (I, J) - B (K, J) * A (I, K) 
  160                   END DO 
                     ENDIF 
  180             END DO 
  200          END DO 
            ENDIF 
         ELSE 
!                                                                       
!           Form  B := alpha*inv( A' )*B.                               
!                                                                       
            IF (UPPER) THEN 
               DO 260 J = 1, N 
                  DO 240 I = 1, M 
                     TEMP = ALPHA * B (I, J) 
                     DO 220 K = 1, I - 1 
                        TEMP = TEMP - A (K, I) * B (K, J) 
  220                END DO 
                     IF (NOUNIT) TEMP = TEMP / A (I, I) 
                     B (I, J) = TEMP 
  240             END DO 
  260          END DO 
            ELSE 
               DO 320 J = 1, N 
                  DO 300 I = M, 1, - 1 
                     TEMP = ALPHA * B (I, J) 
                     DO 280 K = I + 1, M 
                        TEMP = TEMP - A (K, I) * B (K, J) 
  280                END DO 
                     IF (NOUNIT) TEMP = TEMP / A (I, I) 
                     B (I, J) = TEMP 
  300             END DO 
  320          END DO 
            ENDIF 
         ENDIF 
      ELSE 
         IF ( (TRANSA.EQ.'N'.OR.TRANSA.EQ.'n') ) THEN 
!                                                                       
!           Form  B := alpha*B*inv( A ).                                
!                                                                       
            IF (UPPER) THEN 
               DO 420 J = 1, N 
                  IF (ALPHA.NE.ONE) THEN 
                     DO 340 I = 1, M 
                        B (I, J) = ALPHA * B (I, J) 
  340                END DO 
                  ENDIF 
                  DO 380 K = 1, J - 1 
                     IF (A (K, J) .NE.ZERO) THEN 
                        DO 360 I = 1, M 
                           B (I, J) = B (I, J) - A (K, J) * B (I, K) 
  360                   END DO 
                     ENDIF 
  380             END DO 
                  IF (NOUNIT) THEN 
                     TEMP = ONE / A (J, J) 
                     DO 400 I = 1, M 
                        B (I, J) = TEMP * B (I, J) 
  400                END DO 
                  ENDIF 
  420          END DO 
            ELSE 
               DO 520 J = N, 1, - 1 
                  IF (ALPHA.NE.ONE) THEN 
                     DO 440 I = 1, M 
                        B (I, J) = ALPHA * B (I, J) 
  440                END DO 
                  ENDIF 
                  DO 480 K = J + 1, N 
                     IF (A (K, J) .NE.ZERO) THEN 
                        DO 460 I = 1, M 
                           B (I, J) = B (I, J) - A (K, J) * B (I, K) 
  460                   END DO 
                     ENDIF 
  480             END DO 
                  IF (NOUNIT) THEN 
                     TEMP = ONE / A (J, J) 
                     DO 500 I = 1, M 
                        B (I, J) = TEMP * B (I, J) 
  500                END DO 
                  ENDIF 
  520          END DO 
            ENDIF 
         ELSE 
!                                                                       
!           Form  B := alpha*B*inv( A' ).                               
!                                                                       
            IF (UPPER) THEN 
               DO 620 K = N, 1, - 1 
                  IF (NOUNIT) THEN 
                     TEMP = ONE / A (K, K) 
                     DO 540 I = 1, M 
                        B (I, K) = TEMP * B (I, K) 
  540                END DO 
                  ENDIF 
                  DO 580 J = 1, K - 1 
                     IF (A (J, K) .NE.ZERO) THEN 
                        TEMP = A (J, K) 
                        DO 560 I = 1, M 
                           B (I, J) = B (I, J) - TEMP * B (I, K) 
  560                   END DO 
                     ENDIF 
  580             END DO 
                  IF (ALPHA.NE.ONE) THEN 
                     DO 600 I = 1, M 
                        B (I, K) = ALPHA * B (I, K) 
  600                END DO 
                  ENDIF 
  620          END DO 
            ELSE 
               DO 720 K = 1, N 
                  IF (NOUNIT) THEN 
                     TEMP = ONE / A (K, K) 
                     DO 640 I = 1, M 
                        B (I, K) = TEMP * B (I, K) 
  640                END DO 
                  ENDIF 
                  DO 680 J = K + 1, N 
                     IF (A (J, K) .NE.ZERO) THEN 
                        TEMP = A (J, K) 
                        DO 660 I = 1, M 
                           B (I, J) = B (I, J) - TEMP * B (I, K) 
  660                   END DO 
                     ENDIF 
  680             END DO 
                  IF (ALPHA.NE.ONE) THEN 
                     DO 700 I = 1, M 
                        B (I, K) = ALPHA * B (I, K) 
  700                END DO 
                  ENDIF 
  720          END DO 
            ENDIF 
         ENDIF 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06YJF (DTRSM ).                                           
!                                                                       
      END SUBROUTINE F06YJF                         
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
      DOUBLEPRECISION FUNCTION F06EAF (N, X, INCX, Y, INCY) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.                              
!     .. Entry Points ..                                                
      DOUBLEPRECISION DDOT 
      ENTRY DDOT (N, X, INCX, Y, INCY) 
!     .. Scalar Arguments ..                                            
      INTEGER INCX, INCY, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION X ( * ), Y ( * ) 
!     ..                                                                
!                                                                       
!  F06EAF returns the value                                             
!                                                                       
!     F06EAF = x'y                                                      
!                                                                       
!                                                                       
!  Nag Fortran 77 version of the Blas routine DDOT.                     
!  Nag Fortran 77 O( n ) basic linear algebra routine.                  
!                                                                       
!  -- Written on 21-September-1982.                                     
!     Sven Hammarling, Nag Central Office.                              
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ZERO 
      PARAMETER (ZERO = 0.0D+0) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION SUM 
      INTEGER I, IX, IY 
!     ..                                                                
!     .. Executable Statements ..                                       
      SUM = ZERO 
      IF (N.GT.0) THEN 
         IF ( (INCX.EQ.INCY) .AND. (INCX.GT.0) ) THEN 
            DO 10, IX = 1, 1 + (N - 1) * INCX, INCX 
               SUM = SUM + X (IX) * Y (IX) 
   10       END DO 
         ELSE 
            IF (INCY.GE.0) THEN 
               IY = 1 
            ELSE 
               IY = 1 - (N - 1) * INCY 
            ENDIF 
            IF (INCX.GT.0) THEN 
               DO 20, IX = 1, 1 + (N - 1) * INCX, INCX 
                  SUM = SUM + X (IX) * Y (IY) 
                  IY = IY + INCY 
   20          END DO 
            ELSE 
               IX = 1 - (N - 1) * INCX 
               DO 30, I = 1, N 
                  SUM = SUM + X (IX) * Y (IY) 
                  IX = IX + INCX 
                  IY = IY + INCY 
   30          END DO 
            ENDIF 
         ENDIF 
      ENDIF 
!                                                                       
      F06EAF = SUM 
      RETURN 
!                                                                       
!     End of F06EAF. ( DDOT )                                           
!                                                                       
      END FUNCTION F06EAF                           
                                                                        
                                                                        
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
                                                                        
                                                                        
                                                                        
      SUBROUTINE F07ADF (M, N, A, LDA, IPIV, INFO) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991. 

      IMPLICIT NONE
!     .. Entry Points ..                                                
      ENTRY DGETRF (M, N, A, LDA, IPIV, INFO) 
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DGETRF computes an LU factorization of a general m-by-n matrix A     
!  using partial pivoting with row interchanges.                        
!                                                                       
!  The factorization has the form                                       
!     A = P * L * U                                                     
!  where P is a permutation matrix, L is lower triangular with unit     
!  diagonal elements (lower trapezoidal if m > n), and U is upper       
!  triangular (upper trapezoidal if m < n).                             
!                                                                       
!  This is the Level 3 BLAS version of the Crout algorithm.             
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M >= 0.                 
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N >= 0.              
!                                                                       
!  A       (input/output) REAL array, dimension (LDA,N)                 
!          On entry, the m by n matrix to be factored.                  
!          On exit, the factors L and U from the factorization          
!          A = P*L*U; the unit diagonal elements of L are not stored.   
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA >= max(1,M).      
!                                                                       
!  IPIV    (output) INTEGER array, dimension (min(M,N))                 
!          The pivot indices; for 1 <= i <= min(M,N), row i of the      
!          matrix was interchanged with row IPIV(i).                    
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          < 0: if INFO = -k, the k-th argument had an illegal value    
!          > 0: if INFO = k, U(k,k) is exactly zero. The factorization  
!               has been completed, but the factor U is exactly         
!               singular, and division by zero will occur if it is used 
!               to solve a system of equations.                         
!                                                                       
!  -- LAPACK routine (adapted for NAG Library)                          
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE 
      PARAMETER (ONE = 1.0D+0) 
!     .. Scalar Arguments ..                                            
      INTEGER INFO, LDA, M, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ) 
      INTEGER IPIV ( * ) 
!     .. Local Scalars ..                                               
      INTEGER I, IINFO, J, JB, NB 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ, F07ADY, F07ADZ, F07ZAZ, DGEMM, DTRSM 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX, MIN 
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (M.LT.0) THEN 
         INFO = - 1 
      ELSEIF (N.LT.0) THEN 
         INFO = - 2 
      ELSEIF (LDA.LT.MAX (1, M) ) THEN 
         INFO = - 4 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F07ADF/DGETRF', - INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF (M.EQ.0.OR.N.EQ.0) RETURN 
!                                                                       
!     Determine the block size for this environment.                    
!                                                                       
      CALL F07ZAZ (1, 'F07ADF', NB, 0) 
      IF (NB.LE.1) THEN 
!                                                                       
!        Use unblocked code.                                            
!                                                                       
         CALL F07ADZ (M, N, A, LDA, IPIV, INFO) 
      ELSE 
!                                                                       
!        Use blocked code.                                              
!                                                                       
         DO 40 J = 1, MIN (M, N), NB 
            JB = MIN (MIN (M, N) - J + 1, NB) 
!                                                                       
!           Update diagonal and subdiagonal blocks.                     
!                                                                       
            CALL DGEMM ('No transpose', 'No transpose', M - J + 1, JB,  &
            J - 1, - ONE, A (J, 1) , LDA, A (1, J) , LDA, ONE, A (J, J) &
            , LDA)                                                      
!                                                                       
!           Factorize diagonal and subdiagonal blocks and test for      
!           singularity.                                                
!                                                                       
            CALL F07ADZ (M - J + 1, JB, A (J, J), LDA, IPIV (J),        &
            IINFO)                                                      
!                                                                       
!           Update pivot indices and apply the interchanges to the      
!           columns on either side of the current block.                
!                                                                       
            DO 20 I = J, MIN (M, J + JB - 1) 
               IPIV (I) = J - 1 + IPIV (I) 
   20       END DO 
            CALL F07ADY (J - 1, A, LDA, J, J + JB - 1, IPIV, 1) 
            CALL F07ADY (N - J - JB + 1, A (1, J + JB), LDA, J, J + JB -&
            1, IPIV, 1)                                                 
!                                                                       
            IF (INFO.EQ.0.AND.IINFO.GT.0) INFO = IINFO + J - 1 
!                                                                       
            IF (J + JB.LE.N) THEN 
!                                                                       
!              Compute block row of U.                                  
!                                                                       
               CALL DGEMM ('No transpose', 'No transpose', JB, N - J -  &
               JB + 1, J - 1, - ONE, A (J, 1) , LDA, A (1, J + JB) ,    &
               LDA, ONE, A (J, J + JB) , LDA)                           
               CALL DTRSM ('Left', 'Lower', 'No transpose', 'Unit', JB, &
               N - J - JB + 1, ONE, A (J, J) , LDA, A (J, J + JB) , LDA)
            ENDIF 
   40    END DO 
      ENDIF 
      RETURN 
!                                                                       
!     End of F07ADF (DGETRF)                                            
!                                                                       
      END SUBROUTINE F07ADF                         
                                                                        
                                                                        
                                                                        
      SUBROUTINE F07AJF (N, A, LDA, IPIV, WORK, LWORK, INFO) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.
      IMPLICIT NONE
!     .. Entry Points ..                                                
      ENTRY DGETRI (N, A, LDA, IPIV, WORK, LWORK, INFO) 
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DGETRI computes the inverse of a matrix using the LU factorization   
!  computed by F07ADF.                                                  
!                                                                       
!  This method inverts U and then computes inv(A) by solving the system 
!  inv(A)*L = inv(U) for inv(A).                                        
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  N       (input) INTEGER                                              
!          The order of the matrix A.  N >= 0.                          
!                                                                       
!  A       (input/output) REAL array, dimension (LDA,N)                 
!          On entry, the factors L and U from the factorization         
!          A = P*L*U as computed by F07ADF.                             
!          On exit, if INFO = 0, the inverse of the original matrix A.  
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA >= max(1,N).      
!                                                                       
!  IPIV    (input) INTEGER array, dimension (N)                         
!          The pivot indices from F07ADF; for 1<=i<=N, row i of the     
!          matrix was interchanged with row IPIV(i).                    
!                                                                       
!  WORK    (workspace) REAL array, dimension (LWORK)                    
!          If INFO returns 0, then WORK(1) returns the minimum          
!          value of LWORK required for optimal performance.             
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The dimension of the array WORK.  LWORK >= max(N,1).         
!          For optimal performance LWORK should be at least N*NB,       
!          where NB is the optimal blocksize returned by F07ZAZ.        
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          < 0: if INFO = -k, the k-th argument had an illegal value    
!          > 0: if INFO = k, U(k,k) is exactly zero; the matrix is      
!               singular and its inverse could not be computed.         
!                                                                       
!  -- LAPACK routine (adapted for NAG Library)                          
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ZERO, ONE 
      PARAMETER (ZERO = 0.0D+0, ONE = 1.0D+0) 
!     .. Scalar Arguments ..                                            
      INTEGER INFO, LDA, LWORK, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), WORK (LWORK) 
      INTEGER IPIV ( * ) 
!     .. Local Scalars ..                                               
      INTEGER I, IWS, J, JB, JJ, JP, LDWORK, NB, NBMIN, NN 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ, F07TJF, F07ZAZ, DGEMM, DGEMV, DSWAP, DTRSM 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX, MIN 
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      WORK (1) = MAX (N, 1) 
      IF (N.LT.0) THEN 
         INFO = - 1 
      ELSEIF (LDA.LT.MAX (1, N) ) THEN 
         INFO = - 3 
      ELSEIF (LWORK.LT.N) THEN 
         INFO = - 6 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F07AJF/DGETRI', - INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF (N.EQ.0) THEN 
         WORK (1) = 1 
         RETURN 
      ENDIF 
!                                                                       
!     Form inv(U).  If INFO > 0 from F07TJF, then U is singular,        
!     and the inverse is not computed.                                  
!                                                                       
      CALL F07TJF ('Upper', 'Non-unit', N, A, LDA, INFO) 
      IF (INFO.GT.0) RETURN 
!                                                                       
!     Determine the block size for this environment.                    
!                                                                       
      CALL F07ZAZ (1, 'F07AJF', NB, 0) 
      IF (NB.LE.1) NB = N 
!                                                                       
      IF (NB.LT.N) THEN 
         LDWORK = N 
!                                                                       
!        Determine if workspace is large enough for blocked code        
!                                                                       
         IWS = N * NB 
         IF (LWORK.LT.IWS) THEN 
!                                                                       
!           Not enough workspace has been supplied to use the optimal   
!           value of NB: determine the minimum value of NB, and reduce  
!           NB or force use of unblocked code                           
!                                                                       
            CALL F07ZAZ (2, 'F07AJF', NBMIN, 0) 
            NBMIN = MAX (2, NBMIN) 
!                                                                       
            IF (LWORK.GE.N * NBMIN) THEN 
               NB = LWORK / N 
            ELSE 
               NB = N 
            ENDIF 
         ENDIF 
      ELSE 
         IWS = N 
      ENDIF 
!                                                                       
!     Solve the equation inv(A)*L = inv(U) for inv(A).                  
!                                                                       
      IF (NB.GE.N) THEN 
!                                                                       
!        Use unblocked code.                                            
!                                                                       
         DO 40 J = N, 1, - 1 
!                                                                       
!           Copy current column of L to WORK and replace with zeros.    
!                                                                       
            DO 20 I = J + 1, N 
               WORK (I) = A (I, J) 
               A (I, J) = ZERO 
   20       END DO 
!                                                                       
!           Compute current column of inv(A).                           
!                                                                       
            IF (J.LT.N) CALL DGEMV ('No transpose', N, N - J, - ONE, A (&
            1, J + 1) , LDA, WORK (J + 1) , 1, ONE, A (1, J) , 1)       
   40    END DO 
      ELSE 
!                                                                       
!        Use blocked code.                                              
!                                                                       
         NN = ( (N - 1) / NB) * NB + 1 
         DO 100 J = NN, 1, - NB 
            JB = MIN (NB, N - J + 1) 
!                                                                       
!           Copy current block column of L to WORK and replace with     
!           zeros.                                                      
!                                                                       
            DO 80 JJ = J, J + JB - 1 
               DO 60 I = JJ + 1, N 
                  WORK (I + (JJ - J) * LDWORK) = A (I, JJ) 
                  A (I, JJ) = ZERO 
   60          END DO 
   80       END DO 
!                                                                       
!           Compute current block column of inv(A).                     
!                                                                       
            IF (J + JB.LE.N) CALL DGEMM ('No transpose', 'No transpose',&
            N, JB, N - J - JB + 1, - ONE, A (1, J + JB) , LDA, WORK (J +&
            JB) , LDWORK, ONE, A (1, J) , LDA)                          
            CALL DTRSM ('Right', 'Lower', 'No transpose', 'Unit', N, JB,&
            ONE, WORK (J) , LDWORK, A (1, J) , LDA)                     
  100    END DO 
      ENDIF 
!                                                                       
!     Apply column interchanges.                                        
!                                                                       
      DO 120 J = N - 1, 1, - 1 
         JP = IPIV (J) 
         IF (JP.NE.J) CALL DSWAP (N, A (1, J), 1, A (1, JP), 1) 
  120 END DO 
!                                                                       
      WORK (1) = IWS 
      RETURN 
!                                                                       
!     End of F07AJF (DGETRI)                                            
!                                                                       
      END SUBROUTINE F07AJF                         
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F07ADZ (M, N, A, LDA, IPIV, INFO) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.                              
!     ENTRY             DGETF2(M,N,A,LDA,IPIV,INFO)                     
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DGETF2 computes an LU factorization of a general m-by-n matrix A     
!  using partial pivoting with row interchanges.                        
!                                                                       
!  The factorization has the form                                       
!     A = P * L * U                                                     
!  where P is a permutation matrix, L is lower triangular with unit     
!  diagonal elements (lower trapezoidal if m > n), and U is upper       
!  triangular (upper trapezoidal if m < n).                             
!                                                                       
!  This is the Level 2 BLAS version of the Crout algorithm.             
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M >= 0.                 
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N >= 0.              
!                                                                       
!  A       (input/output) REAL array, dimension (LDA,N)                 
!          On entry, the m by n matrix to be factored.                  
!          On exit, the factors L and U from the factorization          
!          A = P*L*U; the unit diagonal elements of L are not stored.   
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA >= max(1,M).      
!                                                                       
!  IPIV    (output) INTEGER array, dimension (min(M,N))                 
!          The pivot indices; for 1 <= i <= min(M,N), row i of the      
!          matrix was interchanged with row IPIV(i).                    
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          < 0: if INFO = -k, the k-th argument had an illegal value    
!          > 0: if INFO = k, U(k,k) is exactly zero. The factorization  
!               has been completed, but the factor U is exactly         
!               singular, and division by zero will occur if it is used 
!               to solve a system of equations.                         
!                                                                       
!  -- LAPACK routine (adapted for NAG Library)                          
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!                                                                       
!  =====================================================================
!         
      IMPLICIT NONE
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
!     .. Scalar Arguments ..                                            
      INTEGER INFO, LDA, M, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ) 
      INTEGER IPIV ( * ) 
!     .. Local Scalars ..                                               
      INTEGER J, JP 
!     .. External Functions ..                                          
      INTEGER IDAMAX 
      EXTERNAL IDAMAX 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ, DGEMV, DSCAL, DSWAP 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX, MIN 
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (M.LT.0) THEN 
         INFO = - 1 
      ELSEIF (N.LT.0) THEN 
         INFO = - 2 
      ELSEIF (LDA.LT.MAX (1, M) ) THEN 
         INFO = - 4 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F07ADZ/DGETF2', - INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF (M.EQ.0.OR.N.EQ.0) RETURN 
!                                                                       
      DO 20 J = 1, MIN (M, N) 
!                                                                       
!        Update diagonal and subdiagonal elements in column J.          
!                                                                       
         CALL DGEMV ('No transpose', M - J + 1, J - 1, - ONE, A (J, 1) ,&
         LDA, A (1, J) , 1, ONE, A (J, J) , 1)                          
!                                                                       
!        Find pivot and test for singularity.                           
!                                                                       
         JP = J - 1 + IDAMAX (M - J + 1, A (J, J), 1) 
         IPIV (J) = JP 
         IF (A (JP, J) .NE.ZERO) THEN 
!                                                                       
!           Apply interchange to columns 1:N.                           
!                                                                       
            IF (JP.NE.J) CALL DSWAP (N, A (J, 1), LDA, A (JP, 1),       &
            LDA)                                                        
!                                                                       
!           Compute elements J+1:M of J-th column.                      
!                                                                       
            IF (J.LT.M) CALL DSCAL (M - J, ONE / A (J, J), A (J + 1, J),&
            1)                                                          
!                                                                       
         ELSEIF (INFO.EQ.0) THEN 
!                                                                       
!           If A( JP, J ) is zero, set INFO to indicate that a zero     
!           pivot has been found.                                       
!                                                                       
            INFO = J 
         ENDIF 
!                                                                       
         IF (J + 1.LE.N) THEN 
!                                                                       
!           Compute block row of U.                                     
!                                                                       
            CALL DGEMV ('Transpose', J - 1, N - J, - ONE, A (1, J + 1) ,&
            LDA, A (J, 1) , LDA, ONE, A (J, J + 1) , LDA)               
         ENDIF 
   20 END DO 
      RETURN 
!                                                                       
!     End of F07ADZ (DGETF2)                                            
!                                                                       
      END SUBROUTINE F07ADZ                         
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F07TJF (UPLO, DIAG, N, A, LDA, INFO) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.
      IMPLICIT NONE 
!     .. Entry Points ..                                                
      ENTRY DTRTRI (UPLO, DIAG, N, A, LDA, INFO) 
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DTRTRI computes the inverse of a real upper or lower triangular      
!  matrix A.                                                            
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  UPLO    (input) CHARACTER*1                                          
!          Specifies whether the matrix A is upper or lower triangular. 
!          = 'U':  Upper triangular                                     
!          = 'L':  Lower triangular                                     
!                                                                       
!  DIAG    (input) CHARACTER*1                                          
!          Specifies whether or not the matrix A is unit triangular.    
!          = 'N':  Non-unit triangular                                  
!          = 'U':  Unit triangular                                      
!                                                                       
!  N       (input) INTEGER                                              
!          The order of the matrix A.  N >= 0.                          
!                                                                       
!  A       (input/output) REAL array, dimension (LDA,N)                 
!          On entry, the triangular matrix A.  If UPLO = 'U', the       
!          leading n by n upper triangular part of the array A contains 
!          the upper triangular matrix, and the strictly lower          
!          triangular part of A is not referenced.  If UPLO = 'L', the  
!          leading n by n lower triangular part of the array A contains 
!          the lower triangular matrix, and the strictly upper          
!          triangular part of A is not referenced.  If DIAG = 'U', the  
!          diagonal elements of A are also not referenced and are       
!          assumed to be 1.                                             
!          On exit, the (triangular) inverse of the original matrix, in 
!          the same storage format.                                     
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA >= max(1,N).      
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          < 0: if INFO = -k, the k-th argument had an illegal value    
!          > 0: if INFO = k, the k-th diagonal element of A is zero,    
!               indicating that the matrix is singular and the inverse  
!               has not been computed.                                  
!                                                                       
!  -- LAPACK routine (adapted for NAG Library)                          
!     Univ. of Tennessee, Oak Ridge National Lab, Argonne National Lab, 
!     Courant Institute, NAG Ltd., and Rice University                  
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ZERO, ONE 
      PARAMETER (ZERO = 0.0D+0, ONE = 1.0D+0) 
!     .. Scalar Arguments ..                                            
      INTEGER INFO, LDA, N 
      CHARACTER DIAG, UPLO 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ) 
!     .. Local Scalars ..                                               
      INTEGER J, JB, NB, NN 
      LOGICAL NOUNIT, UPPER 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ, F07TJZ, F07ZAZ, DTRMM, DTRSM 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX, MIN 
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      UPPER = (UPLO.EQ.'U'.OR.UPLO.EQ.'u') 
      NOUNIT = (DIAG.EQ.'N'.OR.DIAG.EQ.'n') 
      IF (.NOT.UPPER.AND..NOT. (UPLO.EQ.'L'.OR.UPLO.EQ.'l') ) THEN 
         INFO = - 1 
      ELSEIF (.NOT.NOUNIT.AND..NOT. (DIAG.EQ.'U'.OR.DIAG.EQ.'u') ) THEN 
         INFO = - 2 
      ELSEIF (N.LT.0) THEN 
         INFO = - 3 
      ELSEIF (LDA.LT.MAX (1, N) ) THEN 
         INFO = - 5 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F07TJF/DTRTRI', - INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF (N.EQ.0) RETURN 
!                                                                       
!     Check for singularity.                                            
!                                                                       
      IF (NOUNIT) THEN 
         DO 20 INFO = 1, N 
            IF (A (INFO, INFO) .EQ.ZERO) RETURN 
   20    END DO 
      ENDIF 
      INFO = 0 
!                                                                       
!     Determine the block size for this environment.                    
!                                                                       
      CALL F07ZAZ (1, 'F07TJF', NB, 0) 
      IF (NB.LE.1) NB = MAX (1, N) 
!                                                                       
      IF (UPPER) THEN 
!                                                                       
!        Compute inverse of upper triangular matrix                     
!                                                                       
         DO 40 J = 1, N, NB 
            JB = MIN (NB, N - J + 1) 
!                                                                       
!           Compute rows 1:j-1 of current block column                  
!                                                                       
            CALL DTRMM ('Left', 'Upper', 'No transpose', DIAG, J - 1,   &
            JB, ONE, A, LDA, A (1, J) , LDA)                            
            CALL DTRSM ('Right', 'Upper', 'No transpose', DIAG, J - 1,  &
            JB, - ONE, A (J, J) , LDA, A (1, J) , LDA)                  
!                                                                       
!           Compute inverse of current diagonal block                   
!                                                                       
            CALL F07TJZ ('Upper', DIAG, JB, A (J, J) , LDA, INFO) 
   40    END DO 
      ELSE 
!                                                                       
!        Compute inverse of lower triangular matrix                     
!                                                                       
         NN = ( (N - 1) / NB) * NB + 1 
         DO 60 J = NN, 1, - NB 
            JB = MIN (NB, N - J + 1) 
            IF (J + JB.LE.N) THEN 
!                                                                       
!              Compute rows j+jb:n of current block column              
!                                                                       
               CALL DTRMM ('Left', 'Lower', 'No transpose', DIAG, N - J &
               - JB + 1, JB, ONE, A (J + JB, J + JB) , LDA, A (J + JB,  &
               J) , LDA)                                                
               CALL DTRSM ('Right', 'Lower', 'No transpose', DIAG, N -  &
               J - JB + 1, JB, - ONE, A (J, J) , LDA, A (J + JB, J) ,   &
               LDA)                                                     
            ENDIF 
!                                                                       
!           Compute inverse of current diagonal block                   
!                                                                       
            CALL F07TJZ ('Lower', DIAG, JB, A (J, J) , LDA, INFO) 
   60    END DO 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F07TJF (DTRTRI)                                            
!                                                                       
      END SUBROUTINE F07TJF                         
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F06PFF (UPLO, TRANS, DIAG, N, A, LDA, X, INCX) 
!     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
      IMPLICIT NONE
!     .. Entry Points ..                                                
      ENTRY DTRMV (UPLO, TRANS, DIAG, N, A, LDA, X, INCX) 
!     .. Scalar Arguments ..                                            
      INTEGER INCX, LDA, N 
      CHARACTER(1) DIAG, TRANS, UPLO 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), X ( * ) 
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DTRMV  performs one of the matrix-vector operations                  
!                                                                       
!     x := A*x,   or   x := A'*x,                                       
!                                                                       
!  where x is n element vector and A is an n by n unit, or non-unit,    
!  upper or lower triangular matrix.                                    
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  UPLO   - CHARACTER*1.                                                
!           On entry, UPLO specifies whether the matrix is an upper or  
!           lower triangular matrix as follows:                         
!                                                                       
!              UPLO = 'U' or 'u'   A is an upper triangular matrix.     
!                                                                       
!              UPLO = 'L' or 'l'   A is a lower triangular matrix.      
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  TRANS  - CHARACTER*1.                                                
!           On entry, TRANS specifies the operation to be performed as  
!           follows:                                                    
!                                                                       
!              TRANS = 'N' or 'n'   x := A*x.                           
!                                                                       
!              TRANS = 'T' or 't'   x := A'*x.                          
!                                                                       
!              TRANS = 'C' or 'c'   x := A'*x.                          
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  DIAG   - CHARACTER*1.                                                
!           On entry, DIAG specifies whether or not A is unit           
!           triangular as follows:                                      
!                                                                       
!              DIAG = 'U' or 'u'   A is assumed to be unit triangular.  
!                                                                       
!              DIAG = 'N' or 'n'   A is not assumed to be unit          
!                                  triangular.                          
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry, N specifies the order of the matrix A.            
!           N must be at least zero.                                    
!           Unchanged on exit.                                          
!                                                                       
!  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).             
!           Before entry with  UPLO = 'U' or 'u', the leading n by n    
!           upper triangular part of the array A must contain the upper 
!           triangular matrix and the strictly lower triangular part of 
!           A is not referenced.                                        
!           Before entry with UPLO = 'L' or 'l', the leading n by n     
!           lower triangular part of the array A must contain the lower 
!           triangular matrix and the strictly upper triangular part of 
!           A is not referenced.                                        
!           Note that when  DIAG = 'U' or 'u', the diagonal elements of 
!           A are not referenced either, but are assumed to be unity.   
!           Unchanged on exit.                                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program. LDA must be at least          
!           max( 1, n ).                                                
!           Unchanged on exit.                                          
!                                                                       
!  X      - DOUBLE PRECISION array of dimension at least                
!           ( 1 + ( n - 1 )*abs( INCX ) ).                              
!           Before entry, the incremented array X must contain the n    
!           element vector x. On exit, X is overwritten with the        
!           tranformed vector x.                                        
!                                                                       
!  INCX   - INTEGER.                                                    
!           On entry, INCX specifies the increment for the elements of  
!           X. INCX must not be zero.                                   
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 2 Blas routine.                                                
!                                                                       
!  -- Written on 22-October-1986.                                       
!     Jack Dongarra, Argonne National Lab.                              
!     Jeremy Du Croz, Nag Central Office.                               
!     Sven Hammarling, Nag Central Office.                              
!     Richard Hanson, Sandia National Labs.                             
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ZERO 
      PARAMETER (ZERO = 0.0D+0) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION TEMP 
      INTEGER I, INFO, IX, J, JX, KX 
      LOGICAL NOUNIT 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (.NOT. (UPLO.EQ.'U'.OR.UPLO.EQ.'u') .AND..NOT. (               &
      UPLO.EQ.'L'.OR.UPLO.EQ.'l') ) THEN                                
         INFO = 1 
      ELSEIF (.NOT. (TRANS.EQ.'N'.OR.TRANS.EQ.'n') .AND..NOT. (         &
      TRANS.EQ.'T'.OR.TRANS.EQ.'t') .AND..NOT. (                        &
      TRANS.EQ.'C'.OR.TRANS.EQ.'c') ) THEN                              
         INFO = 2 
      ELSEIF (.NOT. (DIAG.EQ.'U'.OR.DIAG.EQ.'u') .AND..NOT. (           &
      DIAG.EQ.'N'.OR.DIAG.EQ.'n') ) THEN                                
         INFO = 3 
      ELSEIF (N.LT.0) THEN 
         INFO = 4 
      ELSEIF (LDA.LT.MAX (1, N) ) THEN 
         INFO = 6 
      ELSEIF (INCX.EQ.0) THEN 
         INFO = 8 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F06PFF/DTRMV ', INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF (N.EQ.0) RETURN 
!                                                                       
      NOUNIT = (DIAG.EQ.'N'.OR.DIAG.EQ.'n') 
!                                                                       
!     Set up the start point in X if the increment is not unity. This   
!     will be  ( N - 1 )*INCX  too small for descending loops.          
!                                                                       
      IF (INCX.LE.0) THEN 
         KX = 1 - (N - 1) * INCX 
      ELSEIF (INCX.NE.1) THEN 
         KX = 1 
      ENDIF 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
      IF ( (TRANS.EQ.'N'.OR.TRANS.EQ.'n') ) THEN 
!                                                                       
!        Form  x := A*x.                                                
!                                                                       
         IF ( (UPLO.EQ.'U'.OR.UPLO.EQ.'u') ) THEN 
            IF (INCX.EQ.1) THEN 
               DO 20, J = 1, N 
                  IF (X (J) .NE.ZERO) THEN 
                     TEMP = X (J) 
                     DO 10, I = 1, J - 1 
                        X (I) = X (I) + TEMP * A (I, J) 
   10                END DO 
                     IF (NOUNIT) X (J) = X (J) * A (J, J) 
                  ENDIF 
   20          END DO 
            ELSE 
               JX = KX 
               DO 40, J = 1, N 
                  IF (X (JX) .NE.ZERO) THEN 
                     TEMP = X (JX) 
                     IX = KX 
                     DO 30, I = 1, J - 1 
                        X (IX) = X (IX) + TEMP * A (I, J) 
                        IX = IX + INCX 
   30                END DO 
                     IF (NOUNIT) X (JX) = X (JX) * A (J, J) 
                  ENDIF 
                  JX = JX + INCX 
   40          END DO 
            ENDIF 
         ELSE 
            IF (INCX.EQ.1) THEN 
               DO 60, J = N, 1, - 1 
                  IF (X (J) .NE.ZERO) THEN 
                     TEMP = X (J) 
                     DO 50, I = N, J + 1, - 1 
                        X (I) = X (I) + TEMP * A (I, J) 
   50                END DO 
                     IF (NOUNIT) X (J) = X (J) * A (J, J) 
                  ENDIF 
   60          END DO 
            ELSE 
               KX = KX + (N - 1) * INCX 
               JX = KX 
               DO 80, J = N, 1, - 1 
                  IF (X (JX) .NE.ZERO) THEN 
                     TEMP = X (JX) 
                     IX = KX 
                     DO 70, I = N, J + 1, - 1 
                        X (IX) = X (IX) + TEMP * A (I, J) 
                        IX = IX - INCX 
   70                END DO 
                     IF (NOUNIT) X (JX) = X (JX) * A (J, J) 
                  ENDIF 
                  JX = JX - INCX 
   80          END DO 
            ENDIF 
         ENDIF 
      ELSE 
!                                                                       
!        Form  x := A'*x.                                               
!                                                                       
         IF ( (UPLO.EQ.'U'.OR.UPLO.EQ.'u') ) THEN 
            IF (INCX.EQ.1) THEN 
               DO 100, J = N, 1, - 1 
                  TEMP = X (J) 
                  IF (NOUNIT) TEMP = TEMP * A (J, J) 
                  DO 90, I = J - 1, 1, - 1 
                     TEMP = TEMP + A (I, J) * X (I) 
   90             END DO 
                  X (J) = TEMP 
  100          END DO 
            ELSE 
               JX = KX + (N - 1) * INCX 
               DO 120, J = N, 1, - 1 
                  TEMP = X (JX) 
                  IX = JX 
                  IF (NOUNIT) TEMP = TEMP * A (J, J) 
                  DO 110, I = J - 1, 1, - 1 
                     IX = IX - INCX 
                     TEMP = TEMP + A (I, J) * X (IX) 
  110             END DO 
                  X (JX) = TEMP 
                  JX = JX - INCX 
  120          END DO 
            ENDIF 
         ELSE 
            IF (INCX.EQ.1) THEN 
               DO 140, J = 1, N 
                  TEMP = X (J) 
                  IF (NOUNIT) TEMP = TEMP * A (J, J) 
                  DO 130, I = J + 1, N 
                     TEMP = TEMP + A (I, J) * X (I) 
  130             END DO 
                  X (J) = TEMP 
  140          END DO 
            ELSE 
               JX = KX 
               DO 160, J = 1, N 
                  TEMP = X (JX) 
                  IX = JX 
                  IF (NOUNIT) TEMP = TEMP * A (J, J) 
                  DO 150, I = J + 1, N 
                     IX = IX + INCX 
                     TEMP = TEMP + A (I, J) * X (IX) 
  150             END DO 
                  X (JX) = TEMP 
                  JX = JX + INCX 
  160          END DO 
            ENDIF 
         ENDIF 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06PFF (DTRMV ).                                           
!                                                                       
      END SUBROUTINE F06PFF                         
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F06YFF (SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, &
      B, LDB)                                                           
!     MARK 14 RELEASE. NAG COPYRIGHT 1989.                              
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DTRMM  performs one of the matrix-matrix operations                  
!                                                                       
!     B := alpha*op( A )*B,   or   B := alpha*B*op( A ),                
!                                                                       
!  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
!  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
!                                                                       
!     op( A ) = A   or   op( A ) = A'.                                  
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  SIDE   - CHARACTER*1.                                                
!           On entry,  SIDE specifies whether  op( A ) multiplies B from
!           the left or right as follows:                               
!                                                                       
!              SIDE = 'L' or 'l'   B := alpha*op( A )*B.                
!                                                                       
!              SIDE = 'R' or 'r'   B := alpha*B*op( A ).                
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  UPLO   - CHARACTER*1.                                                
!           On entry, UPLO specifies whether the matrix A is an upper or
!           lower triangular matrix as follows:                         
!                                                                       
!              UPLO = 'U' or 'u'   A is an upper triangular matrix.     
!                                                                       
!              UPLO = 'L' or 'l'   A is a lower triangular matrix.      
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  TRANSA - CHARACTER*1.                                                
!           On entry, TRANSA specifies the form of op( A ) to be used in
!           the matrix multiplication as follows:                       
!                                                                       
!              TRANSA = 'N' or 'n'   op( A ) = A.                       
!                                                                       
!              TRANSA = 'T' or 't'   op( A ) = A'.                      
!                                                                       
!              TRANSA = 'C' or 'c'   op( A ) = A'.                      
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  DIAG   - CHARACTER*1.                                                
!           On entry, DIAG specifies whether or not A is unit triangular
!           as follows:                                                 
!                                                                       
!              DIAG = 'U' or 'u'   A is assumed to be unit triangular.  
!                                                                       
!              DIAG = 'N' or 'n'   A is not assumed to be unit          
!                                  triangular.                          
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  M      - INTEGER.                                                    
!           On entry, M specifies the number of rows of B. M must be at 
!           least zero.                                                 
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry, N specifies the number of columns of B.  N must be
!           at least zero.                                              
!           Unchanged on exit.                                          
!                                                                       
!  ALPHA  - REAL            .                                           
!           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
!           zero then  A is not referenced and  B need not be set before
!           entry.                                                      
!           Unchanged on exit.                                          
!                                                                       
!  A      - REAL             array of DIMENSION ( LDA, k ), where k is m
!           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
!           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
!           upper triangular part of the array  A must contain the upper
!           triangular matrix  and the strictly lower triangular part of
!           A is not referenced.                                        
!           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
!           lower triangular part of the array  A must contain the lower
!           triangular matrix  and the strictly upper triangular part of
!           A is not referenced.                                        
!           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
!           A  are not referenced either,  but are assumed to be  unity.
!           Unchanged on exit.                                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
!           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
!           then LDA must be at least max( 1, n ).                      
!           Unchanged on exit.                                          
!                                                                       
!  B      - REAL             array of DIMENSION ( LDB, n ).             
!           Before entry,  the leading  m by n part of the array  B must
!           contain the matrix  B,  and  on exit  is overwritten  by the
!           transformed matrix.                                         
!                                                                       
!  LDB    - INTEGER.                                                    
!           On entry, LDB specifies the first dimension of B as declared
!           in  the  calling  (sub)  program.   LDB  must  be  at  least
!           max( 1, m ).                                                
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 3 Blas routine.                                                
!                                                                       
!  -- Written on 8-February-1989.                                       
!     Jack Dongarra, Argonne National Laboratory.                       
!     Iain Duff, AERE Harwell.                                          
!     Jeremy Du Croz, Numerical Algorithms Group Ltd.                   
!     Sven Hammarling, Numerical Algorithms Group Ltd.                  
!                                                                       
!      
      IMPLICIT NONE
!     .. Entry Points ..                                                
      ENTRY DTRMM (SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B,    &
      LDB)                                                              
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION ALPHA 
      INTEGER LDA, LDB, M, N 
      CHARACTER(1) DIAG, SIDE, TRANSA, UPLO 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), B (LDB, * ) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION TEMP 
      INTEGER I, INFO, J, K, NROWA 
      LOGICAL LSIDE, NOUNIT, UPPER 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      LSIDE = (SIDE.EQ.'L'.OR.SIDE.EQ.'l') 
      IF (LSIDE) THEN 
         NROWA = M 
      ELSE 
         NROWA = N 
      ENDIF 
      NOUNIT = (DIAG.EQ.'N'.OR.DIAG.EQ.'n') 
      UPPER = (UPLO.EQ.'U'.OR.UPLO.EQ.'u') 
!                                                                       
      INFO = 0 
      IF ( (.NOT.LSIDE) .AND. (.NOT. (SIDE.EQ.'R'.OR.SIDE.EQ.'r') ) )   &
      THEN                                                              
         INFO = 1 
      ELSEIF ( (.NOT.UPPER) .AND. (.NOT. (UPLO.EQ.'L'.OR.UPLO.EQ.'l') ) &
      ) THEN                                                            
         INFO = 2 
      ELSEIF ( (.NOT. (TRANSA.EQ.'N'.OR.TRANSA.EQ.'n') ) .AND. (.NOT. ( &
      TRANSA.EQ.'T'.OR.TRANSA.EQ.'t') ) .AND. (.NOT. (                  &
      TRANSA.EQ.'C'.OR.TRANSA.EQ.'c') ) ) THEN                          
         INFO = 3 
      ELSEIF ( (.NOT. (DIAG.EQ.'U'.OR.DIAG.EQ.'u') ) .AND. (.NOT. (     &
      DIAG.EQ.'N'.OR.DIAG.EQ.'n') ) ) THEN                              
         INFO = 4 
      ELSEIF (M.LT.0) THEN 
         INFO = 5 
      ELSEIF (N.LT.0) THEN 
         INFO = 6 
      ELSEIF (LDA.LT.MAX (1, NROWA) ) THEN 
         INFO = 9 
      ELSEIF (LDB.LT.MAX (1, M) ) THEN 
         INFO = 11 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F06YFF/DTRMM ', INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF (N.EQ.0) RETURN 
!                                                                       
!     And when  alpha.eq.zero.                                          
!                                                                       
      IF (ALPHA.EQ.ZERO) THEN 
         DO 40 J = 1, N 
            DO 20 I = 1, M 
               B (I, J) = ZERO 
   20       END DO 
   40    END DO 
         RETURN 
      ENDIF 
!                                                                       
!     Start the operations.                                             
!                                                                       
      IF (LSIDE) THEN 
         IF ( (TRANSA.EQ.'N'.OR.TRANSA.EQ.'n') ) THEN 
!                                                                       
!           Form  B := alpha*A*B.                                       
!                                                                       
            IF (UPPER) THEN 
               DO 100 J = 1, N 
                  DO 80 K = 1, M 
                     IF (B (K, J) .NE.ZERO) THEN 
                        TEMP = ALPHA * B (K, J) 
                        DO 60 I = 1, K - 1 
                           B (I, J) = B (I, J) + TEMP * A (I, K) 
   60                   END DO 
                        IF (NOUNIT) TEMP = TEMP * A (K, K) 
                        B (K, J) = TEMP 
                     ENDIF 
   80             END DO 
  100          END DO 
            ELSE 
               DO 160 J = 1, N 
                  DO 140 K = M, 1, - 1 
                     IF (B (K, J) .NE.ZERO) THEN 
                        TEMP = ALPHA * B (K, J) 
                        B (K, J) = TEMP 
                        IF (NOUNIT) B (K, J) = B (K, J) * A (K, K) 
                        DO 120 I = K + 1, M 
                           B (I, J) = B (I, J) + TEMP * A (I, K) 
  120                   END DO 
                     ENDIF 
  140             END DO 
  160          END DO 
            ENDIF 
         ELSE 
!                                                                       
!           Form  B := alpha*B*A'.                                      
!                                                                       
            IF (UPPER) THEN 
               DO 220 J = 1, N 
                  DO 200 I = M, 1, - 1 
                     TEMP = B (I, J) 
                     IF (NOUNIT) TEMP = TEMP * A (I, I) 
                     DO 180 K = 1, I - 1 
                        TEMP = TEMP + A (K, I) * B (K, J) 
  180                END DO 
                     B (I, J) = ALPHA * TEMP 
  200             END DO 
  220          END DO 
            ELSE 
               DO 280 J = 1, N 
                  DO 260 I = 1, M 
                     TEMP = B (I, J) 
                     IF (NOUNIT) TEMP = TEMP * A (I, I) 
                     DO 240 K = I + 1, M 
                        TEMP = TEMP + A (K, I) * B (K, J) 
  240                END DO 
                     B (I, J) = ALPHA * TEMP 
  260             END DO 
  280          END DO 
            ENDIF 
         ENDIF 
      ELSE 
         IF ( (TRANSA.EQ.'N'.OR.TRANSA.EQ.'n') ) THEN 
!                                                                       
!           Form  B := alpha*B*A.                                       
!                                                                       
            IF (UPPER) THEN 
               DO 360 J = N, 1, - 1 
                  TEMP = ALPHA 
                  IF (NOUNIT) TEMP = TEMP * A (J, J) 
                  DO 300 I = 1, M 
                     B (I, J) = TEMP * B (I, J) 
  300             END DO 
                  DO 340 K = 1, J - 1 
                     IF (A (K, J) .NE.ZERO) THEN 
                        TEMP = ALPHA * A (K, J) 
                        DO 320 I = 1, M 
                           B (I, J) = B (I, J) + TEMP * B (I, K) 
  320                   END DO 
                     ENDIF 
  340             END DO 
  360          END DO 
            ELSE 
               DO 440 J = 1, N 
                  TEMP = ALPHA 
                  IF (NOUNIT) TEMP = TEMP * A (J, J) 
                  DO 380 I = 1, M 
                     B (I, J) = TEMP * B (I, J) 
  380             END DO 
                  DO 420 K = J + 1, N 
                     IF (A (K, J) .NE.ZERO) THEN 
                        TEMP = ALPHA * A (K, J) 
                        DO 400 I = 1, M 
                           B (I, J) = B (I, J) + TEMP * B (I, K) 
  400                   END DO 
                     ENDIF 
  420             END DO 
  440          END DO 
            ENDIF 
         ELSE 
!                                                                       
!           Form  B := alpha*B*A'.                                      
!                                                                       
            IF (UPPER) THEN 
               DO 520 K = 1, N 
                  DO 480 J = 1, K - 1 
                     IF (A (J, K) .NE.ZERO) THEN 
                        TEMP = ALPHA * A (J, K) 
                        DO 460 I = 1, M 
                           B (I, J) = B (I, J) + TEMP * B (I, K) 
  460                   END DO 
                     ENDIF 
  480             END DO 
                  TEMP = ALPHA 
                  IF (NOUNIT) TEMP = TEMP * A (K, K) 
                  IF (TEMP.NE.ONE) THEN 
                     DO 500 I = 1, M 
                        B (I, K) = TEMP * B (I, K) 
  500                END DO 
                  ENDIF 
  520          END DO 
            ELSE 
               DO 600 K = N, 1, - 1 
                  DO 560 J = K + 1, N 
                     IF (A (J, K) .NE.ZERO) THEN 
                        TEMP = ALPHA * A (J, K) 
                        DO 540 I = 1, M 
                           B (I, J) = B (I, J) + TEMP * B (I, K) 
  540                   END DO 
                     ENDIF 
  560             END DO 
                  TEMP = ALPHA 
                  IF (NOUNIT) TEMP = TEMP * A (K, K) 
                  IF (TEMP.NE.ONE) THEN 
                     DO 580 I = 1, M 
                        B (I, K) = TEMP * B (I, K) 
  580                END DO 
                  ENDIF 
  600          END DO 
            ENDIF 
         ENDIF 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06YFF (DTRMM ).                                           
!                                                                       
      END SUBROUTINE F06YFF                         
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F07TJZ (UPLO, DIAG, N, A, LDA, INFO) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.                              
!     ENTRY             DTRTI2(UPLO,DIAG,N,A,LDA,INFO)                  
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DTRTI2 computes the inverse of a real upper or lower triangular      
!  matrix A.                                                            
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  UPLO    (input) CHARACTER*1                                          
!          Specifies whether the matrix A is upper or lower triangular. 
!          = 'U':  Upper triangular                                     
!          = 'L':  Lower triangular                                     
!                                                                       
!  DIAG    (input) CHARACTER*1                                          
!          Specifies whether or not the matrix A is unit triangular.    
!          = 'N':  Non-unit triangular                                  
!          = 'U':  Unit triangular                                      
!                                                                       
!  N       (input) INTEGER                                              
!          The order of the matrix A.  N >= 0.                          
!                                                                       
!  A       (input/output) REAL array, dimension (LDA,N)                 
!          On entry, the triangular matrix A.  If UPLO = 'U', the       
!          leading n by n upper triangular part of the array A contains 
!          the upper triangular matrix, and the strictly lower          
!          triangular part of A is not referenced.  If UPLO = 'L', the  
!          leading n by n lower triangular part of the array A contains 
!          the lower triangular matrix, and the strictly upper          
!          triangular part of A is not referenced.  If DIAG = 'U', the  
!          diagonal elements of A are also not referenced and are       
!          assumed to be 1.                                             
!          On exit, the (triangular) inverse of the original matrix, in 
!          the same storage format.                                     
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA >= max(1,N).      
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          < 0: if INFO = -k, the k-th argument had an illegal value    
!          > 0: if INFO = k, the k-th diagonal element of A is zero,    
!               indicating that the matrix is singular and the inverse  
!               has not been computed.                                  
!                                                                       
!  -- LAPACK routine (adapted for NAG Library)                          
!     Univ. of Tennessee, Oak Ridge National Lab, Argonne National Lab, 
!     Courant Institute, NAG Ltd., and Rice University                  
!                                                                       
!  =====================================================================
!           
      IMPLICIT NONE
!     .. Parameters ..                                                  
      DOUBLEPRECISION ZERO, ONE 
      PARAMETER (ZERO = 0.0D+0, ONE = 1.0D+0) 
!     .. Scalar Arguments ..                                            
      INTEGER INFO, LDA, N 
      CHARACTER DIAG, UPLO 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION AJJ 
      INTEGER J 
      LOGICAL NOUNIT, UPPER 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ, DSCAL, DTRMV 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      UPPER = (UPLO.EQ.'U'.OR.UPLO.EQ.'u') 
      NOUNIT = (DIAG.EQ.'N'.OR.DIAG.EQ.'n') 
      IF (.NOT.UPPER.AND..NOT. (UPLO.EQ.'L'.OR.UPLO.EQ.'l') ) THEN 
         INFO = - 1 
      ELSEIF (.NOT.NOUNIT.AND..NOT. (DIAG.EQ.'U'.OR.DIAG.EQ.'u') ) THEN 
         INFO = - 2 
      ELSEIF (N.LT.0) THEN 
         INFO = - 3 
      ELSEIF (LDA.LT.MAX (1, N) ) THEN 
         INFO = - 5 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F07TJZ/DTRTI2', - INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Check for singularity.                                            
!                                                                       
      IF (NOUNIT) THEN 
         DO 20 INFO = 1, N 
            IF (A (INFO, INFO) .EQ.ZERO) RETURN 
   20    END DO 
      ENDIF 
      INFO = 0 
!                                                                       
      IF (UPPER) THEN 
!                                                                       
!        Compute inverse of upper triangular matrix.                    
!                                                                       
         DO 40 J = 1, N 
            IF (NOUNIT) THEN 
               A (J, J) = ONE / A (J, J) 
               AJJ = - A (J, J) 
            ELSE 
               AJJ = - ONE 
            ENDIF 
!                                                                       
!           Compute elements 1:j-1 of j-th column.                      
!                                                                       
            CALL DTRMV ('Upper', 'No transpose', DIAG, J - 1, A, LDA, A &
            (1, J) , 1)                                                 
            CALL DSCAL (J - 1, AJJ, A (1, J), 1) 
   40    END DO 
      ELSE 
!                                                                       
!        Compute inverse of lower triangular matrix.                    
!                                                                       
         DO 60 J = N, 1, - 1 
            IF (NOUNIT) THEN 
               A (J, J) = ONE / A (J, J) 
               AJJ = - A (J, J) 
            ELSE 
               AJJ = - ONE 
            ENDIF 
            IF (J.LT.N) THEN 
!                                                                       
!              Compute elements j+1:n of j-th column.                   
!                                                                       
               CALL DTRMV ('Lower', 'No transpose', DIAG, N - J, A (J + &
               1, J + 1) , LDA, A (J + 1, J) , 1)                       
               CALL DSCAL (N - J, AJJ, A (J + 1, J), 1) 
            ENDIF 
   60    END DO 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F07TJZ (DTRTI2)                                            
!                                                                       
      END SUBROUTINE F07TJZ                         
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
      SUBROUTINE F06PAF (TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y,  &
      INCY)                                                             
!     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.  
      IMPLICIT NONE
!     .. Entry Points ..                                                
      ENTRY DGEMV (TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) 
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION ALPHA, BETA 
      INTEGER INCX, INCY, LDA, M, N 
      CHARACTER(1) TRANS 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), X ( * ), Y ( * ) 
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DGEMV  performs one of the matrix-vector operations                  
!                                                                       
!     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,         
!                                                                       
!  where alpha and beta are scalars, x and y are vectors and A is an    
!  m by n matrix.                                                       
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  TRANS  - CHARACTER*1.                                                
!           On entry, TRANS specifies the operation to be performed as  
!           follows:                                                    
!                                                                       
!              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.            
!                                                                       
!              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.           
!                                                                       
!              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.           
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  M      - INTEGER.                                                    
!           On entry, M specifies the number of rows of the matrix A.   
!           M must be at least zero.                                    
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry, N specifies the number of columns of the matrix A.
!           N must be at least zero.                                    
!           Unchanged on exit.                                          
!                                                                       
!  ALPHA  - DOUBLE PRECISION.                                           
!           On entry, ALPHA specifies the scalar alpha.                 
!           Unchanged on exit.                                          
!                                                                       
!  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).             
!           Before entry, the leading m by n part of the array A must   
!           contain the matrix of coefficients.                         
!           Unchanged on exit.                                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program. LDA must be at least          
!           max( 1, m ).                                                
!           Unchanged on exit.                                          
!                                                                       
!  X      - DOUBLE PRECISION array of DIMENSION at least                
!           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'       
!           and at least                                                
!           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.                    
!           Before entry, the incremented array X must contain the      
!           vector x.                                                   
!           Unchanged on exit.                                          
!                                                                       
!  INCX   - INTEGER.                                                    
!           On entry, INCX specifies the increment for the elements of  
!           X. INCX must not be zero.                                   
!           Unchanged on exit.                                          
!                                                                       
!  BETA   - DOUBLE PRECISION.                                           
!           On entry, BETA specifies the scalar beta. When BETA is      
!           supplied as zero then Y need not be set on input.           
!           Unchanged on exit.                                          
!                                                                       
!  Y      - DOUBLE PRECISION array of DIMENSION at least                
!           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'       
!           and at least                                                
!           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.                    
!           Before entry with BETA non-zero, the incremented array Y    
!           must contain the vector y. On exit, Y is overwritten by the 
!           updated vector y.                                           
!                                                                       
!  INCY   - INTEGER.                                                    
!           On entry, INCY specifies the increment for the elements of  
!           Y. INCY must not be zero.                                   
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 2 Blas routine.                                                
!                                                                       
!  -- Written on 22-October-1986.                                       
!     Jack Dongarra, Argonne National Lab.                              
!     Jeremy Du Croz, Nag Central Office.                               
!     Sven Hammarling, Nag Central Office.                              
!     Richard Hanson, Sandia National Labs.                             
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION TEMP 
      INTEGER I, INFO, IX, IY, J, JX, JY, KX, KY, LENX, LENY 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (.NOT. (TRANS.EQ.'N'.OR.TRANS.EQ.'n') .AND..NOT. (             &
      TRANS.EQ.'T'.OR.TRANS.EQ.'t') .AND..NOT. (                        &
      TRANS.EQ.'C'.OR.TRANS.EQ.'c') ) THEN                              
         INFO = 1 
      ELSEIF (M.LT.0) THEN 
         INFO = 2 
      ELSEIF (N.LT.0) THEN 
         INFO = 3 
      ELSEIF (LDA.LT.MAX (1, M) ) THEN 
         INFO = 6 
      ELSEIF (INCX.EQ.0) THEN 
         INFO = 8 
      ELSEIF (INCY.EQ.0) THEN 
         INFO = 11 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F06PAF/DGEMV ', INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF ( (M.EQ.0) .OR. (N.EQ.0) .OR. ( (ALPHA.EQ.ZERO) .AND. (        &
      BETA.EQ.ONE) ) ) RETURN                                           
!                                                                       
!     Set  LENX  and  LENY, the lengths of the vectors x and y, and set 
!     up the start points in  X  and  Y.                                
!                                                                       
      IF ( (TRANS.EQ.'N'.OR.TRANS.EQ.'n') ) THEN 
         LENX = N 
         LENY = M 
      ELSE 
         LENX = M 
         LENY = N 
      ENDIF 
      IF (INCX.GT.0) THEN 
         KX = 1 
      ELSE 
         KX = 1 - (LENX - 1) * INCX 
      ENDIF 
      IF (INCY.GT.0) THEN 
         KY = 1 
      ELSE 
         KY = 1 - (LENY - 1) * INCY 
      ENDIF 
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
!     First form  y := beta*y.                                          
!                                                                       
      IF (BETA.NE.ONE) THEN 
         IF (INCY.EQ.1) THEN 
            IF (BETA.EQ.ZERO) THEN 
               DO 10, I = 1, LENY 
                  Y (I) = ZERO 
   10          END DO 
            ELSE 
               DO 20, I = 1, LENY 
                  Y (I) = BETA * Y (I) 
   20          END DO 
            ENDIF 
         ELSE 
            IY = KY 
            IF (BETA.EQ.ZERO) THEN 
               DO 30, I = 1, LENY 
                  Y (IY) = ZERO 
                  IY = IY + INCY 
   30          END DO 
            ELSE 
               DO 40, I = 1, LENY 
                  Y (IY) = BETA * Y (IY) 
                  IY = IY + INCY 
   40          END DO 
            ENDIF 
         ENDIF 
      ENDIF 
      IF (ALPHA.EQ.ZERO) RETURN 
      IF ( (TRANS.EQ.'N'.OR.TRANS.EQ.'n') ) THEN 
!                                                                       
!        Form  y := alpha*A*x + y.                                      
!                                                                       
         JX = KX 
         IF (INCY.EQ.1) THEN 
            DO 60, J = 1, N 
               IF (X (JX) .NE.ZERO) THEN 
                  TEMP = ALPHA * X (JX) 
                  DO 50, I = 1, M 
                     Y (I) = Y (I) + TEMP * A (I, J) 
   50             END DO 
               ENDIF 
               JX = JX + INCX 
   60       END DO 
         ELSE 
            DO 80, J = 1, N 
               IF (X (JX) .NE.ZERO) THEN 
                  TEMP = ALPHA * X (JX) 
                  IY = KY 
                  DO 70, I = 1, M 
                     Y (IY) = Y (IY) + TEMP * A (I, J) 
                     IY = IY + INCY 
   70             END DO 
               ENDIF 
               JX = JX + INCX 
   80       END DO 
         ENDIF 
      ELSE 
!                                                                       
!        Form  y := alpha*A'*x + y.                                     
!                                                                       
         JY = KY 
         IF (INCX.EQ.1) THEN 
            DO 100, J = 1, N 
               TEMP = ZERO 
               DO 90, I = 1, M 
                  TEMP = TEMP + A (I, J) * X (I) 
   90          END DO 
               Y (JY) = Y (JY) + ALPHA * TEMP 
               JY = JY + INCY 
  100       END DO 
         ELSE 
            DO 120, J = 1, N 
               TEMP = ZERO 
               IX = KX 
               DO 110, I = 1, M 
                  TEMP = TEMP + A (I, J) * X (IX) 
                  IX = IX + INCX 
  110          END DO 
               Y (JY) = Y (JY) + ALPHA * TEMP 
               JY = JY + INCY 
  120       END DO 
         ENDIF 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06PAF (DGEMV ).                                           
!                                                                       
      END SUBROUTINE F06PAF                         
                                                                        
                                                                        
      SUBROUTINE F03AAF (A, IA, N, DET, WKSPCE, IFAIL) 
!     MARK 15 RE-ISSUE. NAG COPYRIGHT 1991.                             
!                                                                       
!     Determinant of real matrix.                                       
!     1st August 1971                                                   
!                                                                       
!     Rewritten to call F07ADG, a modified version of LAPACK routine    
!     SGETRF/F07ADF; new IFAIL exit inserted for illegal input          
!     parameters; error messages inserted. February 1991.               
!                      
      IMPLICIT NONE
!     .. Parameters ..                                                  
      CHARACTER(6) SRNAME 
      PARAMETER (SRNAME = 'F03AAF') 
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION DET 
      INTEGER IA, IFAIL, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (IA, * ), WKSPCE ( * ) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION ABSDET, ABST, OFLOW, T, UFLOW 
      INTEGER I, IERR, INFO, L, NREC 
!     .. Local Arrays ..                                                
      CHARACTER(80) P01REC (1) 
!     .. External Functions ..                                          
      DOUBLEPRECISION X02AMF 
      INTEGER P01ABF 
      EXTERNAL X02AMF, P01ABF 
!     .. External Subroutines ..                                        
      EXTERNAL F07ADG 
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS, MAX, NINT 
!     .. Executable Statements ..                                       
!                                                                       
      IERR = 0 
      NREC = 0 
      IF (N.LT.0) THEN 
         IERR = 4 
         NREC = 1 
         WRITE (P01REC, FMT = 99999) N 
      ELSEIF (IA.LT.MAX (1, N) ) THEN 
         IERR = 4 
         NREC = 1 
         WRITE (P01REC, FMT = 99998) IA, N 
      ELSE 
!                                                                       
         CALL F07ADG (N, N, A, IA, WKSPCE, INFO) 
!                                                                       
         IF (INFO.EQ.0) THEN 
!                                                                       
!           Compute the determinant as the product of the diagonal      
!           elements of the factor L, with a factor + or - 1            
!           determined by the interchanges.                             
!                                                                       
            UFLOW = X02AMF () 
            OFLOW = ONE / UFLOW 
            DET = ONE 
            DO 20 I = 1, N 
               L = NINT (WKSPCE (I) ) 
               IF (L.NE.I) DET = - DET 
               T = A (I, I) 
               ABST = ABS (T) 
               ABSDET = ABS (DET) 
               IF (ABST.GE.ONE) THEN 
                  IF (ABSDET.GT.OFLOW / ABST) THEN 
                     IERR = 2 
                     NREC = 1 
                     WRITE (P01REC, FMT = 99997) 
                     DET = OFLOW 
                     GOTO 40 
                  ELSE 
                     DET = DET * T 
                  ENDIF 
               ELSE 
                  IF (ABSDET.LT.UFLOW / ABST) THEN 
                     IERR = 3 
                     NREC = 1 
                     WRITE (P01REC, FMT = 99996) 
                     DET = ZERO 
                     GOTO 40 
                  ELSE 
                     DET = DET * T 
                  ENDIF 
               ENDIF 
   20       END DO 
!                                                                       
         ELSE 
            IERR = 1 
            NREC = 1 
            WRITE (P01REC, FMT = 99995) 
            DET = ZERO 
         ENDIF 
      ENDIF 
!                                                                       
   40 IFAIL = P01ABF (IFAIL, IERR, SRNAME, NREC, P01REC) 
      RETURN 
!                                                                       
99999 FORMAT (1X,'** On entry, N.lt.0: N =',I16) 
99998 FORMAT (1X,'** On entry, IA.lt.max(1,N): IA =',I16,', N =',I16) 
99997 FORMAT (1X,'** The value of the determinant is too large to be s',&
     &       'tored.')                                                  
99996 FORMAT (1X,'** The value of the determinant is too small to be s',&
     &       'tored.')                                                  
99995 FORMAT (1X,'** Matrix A is approximately singular.') 
      END SUBROUTINE F03AAF                         
                                                                        
                                                                        
      SUBROUTINE F07ADG (M, N, A, LDA, PIV, INFO) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.                              
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  F07ADG computes an LU factorization of a general m-by-n matrix A     
!  using partial pivoting with row interchanges.                        
!                                                                       
!  The factorization has the form                                       
!     A = P * L * U                                                     
!  where P is a permutation matrix, L is lower triangular (lower        
!  trapezoidal if m > n), and U is upper triangular with unit diagonal  
!  elements (upper trapezoidal if m < n).                               
!                                                                       
!  This is the Level 3 BLAS version of the Crout algorithm.             
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M >= 0.                 
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N >= 0.              
!                                                                       
!  A       (input/output) REAL array, dimension (LDA,N)                 
!          On entry, the m by n matrix to be factored.                  
!          On exit, the factors L and U from the factorization          
!          A = P*L*U; the unit diagonal elements of U are not stored.   
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA >= max(1,M).      
!                                                                       
!  PIV     (output) REAL array, dimension (M)                           
!          The pivot indices; for 1 <= i <= min(M,N), row i of the      
!          matrix was interchanged with row PIV(i). The rest of PIV is  
!          used for workspace.                                          
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          < 0: if INFO = -k, the k-th argument had an illegal value    
!          > 0: if INFO = k, approximate singularity has been detected  
!               at the k-th stage; the factorization has not been       
!               completed.                                              
!                                                                       
!  This is a modified version of the LAPACK routine F07ADF/DGETRF, in   
!  which the INTEGER array IPIV has been replaced by a REAL array PIV,  
!  row-equilibration is used in the choice of pivot, U has unit diagonal
!  elements, and the routine exits immediately if approximate           
!  singularity is detected.                                             
!                                                                       
!  =====================================================================
!        
      IMPLICIT NONE
!     .. Parameters ..                                                  
      DOUBLEPRECISION ZERO, ONE 
      PARAMETER (ZERO = 0.0D+0, ONE = 1.0D+0) 
!     .. Scalar Arguments ..                                            
      INTEGER INFO, LDA, M, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), PIV ( * ) 
!     .. Local Scalars ..                                               
      INTEGER I, IINFO, J, JB, NB 
!     .. External Subroutines ..                                        
      EXTERNAL DGEMM, DTRSM, F06AAZ, F07ADH, F07ADJ, F07ZAZ 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX, MIN, SQRT 
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (M.LT.0) THEN 
         INFO = - 1 
      ELSEIF (N.LT.0) THEN 
         INFO = - 2 
      ELSEIF (LDA.LT.MAX (1, M) ) THEN 
         INFO = - 4 
      ENDIF 
      IF (INFO.NE.0) THEN 
      CALL F06AAZ ('F07ADG       ',  - INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF (M.EQ.0.OR.N.EQ.0) RETURN 
!                                                                       
!     Compute 2-norm of each row and store reciprocal in PIV.           
!                                                                       
      DO 20 I = 1, M 
         PIV (I) = ZERO 
   20 END DO 
      DO 60 J = 1, N 
         DO 40 I = 1, M 
            PIV (I) = PIV (I) + A (I, J) **2 
   40    END DO 
   60 END DO 
      DO 80 I = 1, M 
         IF (PIV (I) .LE.ZERO) THEN 
            INFO = I 
            RETURN 
         ELSE 
            PIV (I) = ONE / SQRT (PIV (I) ) 
         ENDIF 
   80 END DO 
!                                                                       
!     Determine the block size for this environment.                    
!                                                                       
      CALL F07ZAZ (1, 'F07ADG', NB, 0) 
      IF (NB.LE.1) THEN 
!                                                                       
!        Use unblocked code.                                            
!                                                                       
         CALL F07ADH (M, N, A, LDA, PIV, INFO) 
      ELSE 
!                                                                       
!        Use blocked code.                                              
!                                                                       
         DO 120 J = 1, MIN (M, N), NB 
            JB = MIN (MIN (M, N) - J + 1, NB) 
!                                                                       
!           Update diagonal and subdiagonal blocks.                     
!                                                                       
            CALL DGEMM ('No transpose', 'No transpose', M - J + 1, JB,  &
            J - 1, - ONE, A (J, 1) , LDA, A (1, J) , LDA, ONE, A (J, J) &
            , LDA)                                                      
!                                                                       
!           Factorize diagonal and subdiagonal blocks and test for      
!           approximate singularity.                                    
!                                                                       
            CALL F07ADH (M - J + 1, JB, A (J, J), LDA, PIV (J), IINFO) 
!                                                                       
            IF (IINFO.GT.0) THEN 
               INFO = IINFO + J - 1 
               RETURN 
            ENDIF 
!                                                                       
!           Update pivot indices and apply the interchanges to columns  
!           1:J-1.                                                      
!                                                                       
            DO 100 I = J, MIN (M, J + JB - 1) 
               PIV (I) = J - 1 + PIV (I) 
  100       END DO 
            CALL F07ADJ (J - 1, A, LDA, J, J + JB - 1, PIV, 1) 
!                                                                       
            IF (J + JB.LE.N) THEN 
!                                                                       
!              Apply the interchanges to columns J+JB:N.                
!                                                                       
               CALL F07ADJ (N - J - JB + 1, A (1, J + JB), LDA, J, J +  &
               JB - 1, PIV, 1)                                          
!                                                                       
!              Compute block row of U.                                  
!                                                                       
               CALL DGEMM ('No transpose', 'No transpose', JB, N - J -  &
               JB + 1, J - 1, - ONE, A (J, 1) , LDA, A (1, J + JB) ,    &
               LDA, ONE, A (J, J + JB) , LDA)                           
               CALL DTRSM ('Left', 'Lower', 'No transpose', 'Non-unit', &
               JB, N - J - JB + 1, ONE, A (J, J) , LDA, A (J, J + JB) , &
               LDA)                                                     
            ENDIF 
  120    END DO 
      ENDIF 
      RETURN 
!                                                                       
!     End of F07ADG                                                     
!                                                                       
      END SUBROUTINE F07ADG                         
                                                                        
                                                                        
      INTEGER FUNCTION P01ABF (IFAIL, IERROR, SRNAME, NREC, REC) 
!     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.                       
!     MARK 13 REVISED. IER-621 (APR 1988).                              
!     MARK 13B REVISED. IER-668 (AUG 1988).                             
!                                                                       
!     P01ABF is the error-handling routine for the NAG Library.         
!                                                                       
!     P01ABF either returns the value of IERROR through the routine     
!     name (soft failure), or terminates execution of the program       
!     (hard failure). Diagnostic messages may be output.                
!                                                                       
!     If IERROR = 0 (successful exit from the calling routine),         
!     the value 0 is returned through the routine name, and no          
!     message is output                                                 
!                                                                       
!     If IERROR is non-zero (abnormal exit from the calling routine),   
!     the action taken depends on the value of IFAIL.                   
!                                                                       
!     IFAIL =  1: soft failure, silent exit (i.e. no messages are       
!                 output)                                               
!     IFAIL = -1: soft failure, noisy exit (i.e. messages are output)   
!     IFAIL =-13: soft failure, noisy exit but standard messages from   
!                 P01ABF are suppressed                                 
!     IFAIL =  0: hard failure, noisy exit                              
!                                                                       
!     For compatibility with certain routines included before Mark 12   
!     P01ABF also allows an alternative specification of IFAIL in which 
!     it is regarded as a decimal integer with least significant digits 
!     cba. Then                                                         
!                                                                       
!     a = 0: hard failure  a = 1: soft failure                          
!     b = 0: silent exit   b = 1: noisy exit                            
!                                                                       
!     except that hard failure now always implies a noisy exit.         
!                                                                       
!     S.Hammarling, M.P.Hooper and J.J.du Croz, NAG Central Office.     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER IERROR, IFAIL, NREC 
      CHARACTER ( * ) SRNAME 
!     .. Array Arguments ..                                             
      CHARACTER ( * ) REC ( * ) 
!     .. Local Scalars ..                                               
      INTEGER I, NERR 
      CHARACTER(72) MESS 
!     .. External Subroutines ..                                        
      EXTERNAL P01ABZ, X04AAF, X04BAF 
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS, MOD 
!     .. Executable Statements ..                                       
      IF (IERROR.NE.0) THEN 
!        Abnormal exit from calling routine                             
         IF (IFAIL.EQ. - 1.OR.IFAIL.EQ.0.OR.IFAIL.EQ. - 13.OR. (        &
         IFAIL.GT.0.AND.MOD (IFAIL / 10, 10) .NE.0) ) THEN              
!           Noisy exit                                                  
            CALL X04AAF (0, NERR) 
            DO 20 I = 1, NREC 
               CALL X04BAF (NERR, REC (I) ) 
   20       END DO 
            IF (IFAIL.NE. - 13) THEN 
               WRITE (MESS, FMT = 99999) SRNAME, IERROR 
               CALL X04BAF (NERR, MESS) 
               IF (ABS (MOD (IFAIL, 10) ) .NE.1) THEN 
!                 Hard failure                                          
      CALL X04BAF (NERR, ' ** NAG hard failure - execution terminated') 
                  CALL P01ABZ 
               ELSE 
!                 Soft failure                                          
      CALL X04BAF (NERR, ' ** NAG soft failure - control returned') 
               ENDIF 
            ENDIF 
         ENDIF 
      ENDIF 
      P01ABF = IERROR 
      RETURN 
!                                                                       
99999 FORMAT (' ** ABNORMAL EXIT from NAG Library routine ',A,': IFAIL',&
     &  ' =',I6)                                                        
      END FUNCTION P01ABF                           
                                                                        
                                                                        
      DOUBLEPRECISION FUNCTION X02AMF () 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.                              
!                                                                       
!     RETURNS THE 'SAFE RANGE' PARAMETER                                
!     I.E. THE SMALLEST POSITIVE MODEL NUMBER Z SUCH THAT               
!     FOR ANY X WHICH SATISFIES X.GE.Z AND X.LE.1/Z                     
!     THE FOLLOWING CAN BE COMPUTED WITHOUT OVERFLOW, UNDERFLOW OR OTHER
!     ERROR                                                             
!                                                                       
!        -X                                                             
!        1.0/X                                                          
!        SQRT(X)                                                        
!        LOG(X)                                                         
!        EXP(LOG(X))                                                    
!        Y**(LOG(X)/LOG(Y)) FOR ANY Y                                   
!                                                                       
!     .. Executable Statements ..                                       
      X02AMF = (0.5D0 + 2.0D0** ( - 52) ) * 2.0D0** ( - 126) 
      RETURN 
      END FUNCTION X02AMF                           
                                                                        
                                                                        
      SUBROUTINE F07ADH (M, N, A, LDA, PIV, INFO) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.                              
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  F07ADH computes an LU factorization of a general m-by-n matrix A     
!  using partial pivoting with row interchanges.                        
!                                                                       
!  The factorization has the form                                       
!     A = P * L * U                                                     
!  where P is a permutation matrix, L is lower triangular (lower        
!  trapezoidal if m > n), and U is upper triangular with unit diagonal  
!  elements (upper trapezoidal if m < n).                               
!                                                                       
!  This is the Level 2 BLAS version of the Crout algorithm.             
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M >= 0.                 
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N >= 0.              
!                                                                       
!  A       (input/output) REAL array, dimension (LDA,N)                 
!          On entry, the m by n matrix to be factored.                  
!          On exit, the factors L and U from the factorization          
!          A = P*L*U; the unit diagonal elements of U are not stored.   
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA >= max(1,M).      
!                                                                       
!  PIV     (input/output) REAL array, dimension (M)                     
!          On entry, M scale factors for equilibrating the rows of A.   
!          On exit, the pivot indices; for 1 <= i <= min(M,N), row i of 
!          the matrix was interchanged with row PIV(i).                 
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          < 0: if INFO = -k, the k-th argument had an illegal value    
!          > 0: if INFO = k, approximate singularity has been detected a
!               the k-th stage; the factorization has not been          
!               completed.                                              
!                                                                       
!  This is a modified version of the LAPACK routine F07ADZ/DGETF2, in   
!  which the INTEGER array IPIV has been replaced by a REAL array PIV,  
!  row-equilibration is used in the choice of pivot, U has unit diagonal
!  elements, and the routine exits immediately if approximate           
!  singularity is detected.                                             
!                                                                       
!  =====================================================================
!           
      IMPLICIT NONE
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO, EIGHT 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0, EIGHT = 8.0D+0) 
!     .. Scalar Arguments ..                                            
      INTEGER INFO, LDA, M, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), PIV ( * ) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION THRESH, X, Y 
      INTEGER I, J, JP 
!     .. External Functions ..                                          
      DOUBLEPRECISION X02AJF 
      EXTERNAL X02AJF 
!     .. External Subroutines ..                                        
      EXTERNAL DGEMV, DSCAL, DSWAP, F06AAZ 
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS, MAX, MIN 
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      IF (M.LT.0) THEN 
         INFO = - 1 
      ELSEIF (N.LT.0) THEN 
         INFO = - 2 
      ELSEIF (LDA.LT.MAX (1, M) ) THEN 
         INFO = - 4 
      ENDIF 
      IF (INFO.NE.0) THEN 
      CALL F06AAZ ('F07ADH       ',  - INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF (M.EQ.0.OR.N.EQ.0) RETURN 
!                                                                       
!     Set threshold for test for singularity                            
!                                                                       
      THRESH = EIGHT * X02AJF () 
!                                                                       
      DO 40 J = 1, MIN (M, N) 
!                                                                       
!        Update diagonal and subdiagonal elements in column J.          
!                                                                       
         CALL DGEMV ('No transpose', M - J + 1, J - 1, - ONE, A (J, 1) ,&
         LDA, A (1, J) , 1, ONE, A (J, J) , 1)                          
!                                                                       
!        Find pivot and test for singularity.                           
!                                                                       
         JP = J 
         X = ZERO 
         DO 20 I = J, M 
            Y = ABS (A (I, J) ) * PIV (I) 
            IF (Y.GT.X) THEN 
               JP = I 
               X = Y 
            ENDIF 
   20    END DO 
         PIV (JP) = PIV (J) 
         PIV (J) = JP 
         IF (X.GE.THRESH) THEN 
!                                                                       
!           Apply interchange to columns 1:N.                           
!                                                                       
            IF (JP.NE.J) CALL DSWAP (N, A (J, 1), LDA, A (JP, 1),       &
            LDA)                                                        
!                                                                       
            IF (J + 1.LE.N) THEN 
!                                                                       
!              Compute row of U.                                        
!                                                                       
               CALL DGEMV ('Transpose', J - 1, N - J, - ONE, A (1, J +  &
               1) , LDA, A (J, 1) , LDA, ONE, A (J, J + 1) , LDA)       
!                                                                       
               CALL DSCAL (N - J, ONE / A (J, J), A (J, J + 1), LDA) 
            ENDIF 
!                                                                       
         ELSE 
!                                                                       
!           If A( JP, J ) is small, set INFO to indicate that a small   
!           pivot has been found.                                       
!                                                                       
            INFO = J 
            RETURN 
         ENDIF 
   40 END DO 
      RETURN 
!                                                                       
!     End of F07ADH                                                     
!                                                                       
      END SUBROUTINE F07ADH                         
                                                                        
                                                                        
      SUBROUTINE F07ADJ (N, A, LDA, K1, K2, PIV, INCX) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.                              
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  F07ADJ performs a series of row interchanges on the matrix A.        
!  One row interchange is initiated for each of rows K1 through K2 of A.
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.                       
!                                                                       
!  A       (input/output) REAL array, dimension (LDA,N)                 
!          On entry, the matrix of column dimension N to which the row  
!          interchanges will be applied.                                
!          On exit, the permuted matrix.                                
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.                        
!                                                                       
!  K1      (input) INTEGER                                              
!          The first element of PIV for which a row interchange will    
!          be done.                                                     
!                                                                       
!  K2      (input) INTEGER                                              
!          The last element of PIV for which a row interchange will     
!          be done.                                                     
!                                                                       
!  PIV     (input) REAL array, dimension( M*abs(INCX) )                 
!          The vector of pivot indices.  Only the elements in positions 
!          K1 through K2 of PIV are accessed.                           
!          PIV(K) = L implies rows K and L are to be interchanged.      
!                                                                       
!  INCX    (input) INTEGER                                              
!          The increment between succesive values of PIV.  If PIV       
!          is negative, the pivots are applied in reverse order.        
!                                                                       
!  This is a modified version of the LAPACK auxiliary routine           
!  F07ADY/DLASWP, in which the INTEGER array IPIV has been replaced by  
!  a REAL array PIV.                                                    
!                     
      IMPLICIT NONE
!     .. Scalar Arguments ..                                            
      INTEGER INCX, K1, K2, LDA, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), PIV ( * ) 
!     .. Local Scalars ..                                               
      INTEGER I, IP, IX 
!     .. External Subroutines ..                                        
      EXTERNAL DSWAP 
!     .. Intrinsic Functions ..                                         
      INTRINSIC NINT 
!     .. Executable Statements ..                                       
!                                                                       
!     Interchange row I with row PIV(I) for each of rows K1 through K2. 
!                                                                       
      IF (INCX.EQ.0) RETURN 
      IF (INCX.GT.0) THEN 
         IX = K1 
      ELSE 
         IX = 1 + (1 - K2) * INCX 
      ENDIF 
      IF (INCX.EQ.1) THEN 
         DO 20 I = K1, K2 
            IP = NINT (PIV (I) ) 
            IF (IP.NE.I) CALL DSWAP (N, A (I, 1), LDA, A (IP, 1),       &
            LDA)                                                        
   20    END DO 
      ELSEIF (INCX.GT.1) THEN 
         DO 40 I = K1, K2 
            IP = NINT (PIV (IX) ) 
            IF (IP.NE.I) CALL DSWAP (N, A (I, 1), LDA, A (IP, 1),       &
            LDA)                                                        
            IX = IX + INCX 
   40    END DO 
      ELSEIF (INCX.LT.0) THEN 
         DO 60 I = K2, K1, - 1 
            IP = NINT (PIV (IX) ) 
            IF (IP.NE.I) CALL DSWAP (N, A (I, 1), LDA, A (IP, 1),       &
            LDA)                                                        
            IX = IX + INCX 
   60    END DO 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F07ADJ                                                     
!                                                                       
      END SUBROUTINE F07ADJ                         
                                                                        
                                                                        
      DOUBLEPRECISION FUNCTION X02AJF () 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.                              
!                                                                       
!     RETURNS  (1/2)*B**(1-P)  IF ROUNDS IS .TRUE.                      
!     RETURNS  B**(1-P)  OTHERWISE                                      
!                                                                       
!     .. Executable Statements ..                                       
!     IN THEORY THIS SHOULD BE 2.0**(-56) BUT 2.0**(-55) HAS BEEN FOUND 
!     TO BE MORE PRACTICAL IN THE PAST.                                 
!     HOWEVER, FROM MARK 14 THE THEORETICAL VALUE WILL BE USED.         
      X02AJF = 2.0D0** ( - 56) 
      RETURN 
      END FUNCTION X02AJF                           
                                                                        
                                                                        
      SUBROUTINE F07AEF (TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO) 
!     MARK 15 RELEASE. NAG COPYRIGHT 1991.    
      IMPLICIT NONE
!     .. Entry Points ..                                                
      ENTRY DGETRS (TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO) 
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  DGETRS solves a system of linear equations                           
!     A * X = B  or  A' * X = B                                         
!  with a general n by n matrix A using the LU factorization computed   
!  by F07ADF.                                                           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  TRANS   (input) CHARACTER*1                                          
!          Specifies the form of the system of equations.               
!          = 'N':  A * X = B  (No transpose)                            
!          = 'T':  A'* X = B  (Transpose)                               
!          = 'C':  A'* X = B  (Conjugate transpose = Transpose)         
!                                                                       
!  N       (input) INTEGER                                              
!          The order of the matrix A.  N >= 0.                          
!                                                                       
!  NRHS    (input) INTEGER                                              
!          The number of right hand sides, i.e., the number of columns  
!          of the matrix B.  NRHS >= 0.                                 
!                                                                       
!  A       (input) REAL array, dimension (LDA,N)                        
!          The factors L and U from the factorization A = P*L*U         
!          as computed by F07ADF.                                       
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA >= max(1,N).      
!                                                                       
!  IPIV    (input) INTEGER array, dimension (N)                         
!          The pivot indices from F07ADF; for 1<=i<=N, row i of the     
!          matrix was interchanged with row IPIV(i).                    
!                                                                       
!  B       (input/output) REAL array, dimension (LDB,NRHS)              
!          On entry, the right hand side vectors B for the system of    
!          linear equations.                                            
!          On exit, the solution vectors, X.                            
!                                                                       
!  LDB     (input) INTEGER                                              
!          The leading dimension of the array B.  LDB >= max(1,N).      
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          < 0: if INFO = -k, the k-th argument had an illegal value    
!                                                                       
!  -- LAPACK routine (adapted for NAG Library)                          
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE 
      PARAMETER (ONE = 1.0D+0) 
!     .. Scalar Arguments ..                                            
      INTEGER INFO, LDA, LDB, N, NRHS 
      CHARACTER TRANS 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), B (LDB, * ) 
      INTEGER IPIV ( * ) 
!     .. Local Scalars ..                                               
      LOGICAL NOTRAN 
!     .. External Subroutines ..                                        
      EXTERNAL F06AAZ, F07ADY, DTRSM 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MAX 
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0 
      NOTRAN = (TRANS.EQ.'N'.OR.TRANS.EQ.'n') 
      IF (.NOT.NOTRAN.AND..NOT. (TRANS.EQ.'T'.OR.TRANS.EQ.'t')          &
      .AND..NOT. (TRANS.EQ.'C'.OR.TRANS.EQ.'c') ) THEN                  
         INFO = - 1 
      ELSEIF (N.LT.0) THEN 
         INFO = - 2 
      ELSEIF (NRHS.LT.0) THEN 
         INFO = - 3 
      ELSEIF (LDA.LT.MAX (1, N) ) THEN 
         INFO = - 5 
      ELSEIF (LDB.LT.MAX (1, N) ) THEN 
         INFO = - 8 
      ENDIF 
      IF (INFO.NE.0) THEN 
         CALL F06AAZ ('F07AEF/DGETRS', - INFO) 
         RETURN 
      ENDIF 
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF (N.EQ.0.OR.NRHS.EQ.0) RETURN 
!                                                                       
      IF (NOTRAN) THEN 
!                                                                       
!        Solve A * X = B.                                               
!                                                                       
!        Apply row interchanges to the right hand sides.                
!                                                                       
         CALL F07ADY (NRHS, B, LDB, 1, N, IPIV, 1) 
!                                                                       
!        Solve L*X = B, overwriting B with X.                           
!                                                                       
         CALL DTRSM ('Left', 'Lower', 'No transpose', 'Unit', N, NRHS,  &
         ONE, A, LDA, B, LDB)                                           
!                                                                       
!        Solve U*X = B, overwriting B with X.                           
!                                                                       
         CALL DTRSM ('Left', 'Upper', 'No transpose', 'Non-unit', N,    &
         NRHS, ONE, A, LDA, B, LDB)                                     
      ELSE 
!                                                                       
!        Solve A' * X = B.                                              
!                                                                       
!        Solve U'*X = B, overwriting B with X.                          
!                                                                       
         CALL DTRSM ('Left', 'Upper', 'Transpose', 'Non-unit', N, NRHS, &
         ONE, A, LDA, B, LDB)                                           
!                                                                       
!        Solve L'*X = B, overwriting B with X.                          
!                                                                       
         CALL DTRSM ('Left', 'Lower', 'Transpose', 'Unit', N, NRHS, ONE,&
         A, LDA, B, LDB)                                                
!                                                                       
!        Apply row interchanges to the solution vectors.                
!                                                                       
         CALL F07ADY (NRHS, B, LDB, 1, N, IPIV, - 1) 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F07AEF (DGETRS)                                            
!                                                                       
      END SUBROUTINE F07AEF                         
                                                                        
                                                                        
      SUBROUTINE F04JAF (M, N, A, NRA, B, TOL, SIGMA, IRANK, WORK,      &
      LWORK, IFAIL)                                                     
!     MARK 8 RELEASE. NAG COPYRIGHT 1979.                               
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (SVDLS1)          
!                                                                       
!     F04JAF RETURNS THE N ELEMENT VECTOR X, OF MINIMAL                 
!     LENGTH, THAT MINIMIZES THE EUCLIDEAN LENGTH OF THE M              
!     ELEMENT VECTOR R GIVEN BY                                         
!                                                                       
!     R = B-A*X ,                                                       
!                                                                       
!     WHERE A IS AN M*N (M.GE.N) MATRIX AND B IS AN M ELEMENT           
!     VECTOR. X IS OVERWRITTEN ON B.                                    
!                                                                       
!     THE SOLUTION IS OBTAINED VIA A SINGULAR VALUE                     
!     DECOMPOSITION (SVD) OF THE MATRIX A GIVEN BY                      
!                                                                       
!     A = Q*(D)*(P**T) ,                                                
!           (0)                                                         
!                                                                       
!     WHERE Q AND P ARE ORTHOGONAL AND D IS A DIAGONAL MATRIX WITH      
!     NON-NEGATIVE DIAGONAL ELEMENTS, THESE BEING THE SINGULAR          
!     VALUES OF A.                                                      
!                                                                       
!     INPUT PARAMETERS.                                                 
!                                                                       
!     M     - NUMBER OF ROWS OF A. M MUST BE AT LEAST N.                
!                                                                       
!     N     - NUMBER OF COLUMNS OF A. N MUST BE AT LEAST UNITY.         
!                                                                       
!     A     - AN M*N REAL MATRIX.                                       
!                                                                       
!     NRA   - ROW DIMENSION OF A AS DECLARED IN THE CALLING PROGRAM.    
!             NRA MUST BE AT LEAST M.                                   
!                                                                       
!     B     - AN M ELEMENT REAL VECTOR.                                 
!                                                                       
!     TOL   - A RELATIVE TOLERANCE USED TO DETERMINE THE RANK OF A.     
!             TOL SHOULD BE CHOSEN AS APPROXIMATELY THE                 
!             LARGEST RELATIVE ERROR IN THE ELEMENTS OF A.              
!             FOR EXAMPLE IF THE ELEMENTS OF A ARE CORRECT              
!             TO ABOUT 4 SIGNIFICANT FIGURES THEN TOL                   
!             SHOULD BE CHOSEN AS ABOUT 5.0*10.0**(-4).                 
!                                                                       
!     IFAIL - THE USUAL FAILURE PARAMETER. IF IN DOUBT SET              
!             IFAIL TO ZERO BEFORE CALLING THIS ROUTINE.                
!                                                                       
!     OUTPUT PARAMETERS.                                                
!                                                                       
!     A     - THE TOP N*N PART OF A WILL CONTAIN THE                    
!             ORTHOGONAL MATRIX P**T OF THE SVD.                        
!             THE REMAINDER OF A IS USED FOR INTERNAL WORKSPACE.        
!                                                                       
!     B     - THE FIRST N ELEMENTS OF B WILL CONTAIN THE                
!             MINIMAL LEAST SQUARES SOLUTION VECTOR X.                  
!                                                                       
!     SIGMA - IF M IS GREATER THAN IRANK THEN SIGMA WILL CONTAIN THE    
!             STANDARD ERROR GIVEN BY                                   
!             SIGMA=L(R)/SQRT(M-IRANK), WHERE L(R) DENOTES              
!             THE EUCLIDEAN LENGTH OF THE RESIDUAL VECTOR               
!             R. IF M=IRANK THEN SIGMA IS RETURNED AS ZERO.             
!                                                                       
!     IRANK - THE RANK OF THE MATRIX A.                                 
!                                                                       
!     IFAIL - ON NORMAL RETURN IFAIL WILL BE ZERO.                      
!             IN THE UNLIKELY EVENT THAT THE QR-ALGORITHM               
!             FAILS TO FIND THE SINGULAR VALUES IN 50*N                 
!             ITERATIONS THEN IFAIL IS SET TO 2.                        
!             IF AN INPUT PARAMETER IS INCORRECTLY SUPPLIED             
!             THEN IFAIL IS SET TO UNITY.                               
!                                                                       
!     WORKSPACE PARAMETERS.                                             
!                                                                       
!     WORK  - A 4*N ELEMENT VECTOR.                                     
!             ON RETURN THE FIRST N ELEMENTS OF WORK WILL               
!             CONTAIN THE SINGULAR VALUES OF A ARRANGED IN              
!             DESCENDING ORDER.                                         
!             WORK(N+1) WILL CONTAIN THE TOTAL NUMBER OF ITERATIONS     
!             TAKEN BY THE QR-ALGORITHM.                                
!                                                                       
!     LWORK - THE LENGTH OF THE VECTOR WORK. LWORK MUST BE              
!             AT LEAST 4*N.                                             
!             
      IMPLICIT NONE
!     .. Parameters ..                                                  
      CHARACTER(6) SRNAME 
      PARAMETER (SRNAME = 'F04JAF') 
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION SIGMA, TOL 
      INTEGER IFAIL, IRANK, LWORK, M, N, NRA 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (NRA, N), B (M), WORK (LWORK) 
!     .. Local Scalars ..                                               
      INTEGER IERR, NNN, NP1, NP2 
!     .. Local Arrays ..                                                
      CHARACTER(1) P01REC (1) 
!     .. External Functions ..                                          
      INTEGER F02WDY, P01ABF 
      EXTERNAL F02WDY, P01ABF 
!     .. External Subroutines ..                                        
      EXTERNAL F02WAF, F04JAZ 
!     .. Executable Statements ..                                       
      IERR = IFAIL 
      IF (IERR.EQ.0) IFAIL = 1 
!                                                                       
      IF (NRA.LT.M.OR.M.LT.N.OR.N.LT.1.OR.LWORK.LT.4 * N) GOTO 20 
!                                                                       
      NP1 = N + 1 
      NP2 = NP1 + 1 
      NNN = 3 * N 
!                                                                       
      CALL F02WAF (M, N, A, NRA, .TRUE., B, WORK, WORK (NP1), NNN,      &
      IFAIL)                                                            
!                                                                       
      IF (IFAIL.NE.0) GOTO 20 
!                                                                       
      IRANK = F02WDY (N, WORK, TOL) 
!                                                                       
      CALL F04JAZ (M, N, IRANK, WORK, N, B, A, NRA, B, SIGMA, WORK (NP2)&
      )                                                                 
!                                                                       
      RETURN 
!                                                                       
   20 IFAIL = P01ABF (IERR, IFAIL, SRNAME, 0, P01REC) 
      RETURN 
      END SUBROUTINE F04JAF                         
                                                                        
                                                                        
      SUBROUTINE F02WAF (M, N, A, NRA, WANTB, B, SV, WORK, LWORK, IFAIL) 
!     MARK 8 RELEASE. NAG COPYRIGHT 1979.                               
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     MARK 15 REVISED. IER-912 (APR 1991).                              
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (SVDGN1)          
!     Modified by Sven to replace calls to F01QAF and F02WAZ.           
!     7-Feb-1991.                                                       
!                                                                       
!     F02WAF RETURNS PART OF THE SINGULAR VALUE DECOMPOSITION           
!     OF THE M*N (M.GE.N) MATRIX A GIVEN BY                             
!                                                                       
!     A = Q*(D)*(P**T) ,                                                
!           (0)                                                         
!                                                                       
!     WHERE Q AND P ARE ORTHOGONAL MATRICES AND D IS AN N*N             
!     DIAGONAL MATRIX WITH NON-NEGATIVE DIAGONAL ELEMENTS,              
!     THESE BEING THE SINGULAR VALUES OF A.                             
!                                                                       
!     P**T AND THE DIAGONAL ELEMENTS OF D ARE RETURNED.                 
!     IF WANTB IS .TRUE. THEN (Q**T)*B IS ALSO RETURNED.                
!                                                                       
!     INPUT PARAMETERS.                                                 
!                                                                       
!     M     - NUMBER OF ROWS OF A. M MUST BE AT LEAST N.                
!                                                                       
!     N     - NUMBER OF COLUMNS OF A. N MUST BE AT LEAST                
!             UNITY AND MUST NOT BE LARGER THAN THAN M.                 
!                                                                       
!     A     - THE M*N MATRIX TO BE FACTORIZED.                          
!                                                                       
!     NRA   - ROW DIMENSION OF A AS DECLARED IN THE CALLING PROGRAM.    
!             NRA MUST BE AT LEAST M.                                   
!                                                                       
!     WANTB - MUST BE .TRUE. IF (Q**T)*B IS REQUIRED.                   
!             IF WANTB IS .FALSE. THEN B IS NOT REFERENCED.             
!                                                                       
!     B     - AN M ELEMENT VECTOR.                                      
!                                                                       
!     IFAIL - THE USUAL FAILURE PARAMETER. IF IN DOUBT SET              
!             IFAIL TO ZERO BEFORE CALLING F02WAF.                      
!                                                                       
!     OUTPUT PARAMETERS.                                                
!                                                                       
!     A     - THE TOP N*N PART OF A WILL CONTAIN THE N*N ORTHOGONAL     
!             MATRIX P**T.                                              
!             THE REMAINING (M-N)*N PART OF A IS USED FOR INTERNAL      
!             WORKSPACE.                                                
!                                                                       
!     B     - IF WANTB IS .TRUE. THEN B IS OVERWRITTEN BY               
!             THE M ELEMENT VECTOR (Q**T)*B.                            
!                                                                       
!     SV    - N ELEMENT VECTOR CONTAINING THE SINGULAR                  
!             VALUES OF A. THEY ARE ORDERED SO THAT                     
!             SV(1).GE.SV(2).GE. ... .GE.SV(N).GE.0.                    
!                                                                       
!     IFAIL - ON NORMAL RETURN IFAIL WILL BE ZERO.                      
!             IN THE UNLIKELY EVENT THAT THE QR-ALGORITHM               
!             FAILS TO FIND THE SINGULAR VALUES IN 50*N                 
!             ITERATIONS THEN IFAIL IS SET TO 2.                        
!             IF AN INPUT PARAMETER IS INCORRECTLY SUPPLIED             
!             THEN IFAIL IS SET TO UNITY.                               
!                                                                       
!     WORKSPACE PARAMETERS.                                             
!                                                                       
!     WORK  - A 3*N ELEMENT VECTOR.                                     
!             WORK(1) RETURNS THE TOTAL NUMBER OF ITERATIONS TAKEN      
!             BY THE QR-ALGORITHM.                                      
!                                                                       
!     LWORK - THE LENGTH OF THE VECTOR WORK. LWORK MUST BE              
!             AT LEAST 3*N.                                             
!                 
      IMPLICIT NONE
!     .. Parameters ..                                                  
      CHARACTER(6) SRNAME 
      PARAMETER (SRNAME = 'F02WAF') 
!     .. Scalar Arguments ..                                            
      INTEGER IFAIL, LWORK, M, N, NRA 
      LOGICAL WANTB 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (NRA, N), B (M), SV (N), WORK (LWORK) 
!     .. Local Scalars ..                                               
      INTEGER IERR, NP1, NPNP1 
!     .. Local Arrays ..                                                
      CHARACTER(1) P01REC (1) 
!     .. External Functions ..                                          
      INTEGER P01ABF 
      EXTERNAL P01ABF 
!     .. External Subroutines ..                                        
      EXTERNAL F01LZF, F01QCF, F02SZF, F02WAY, F01QDF 
!     .. Executable Statements ..                                       
      IERR = IFAIL 
      IF (IERR.EQ.0) IFAIL = 1 
!                                                                       
      IF (NRA.LT.M.OR.M.LT.N.OR.LWORK.LT.3 * N.OR.N.LT.1) GOTO 20 
!                                                                       
      NP1 = N + 1 
      NPNP1 = N + NP1 
!                                                                       
!     Call to F01QAF replaced by a call to F01QCF.                      
!     CALL F01QAF(M,N,A,NRA,A,NRA,WORK,IFAIL)                           
      CALL F01QCF (M, N, A, NRA, WORK, IFAIL) 
!                                                                       
!     Call to F02WAZ replaced by a call to F01QDF.                      
!     IF (WANTB) CALL F02WAZ(M,N,A,NRA,WORK,B,B)                        
      IF (WANTB) CALL F01QDF ('Transpose', 'Separate', M, N, A, NRA,    &
      WORK, 1, B, M, WORK (N + 1) , IFAIL)                              
!                                                                       
      CALL F01LZF (N, A, NRA, A, NRA, WANTB, B, .FALSE., .FALSE., WORK, &
      1, 1, .FALSE., WORK, 1, 1, SV, WORK, WORK, WORK, IFAIL)           
!                                                                       
      CALL F02WAY (N, A, NRA, A, NRA) 
!                                                                       
      IFAIL = 1 
      CALL F02SZF (N, SV, WORK, SV, WANTB, B, .FALSE., WORK, 1, 1,      &
      .TRUE., A, NRA, N, WORK, WORK (NP1), WORK (NPNP1), IFAIL)         
!                                                                       
      IF (IFAIL.EQ.0) RETURN 
!                                                                       
      IFAIL = 2 
   20 IFAIL = P01ABF (IERR, IFAIL, SRNAME, 0, P01REC) 
      RETURN 
      END SUBROUTINE F02WAF                         
                                                                        
                                                                        
      INTEGER FUNCTION F02WDY (N, SV, TOL) 
!     MARK 8 RELEASE. NAG COPYRIGHT 1979.                               
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).         
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (IRKSVD)          
!                                                                       
!     F02WDY RETURNS THE RANK OF AN M*K MATRIX A FOLLOWING A            
!     SINGULAR VALUE DECOMPOSITION OF A.                                
!                                                                       
!     THE N=MIN(M,K) SINGULAR VALUES OF A MUST BE IN                    
!     DESCENDING ORDER IN THE N ELEMENT VECTOR SV. THEN F02WDY          
!     RETURNS THE LARGEST INTEGER SUCH THAT                             
!                                                                       
!     SV(F02WDY) .GT. TOL*SV(1) .                                       
!                                                                       
!     IF SV(1)=0 THEN F02WDY IS RETURNED AS ZERO.                       
!                                                                       
!     IF TOL.LT.EPS OR TOL.GE.1 THEN THE VALUE EPS IS USED IN           
!     PLACE OF TOL, WHERE EPS IS THE SMALLEST REAL FOR WHICH            
!     1.0+EPS.GT.1.0 ON THE MACHINE. FOR MOST PROBLEMS THIS IS          
!     UNREASONABLY SMALL AND TOL SHOULD BE CHOSEN TO                    
!     APPROXIMATE THE RELATIVE ERRORS IN THE ELEMENTS OF A.             
!                                                                       
!     IF INSTEAD SINGULAR VALUES BELOW SOME VALUE DELTA ARE TO          
!     BE REGARDED AS ZERO THEN SUPPLY TOL AS DELTA/SV(1).               
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION TOL 
      INTEGER N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION SV (N) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION DELTA, TL 
      INTEGER I, IR 
!     .. External Functions ..                                          
      DOUBLEPRECISION X02AJF 
      EXTERNAL X02AJF 
!     .. Executable Statements ..                                       
      TL = TOL 
      DELTA = X02AJF () 
      IF (TL.LT.DELTA.OR.TL.GE.1.0D0) TL = DELTA 
!                                                                       
      IR = 0 
      DELTA = TL * SV (1) 
!                                                                       
      DO 20 I = 1, N 
         IF (SV (I) .LE.DELTA) GOTO 40 
         IR = I 
   20 END DO 
!                                                                       
   40 F02WDY = IR 
      RETURN 
      END FUNCTION F02WDY                           
                                                                        
                                                                        
      SUBROUTINE F04JAZ (M, N, IRANK, SV, LSV, B, PT, NRPT, X, SIGMA,   &
      WORK)                                                             
!     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.                             
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (SVDLS0)          
!                                                                       
!     F04JAZ RETURNS THE N ELEMENT VECTOR X, OF MINIMAL                 
!     LENGTH, THAT MINIMIZES THE EUCLIDEAN LENGTH OF THE M              
!     ELEMENT VECTOR R GIVEN BY                                         
!                                                                       
!     R = B-A*X ,                                                       
!                                                                       
!     WHERE B IS AN M ELEMENT VECTOR AND A IS AN M*N MATRIX,            
!     FOLLOWING A SINGULAR VALUE DECOMPOSITION (SVD) OF A               
!     GIVEN BY                                                          
!                                                                       
!     A = Q*D*(P**T) ,                                                  
!                                                                       
!     WHERE D IS A RECTANGULAR DIAGONAL MATRIX WHOSE DIAGONAL           
!     ELEMENTS CONTAIN THE SINGULAR VALUES OF A IN DESCENDING           
!     ORDER.                                                            
!                                                                       
!     INPUT PARAMETERS.                                                 
!                                                                       
!     M     - NUMBER OF ROWS OF A. M MUST BE AT LEAST UNITY.            
!                                                                       
!     N     - NUMBER OF COLUMNS OF A. N MUST BE AT LEAST UNITY.         
!                                                                       
!     IRANK - THE RANK OF THE MATRIX A. IRANK MUST BE SUCH THAT THE     
!             ELEMENTS SV(I), I=1,2,...,IRANK ARE NON-NEGLIGIBLE.       
!             IRANK MUST BE AT LEAST ZERO AND MUST NOT BE               
!             LARGER THAN MIN(M,N).                                     
!             ROUTINE F02WDY CAN BE USED TO DETERMINE RANK FOLLOWING    
!             AN SVD.                                                   
!                                                                       
!     SV    - AN LSV ELEMENT VECTOR CONTAINING THE POSITIVE             
!             NON-NEGLIGIBLE SINGULAR VALUES OF A.                      
!                                                                       
!     LSV   - LENGTH OF THE VECTOR SV.                                  
!             LSV MUST BE AT LEAST MAX(1,IRANK).                        
!                                                                       
!     B     - MUST CONTAIN THE M ELEMENT VECTOR (Q**T)*B, WHERE Q IS    
!             THE LEFT-HAND ORTHOGONAL MATRIX OF THE SVD.               
!                                                                       
!     PT    - THE IRANK*N PART OF PT MUST CONTAIN THE FIRST             
!             IRANK ROWS OF THE RIGHT-HAND ORTHOGONAL                   
!             MATRIX P**T OF THE SVD.                                   
!                                                                       
!     NRPT  - ROW DIMENSION OF PT AS DECLARED IN THE CALLING PROGRAM    
!             NRPT MUST BE AT LEAST LSV.                                
!                                                                       
!     OUTPUT PARAMETERS.                                                
!                                                                       
!     X     - THE N ELEMENT SOLUTION VECTOR.                            
!             THE ROUTINE MAY BE CALLED WITH X=B OR WITH X=SV.          
!                                                                       
!     SIGMA - IF M IS GREATER THAN IRANK THEN SIGMA WILL CONTAIN THE    
!             STANDARD ERROR GIVEN BY                                   
!             SIGMA=L(R)/SQRT(M-IRANK), WHERE L(R) DENOTES              
!             THE EUCLIDEAN LENGTH OF THE RESIDUAL VECTOR               
!             R. IF M=IRANK THEN SIGMA IS RETURNED AS ZERO.             
!                                                                       
!     WORKSPACE PARAMETER.                                              
!                                                                       
!     WORK  - AN LSV ELEMENT VECTOR.                                    
!             IF THE ROUTINE IS NOT CALLED WITH X=B THEN IT MAY BE      
!             CALLED WITH WORK=B. SIMILARLY IF THE ROUTINE              
!             IS NOT CALLED WITH X=SV THEN IT MAY BE CALLED             
!             WITH WORK=SV.                                             
!                                                                       
!     Modified to call BLAS.                                            
!     Jeremy Du Croz, NAG Central Office, October 1987.                 
!                
      IMPLICIT NONE
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION SIGMA 
      INTEGER IRANK, LSV, M, N, NRPT 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION B (M), PT (NRPT, N), SV (LSV), WORK (LSV),        &
      X (N)                                                             
!     .. Local Scalars ..                                               
      INTEGER IRP1, MMIR 
!     .. External Functions ..                                          
      DOUBLEPRECISION F06EJF 
      EXTERNAL F06EJF 
!     .. External Subroutines ..                                        
      EXTERNAL F04JAY 
!     .. Intrinsic Functions ..                                         
      INTRINSIC DBLE, SQRT 
!     .. Executable Statements ..                                       
      SIGMA = 0.0D0 
      IF (IRANK.EQ.M) GOTO 20 
      IRP1 = IRANK + 1 
      MMIR = M - IRANK 
!                                                                       
      SIGMA = F06EJF (MMIR, B (IRP1), 1) / SQRT (DBLE (MMIR) ) 
!                                                                       
   20 CALL F04JAY (N, IRANK, SV, LSV, B, PT, NRPT, X, WORK) 
!                                                                       
      RETURN 
      END SUBROUTINE F04JAZ                         
                                                                        
                                                                        
      SUBROUTINE F01LZF (N, A, NRA, C, NRC, WANTB, B, WANTQ, WANTY, Y,  &
      NRY, LY, WANTZ, Z, NRZ, NCZ, D, E, WORK1, WORK2, IFAIL)           
!     MARK 8 RELEASE. NAG COPYRIGHT 1979.                               
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).         
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (BIDIAG)          
!                                                                       
!     F01LZF RETURNS ALL OR PART OF THE FACTORIZATION OF THE            
!     N*N UPPER TRIANGULAR MATRIX A GIVEN BY                            
!                                                                       
!     A = Q*C*(P**T) ,                                                  
!                                                                       
!     WHERE Q AND P ARE N*N ORTHOGONAL MATRICES AND C IS AN             
!     N*N UPPER BIDIAGONAL MATRIX.                                      
!                                                                       
!     IF WANTB IS .TRUE. THEN B RETURNS (Q**T)*B.                       
!     IF WANTY IS .TRUE. THEN Y RETURNS Y*Q.                            
!     IF WANTZ IS .TRUE. THEN Z RETURNS (P**T)*Z.                       
!                                                                       
!     INPUT PARAMETERS.                                                 
!                                                                       
!     N     - ORDER OF THE MATRIX A.                                    
!                                                                       
!     A     - THE N*N UPPER TRIANGULAR MATRIX TO BE FACTORIZED. THE     
!             STRICTLY LOWER TRIANGULAR PART OF A IS NOT REFERENCED.    
!                                                                       
!     NRA   - ROW DIMENSION OF A AS DECLARED IN THE CALLING PROGRAM.    
!             NRA MUST BE AT LEAST N.                                   
!                                                                       
!     NRC   - ROW DIMENSION OF C AS DECLARED IN THE CALLING PROGRAM.    
!             NRC MUST BE AT LEAST N.                                   
!                                                                       
!     WANTB - MUST BE .TRUE. IF (Q**T)*B IS REQUIRED.                   
!             IF WANTB IS .FALSE. THEN B IS NOT REFERENCED.             
!                                                                       
!     B     - AN N ELEMENT REAL VECTOR.                                 
!                                                                       
!     WANTQ - MUST BE .TRUE. IF DETAILS OF Q ARE TO BE                  
!             STORED BELOW THE BIDIAGONAL PART OF C.                    
!             IF WANTQ IS .FALSE. THEN THE LOWER TRIANGULAR             
!             PART OF C IS NOT REFERENCED.                              
!                                                                       
!     WANTY - MUST BE .TRUE. IF Y*Q IS REQUIRED.                        
!             IF WANTY IS .FALSE. THEN Y IS NOT REFERENCED.             
!                                                                       
!     Y     - AN LY*N REAL MATRIX.                                      
!                                                                       
!     NRY   - IF WANTY IS .TRUE. THEN NRY MUST BE THE ROW               
!             DIMENSION OF Y AS DECLARED IN THE CALLING                 
!             PROGRAM AND MUST BE AT LEAST LY.                          
!                                                                       
!     LY    - IF WANTY IS .TRUE. THEN LY MUST BE THE NUMBER             
!             OF ROWS OF Y AND MUST BE AT LEAST 1.                      
!                                                                       
!     WANTZ - MUST BE .TRUE. IF (P**T)*Z IS REQUIRED.                   
!             IF WANTZ IS .FALSE. THEN Z IS NOT REFERENCED.             
!                                                                       
!     Z     - AN N*NCZ REAL MATRIX.                                     
!                                                                       
!     NRZ   - IF WANTZ IS .TRUE. THEN NRZ MUST BE THE ROW               
!             DIMENSION OF Z AS DECLARED IN THE CALLING                 
!             PROGRAM AND MUST BE AT LEAST N.                           
!                                                                       
!     NCZ   - IF WANTZ IS .TRUE. THEN NCZ MUST BE THE                   
!             NUMBER OF COLUMNS OF Z AND MUST BE AT LEAST               
!             1.                                                        
!                                                                       
!     IFAIL - THE USUAL FAILURE PARAMETER. IF IN DOUBT SET              
!             IFAIL TO ZERO BEFORE CALLING THIS ROUTINE.                
!                                                                       
!     OUTPUT PARAMETERS.                                                
!                                                                       
!     C     - N*N MATRIX CONTAINING THE UPPER BIDIAGONAL MATRIX B.      
!             DETAILS OF P ARE STORED ABOVE THE BIDIAGONAL              
!             PART OF C. UNLESS WANTQ IS .TRUE. THE                     
!             STRICTLY LOWER TRIANGULAR PART OF C IS NOT                
!             REFERENCED.                                               
!             THE ROUTINE MAY BE CALLED WITH C=A.                       
!                                                                       
!     B     - IF WANTB IS .TRUE. THEN B WILL RETURN THE N ELEMENT       
!             VECTOR (Q**T)*B.                                          
!                                                                       
!     Y     - IF WANTY IS .TRUE. THEN Y WILL RETURN THE                 
!             LY*N MATRIX Y*Q.                                          
!                                                                       
!     Z     - IF WANTZ IS .TRUE. THEN Z WILL RETURN THE N*NCZ MATRIX    
!             (P**T)*Z.                                                 
!                                                                       
!     D     - N ELEMENT VECTOR CONTAINING THE DIAGONAL ELEMENTS OF C    
!             SUCH THAT D(I)=C(I,I), I=1,2,...,N.                       
!                                                                       
!     E     - N ELEMENT VECTOR CONTAINING THE                           
!             SUPER-DIAGONAL ELEMENTS OF C SUCH THAT                    
!             E(I)=C(I-1,I), I=2,3,...,N. E(1) IS NOT                   
!             REFERENCED.                                               
!                                                                       
!     IFAIL - ON NORMAL RETURN IFAIL WILL BE ZERO.                      
!             IF AN INPUT PARAMETER IS INCORRECTLY SUPPLIED             
!             THEN IFAIL IS SET TO UNITY. NO OTHER FAILURE              
!             IS POSSIBLE.                                              
!                                                                       
!     WORKSPACE PARAMETERS.                                             
!                                                                       
!     WORK1                                                             
!     WORK2 - N ELEMENT REAL VECTORS.                                   
!             IF WANTZ IS .FALSE. THEN WORK1 AND WORK2 ARE NOT          
!             REFERENCED.                                               
!             
      IMPLICIT NONE
!     .. Parameters ..                                                  
      CHARACTER(6) SRNAME 
      PARAMETER (SRNAME = 'F01LZF') 
!     .. Scalar Arguments ..                                            
      INTEGER IFAIL, LY, N, NCZ, NRA, NRC, NRY, NRZ 
      LOGICAL WANTB, WANTQ, WANTY, WANTZ 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (NRA, N), B (N), C (NRC, N), D (N), E (N),      &
      WORK1 (N), WORK2 (N), Y (NRY, N), Z (NRZ, NCZ)                    
!     .. Local Scalars ..                                               
      DOUBLEPRECISION BIG, CS, EPS, RSQTPS, SMALL, SN, SQTEPS, T, W, X 
      INTEGER I, IERR, J, JJ, JP1, K, KP1, KP2, NM2 
!     .. Local Arrays ..                                                
      CHARACTER(1) P01REC (1) 
!     .. External Functions ..                                          
      DOUBLEPRECISION F01LZZ, X02AJF, X02AMF 
      INTEGER P01ABF 
      EXTERNAL F01LZZ, X02AJF, X02AMF, P01ABF 
!     .. External Subroutines ..                                        
      EXTERNAL F01LZW, F01LZX, F01LZY 
!     .. Intrinsic Functions ..                                         
      INTRINSIC SQRT 
!     .. Executable Statements ..                                       
      IERR = IFAIL 
      IF (IERR.EQ.0) IFAIL = 1 
!                                                                       
      IF (NRA.LT.N.OR.NRC.LT.N.OR.N.LT.1) GOTO 220 
      IF (WANTY.AND. (NRY.LT.LY.OR.LY.LT.1) ) GOTO 220 
      IF (WANTZ.AND. (NRZ.LT.N.OR.NCZ.LT.1) ) GOTO 220 
!                                                                       
      SMALL = X02AMF () 
      BIG = 1.0D0 / SMALL 
      EPS = X02AJF () 
      SQTEPS = SQRT (EPS) 
      RSQTPS = 1.0D0 / SQTEPS 
!                                                                       
      D (1) = A (1, 1) 
!                                                                       
      DO 40 J = 1, N 
         DO 20 I = 1, J 
            C (I, J) = A (I, J) 
   20    END DO 
   40 END DO 
!                                                                       
      IFAIL = 0 
      IF (N.EQ.1) RETURN 
      IF (N.EQ.2) GOTO 200 
!                                                                       
!     START MAIN LOOP. K(TH) STEP PUTS ZEROS INTO K(TH) ROW OF C.       
!                                                                       
      NM2 = N - 2 
      DO 180 K = 1, NM2 
         KP1 = K + 1 
!                                                                       
!        SET UP PLANE ROTATION P(J,J+1) TO ANNIHILATE C(K,J+1).         
!        THIS ROTATION INTRODUCES AN UNWANTED ELEMENT IN C(J+1,J)       
!        WHICH IS STORED IN X.                                          
!        J GOES N-1,N-2,...,K+1.                                        
!                                                                       
         J = N 
         DO 100 JJ = K, NM2 
            JP1 = J 
            J = J - 1 
            W = C (K, JP1) 
!                                                                       
            T = F01LZZ (C (K, J), W, SMALL, BIG) 
!                                                                       
            C (K, JP1) = T 
            X = 0.0D0 
!                                                                       
            CALL F01LZW (T, CS, SN, SQTEPS, RSQTPS, BIG) 
!                                                                       
            IF (.NOT.WANTZ) GOTO 60 
            WORK1 (J) = CS 
            WORK2 (J) = SN 
!                                                                       
   60       IF (T.EQ.0.0D0) GOTO 80 
            C (K, J) = CS * C (K, J) + SN * W 
!                                                                       
!           NOW APPLY THE TRANSFORMATION P(J,J+1).                      
!                                                                       
            CALL F01LZY (J - K, CS, SN, C (KP1, J), C (KP1, JP1) ) 
!                                                                       
            X = SN * C (JP1, JP1) 
            C (JP1, JP1) = CS * C (JP1, JP1) 
!                                                                       
!           NOW SET UP PLANE ROTATION Q(J,J+1)**T TO ANNIHILATE         
!           X=C(J+1,J).                                                 
!                                                                       
   80       T = F01LZZ (C (J, J), X, SMALL, BIG) 
!                                                                       
            IF (WANTQ) C (JP1, K) = T 
!                                                                       
            CALL F01LZW (T, D (J), E (J), SQTEPS, RSQTPS, BIG) 
!                                                                       
            C (J, J) = D (J) * C (J, J) + E (J) * X 
!                                                                       
            IF (WANTY) CALL F01LZY (LY, D (J), E (J), Y (1, J), Y (1,   &
            JP1) )                                                      
!                                                                       
  100    END DO 
!                                                                       
!        NOW APPLY THE TRANSFORMATIONS Q(J,J+1)**T AND FORM             
!        (P(J,J+1)**T)*Z, J=N-1,N-2,...,K+1 COLUMN BY COLUMN            
!                                                                       
         KP2 = KP1 + 1 
         DO 120 J = KP2, N 
!                                                                       
            CALL F01LZX (J - K, D (K), E (K), C (KP1, J) ) 
!                                                                       
  120    END DO 
!                                                                       
         IF (WANTB) CALL F01LZX (N - K, D (K), E (K), B (KP1) ) 
!                                                                       
         IF (.NOT.WANTZ) GOTO 160 
         DO 140 J = 1, NCZ 
!                                                                       
            CALL F01LZX (N - K, WORK1 (K), WORK2 (K), Z (KP1, J) ) 
!                                                                       
  140    END DO 
!                                                                       
  160    D (KP1) = C (KP1, KP1) 
         E (KP1) = C (K, KP1) 
!                                                                       
  180 END DO 
!                                                                       
  200 D (N) = C (N, N) 
      E (N) = C (N - 1, N) 
      RETURN 
!                                                                       
  220 IFAIL = P01ABF (IERR, IFAIL, SRNAME, 0, P01REC) 
      RETURN 
      END SUBROUTINE F01LZF                         
                                                                        
                                                                        
      SUBROUTINE F01LZW (T, C, S, SQTEPS, RSQTPS, BIG) 
!     MARK 8 RELEASE. NAG COPYRIGHT 1979.                               
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).         
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (COSSIN)          
!                                                                       
!     F01LZW RETURNS THE VALUES                                         
!                                                                       
!     C = COS(THETA)   AND   S = SIN(THETA)                             
!                                                                       
!     FOR A GIVEN VALUE OF                                              
!                                                                       
!     T = TAN(THETA) .                                                  
!                                                                       
!     C IS ALWAYS NON-NEGATIVE AND S HAS THE SAME SIGN AS T.            
!                                                                       
!     SQTEPS, RSQTPS AND BIG MUST BE SUCH THAT                          
!                                                                       
!     SQTEPS = SQRT(X02AJF) , RSQTPS = 1.0/SQTEPS AND BIG =             
!     1.0/X02AMF ,                                                      
!                                                                       
!     WHERE X02AJF AND X02AMF ARE THE NUMBERS RETURNED FROM             
!     ROUTINES X02AJF AND X02AMF RESPECTIVELY.                          
!                   
      IMPLICIT NONE
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION BIG, C, RSQTPS, S, SQTEPS, T 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION ABST, TT 
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS, SIGN, SQRT 
!     .. Executable Statements ..                                       
      IF (T.NE.0.0D0) GOTO 20 
      C = 1.0D0 
      S = 0.0D0 
      RETURN 
!                                                                       
   20 ABST = ABS (T) 
      IF (ABST.LT.SQTEPS) GOTO 60 
      IF (ABST.GT.RSQTPS) GOTO 80 
!                                                                       
      TT = ABST * ABST 
      IF (ABST.GT.1.0D0) GOTO 40 
!                                                                       
      TT = 0.25D0 * TT 
      C = 0.5D0 / SQRT (0.25D0 + TT) 
      S = C * T 
      RETURN 
!                                                                       
   40 TT = 0.25D0 / TT 
      S = 0.5D0 / SQRT (0.25D0 + TT) 
      C = S / ABST 
      S = SIGN (S, T) 
      RETURN 
!                                                                       
   60 C = 1.0D0 
      S = T 
      RETURN 
!                                                                       
   80 C = 0.0D0 
      IF (ABST.LT.BIG) C = 1.0D0 / ABST 
      S = SIGN (1.0D0, T) 
      RETURN 
      END SUBROUTINE F01LZW                         
                                                                        
                                                                        
      SUBROUTINE F01LZX (N, C, S, X) 
!     MARK 8 RELEASE. NAG COPYRIGHT 1979.                               
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (PLROT6)          
!                                                                       
!     F01LZX RETURNS THE N ELEMENT VECTOR                               
!                                                                       
!     Y = R(1,2)*R(2,3)*...*R(N-1,N)*X ,                                
!                                                                       
!     WHERE X IS AN N ELEMENT VECTOR AND R(J-1,J) IS A PLANE            
!     ROTATION FOR THE (J-1,J)-PLANE.                                   
!                                                                       
!     Y IS OVERWRITTEN ON X.                                            
!                                                                       
!     THE N ELEMENT VECTORS C AND S MUST BE SUCH THAT THE               
!     NON-IDENTITY PART OF R(J-1,J) IS GIVEN BY                         
!                                                                       
!     R(J-1,J) = (  C(J)  S(J) ) .                                      
!                ( -S(J)  C(J) )                                        
!                                                                       
!     C(1) AND S(1) ARE NOT REFERENCED.                                 
!                                                                       
!                                                                       
!     N MUST BE AT LEAST 1. IF N=1 THEN AN IMMEDIATE RETURN TO          
!     THE CALLING PROGRAM IS MADE.                                      
!              
      IMPLICIT NONE
!     .. Scalar Arguments ..                                            
      INTEGER N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION C (N), S (N), X (N) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION W 
      INTEGER I, II, IM1 
!     .. Executable Statements ..                                       
      IF (N.EQ.1) RETURN 
!                                                                       
      I = N 
      DO 20 II = 2, N 
         IM1 = I - 1 
         W = X (IM1) 
         X (IM1) = C (I) * W + S (I) * X (I) 
         X (I) = C (I) * X (I) - S (I) * W 
         I = IM1 
   20 END DO 
!                                                                       
      RETURN 
      END SUBROUTINE F01LZX                         
                                                                        
                                                                        
      SUBROUTINE F01LZY (N, C, S, X, Y) 
!     MARK 8 RELEASE. NAG COPYRIGHT 1979.                               
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (PLROT8)          
!                                                                       
!     F01LZY FORMS THE N*2 MATRIX                                       
!                                                                       
!     Z = ( X  Y )*( C  -S ) ,                                          
!                  ( S   C )                                            
!                                                                       
!     WHERE X AND Y ARE N ELEMENT VECTORS, C=COS(THETA) AND             
!     S=SIN(THETA).                                                     
!                                                                       
!     THE FIRST COLUMN OF Z IS OVERWRITTEN ON X AND THE SECOND          
!     COLUMN OF Z IS OVERWRITTEN ON Y.                                  
!                                                                       
!                                                                       
!     N MUST BE AT LEAST 1. 
      IMPLICIT NONE 
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION C, S 
      INTEGER N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION X (N), Y (N) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION W 
      INTEGER I 
!     .. Executable Statements ..                                       
      DO 20 I = 1, N 
         W = X (I) 
         X (I) = C * W + S * Y (I) 
         Y (I) = C * Y (I) - S * W 
   20 END DO 
!                                                                       
      RETURN 
      END SUBROUTINE F01LZY                         
                                                                        
                                                                        
      DOUBLEPRECISION FUNCTION F01LZZ (A, B, SMALL, BIG) 
!     MARK 8 RELEASE. NAG COPYRIGHT 1979.                               
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).         
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (TANGNT)          
!                                                                       
!     F01LZZ RETURNS THE VALUE                                          
!                                                                       
!     F01LZZ = B/A .                                                    
!                                                                       
!     SMALL AND BIG MUST BE SUCH THAT                                   
!                                                                       
!     SMALL = X02AMF     AND     BIG = 1.0/SMALL ,                      
!                                                                       
!     WHERE X02AMF IS THE SMALL NUMBER RETURNED FROM ROUTINE            
!     X02AMF.                                                           
!                                                                       
!     IF B/A IS LESS THAN SMALL THEN F01LZZ IS RETURNED AS              
!     ZERO AND IF B/A IS GREATER THAN BIG THEN F01LZZ IS                
!     RETURNED AS SIGN(BIG,B).                                          
!                                                                       
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION A, B, BIG, SMALL 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION ABSA, ABSB, X 
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS, SIGN 
!     .. Executable Statements ..                                       
      F01LZZ = 0.0D0 
      IF (B.EQ.0.0D0) RETURN 
!                                                                       
      ABSA = ABS (A) 
      ABSB = ABS (B) 
      X = 0.0D0 
      IF (ABSA.GE.1.0D0) X = ABSA * SMALL 
!                                                                       
      IF (ABSB.LT.X) RETURN 
!                                                                       
      X = 0.0D0 
      IF (ABSB.GE.1.0D0) X = ABSB * SMALL 
!                                                                       
      IF (ABSA.LE.X) GOTO 20 
!                                                                       
      F01LZZ = B / A 
      RETURN 
!                                                                       
   20 F01LZZ = SIGN (BIG, B) 
      RETURN 
      END FUNCTION F01LZZ                           
                                                                        
                                                                        
      SUBROUTINE F01QCF (M, N, A, LDA, ZETA, IFAIL) 
!     MARK 14 RELEASE. NAG COPYRIGHT 1989.                              
!                                                                       
!  1. Purpose                                                           
!     =======                                                           
!                                                                       
!  F01QCF  finds  the  QR factorization  of the real  m by n,  m .ge. n,
!  matrix A,  so that  A is reduced to upper triangular form by means of
!  orthogonal transformations.                                          
!                                                                       
!  2. Description                                                       
!     ===========                                                       
!                                                                       
!  The m by n matrix A is factorized as                                 
!                                                                       
!     A = Q*( R )   when   m.gt.n,                                      
!           ( 0 )                                                       
!                                                                       
!     A = Q*R       when   m = n,                                       
!                                                                       
!  where  Q  is an  m by m orthogonal matrix and  R  is an  n by n upper
!  triangular matrix.                                                   
!                                                                       
!  The  factorization  is  obtained  by  Householder's  method. The  kth
!  transformation matrix, Q( k ), which is used  to introduce zeros into
!  the kth column of A is given in the form                             
!                                                                       
!     Q( k ) = ( I     0   ),                                           
!              ( 0  T( k ) )                                            
!                                                                       
!  where                                                                
!                                                                       
!     T( k ) = I - u( k )*u( k )',                                      
!                                                                       
!     u( k ) = ( zeta( k ) ),                                           
!              (    z( k ) )                                            
!                                                                       
!  zeta( k )  is a scalar and  z( k )  is an  ( m - k )  element vector.
!  zeta( k ) and z( k )  are chosen to annhilate the elements  below the
!  triangular part of  A.                                               
!                                                                       
!  The vector  u( k ) is returned in the kth element of  ZETA and in the
!  kth column of A, such that zeta( k ) is in ZETA( k ) and the elements
!  of  z( k ) are in  a( k + 1, k ), ..., a( m, k ).  The elements of  R
!  are returned in the upper triangular part of  A.                     
!                                                                       
!  Q is given by                                                        
!                                                                       
!     Q = ( Q( n )*Q( n - 1 )*...*Q( 1 ) )'.                            
!                                                                       
!  3. Parameters                                                        
!     ==========                                                        
!                                                                       
!  M      - INTEGER.                                                    
!                                                                       
!           On entry, M must specify the number of rows of  A. M must be
!           at least  n.                                                
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!                                                                       
!           On entry, N must specify the number of columns of  A. N must
!           be  at  least zero. When  N = 0  then an immediate return is
!           effected.                                                   
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  A      - REAL             array of DIMENSION ( LDA, n ).             
!                                                                       
!           Before entry, the leading  M by N  part of the array  A must
!           contain the matrix to be factorized.                        
!                                                                       
!           On exit, the  N by N upper triangular part of A will contain
!           the upper triangular matrix R and the  M by N strictly lower
!           triangular  part   of   A   will  contain  details   of  the
!           factorization as described above.                           
!                                                                       
!  LDA    - INTEGER.                                                    
!                                                                       
!           On entry, LDA  must  specify  the  leading dimension of  the
!           array  A  as declared in the calling (sub) program. LDA must
!           be at least  m.                                             
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  ZETA   - REAL             array of DIMENSION at least ( n ).         
!                                                                       
!           On exit,  ZETA( k )  contains the scalar  zeta( k )  for the
!           kth  transformation.  If  T( k ) = I  then  ZETA( k ) = 0.0,
!           otherwise  ZETA( k )  contains  zeta( k ) as described above
!           and  zeta( k ) is always in the range  ( 1.0, sqrt( 2.0 ) ).
!                                                                       
!  IFAIL  - INTEGER.                                                    
!                                                                       
!           Before entry,  IFAIL  must contain one of the values -1 or 0
!           or 1 to specify noisy soft failure or noisy hard failure  or
!           silent soft failure. ( See Chapter P01 for further details.)
!                                                                       
!           On successful  exit  IFAIL  will be  zero,  otherwise  IFAIL
!           will  be set to  -1  indicating that an  input parameter has
!           been  incorrectly  set. See  the  next section  for  further
!           details.                                                    
!                                                                       
!  4. Diagnostic Information                                            
!     ======================                                            
!                                                                       
!  IFAIL = -1                                                           
!                                                                       
!     One or more of the following conditions holds:                    
!                                                                       
!        M   .lt. N                                                     
!        N   .lt. 0                                                     
!        LDA .lt. M                                                     
!                                                                       
!  If  on  entry,  IFAIL  was  either  -1 or 0  then  further diagnostic
!  information  will  be  output  on  the  error message  channel. ( See
!  routine  X04AAF. )                                                   
!                                                                       
!  5. Further information                                               
!     ===================                                               
!                                                                       
!  Following the use of this routine the operations                     
!                                                                       
!        B := Q*B   and   B := Q'*B,                                    
!                                                                       
!  where  B  is an  m by k  matrix, can  be  performed  by calls to  the
!  NAG Library routine  F01QDF. The  operation  B := Q*B can be obtained
!  by the call:                                                         
!                                                                       
!     IFAIL = 0                                                         
!     CALL F01QDF( 'No transpose', 'Separate', M, N, A, LDA, ZETA,      
!    $             K, B, LDB, WORK, IFAIL )                             
!                                                                       
!  and  B := Q'*B  can be obtained by the call:                         
!                                                                       
!     IFAIL = 0                                                         
!     CALL F01QDF( 'Transpose', 'Separate', M, N, A, LDA, ZETA,         
!    $             K, B, LDB, WORK, IFAIL )                             
!                                                                       
!  In  both  cases  WORK  must be a  k  element array  that  is used  as
!  workspace. If  B  is a one-dimensional array (single column) then the
!  parameter  LDB  can be replaced by  M. See routine F01QDF for further
!  details.                                                             
!                                                                       
!  The first k columns of the orthogonal matrix Q can either be obtained
!  by setting  B to the first k columns of the unit matrix and using the
!  first of the above two calls,  or by calling the  NAG Library routine
!  F01QEF, which overwrites the k columns of Q on the first k columns of
!  the array A.  Q is obtained by the call:                             
!                                                                       
!     CALL F01QEF( 'Separate', M, N, K, A, LDA, ZETA, WORK, IFAIL )     
!                                                                       
!  As above WORK must be a k element array.  If K is larger than N, then
!  A must have been declared to have at least K columns.                
!                                                                       
!  Operations involving the matrix  R  can readily  be performed by  the
!  Level 2 BLAS  routines  DTRSV  and DTRMV  (see Chapter F06), but note
!  that no test for  near singularity  of  R  is incorporated in DTRSV .
!  If  R  is singular,  or nearly singular then the  NAG Library routine
!  F02WUF  can be  used to  determine  the  singular value decomposition
!  of  R.                                                               
!                                                                       
!                                                                       
!  Nag Fortran 77 Auxiliary linear algebra routine.                     
!                                                                       
!  -- Written on 21-December-1985.                                      
!     Sven Hammarling, Nag Central Office.
      IMPLICIT NONE 
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
      CHARACTER(6) SRNAME 
      PARAMETER (SRNAME = 'F01QCF') 
!     .. Scalar Arguments ..                                            
      INTEGER IFAIL, LDA, M, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), ZETA ( * ) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION TEMP 
      INTEGER IERR, K, LA 
!     .. Local Arrays ..                                                
      CHARACTER(46) REC (1) 
!     .. External Functions ..                                          
      INTEGER P01ABF 
      EXTERNAL P01ABF 
!     .. External Subroutines ..                                        
      EXTERNAL DGEMV, DGER, F06FRF, P01ABY 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MIN 
!     .. Executable Statements ..                                       
!                                                                       
!     Check the input parameters.                                       
!                                                                       
      IERR = 0 
      IF (M.LT.N) CALL P01ABY (M, 'M', IFAIL, IERR, SRNAME) 
      IF (N.LT.0) CALL P01ABY (N, 'N', IFAIL, IERR, SRNAME) 
      IF (LDA.LT.M) CALL P01ABY (LDA, 'LDA', IFAIL, IERR, SRNAME) 
      IF (IERR.GT.0) THEN 
         WRITE (REC, FMT = 99999) IERR 
         IFAIL = P01ABF (IFAIL, - 1, SRNAME, 1, REC) 
         RETURN 
      ENDIF 
!                                                                       
!     Perform the factorization.                                        
!                                                                       
      IF (N.EQ.0) THEN 
         IFAIL = P01ABF (IFAIL, 0, SRNAME, 0, REC) 
         RETURN 
      ENDIF 
      LA = LDA 
      DO 20 K = 1, MIN (M - 1, N) 
!                                                                       
!        Use a  Householder reflection  to  zero the  kth column  of  A.
!        First set up the reflection.                                   
!                                                                       
         CALL F06FRF (M - K, A (K, K), A (K + 1, K), 1, ZERO, ZETA (K) ) 
         IF ( (ZETA (K) .GT.ZERO) .AND. (K.LT.N) ) THEN 
            IF ( (K + 1) .EQ.N) LA = M - K + 1 
!                                                                       
!           Temporarily  store  beta and  put  zeta( k )  in  a( k, k ).
!                                                                       
            TEMP = A (K, K) 
            A (K, K) = ZETA (K) 
!                                                                       
!           We now perform the operation  A := Q( k )*A.                
!                                                                       
!           Let  B  denote  the bottom  ( m - k + 1 ) by ( n - k )  part
!           of  A.                                                      
!                                                                       
!           First form   work = B'*u.  ( work  is stored in the elements
!           ZETA( k + 1 ), ..., ZETA( n ). )                            
!                                                                       
            CALL DGEMV ('Transpose', M - K + 1, N - K, ONE, A (K, K + 1)&
            , LA, A (K, K) , 1, ZERO, ZETA (K + 1) , 1)                 
!                                                                       
!           Now form  B := B - u*work'.                                 
!                                                                       
            CALL DGER (M - K + 1, N - K, - ONE, A (K, K), 1, ZETA (K +  &
            1), 1, A (K, K + 1), LA)                                    
!                                                                       
!           Restore beta.                                               
!                                                                       
            A (K, K) = TEMP 
         ENDIF 
   20 END DO 
!                                                                       
!     Set the final  ZETA  when  m.eq.n.                                
!                                                                       
      IF (M.EQ.N) ZETA (N) = ZERO 
!                                                                       
      IFAIL = P01ABF (IFAIL, 0, SRNAME, 0, REC) 
      RETURN 
!                                                                       
!                                                                       
!     End of F01QCF. ( SGEQR )                                          
!                                                                       
99999 FORMAT ('    The input parameters contained ',I2,' error(s)') 
      END SUBROUTINE F01QCF                         
                                                                        
                                                                        
      SUBROUTINE F01QDF (TRANS, WHERET, M, N, A, LDA, ZETA, NCOLB, B,   &
      LDB, WORK, IFAIL)                                                 
!     MARK 14 RELEASE. NAG COPYRIGHT 1989.                              
!                                                                       
!  1. Purpose                                                           
!     =======                                                           
!                                                                       
!  F01QDF performs one of the transformations                           
!                                                                       
!     B := Q*B   or   B := Q'*B,                                        
!                                                                       
!  where  B is an  m by ncolb real matrix and  Q is an m by m orthogonal
!  matrix, given as the product of  Householder transformation matrices.
!                                                                       
!  This  routine  is  intended  for  use  following  NAG Fortran Library
!  routine  F01QCF.                                                     
!                                                                       
!  2. Description                                                       
!     ===========                                                       
!                                                                       
!  Q is assumed to be given by                                          
!                                                                       
!     Q = ( Q( n )*Q( n - 1 )*...*Q( 1 ) )',                            
!                                                                       
!  Q( k ) being given in the form                                       
!                                                                       
!     Q( k ) = ( I     0   ),                                           
!              ( 0  T( k ) )                                            
!                                                                       
!  where                                                                
!                                                                       
!     T( k ) = I - u( k )*u( k )'                                       
!                                                                       
!     u( k ) = ( zeta( k ) ),                                           
!              (    z( k ) )                                            
!                                                                       
!  zeta( k )  is a scalar and  z( k )  is an  ( m - k )  element vector.
!                                                                       
!  z( k )  must  be  supplied  in  the  kth  column  of  A  in  elements
!  a( k + 1, k ), ..., a( m, k )  and  zeta( k ) must be supplied either
!  in  a( k, k ) or in zeta( k ),  depending upon the parameter  WHERET.
!                                                                       
!  To obtain Q explicitly B may be set to I and premultiplied by Q. This
!  is more efficient than obtaining Q'.                                 
!                                                                       
!  3. Parameters                                                        
!     ==========                                                        
!                                                                       
!  TRANS  - CHARACTER*1.                                                
!                                                                       
!           On entry, TRANS  specifies the operation to be performed  as
!           follows.                                                    
!                                                                       
!           TRANS = 'N' or 'n'  ( No transpose )                        
!                                                                       
!              Perform the operation  B := Q*B.                         
!                                                                       
!           TRANS = 'T' or 't' or 'C' or 'c'  ( Transpose )             
!                                                                       
!              Perform the operation  B := Q'*B.                        
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  WHERET - CHARACTER*1.                                                
!                                                                       
!           On entry,  WHERET  specifies where the elements of  zeta are
!           to be found as follows.                                     
!                                                                       
!           WHERET = 'I' or 'i'   ( In A )                              
!                                                                       
!              The elements of zeta are in A.                           
!                                                                       
!           WHERET = 'S' or 's'   ( Separate )                          
!                                                                       
!              The elements of zeta are separate from A, in ZETA.       
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  M      - INTEGER.                                                    
!                                                                       
!           On entry, M  must specify the number of rows of A. M must be
!           at least n.                                                 
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!                                                                       
!           On entry, N  must specify the number of columns of A. N must
!           be  at least zero. When  N = 0  then an immediate return  is
!           effected.                                                   
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  A      - REAL             array of DIMENSION ( LDA, n ).             
!                                                                       
!           Before entry, the leading  M by N  stricly lower  triangular
!           part of the array  A  must contain details of the matrix  Q.
!           In  addition, when  WHERET = 'I' or 'i'  then  the  diagonal
!           elements of A must contain the elements of zeta as described
!           under the argument  ZETA  below.                            
!                                                                       
!           When  WHERET = 'S' or 's'  then the diagonal elements of the
!           array  A  are referenced, since they are used temporarily to
!           store the  zeta( k ), but they contain their original values
!           on return.                                                  
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  LDA    - INTEGER.                                                    
!                                                                       
!           On  entry, LDA  must specify  the leading dimension  of  the
!           array  A  as declared in the calling (sub) program. LDA must
!           be at least m.                                              
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  ZETA   - REAL             array of  DIMENSION  at least  ( n ),  when
!           WHERET = 'S' or 's'.                                        
!                                                                       
!           Before entry with  WHERET = 'S' or 's', the array  ZETA must
!           contain  the  elements  of  zeta.  If  ZETA( k ) = 0.0  then
!           T( k )  is assumed  to be  I otherwise  ZETA( k ) is assumed
!           to contain zeta( k ).                                       
!                                                                       
!           When WHERET = 'I' or 'i', the array  ZETA is not referenced.
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  NCOLB  - INTEGER.                                                    
!                                                                       
!           On  entry, NCOLB  must specify  the number of columns of  B.
!           NCOLB  must  be  at  least  zero.  When  NCOLB = 0  then  an
!           immediate return is effected.                               
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  B      - REAL             array of DIMENSION ( LDB, ncolb ).         
!                                                                       
!           Before entry, the leading  M by NCOLB  part of  the array  B
!           must  contain  the matrix to be  transformed.               
!                                                                       
!           On  exit,  B  is  overwritten  by  the  transformed  matrix.
!                                                                       
!  LDB    - INTEGER.                                                    
!                                                                       
!           On  entry, LDB  must specify  the  leading dimension of  the
!           array  B as declared in the calling (sub) program. LDB  must
!           be at least m.                                              
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  WORK   - REAL             array of DIMENSION at least ( ncolb ).     
!                                                                       
!           Used as internal workspace.                                 
!                                                                       
!  IFAIL  - INTEGER.                                                    
!                                                                       
!           Before entry,  IFAIL  must contain one of the values -1 or 0
!           or 1 to specify noisy soft failure or noisy hard failure  or
!           silent soft failure. ( See Chapter P01 for further details.)
!                                                                       
!           On  successful exit  IFAIL  will be  zero,  otherwise  IFAIL
!           will  be set to   -1  indicating that an input parameter has
!           been  incorrectly  set. See  the  next  section  for further
!           details.                                                    
!                                                                       
!  4. Diagnostic Information                                            
!     ======================                                            
!                                                                       
!  IFAIL = -1                                                           
!                                                                       
!     One or more of the following conditions holds:                    
!                                                                       
!        TRANS  .ne. 'N' or 'n' or 'T' or 't' or 'C' or 'c'             
!        WHERET .ne. 'I' or 'i' or 'S' or 's'                           
!        M      .lt. N                                                  
!        N      .lt. 0                                                  
!        LDA    .lt. M                                                  
!        NCOLB  .lt. 0                                                  
!        LDB    .lt. M                                                  
!                                                                       
!  If  on  entry,  IFAIL  was either  -1 or 0  then  further  diagnostic
!  information  will  be  output  on  the  error message  channel. ( See
!  routine  X04AAF. )                                                   
!                                                                       
!                                                                       
!  Nag Fortran 77 Auxiliary linear algebra routine.                     
!                                                                       
!  -- Written on 13-November-1987.                                      
!     Sven Hammarling, Nag Central Office. 
      IMPLICIT NONE
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
      CHARACTER(6) SRNAME 
      PARAMETER (SRNAME = 'F01QDF') 
!     .. Scalar Arguments ..                                            
      INTEGER IFAIL, LDA, LDB, M, N, NCOLB 
      CHARACTER(1) TRANS, WHERET 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION A (LDA, * ), B (LDB, * ), WORK ( * ), ZETA ( * ) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION TEMP, ZETAK 
      INTEGER IERR, K, KK, LB 
!     .. Local Arrays ..                                                
      CHARACTER(46) REC (1) 
!     .. External Functions ..                                          
      INTEGER P01ABF 
      EXTERNAL P01ABF 
!     .. External Subroutines ..                                        
      EXTERNAL DGEMV, DGER, P01ABW, P01ABY 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MIN 
!     .. Executable Statements ..                                       
!                                                                       
!     Check the input parameters.                                       
!                                                                       
      IERR = 0 
      IF ( (TRANS.NE.'N') .AND. (TRANS.NE.'n') .AND. (TRANS.NE.'T')     &
      .AND. (TRANS.NE.'t') .AND. (TRANS.NE.'C') .AND. (TRANS.NE.'c') )  &
      CALL P01ABW (TRANS, 'TRANS', IFAIL, IERR, SRNAME)                 
      IF ( (WHERET.NE.'I') .AND. (WHERET.NE.'i') .AND. (WHERET.NE.'S')  &
      .AND. (WHERET.NE.'s') ) CALL P01ABW (WHERET, 'WHERET', IFAIL,     &
      IERR, SRNAME)                                                     
      IF (M.LT.N) CALL P01ABY (M, 'M', IFAIL, IERR, SRNAME) 
      IF (N.LT.0) CALL P01ABY (N, 'N', IFAIL, IERR, SRNAME) 
      IF (LDA.LT.M) CALL P01ABY (LDA, 'LDA', IFAIL, IERR, SRNAME) 
      IF (NCOLB.LT.0) CALL P01ABY (NCOLB, 'NCOLB', IFAIL, IERR, SRNAME) 
      IF (LDB.LT.M) CALL P01ABY (LDB, 'LDB', IFAIL, IERR, SRNAME) 
      IF (IERR.GT.0) THEN 
         WRITE (REC, FMT = 99999) IERR 
         IFAIL = P01ABF (IFAIL, - 1, SRNAME, 1, REC) 
         RETURN 
      ENDIF 
!                                                                       
!     Perform the transformation.                                       
!                                                                       
      IF (MIN (N, NCOLB) .EQ.0) THEN 
         IFAIL = P01ABF (IFAIL, 0, SRNAME, 0, REC) 
         RETURN 
      ENDIF 
      LB = LDB 
      DO 20 KK = 1, N 
         IF ( (TRANS.EQ.'T') .OR. (TRANS.EQ.'t') .OR. (TRANS.EQ.'C')    &
         .OR. (TRANS.EQ.'c') ) THEN                                     
!                                                                       
!           Q'*B = Q( n )*...*Q( 2 )*Q( 1 )*B,                          
!                                                                       
            K = KK 
         ELSE 
!                                                                       
!           Q*B  = Q( 1 )'*Q( 2 )'*...*Q( n )'*B,                       
!                                                                       
            K = N + 1 - KK 
         ENDIF 
         IF ( (WHERET.EQ.'S') .OR. (WHERET.EQ.'s') ) THEN 
            ZETAK = ZETA (K) 
         ELSE 
            ZETAK = A (K, K) 
         ENDIF 
         IF (ZETAK.GT.ZERO) THEN 
            TEMP = A (K, K) 
            A (K, K) = ZETAK 
            IF (NCOLB.EQ.1) LB = M - K + 1 
!                                                                       
!           Let C denote the bottom ( m - k + 1 ) by ncolb part of B.   
!                                                                       
!           First form  work = C'*u.                                    
!                                                                       
            CALL DGEMV ('Transpose', M - K + 1, NCOLB, ONE, B (K, 1) ,  &
            LB, A (K, K) , 1, ZERO, WORK, 1)                            
!                                                                       
!           Now form  C := C - u*work'.                                 
!                                                                       
            CALL DGER (M - K + 1, NCOLB, - ONE, A (K, K), 1, WORK, 1, B &
            (K, 1), LB)                                                 
!                                                                       
!           Restore the diagonal element of A.                          
!                                                                       
            A (K, K) = TEMP 
         ENDIF 
   20 END DO 
!                                                                       
      IFAIL = P01ABF (IFAIL, 0, SRNAME, 0, REC) 
      RETURN 
!                                                                       
!                                                                       
!     End of F01QDF. ( SGEAPQ )                                         
!                                                                       
99999 FORMAT ('    The input parameters contained ',I2,' error(s)') 
      END SUBROUTINE F01QDF                         
                                                                        
                                                                        
      SUBROUTINE F02SZF (N, D, E, SV, WANTB, B, WANTY, Y, NRY, LY,      &
      WANTZ, Z, NRZ, NCZ, WORK1, WORK2, WORK3, IFAIL)                   
!     MARK 8 RELEASE. NAG COPYRIGHT 1979.                               
!     MARK 9 REVISED. IER-328 (SEP 1981).                               
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     MARK 12 REVISED. IER-518 (AUG 1986).                              
!     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).         
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (SVDBID)          
!                                                                       
!     F02SZF RETURNS PART OR ALL OF THE SINGULAR VALUE                  
!     DECOMPOSITION OF THE N*N UPPER BIDIAGONAL MATRIX A. THAT          
!     IS, A IS FACTORIZED AS                                            
!                                                                       
!     A = Q*DIAG(SV)*(P**T) ,                                           
!                                                                       
!     WHERE Q AND P ARE N*N ORTHOGONAL MATRICES AND DIAG(SV)            
!     IS AN N*N DIAGONAL MATRIX WITH NON-NEGATIVE DIAGONAL              
!     ELEMENTS SV(1),SV(2),..., SV(N), THESE BEING THE                  
!     SINGULAR VALUES OF A.                                             
!                                                                       
!     IF WANTB IS .TRUE. THEN B RETURNS (Q**T)*B.                       
!     IF WANTY IS .TRUE. THEN Y RETURNS Y*Q.                            
!     IF WANTZ IS .TRUE. THEN Z RETURNS (P**T)*Z.                       
!                                                                       
!     INPUT PARAMETERS.                                                 
!                                                                       
!     N     - THE ORDER OF THE MATRIX. MUST BE AT LEAST 1.              
!                                                                       
!     D     - N ELEMENT VECTOR SUCH THAT D(I)=A(I,I), I=1,2,...,N.      
!             D IS UNALTERED UNLESS ROUTINE IS CALLED WITH SV=D.        
!                                                                       
!     E     - N ELEMENT VECTOR SUCH THAT E(I)=A(I-1,I), I=2,3,...,N.    
!             E(1) IS NOT REFERENCED.                                   
!             E IS UNALTERED UNLESS ROUTINE IS CALLED WITH WORK1=E.     
!                                                                       
!     WANTB - MUST BE .TRUE. IF (Q**T)*B IS REQUIRED.                   
!             IF WANTB IS .FALSE. THEN B IS NOT REFERENCED.             
!                                                                       
!     B     - AN N ELEMENT REAL VECTOR.                                 
!                                                                       
!     WANTY - MUST BE .TRUE. IF Y*Q IS REQUIRED.                        
!             IF WANTY IS .FALSE. THEN Y IS NOT REFERENCED.             
!                                                                       
!     Y     - AN LY*N REAL MATRIX.                                      
!                                                                       
!     NRY   - IF WANTY IS .TRUE. THEN NRY MUST BE THE ROW               
!             DIMENSION OF Y AS DECLARED IN THE CALLING                 
!             PROGRAM AND MUST BE AT LEAST LY.                          
!                                                                       
!     LY    - IF WANTY IS .TRUE. THEN LY MUST BE THE NUMBER             
!             OF ROWS OF Y AND MUST BE AT LEAST 1.                      
!                                                                       
!     WANTZ - MUST BE .TRUE. IF (P**T)*Z IS REQUIRED.                   
!             IF WANTZ IS .FALSE. THEN Z IS NOT REFERENCED.             
!                                                                       
!     Z     - AN N*NCZ REAL MATRIX.                                     
!                                                                       
!     NRZ   - IF WANTZ IS .TRUE. THEN NRZ MUST BE THE ROW               
!             DIMENSION OF Z AS DECLARED IN THE CALLING                 
!             PROGRAM AND MUST BE AT LEAST N.                           
!                                                                       
!     NCZ   - IF WANTZ IS .TRUE. THEN NCZ MUST BE THE                   
!             NUMBER OF COLUMNS OF Z AND MUST BE AT LEAST               
!             1.                                                        
!                                                                       
!     IFAIL - THE USUAL FAILURE PARAMETER. IF IN DOUBT SET              
!             IFAIL TO ZERO BEFORE CALLING F02SZF.                      
!                                                                       
!     OUTPUT PARAMETERS.                                                
!                                                                       
!     SV    - N ELEMENT VECTOR CONTAINING THE SINGULAR                  
!             VALUES OF A. THEY ARE ORDERED SO THAT                     
!             SV(1).GE.SV(2).GE. ... .GE.SV(N). THE ROUTINE             
!             MAY BE CALLED WITH SV=D.                                  
!                                                                       
!     B     - IF WANTB IS .TRUE. THEN B WILL RETURN THE N               
!             ELEMENT VECTOR (Q**T)*B.                                  
!                                                                       
!     Y     - IF WANTY IS .TRUE. THEN Y WILL RETURN THE                 
!             LY*N MATRIX Y*Q.                                          
!                                                                       
!     Z     - IF WANTZ IS .TRUE. THEN Z WILL RETURN THE N*NCZ MATRIX    
!             (P**T)*Z.                                                 
!                                                                       
!     IFAIL - ON NORMAL RETURN IFAIL WILL BE ZERO.                      
!             IN THE UNLIKELY EVENT THAT THE QR-ALGORITHM               
!             FAILS TO FIND THE SINGULAR VALUES IN 50*N                 
!             ITERATIONS THEN IFAIL WILL BE 2 OR MORE AND               
!             SUCH THAT SV(1),SV(2),..,SV(IFAIL-1) MAY NOT              
!             HAVE BEEN FOUND. SEE WORK1 BELOW. THIS                    
!             FAILURE IS NOT LIKELY TO OCCUR.                           
!             IF AN INPUT PARAMETER IS INCORRECTLY SUPPLIED             
!             THEN IFAIL IS SET TO UNITY.                               
!                                                                       
!     WORKSPACE PARAMETERS.                                             
!                                                                       
!     WORK1 - AN N ELEMENT VECTOR. IF E IS NOT REQUIRED ON              
!             RETURN THEN THE ROUTINE MAY BE CALLED WITH                
!             WORK1=E. WORK1(1) RETURNS THE TOTAL NUMBER OF             
!             ITERATIONS TAKEN BY THE  QR-ALGORITHM. IF                 
!             IFAIL IS POSITIVE ON RETURN THEN THE MATRIX A             
!             IS GIVEN  BY A=Q*C*(P**T) , WHERE C IS THE                
!             UPPER BIDIAGONAL MATRIX WITH SV AS ITS                    
!             DIAGONAL AND WORK1 AS ITS SUPER-DIAGONAL.                 
!                                                                       
!     WORK2                                                             
!     WORK3 - N ELEMENT VECTORS. IF WANTZ IS .FALSE. THEN WORK2 AND     
!             WORK3 ARE NOT REFERENCED.   
      IMPLICIT NONE
!                                                                       
!     .. Parameters ..                                                  
      CHARACTER(6) SRNAME 
      PARAMETER (SRNAME = 'F02SZF') 
!     .. Scalar Arguments ..                                            
      INTEGER IFAIL, LY, N, NCZ, NRY, NRZ 
      LOGICAL WANTB, WANTY, WANTZ 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION B (N), D (N), E (N), SV (N), WORK1 (N), WORK2 (N),&
      WORK3 (N), Y (NRY, N), Z (NRZ, NCZ)                               
!     .. Local Scalars ..                                               
      DOUBLEPRECISION ANORM, BIG, C, DK, DKM1, DL, EK, EKM1, EPS, F, G, &
      RSQTPS, S, SHUFT, SMALL, SQTEPS, SVI, T, X                        
      INTEGER I, IERR, ITER, J, JJ, K, KK, L, LL, LM1, LP1, MAXIT 
!     .. Local Arrays ..                                                
      CHARACTER(1) P01REC (1) 
!     .. External Functions ..                                          
      DOUBLEPRECISION F01LZZ, X02AJF, X02AMF 
      INTEGER P01ABF 
      EXTERNAL F01LZZ, X02AJF, X02AMF, P01ABF 
!     .. External Subroutines ..                                        
      EXTERNAL F01LZW, F01LZY, F02SZZ 
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS, MAX, SQRT 
!     .. Executable Statements ..                                       
      IERR = IFAIL 
      IF (IERR.EQ.0) IFAIL = 1 
!                                                                       
      IF (N.LT.1) GOTO 500 
      IF (WANTY.AND. (NRY.LT.LY.OR.LY.LT.1) ) GOTO 500 
      IF (WANTZ.AND. (NRZ.LT.N.OR.NCZ.LT.1) ) GOTO 500 
!                                                                       
      SMALL = X02AMF () 
      BIG = 1.0D0 / SMALL 
      EPS = X02AJF () 
      SQTEPS = SQRT (EPS) 
      RSQTPS = 1.0D0 / SQTEPS 
!                                                                       
      ITER = 0 
      K = N 
      SV (1) = D (1) 
      ANORM = ABS (D (1) ) 
      IF (N.EQ.1) GOTO 280 
!                                                                       
      DO 20 I = 2, N 
         SV (I) = D (I) 
         WORK1 (I) = E (I) 
         ANORM = MAX (ANORM, ABS (D (I) ), ABS (E (I) ) ) 
   20 END DO 
!                                                                       
      MAXIT = 50 * N 
      EPS = EPS * ANORM 
!                                                                       
!     MAXIT IS THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.                
!     EPS WILL BE USED TO TEST FOR NEGLIGIBLE ELEMENTS.                 
!     START MAIN LOOP. ONE SINGULAR VALUE IS FOUND FOR EACH             
!     VALUE OF K. K GOES IN OPPOSITE DIRECTION TO KK.                   
!                                                                       
      DO 260 KK = 2, N 
!                                                                       
!        NOW TEST FOR SPLITTING. L GOES IN OPPOSITE DIRECTION TO LL.    
!                                                                       
   40    L = K 
         DO 60 LL = 2, K 
            IF (ABS (WORK1 (L) ) .LE.EPS) GOTO 240 
            L = L - 1 
            IF (ABS (SV (L) ) .LT.EPS) GOTO 180 
   60    END DO 
!                                                                       
   80    IF (ITER.EQ.MAXIT) GOTO 280 
!                                                                       
!        MAXIT QR-STEPS WITHOUT CONVERGENCE. FAILURE.                   
!                                                                       
         ITER = ITER + 1 
!                                                                       
!        NOW DETERMINE SHIFT.                                           
!                                                                       
         LP1 = L + 1 
         DL = SV (L) 
         DKM1 = SV (K - 1) 
         DK = SV (K) 
         EKM1 = 0.0D0 
         IF (K.NE.2) EKM1 = WORK1 (K - 1) 
         EK = WORK1 (K) 
         F = (DKM1 - DK) * (DKM1 + DK) + (EKM1 - EK) * (EKM1 + EK) 
         F = F / (2.0D0 * EK * DKM1) 
         G = ABS (F) 
         IF (G.LE.RSQTPS) G = SQRT (1.0D0 + F**2) 
         IF (F.LT.0.0D0) G = - G 
!                                                                       
         SHUFT = EK * (EK - DKM1 / (F + G) ) 
         F = (DL - DK) * (DL + DK) - SHUFT 
         X = DL * WORK1 (LP1) 
!                                                                       
!        NOW PERFORM THE QR-STEP AND CHASE ZEROS.                       
!                                                                       
         DO 140 I = LP1, K 
!                                                                       
            T = F01LZZ (F, X, SMALL, BIG) 
!                                                                       
            CALL F01LZW (T, C, S, SQTEPS, RSQTPS, BIG) 
!                                                                       
            IF (I.GT.LP1) WORK1 (I - 1) = C * F + S * X 
            F = C * SV (I - 1) + S * WORK1 (I) 
            WORK1 (I) = C * WORK1 (I) - S * SV (I - 1) 
            X = S * SV (I) 
            SVI = C * SV (I) 
!                                                                       
            IF (.NOT.WANTZ) GOTO 100 
            WORK2 (I) = C 
            WORK3 (I) = S 
!                                                                       
  100       T = F01LZZ (F, X, SMALL, BIG) 
!                                                                       
            CALL F01LZW (T, C, S, SQTEPS, RSQTPS, BIG) 
!                                                                       
            IF (WANTY) CALL F01LZY (LY, C, S, Y (1, I - 1), Y (1, I) ) 
!                                                                       
            IF (.NOT.WANTB) GOTO 120 
            T = B (I) 
            B (I) = C * T - S * B (I - 1) 
            B (I - 1) = C * B (I - 1) + S * T 
!                                                                       
  120       SV (I - 1) = C * F + S * X 
            F = C * WORK1 (I) + S * SVI 
            SV (I) = C * SVI - S * WORK1 (I) 
!                                                                       
            IF (I.EQ.K) GOTO 140 
            X = S * WORK1 (I + 1) 
            WORK1 (I + 1) = C * WORK1 (I + 1) 
!                                                                       
  140    END DO 
!                                                                       
         WORK1 (K) = F 
         IF (.NOT.WANTZ) GOTO 40 
         DO 160 J = 1, NCZ 
!                                                                       
            CALL F02SZZ (K - L + 1, WORK2 (L), WORK3 (L), Z (L, J) ) 
!                                                                       
  160    END DO 
         GOTO 40 
!                                                                       
!        COME TO NEXT PIECE IF SV(L-1) IS NEGLIGIBLE. FORCE A SPLIT.    
!                                                                       
  180    LM1 = L 
         L = L + 1 
         X = WORK1 (L) 
         WORK1 (L) = 0.0D0 
         DO 220 I = L, K 
!                                                                       
            T = F01LZZ (SV (I), X, SMALL, BIG) 
!                                                                       
            CALL F01LZW (T, C, S, SQTEPS, RSQTPS, BIG) 
!                                                                       
            IF (WANTY) CALL F01LZY (LY, C, - S, Y (1, LM1), Y (1, I) ) 
!                                                                       
            IF (.NOT.WANTB) GOTO 200 
            T = B (I) 
            B (I) = C * T + S * B (LM1) 
            B (LM1) = C * B (LM1) - S * T 
!                                                                       
  200       SV (I) = C * SV (I) + S * X 
            IF (I.EQ.K) GOTO 220 
            X = - S * WORK1 (I + 1) 
            WORK1 (I + 1) = C * WORK1 (I + 1) 
!                                                                       
  220    END DO 
!                                                                       
!        IF WE COME HERE WITH L=K THEN A SINGULAR VALUE HAS BEEN        
!        FOUND.                                                         
!                                                                       
  240    IF (L.LT.K) GOTO 80 
!                                                                       
         K = K - 1 
  260 END DO 
!                                                                       
  280 IFAIL = K - 1 
      WORK1 (1) = ITER 
!                                                                       
!     NOW MAKE SINGULAR VALUES NON-NEGATIVE.                            
!     K WILL BE 1 UNLESS FAILURE HAS OCCURED.                           
!                                                                       
      DO 320 J = K, N 
         IF (SV (J) .GE.0.0D0) GOTO 320 
!                                                                       
         SV (J) = - SV (J) 
!                                                                       
         IF (WANTB) B (J) = - B (J) 
         IF (.NOT.WANTY) GOTO 320 
         DO 300 I = 1, LY 
            Y (I, J) = - Y (I, J) 
  300    END DO 
!                                                                       
  320 END DO 
!                                                                       
!     NOW SORT THE SINGULAR VALUES INTO DESCENDING ORDER.               
!                                                                       
      IF (WANTZ) JJ = 0 
      DO 400 J = K, N 
         S = 0.0D0 
         L = J 
!                                                                       
         DO 340 I = J, N 
            IF (SV (I) .LE.S) GOTO 340 
            S = SV (I) 
            L = I 
  340    END DO 
!                                                                       
         IF (S.EQ.0.0D0) GOTO 420 
         IF (WANTZ) WORK2 (J) = L 
         IF (L.EQ.J) GOTO 400 
         IF (WANTZ) JJ = J 
!                                                                       
         SV (L) = SV (J) 
         SV (J) = S 
         IF (.NOT.WANTY) GOTO 380 
!                                                                       
         DO 360 I = 1, LY 
            T = Y (I, J) 
            Y (I, J) = Y (I, L) 
            Y (I, L) = T 
  360    END DO 
!                                                                       
  380    IF (.NOT.WANTB) GOTO 400 
         T = B (J) 
         B (J) = B (L) 
         B (L) = T 
!                                                                       
  400 END DO 
!                                                                       
  420 IF (.NOT.WANTZ) GOTO 480 
      IF (JJ.EQ.0) GOTO 480 
      DO 460 I = 1, NCZ 
         DO 440 J = K, JJ 
            L = WORK2 (J) 
            IF (J.EQ.L) GOTO 440 
            T = Z (J, I) 
            Z (J, I) = Z (L, I) 
            Z (L, I) = T 
  440    END DO 
  460 END DO 
!                                                                       
  480 IF (IFAIL.EQ.0) RETURN 
!                                                                       
      IFAIL = IFAIL + 1 
  500 IFAIL = P01ABF (IERR, IFAIL, SRNAME, 0, P01REC) 
      RETURN 
      END SUBROUTINE F02SZF                         
                                                                        
                                                                        
      SUBROUTINE F02SZZ (N, C, S, X) 
!     MARK 8 RELEASE. NAG COPYRIGHT 1979.                               
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (PLRT10)          
!                                                                       
!     F02SZZ RETURNS THE N ELEMENT VECTOR                               
!                                                                       
!     Y = R(N-1,N)*R(N-2,N-1)*...*R(1,2)*X ,                            
!                                                                       
!     WHERE X IS AN N ELEMENT VECTOR AND R(J-1,J) IS A PLANE            
!     ROTATION FOR THE (J-1,J)-PLANE.                                   
!                                                                       
!     Y IS OVERWRITTEN ON X.                                            
!                                                                       
!     THE N ELEMENT VECTORS C AND S MUST BE SUCH THAT THE               
!     NON-IDENTITY PART OF R(J-1,J) IS GIVEN BY                         
!                                                                       
!     R(J-1,J) = (  C(J)  S(J) ) .                                      
!                ( -S(J)  C(J) )                                        
!                                                                       
!     C(1) AND S(1) ARE NOT REFERENCED.                                 
!                                                                       
!                                                                       
!     N MUST BE AT LEAST 1. IF N=1 THEN AN IMMEDIATE RETURN TO          
!     THE CALLING PROGRAM IS MADE. 
      IMPLICIT NONE
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION C (N), S (N), X (N) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION W 
      INTEGER I 
!     .. Executable Statements ..                                       
      IF (N.EQ.1) RETURN 
!                                                                       
      DO 20 I = 2, N 
         W = X (I - 1) 
         X (I - 1) = C (I) * W + S (I) * X (I) 
         X (I) = C (I) * X (I) - S (I) * W 
   20 END DO 
!                                                                       
      RETURN 
      END SUBROUTINE F02SZZ                         
                                                                        
                                                                        
      SUBROUTINE F02WAY (N, C, NRC, PT, NRPT) 
!     MARK 8 RELEASE. NAG COPYRIGHT 1979.                               
!     MARK 11.5(F77) REVISED. (SEPT 1985.)                              
!     MARK 12 REVISED. IER-519 (AUG 1986).                              
!     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).         
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (BIGVPT)          
!                                                                       
!     F02WAY RETURNS THE N*N ORTHOGONAL MATRIX P**T FOR THE             
!     FACTORIZATION OF ROUTINE F01LZF.                                  
!                                                                       
!     DETAILS OF P MUST BE SUPPLIED IN THE N*N MATRIX C AS              
!     RETURNED FROM ROUTINE F01LZF.                                     
!                                                                       
!     NRC AND NRPT MUST BE THE ROW DIMENSIONS OF C AND PT               
!     RESPECTIVELY AS DECLARED IN THE CALLING PROGRAM AND MUST          
!     EACH BE AT LEAST N.                                               
!                                                                       
!     THE ROUTINE MAY BE CALLED WITH PT=C.   
      IMPLICIT NONE
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER N, NRC, NRPT 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION C (NRC, N), PT (NRPT, N) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION BIG, CS, RSQTPS, SN, SQTEPS, T 
      INTEGER I, J, K, KK, KM1, KP1 
!     .. External Functions ..                                          
      DOUBLEPRECISION X02AJF, X02AMF 
      EXTERNAL X02AJF, X02AMF 
!     .. External Subroutines ..                                        
      EXTERNAL F01LZW, F01LZY 
!     .. Intrinsic Functions ..                                         
      INTRINSIC SQRT 
!     .. Executable Statements ..                                       
      BIG = 1.0D0 / X02AMF () 
      SQTEPS = SQRT (X02AJF () ) 
      RSQTPS = 1.0D0 / SQTEPS 
      DO 15 J = 3, N 
         DO 5 I = 1, J - 2 
            PT (I, J) = C (I, J) 
    5    END DO 
   15 END DO 
!                                                                       
      PT (N, N) = 1.0D0 
      IF (N.EQ.1) RETURN 
!                                                                       
      PT (N - 1, N) = 0.0D0 
      PT (N, N - 1) = 0.0D0 
      PT (N - 1, N - 1) = 1.0D0 
      IF (N.EQ.2) RETURN 
!                                                                       
      K = N 
      DO 60 KK = 3, N 
         KP1 = K 
         K = K - 1 
         KM1 = K - 1 
         PT (KM1, K) = 0.0D0 
!                                                                       
         DO 20 J = KP1, N 
            T = PT (KM1, J) 
            PT (KM1, J) = 0.0D0 
            IF (T.EQ.0.0D0) GOTO 20 
!                                                                       
            CALL F01LZW ( - T, CS, SN, SQTEPS, RSQTPS, BIG) 
!                                                                       
            CALL F01LZY (N - KM1, CS, SN, PT (K, J - 1), PT (K, J) ) 
!                                                                       
   20    END DO 
!                                                                       
         PT (KM1, KM1) = 1.0D0 
         DO 40 I = K, N 
            PT (I, KM1) = 0.0D0 
   40    END DO 
!                                                                       
   60 END DO 
!                                                                       
      RETURN 
      END SUBROUTINE F02WAY                         
                                                                        
                                                                        
      SUBROUTINE F04JAY (N, IRANK, SV, LSV, B, PT, NRPT, X, WORK) 
!     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.                             
!     WRITTEN BY S. HAMMARLING, MIDDLESEX POLYTECHNIC (SVDLSQ)          
!                                                                       
!     F04JAY RETURNS THE N ELEMENT VECTOR X GIVEN BY                    
!                                                                       
!     X = P*(D**(-1))*B ,                                               
!                                                                       
!     WHERE D IS AN IRANK*IRANK NON-SINGULAR DIAGONAL MATRIX,           
!     P CONTAINS THE FIRST IRANK COLUMNS OF AN N*N ORTHOGONAL           
!     MATRIX AND B IS AN IRANK ELEMENT VECTOR.                          
!                                                                       
!     THE ROUTINE MAY BE CALLED WITH IRANK=0 IN WHICH CASE X            
!     IS RETURNED AS THE ZERO VECTOR.                                   
!                                                                       
!     INPUT PARAMETERS.                                                 
!                                                                       
!     N     - NUMBER OF ROWS OF P. N MUST BE AT LEAST UNITY.            
!                                                                       
!     IRANK - ORDER OF THE MATRIX D.                                    
!             IF IRANK=0 THEN SV, B, PT AND WORK ARE NOT REFERENCED.    
!                                                                       
!     SV    - AN IRANK ELEMENT VECTOR CONTAINING THE                    
!             DIAGONAL ELEMENTS OF D. SV MUST BE SUCH THAT              
!             NO ELEMENT OF (D**(-1)*B WILL OVERFLOW.                   
!                                                                       
!     LSV   - LSV MUST BE AT LEAST MAX(1,IRANK).                        
!                                                                       
!     B     - AN IRANK ELEMENT VECTOR.                                  
!                                                                       
!     PT    - AN IRANK*N ELEMENT MATRIX CONTAINING THE MATRIX P**T.     
!                                                                       
!     NRPT  - ROW DIMENSION OF PT AS DECLARED IN THE                    
!             CALLING PROGRAM. NRPT MUST BE AT LEAST LSV.               
!                                                                       
!     OUTPUT PARAMETER.                                                 
!                                                                       
!     X     - N ELEMENT VECTOR CONTAINING P*(D**(-1))*B.                
!             IF IRANK=0 THEN X RETURNS THE ZERO VECTOR.                
!             THE ROUTINE MAY BE CALLED WITH X=B OR WITH X=SV.          
!                                                                       
!     WORKSPACE PARAMETER.                                              
!                                                                       
!     WORK  - AN LSV ELEMENT VECTOR.                                    
!             IF THE ROUTINE IS NOT CALLED WITH X=B THEN IT MAY BE      
!             CALLED WITH WORK=B. SIMILARLY IF THE ROUTINE              
!             IS NOT CALLED WITH X=SV THEN IT MAY BE CALLED             
!             WITH WORK=SV.                                             
!                                                                       
!     Modified to call BLAS.                                            
!     Jeremy Du Croz, NAG Central Office, October 1987.  
      IMPLICIT NONE
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER IRANK, LSV, N, NRPT 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION B (LSV), PT (NRPT, N), SV (LSV), WORK (LSV),      &
      X (N)                                                             
!     .. Local Scalars ..                                               
      INTEGER I 
!     .. External Subroutines ..                                        
      EXTERNAL DGEMV 
!     .. Executable Statements ..                                       
      IF (IRANK.EQ.0) GOTO 40 
!                                                                       
      DO 20 I = 1, IRANK 
         WORK (I) = B (I) / SV (I) 
   20 END DO 
!                                                                       
      CALL DGEMV ('Transpose', IRANK, N, 1.0D0, PT, NRPT, WORK, 1,      &
      0.0D0, X, 1)                                                      
!                                                                       
      RETURN 
!                                                                       
   40 DO 60 I = 1, N 
         X (I) = 0.0D0 
   60 END DO 
!                                                                       
      RETURN 
      END SUBROUTINE F04JAY                         
                                                                        
                                                                        
      DOUBLEPRECISION FUNCTION F06BMF (SCALE, SSQ) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.                              
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION SCALE, SSQ 
!     ..                                                                
!                                                                       
!  F06BMF returns the value norm given by                               
!                                                                       
!     norm = ( scale*sqrt( ssq ), scale*sqrt( ssq ) .lt. flmax          
!            (                                                          
!            ( flmax,             scale*sqrt( ssq ) .ge. flmax          
!                                                                       
!  via the function name.                                               
!                                                                       
!                                                                       
!  Nag Fortran 77 O( 1 ) basic linear algebra routine.                  
!                                                                       
!  -- Written on 22-October-1982.                                       
!     Sven Hammarling, Nag Central Office.                              
!                                                                       
!                                                                       
!     .. Local Scalars ..                                               
      DOUBLEPRECISION FLMAX, FLMIN, NORM, SQT 
      LOGICAL FIRST 
!     .. External Functions ..                                          
      DOUBLEPRECISION X02AMF 
      EXTERNAL X02AMF 
!     .. Intrinsic Functions ..                                         
      INTRINSIC SQRT 
!     .. Save statement ..                                              
      SAVE FIRST, FLMAX 
!     .. Data statements ..                                             
      DATA FIRST / .TRUE. / 
!     ..                                                                
!     .. Executable Statements ..                                       
      IF (FIRST) THEN 
         FIRST = .FALSE. 
         FLMIN = X02AMF () 
         FLMAX = 1 / FLMIN 
      ENDIF 
!                                                                       
      SQT = SQRT (SSQ) 
      IF (SCALE.LT.FLMAX / SQT) THEN 
         NORM = SCALE * SQT 
      ELSE 
         NORM = FLMAX 
      ENDIF 
!                                                                       
      F06BMF = NORM 
      RETURN 
!                                                                       
!     End of F06BMF. ( SNORM )                                          
!                                                                       
      END FUNCTION F06BMF                           
                                                                        
                                                                        
      DOUBLEPRECISION FUNCTION F06EJF (N, X, INCX) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.                              
!     .. Entry Points ..                                                
      DOUBLEPRECISION DNRM2 
      ENTRY DNRM2 (N, X, INCX) 
!     .. Scalar Arguments ..                                            
      INTEGER INCX, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION X ( * ) 
!     ..                                                                
!                                                                       
!  F06EJF returns the euclidean norm of a vector via the function       
!  name, so that                                                        
!                                                                       
!     F06EJF := sqrt( x'*x )                                            
!                                                                       
!                                                                       
!  Nag Fortran 77 version of the Blas routine DNRM2.                    
!  Nag Fortran 77 O( n ) basic linear algebra routine.                  
!                                                                       
!  -- Written on 25-October-1982.                                       
!     Sven Hammarling, Nag Central Office.                              
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION NORM, SCALE, SSQ 
!     .. External Functions ..                                          
      DOUBLEPRECISION F06BMF 
      EXTERNAL F06BMF 
!     .. External Subroutines ..                                        
      EXTERNAL F06FJF 
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
      IF (N.LT.1) THEN 
         NORM = ZERO 
      ELSEIF (N.EQ.1) THEN 
         NORM = ABS (X (1) ) 
      ELSE 
         SCALE = ZERO 
         SSQ = ONE 
         CALL F06FJF (N, X, INCX, SCALE, SSQ) 
         NORM = F06BMF (SCALE, SSQ) 
      ENDIF 
!                                                                       
      F06EJF = NORM 
      RETURN 
!                                                                       
!     End of F06EJF. ( DNRM2 )                                          
!                                                                       
      END FUNCTION F06EJF                           
                                                                        
                                                                        
      SUBROUTINE F06FJF (N, X, INCX, SCALE, SUMSQ) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.     
      IMPLICIT NONE
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION SCALE, SUMSQ 
      INTEGER INCX, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION X ( * ) 
!     ..                                                                
!                                                                       
!  F06FJF returns the values scl and smsq such that                     
!                                                                       
!     ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq, 
!                                                                       
!  where x( i ) = X( 1 + ( i - 1 )*INCX ). The value of sumsq is assumed
!  to be at least unity and the value of smsq will then satisfy         
!                                                                       
!     1.0 .le. smsq .le. ( sumsq + n ) .                                
!                                                                       
!  scale is assumed to be non-negative and scl returns the value        
!                                                                       
!     scl = max( scale, abs( x( i ) ) ) .                               
!                                                                       
!  scale and sumsq must be supplied in SCALE and SUMSQ respectively.    
!  scl and smsq are overwritten on SCALE and SUMSQ respectively.        
!                                                                       
!  The routine makes only one pass through the vector X.                
!                                                                       
!                                                                       
!  Nag Fortran 77 O( n ) basic linear algebra routine.                  
!                                                                       
!  -- Written on 22-October-1982.                                       
!     Sven Hammarling, Nag Central Office.                              
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ZERO 
      PARAMETER (ZERO = 0.0D+0) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION ABSXI 
      INTEGER IX 
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS 
!     ..                                                                
!     .. Executable Statements ..                                       
      IF (N.GT.0) THEN 
         DO 10, IX = 1, 1 + (N - 1) * INCX, INCX 
            IF (X (IX) .NE.ZERO) THEN 
               ABSXI = ABS (X (IX) ) 
               IF (SCALE.LT.ABSXI) THEN 
                  SUMSQ = 1 + SUMSQ * (SCALE / ABSXI) **2 
                  SCALE = ABSXI 
               ELSE 
                  SUMSQ = SUMSQ + (ABSXI / SCALE) **2 
               ENDIF 
            ENDIF 
   10    END DO 
      ENDIF 
      RETURN 
!                                                                       
!     End of F06FJF. ( SSSQ )                                           
!                                                                       
      END SUBROUTINE F06FJF                         
                                                                        
                                                                        
      SUBROUTINE F06FRF (N, ALPHA, X, INCX, TOL, ZETA) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.  
      IMPLICIT NONE 
!     .. Scalar Arguments ..                                            
      DOUBLEPRECISION ALPHA, TOL, ZETA 
      INTEGER INCX, N 
!     .. Array Arguments ..                                             
      DOUBLEPRECISION X ( * ) 
!     ..                                                                
!                                                                       
!  F06FRF generates details of a generalized Householder reflection such
!  that                                                                 
!                                                                       
!     P*( alpha ) = ( beta ),   P'*P = I.                               
!       (   x   )   (   0  )                                            
!                                                                       
!  P is given in the form                                               
!                                                                       
!     P = I - ( zeta )*( zeta  z' ),                                    
!             (   z  )                                                  
!                                                                       
!  where z is an n element vector and zeta is a scalar that satisfies   
!                                                                       
!     1.0 .le. zeta .le. sqrt( 2.0 ).                                   
!                                                                       
!  zeta is returned in ZETA unless x is such that                       
!                                                                       
!     max( abs( x( i ) ) ) .le. max( eps*abs( alpha ), tol )            
!                                                                       
!  where eps is the relative machine precision and tol is the user      
!  supplied value TOL, in which case ZETA is returned as 0.0 and P can  
!  be taken to be the unit matrix.                                      
!                                                                       
!  beta is overwritten on alpha and z is overwritten on x.              
!  the routine may be called with  n = 0  and advantage is taken of the 
!  case where  n = 1.                                                   
!                                                                       
!                                                                       
!  Nag Fortran 77 O( n ) basic linear algebra routine.                  
!                                                                       
!  -- Written on 30-August-1984.                                        
!     Sven Hammarling, Nag Central Office.                              
!     This version dated 28-September-1984.                             
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      DOUBLEPRECISION ONE, ZERO 
      PARAMETER (ONE = 1.0D+0, ZERO = 0.0D+0) 
!     .. Local Scalars ..                                               
      DOUBLEPRECISION BETA, EPS, SCALE, SSQ 
      LOGICAL FIRST 
!     .. External Functions ..                                          
      DOUBLEPRECISION X02AJF 
      EXTERNAL X02AJF 
!     .. External Subroutines ..                                        
      EXTERNAL F06FJF, DSCAL 
!     .. Intrinsic Functions ..                                         
      INTRINSIC ABS, MAX, SIGN, SQRT 
!     .. Save statement ..                                              
      SAVE EPS, FIRST 
!     .. Data statements ..                                             
      DATA FIRST / .TRUE. / 
!     ..                                                                
!     .. Executable Statements ..                                       
      IF (N.LT.1) THEN 
         ZETA = ZERO 
      ELSEIF ( (N.EQ.1) .AND. (X (1) .EQ.ZERO) ) THEN 
         ZETA = ZERO 
      ELSE 
!                                                                       
         IF (FIRST) THEN 
            FIRST = .FALSE. 
            EPS = X02AJF () 
         ENDIF 
!                                                                       
!        Treat case where P is a 2 by 2 matrix specially.               
!                                                                       
         IF (N.EQ.1) THEN 
!                                                                       
!           Deal with cases where  ALPHA = zero  and                    
!           abs( X( 1 ) ) .le. max( EPS*abs( ALPHA ), TOL )  first.     
!                                                                       
            IF (ALPHA.EQ.ZERO) THEN 
               ZETA = ONE 
               ALPHA = ABS (X (1) ) 
               X (1) = - SIGN (ONE, X (1) ) 
            ELSEIF (ABS (X (1) ) .LE.MAX (EPS * ABS (ALPHA), TOL) )     &
            THEN                                                        
               ZETA = ZERO 
            ELSE 
               IF (ABS (ALPHA) .GE.ABS (X (1) ) ) THEN 
                  BETA = ABS (ALPHA) * SQRT (1 + (X (1) / ALPHA) **2) 
               ELSE 
                  BETA = ABS (X (1) ) * SQRT (1 + (ALPHA / X (1) ) **2) 
               ENDIF 
               ZETA = SQRT ( (ABS (ALPHA) + BETA) / BETA) 
               IF (ALPHA.GE.ZERO) BETA = - BETA 
               X (1) = - X (1) / (ZETA * BETA) 
               ALPHA = BETA 
            ENDIF 
         ELSE 
!                                                                       
!           Now P is larger than 2 by 2.                                
!                                                                       
            SSQ = ONE 
            SCALE = ZERO 
            CALL F06FJF (N, X, INCX, SCALE, SSQ) 
!                                                                       
!           Treat cases where  SCALE = zero,                            
!           SCALE .le. max( EPS*abs( ALPHA ), TOL )  and                
!           ALPHA = zero  specially.                                    
!           Note that  SCALE = max( abs( X( i ) ) ).                    
!                                                                       
            IF ( (SCALE.EQ.ZERO) .OR. (SCALE.LE.MAX (EPS * ABS (ALPHA), &
            TOL) ) ) THEN                                               
               ZETA = ZERO 
            ELSEIF (ALPHA.EQ.ZERO) THEN 
               ZETA = ONE 
               ALPHA = SCALE * SQRT (SSQ) 
               CALL DSCAL (N, - 1 / ALPHA, X, INCX) 
            ELSE 
               IF (SCALE.LT.ABS (ALPHA) ) THEN 
                  BETA = ABS (ALPHA) * SQRT (1 + SSQ * (SCALE / ALPHA)  &
                  **2)                                                  
               ELSE 
                  BETA = SCALE * SQRT (SSQ + (ALPHA / SCALE) **2) 
               ENDIF 
               ZETA = SQRT ( (BETA + ABS (ALPHA) ) / BETA) 
               IF (ALPHA.GT.ZERO) BETA = - BETA 
               CALL DSCAL (N, - 1 / (ZETA * BETA), X, INCX) 
               ALPHA = BETA 
            ENDIF 
         ENDIF 
      ENDIF 
!                                                                       
      RETURN 
!                                                                       
!     End of F06FRF. ( SGRFG )                                          
!                                                                       
      END SUBROUTINE F06FRF                         
                                                                        
                                                                        
      SUBROUTINE P01ABW (N, NAME, INFORM, IERR, SRNAME) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.                              
!                                                                       
!     P01ABW increases the value of IERR by 1 and, if                   
!                                                                       
!        ( mod( INFORM, 10 ).ne.1 ).or.( mod( INFORM/10, 10 ).ne.0 )    
!                                                                       
!     writes a message on the current error message channel giving the  
!     value of N, a message to say that N is invalid and the strings    
!     NAME and SRNAME.                                                  
!                                                                       
!     NAME must be the name of the actual argument for N and SRNAME must
!     be the name of the calling routine.                               
!                                                                       
!     This routine is intended for use when N is an invalid input       
!     parameter to routine SRNAME. For example                          
!                                                                       
!        IERR = 0                                                       
!        IF( N.NE.'Valid value' )                                       
!     $     CALL P01ABW( N, 'N', IDIAG, IERR, SRNAME )                  
!                                                                       
!  -- Written on 15-November-1984.                                      
!     Sven Hammarling, Nag Central Office.  
      IMPLICIT NONE
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER IERR, INFORM 
      CHARACTER ( * ) N 
      CHARACTER ( * ) NAME, SRNAME 
!     .. Local Scalars ..                                               
      INTEGER NERR 
!     .. Local Arrays ..                                                
      CHARACTER(65) REC (3) 
!     .. External Subroutines ..                                        
      EXTERNAL X04AAF, X04BAF 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     .. Executable Statements ..                                       
      IERR = IERR + 1 
      IF ( (MOD (INFORM, 10) .NE.1) .OR. (MOD (INFORM / 10, 10) .NE.0) )&
      THEN                                                              
         CALL X04AAF (0, NERR) 
         WRITE (REC, FMT = 99999) NAME, SRNAME, N 
         CALL X04BAF (NERR, ' ') 
         CALL X04BAF (NERR, REC (1) ) 
         CALL X04BAF (NERR, REC (2) ) 
         CALL X04BAF (NERR, REC (3) ) 
      ENDIF 
      RETURN 
!                                                                       
!                                                                       
!     End of P01ABW.                                                    
!                                                                       
99999 FORMAT (' *****  Parameter  ',A,'  is invalid in routine  ',A,    &
     &  '  ***** ',/8X,'Value supplied is',/8X,A)                       
      END SUBROUTINE P01ABW                         
                                                                        
                                                                        
      SUBROUTINE P01ABY (N, NAME, INFORM, IERR, SRNAME) 
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.                              
!                                                                       
!     P01ABY increases the value of IERR by 1 and, if                   
!                                                                       
!        ( mod( INFORM, 10 ).ne.1 ).or.( mod( INFORM/10, 10 ).ne.0 )    
!                                                                       
!     writes a message on the current error message channel giving the  
!     value of N, a message to say that N is invalid and the strings    
!     NAME and SRNAME.                                                  
!                                                                       
!     NAME must be the name of the actual argument for N and SRNAME must
!     be the name of the calling routine.                               
!                                                                       
!     This routine is intended for use when N is an invalid input       
!     parameter to routine SRNAME. For example                          
!                                                                       
!        IERR = 0                                                       
!        IF( N.LT.1 )CALL P01ABY( N, 'N', IDIAG, IERR, SRNAME )         
!                                                                       
!  -- Written on 23-February-1984.  Sven.
      IMPLICIT NONE
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER IERR, INFORM, N 
      CHARACTER ( * ) NAME, SRNAME 
!     .. Local Scalars ..                                               
      INTEGER NERR 
!     .. Local Arrays ..                                                
      CHARACTER(65) REC (2) 
!     .. External Subroutines ..                                        
      EXTERNAL X04AAF, X04BAF 
!     .. Intrinsic Functions ..                                         
      INTRINSIC MOD 
!     .. Executable Statements ..                                       
      IERR = IERR + 1 
      IF ( (MOD (INFORM, 10) .NE.1) .OR. (MOD (INFORM / 10, 10) .NE.0) )&
      THEN                                                              
         CALL X04AAF (0, NERR) 
         WRITE (REC, FMT = 99999) NAME, SRNAME, N 
         CALL X04BAF (NERR, ' ') 
         CALL X04BAF (NERR, REC (1) ) 
         CALL X04BAF (NERR, REC (2) ) 
      ENDIF 
      RETURN 
!                                                                       
!                                                                       
!     End of P01ABY.                                                    
!                                                                       
99999 FORMAT (' *****  Parameter  ',A,'  is invalid in routine  ',A,    &
     &  '  ***** ',/8X,'Value supplied is ',I6)                         
      END SUBROUTINE P01ABY                         
!**************** ESTO LO HE AGREGADO A LO QUE HABA********************
!                                                                       
!     This is a lightweight substitute to the external LAPACK routines  
!     used by EXPOKIT. It is supplied to ensure that EXPOKIT is         
!     self-contained and can still run if LAPACK is not yet installed   
!     in your environement.                                             
!----------------------------------------------------------------------|
      SUBROUTINE DGESV (N, M, A, LDA, IPIV, B, LDB, IFLAG) 
      IMPLICIT NONE
      INTEGER j, N, M, LDA, LDB, IPIV (N), IFLAG 
      DOUBLEPRECISION A (LDA, N), B (LDB, M) 
      CALL DGEFA (A, LDA, N, IPIV, IFLAG) 
      IF (IFLAG.ne.0) stop "ErrorinDGESV (LUfactorisation) " 
      DO j = 1, M 
      CALL DGESL (A, LDA, N, IPIV, B (1, j), 0) 
      enddo 
      END SUBROUTINE DGESV                          
!----------------------------------------------------------------------|
!----------------------------------------------------------------------|
      SUBROUTINE dgefa (a, lda, n, ipvt, info) 
      IMPLICIT NONE
      INTEGER lda, n, ipvt (n), info 
      DOUBLEPRECISION a (lda, n) 
!                                                                       
!     dgefa factors a double precision matrix by gaussian elimination.  
!                                                                       
!     dgefa is usually called by dgeco, but it can be called            
!     directly with a saving in time if  rcond  is not needed.          
!     (time for dgeco) = (1 + 9/n)*(time for dgefa) .                   
!                                                                       
!     on entry                                                          
!                                                                       
!        a       double precision(lda, n)                               
!                the matrix to be factored.                             
!                                                                       
!        lda     integer                                                
!                the leading dimension of the array  a .                
!                                                                       
!        n       integer                                                
!                the order of the matrix  a .                           
!                                                                       
!     on return                                                         
!                                                                       
!        a       an upper triangular matrix and the multipliers         
!                which were used to obtain it.                          
!                the factorization can be written  a = l*u  where       
!                l  is a product of permutation and unit lower          
!                triangular matrices and  u  is upper triangular.       
!                                                                       
!        ipvt    integer(n)                                             
!                an integer vector of pivot indices.                    
!                                                                       
!        info    integer                                                
!                = 0  normal value.                                     
!                = k  if  u(k,k) .eq. 0.0 .  this is not an error       
!                     condition for this subroutine, but it does        
!                     indicate that dgesl or dgedi will divide by zero  
!                     if called.  use  rcond  in dgeco for a reliable   
!                     indication of singularity.                        
!                                                                       
!     linpack. this version dated 08/14/78 .                            
!     cleve moler, university of new mexico, argonne national lab.      
!                                                                       
!     subroutines and functions                                         
!                                                                       
!     blas daxpy,dscal,idamax                                           
!                                                                       
!     internal variables                                                
!                                                                       
      DOUBLEPRECISION t 
      INTEGER idamax, j, k, kp1, l, nm1 
!                                                                       
!                                                                       
!     gaussian elimination with partial pivoting                        
!                                                                       
      info = 0 
      nm1 = n - 1 
      IF (nm1.lt.1) goto 70 
      DO 60 k = 1, nm1 
         kp1 = k + 1 
!                                                                       
!        find l = pivot index                                           
!                                                                       
         l = idamax (n - k + 1, a (k, k), 1) + k - 1 
         ipvt (k) = l 
!                                                                       
!        zero pivot implies this column already triangularized          
!                                                                       
         IF (a (l, k) .eq.0.0d0) goto 40 
!                                                                       
!           interchange if necessary                                    
!                                                                       
         IF (l.eq.k) goto 10 
         t = a (l, k) 
         a (l, k) = a (k, k) 
         a (k, k) = t 
   10    CONTINUE 
!                                                                       
!           compute multipliers                                         
!                                                                       
         t = - 1.0d0 / a (k, k) 
         CALL dscal (n - k, t, a (k + 1, k), 1) 
!                                                                       
!           row elimination with column indexing                        
!                                                                       
         DO 30 j = kp1, n 
            t = a (l, j) 
            IF (l.eq.k) goto 20 
            a (l, j) = a (k, j) 
            a (k, j) = t 
   20       CONTINUE 
            CALL daxpy (n - k, t, a (k + 1, k), 1, a (k + 1, j),        &
            1)                                                          
   30    END DO 
         GOTO 50 
   40    CONTINUE 
         info = k 
   50    CONTINUE 
   60 END DO 
   70 CONTINUE 
      ipvt (n) = n 
      IF (a (n, n) .eq.0.0d0) info = n 
      RETURN 
      END SUBROUTINE dgefa                          
!----------------------------------------------------------------------|
      SUBROUTINE dgesl (a, lda, n, ipvt, b, job) 
      IMPLICIT NONE
      INTEGER lda, n, ipvt (n), job 
      DOUBLEPRECISION a (lda, n), b (n) 
!                                                                       
!     dgesl solves the double precision system                          
!     a * x = b  or  trans(a) * x = b                                   
!     using the factors computed by dgeco or dgefa.                     
!                                                                       
!     on entry                                                          
!                                                                       
!        a       double precision(lda, n)                               
!                the output from dgeco or dgefa.                        
!                                                                       
!        lda     integer                                                
!                the leading dimension of the array  a .                
!                                                                       
!        n       integer                                                
!                the order of the matrix  a .                           
!                                                                       
!        ipvt    integer(n)                                             
!                the pivot vector from dgeco or dgefa.                  
!                                                                       
!        b       double precision(n)                                    
!                the right hand side vector.                            
!                                                                       
!        job     integer                                                
!                = 0         to solve  a*x = b ,                        
!                = nonzero   to solve  trans(a)*x = b  where            
!                            trans(a)  is the transpose.                
!                                                                       
!     on return                                                         
!                                                                       
!        b       the solution vector  x .                               
!                                                                       
!     error condition                                                   
!                                                                       
!        a division by zero will occur if the input factor contains a   
!        zero on the diagonal.  technically this indicates singularity  
!        but it is often caused by improper arguments or improper       
!        setting of lda .  it will not occur if the subroutines are     
!        called correctly and if dgeco has set rcond .gt. 0.0           
!        or dgefa has set info .eq. 0 .                                 
!                                                                       
!     to compute  inverse(a) * c  where  c  is a matrix                 
!     with  p  columns                                                  
!           call dgeco(a,lda,n,ipvt,rcond,z)                            
!           if (rcond is too small) go to ...                           
!           do 10 j = 1, p                                              
!              call dgesl(a,lda,n,ipvt,c(1,j),0)                        
!        10 continue                                                    
!                                                                       
!     linpack. this version dated 08/14/78 .                            
!     cleve moler, university of new mexico, argonne national lab.      
!                                                                       
!     subroutines and functions                                         
!                                                                       
!     blas daxpy,ddot                                                   
!                                                                       
!     internal variables                                                
!                                                                       
      DOUBLEPRECISION ddot, t 
      INTEGER k, kb, l, nm1 
!                                                                       
      nm1 = n - 1 
      IF (job.ne.0) goto 50 
!                                                                       
!        job = 0 , solve  a * x = b                                     
!        first solve  l*y = b                                           
!                                                                       
      IF (nm1.lt.1) goto 30 
      DO 20 k = 1, nm1 
         l = ipvt (k) 
         t = b (l) 
         IF (l.eq.k) goto 10 
         b (l) = b (k) 
         b (k) = t 
   10    CONTINUE 
         CALL daxpy (n - k, t, a (k + 1, k), 1, b (k + 1), 1) 
   20 END DO 
   30 CONTINUE 
!                                                                       
!        now solve  u*x = y                                             
!                                                                       
      DO 40 kb = 1, n 
         k = n + 1 - kb 
         b (k) = b (k) / a (k, k) 
         t = - b (k) 
         CALL daxpy (k - 1, t, a (1, k), 1, b (1), 1) 
   40 END DO 
      GOTO 100 
   50 CONTINUE 
!                                                                       
!        job = nonzero, solve  trans(a) * x = b                         
!        first solve  trans(u)*y = b                                    
!                                                                       
      DO 60 k = 1, n 
         t = ddot (k - 1, a (1, k), 1, b (1), 1) 
         b (k) = (b (k) - t) / a (k, k) 
   60 END DO 
!                                                                       
!        now solve trans(l)*x = y                                       
!                                                                       
      IF (nm1.lt.1) goto 90 
      DO 80 kb = 1, nm1 
         k = n - kb 
         b (k) = b (k) + ddot (n - k, a (k + 1, k), 1, b (k + 1),       &
         1)                                                             
         l = ipvt (k) 
         IF (l.eq.k) goto 70 
         t = b (l) 
         b (l) = b (k) 
         b (k) = t 
   70    CONTINUE 
   80 END DO 
   90 CONTINUE 
  100 CONTINUE 
      RETURN 
      END SUBROUTINE dgesl                          
