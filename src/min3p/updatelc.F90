!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 869 $
!> $Author: dsu $
!> $Date: 2023-08-18 09:44:21 -0700 (Fri, 18 Aug 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/updatelc.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine updatelc
!c -------------------
!c
!c update free species concentrations and check for convergence
!c (local chemistry)
!c
!c written by:      Uli Mayer - November 29, 96
!c
!c last modified:   Tom Henderson - June 23, 2004
!c                                  supress lc output: nodal initial condition
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   real*8:
!c           -------
!c           c(nc-1)            = concentrations of free species      + +
!c                                [moles/l water] 
!c           ulc(nc-1)          = update towards solution-vector      + +
!c
!c           integer*4:
!c           ----------
!c           ilog               = unit number, log file               + -
!c
!c           logical:
!c           --------
!c           not_converged      = .true.  -> continue Newton          + +
!c                                           iteration
!c
!c           character:
!c           ----------
!c           zone_name          = name of zone                        + -
!c
!c common:
!c chem.f:   real*8:
!c           -------
!c           srelfac_lc
!c                              = user specified underrelaxation      + -
!c                                factor
!c           tol_lc             = convergence tolerance               + -
!c                                (reactive transport)
!c
!c           integer*4:
!c           ----------
!c           idetail_lc
!c                              = information level                   + -
!c           iter_lc(nthreads)  = current newton iteration            + -
!c           nc                 = number of components excluding h2o  + -
!c                                equals number of unknowns per
!c                                control volume
!c           nopu               = number of primary unknowns          + -
!c
!c           logical:
!c           --------
!c           under_relax_lc     = .true.  -> underrelaxation          + -
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c
!c local:    real*8:
!c           -------
!c           enat               = e
!c           r0                 = constant
!c           r1                 = constant
!c           ulcmax             = actual maximum update
!c           ulclim             = allowed maximum update
!c
!c           integer*4:
!c           ----------
!c           ic                 = counter (components)
!c           icount             = counter (non-convergent components)
!c           ivol               = counter (number of control volumes)
!c           maxvol             = volume with maximum solution update
!c           nexvol             = number of volumes exceeding update
!c                                tolerance
!c
!c           character:
!c           ----------
!c           name               = name of chemical species
!c                                (max update)
!c
!c external: -
!c ----------------------------------------------------------------------

      subroutine updatelc(c,ulc,por,ilog,tid,not_converged,zone_name)
 
      use parm
      use chem
      use dens
      use gen, only : rank, b_enable_output
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
 
      implicit none
      
      integer :: tid
      
      real*8 :: c, ulc, por

      dimension c(*),ulc(*)

      logical not_converged
      character*72 name
      character*72 zone_name
 
      real*8 :: r0, r1, r10, enat
      integer :: ic, ilog, info_debug
      parameter (r0 = 0.0d0, r1 = 1.0d0, r10 = 1.0d1,                 &
     &           enat = 2.71828182845904509d0)
      
      !local variable
      real(type_r8) :: ulclim
      real(type_r8) :: ulcmax        
     
      name = ''
      ulclim = r1 * enat


!c  update solution after new iteration, check for global convergence
  
      ulcmax = r0

      do ic = 1,nopu              !loop over primary unknowns
  
!c  user specified underrelaxation

        if (under_relax_lc) then
          ulc(ic) = srelfac_lc * ulc(ic)
        end if

!c  use line search, if absolute magnitude of update too large 
!c  limit magnitude of update to one log cycle
 
        if (ulc(ic).gt.ulclim) then    
          ulc(ic) = ulclim
        elseif (ulc(ic).lt.-ulclim) then
          ulc(ic) = -ulclim
        end if

!c  update ln c = ln c + delta (ln c)

        c(ic) = dlog(c(ic)) + ulc(ic)

!c  convert to concentrations

        c(ic) = enat**c(ic)


!cdsu apply concentration limitation to avoid numerical instability
        if (c(ic) < conc_corr_min) then
          c(ic) = conc_corr_min
        else if (c(ic) > conc_corr_max) then
          c(ic) = conc_corr_max
        end if

!c  determine maximum update

        if (dabs(ulc(ic)).gt.dabs(ulcmax)) then
          ulcmax = ulc(ic)
          name = namec(ic)
        end if
      end do                           !loop over components

!c  report maximum update in log_10 cycles

!c     ulcmax = ulcmax/enat    !error in this conversion THH 3/2/04

!c  log10(x) = ln(x)/ln(10)

      ulcmax = ulcmax/dlog(r10)  !correct conversion

!c  determine, if global convergence is achieved
 
      if (dabs(ulcmax).lt.tol_lc) then
        not_converged = .false.
      end if

!c  write convergence history to screen
      if(rank == 0 .and. b_enable_output)  then
 
        if ((idetail_lc.gt.0 .and. .not.aq_conc_field) .and.           &
            zone_name.ne.'temperature-correction') then
                                                                       
          if (iter_lc(tid).eq.1 .or. idetail_lc.eq.2) then                    
            write(ilog,'(2a,1x,1pe15.6e3)')                            &
                  ' Newton Iteration Convergence Summary:',            &
                  ' updatelc with porosity',por
            write(ilog,'(a)') ' Newton     maximum    for         '      
            write(ilog,'(a)') ' iteration  update     component   '      
          end if
                                                                       
          write(ilog,'(i6,5x,1pe11.4,1x,a12)') iter_lc(tid),ulcmax,name

        end if
     
      end if
     
!cdbg
      info_debug = 0
      if (info_debug.gt.0) then
        write(*,*)
        do ic = 1,nopu
          write(*,*) trim(namec(ic))," ", ulc(ic)
        end do
        write(*,*)
      end if
      if (info_debug.eq.2) then
        !pause
      elseif (info_debug.eq.3) then
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
!cdbg

      return
      end 
