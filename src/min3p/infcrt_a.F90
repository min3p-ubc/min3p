!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 850 $
!> $Author: dsu $
!> $Date: 2023-01-27 08:58:23 -0800 (Fri, 27 Jan 2023) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/infcrt_a.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine infcrt_a
!c -------------------
!c
!c compute influence coefficients for advective and dispersive flux 
!c terms for rectangular, cartesian finite volume discretization 
!c (reactive transport) for aqueous phase
!c
!c written by:      Uli Mayer - August 15, 96
!c
!c last modified:   Uli Mayer - November 20, 96
!c                  Sergi Molins - Feb 18, 2007
!c                  added correction for tortuosity when oil present
!c
!c                  Danyang Su - March 14, 2014
!c                  HPC capabilities
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c     input:
!c
!c passed:   real*8:
!c           -------
!c           d(3, ibk)          = dimension of cells in x,y,z         + -
!c                                direction
!c           diffu              = phase molecular diffusion (m2/day)
!c           disx(nzn)          = dispersion, x direction (m)
!c           disy(nzn)          =    "      , y    "      (m)
!c           disz(nzn)          =    "      , z    "      (m)
!c           cinfrt_va()        = influence coefficients 
!c                                J^w_ij/A_ij
!c                                (advective flux terms)
!c           cinfrt_da()        = influence coefficients
!c                                D_ij * A_ij / d_ij  
!c                                (dispersvie flux terms)
!c
!c           integer*4:
!c           ----------
!c           ibk                = block i
!c           id                 = connected block j
!c           idbg               = output for debugging information
!c           ilog               = unit number, logbook
!c           nmax               = max cells for dim purposes
!c           nphas              = max number of phases
!c           njamxc             = max dim ja array (ncomp.com)
!c           nvx                = number of control volumes 
!c                                in x direction
!c           nvy                = number of control volumes 
!c                                in y direction
!c           nvz                = number of control volumes 
!c                                in z direction
!c           pornew(ibk)        = porosity
!c           sanew(nmax)        = aqueous phase saturation
!c                                - new time level
!c           hhead(nmax)        = hydraulic head
!c           uvsnew(nmax)       = hydraulic pressure
!c           relperm(nmax)      = rel permeability
!c           cinfvs(nmax)       = influence coefficient 
!c                                (variably saturated flow) 
!c           ia(), ja()         = ysmp pointers
!c           isymm(ii)          = symmetry pointer for cell ibk
!c
!c           logical:
!c           --------
!c           fully_saturated    = .true.  -> saturated conditions
!c           variably_saturated = .true.  -> .not.fully_saturated,
!c                                        -> variably saturated
!c                                           conditions
!c           half_cells         = .true.  -> half cells on boundary
!c           tortuosity_corr    = .true.  -> Millington-Quirk 
!c                                           tortuosity correction
!c                                           for diffusion
!c                                           coefficients
!c
!c multidiff.f90
!c           logical:
!c           --------
!c         multi_diff = .true. -> multicomponent diffusion (MCD)
!c local:
!c
!c external: diffcoff  = compute effective diffusion coefficient
!c           fluxfs    = flux function for fully saturated flow 
!c           fluxvs    = flux function for variably saturated flow
!c --------------------------------------------------------------------------

      subroutine infcrt_a (nvxgls, nvxgle, nvxgbl,                &
                         nvygls, nvygle, nvygbl,                  &
                         nvzgls, nvzgle, nvzgbl,                  &
                         nvx, nvy, nvz, ia, ja, isymm,            &
                         cinfvs, cinfrt_va, cinfrt_da, d,         &
                         mprop, nzn, diffu, diffu_tensor,         &
                         type_diffu, frozen_diffu,                &
                         tkel, disx, disy, disz,                  &
                         pornew, sanew, uvsnew, hhead, relperm,   & 
                         idbg, ilog, upstream, fully_saturated,   &
                         variably_saturated, njamxc, nmax,        &
                         tortuosity_corr,half_cells,cinfrt_da_ic, &
                         diff_coff, nc, diff_ic, diff_ic_tensor,  &
                         type_diff_ic, assigned_tau,              &
                         tau,type_tortuosity,marchies,cinfrad,    &
                         radial_coord, multi_diff, tau_fac,       &
                         harmonic_porosity, delx,dely,delz,       &
                         type_averaging_De, xg,                   &
                         sonew,oil_saturation)
#ifdef OPENMP      
      use omp_lib 
#endif

      use geometry_definition
      use geometry
      use mod_diffcoff, only : diffcoff      
      use gen, only :                                             &
#ifdef OPENMP  
                      numofthreads_global,                        &
                      numofloops_thred_global,                    &
                      numofloops_thred_infcrt_a_1,                &
                      numofloops_thred_infcrt_a_2,                &
                      numofloops_thred_infcrt_a_3,                &
#endif
                      b_use_fixed_flow_vel, fixed_flow_vel,       &
                      b_use_zero_flow_vel,                        &
                      tor_corr_a_mq, tor_corr_b_mq,               &
                      b_water_freezing, rank, b_enable_output

#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif

      implicit none
      
      integer :: ic, ivol, ivxp, ivxn, ivyp, ivyn, ivzp, ivzn, jvol,   &
                 jzn, jtemp, nmax, njamxc, info_debug
      real*8 :: diff_eff1, diff_eff2

      real*8, external :: fluxfs,fluxvs, pressure_melt_k
      
      integer :: nvxgls, nvxgle, nvxgbl, nvygls, nvygle, nvygbl,       &
                 nvzgls, nvzgle, nvzgbl, ivxgbl, ivygbl, ivzgbl,       &
                 ivxpgbl, ivypgbl, ivzpgbl, ivxngbl, ivyngbl, ivzngbl, & 
                 nvx, nvy, nvz, ia(nmax+1), ja(njamxc), isymm(njamxc), &
                 idbg, ilog, nzn, mprop(*), nc, type_diffu,            &
                 type_diff_ic

      logical :: half_cells, fully_saturated, variably_saturated,      &
                 upstream, tortuosity_corr,diff_coff,assigned_tau,     &
                 radial_coord, multi_diff, harmonic_porosity,          &
                 oil_saturation
      
      character(len=30) :: type_averaging_De

      real*8 :: diffu, disx(nzn), disy(nzn), disz(nzn),                &
                frozen_diffu, tkel(nmax),                              &
                pornew(nmax), uvsnew(nmax), hhead(nmax),               &
                relperm(nmax),sanew(nmax), d(3,nmax),                  &
                cinfvs(njamxc), cinfrt_va(njamxc),                     &
                cinfrt_da(njamxc),cinfrt_da_ic(nc,njamxc),             &
                diff_ic(nc),tau(nmax),cinfrad(njamxc),                 &
                tau_fac(nmax), marchies(nmax), sonew(nmax)
                
      real*8 :: delx(nvx),dely(nvy),delz(nvz), xg(nvx)
      
      character(len=*) :: type_tortuosity

      type(tensor) :: diffu_tensor, diff_ic_tensor(nc)

!c     local variables

      real*8, parameter :: eps = 1.0d-300, r0 = 0.0d0, rhalf = 0.5d0,  & 
                r1 = 1.0d0, r2 = 2.0d0, pi = 3.141592653589793d0

      real*8 :: aread(3,12),areax(3,12),vel(3),dist(3,12),             &
                porav, satav, vx2, vy2, vz2, vmag,                     &
                tend(3), areai,                                        &
                diffav, diff_eff,disx_avg, disy_avg,                   &
                disz_avg, dflux,tauav, marchieav, so_av

!cmx    changed: Mar. 13, added for harmonic averaging
      real*8 :: diff_i,diff_j,diff_ij,areaf,                           &
                por_i,por_j,delx_i,dely_i,delz_i,delx_j,dely_j,delz_j, &
                tau_i, tau_j

      type(tensor) :: diffav_tensor, diff_eff_tensor,                  &
                      diff_i_tensor, diff_j_tensor,                    &
                      diff_eff1_tensor, diff_eff2_tensor

      integer :: ibk, ivz, ivy, ivx, ibkz, ibky,                       &
                 ii, id, ixx, iyy, izz, iisav,                         &
                 idim, npair(3), iface(3,12), ndim,                    &
                 fvpair(3,12,2), ipair, idim2, idim3, irk_ibk, irk_id

      character*1 :: iups
      real*8 :: por1, por2
#ifdef OPENMP      
      integer :: nvols
#endif

      delx_i = r0
      delx_j = r0
      dely_i = r0
      dely_j = r0
      delz_i = r0
      delz_j = r0
      dflux = r0
      iisav = 0

!c  compute influence coefficients for advective flux terms
!c  (influence coefficients are equal Darcy flux = J_ij/A_ij)

!c  loop over control volumes
      ivol=0
      tau_i = r1
      tau_j = r1
#ifdef OPENMP      
      nvols = nvx * nvy * nvz
#endif
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nvols > numofloops_thred_infcrt_a_1)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ibk, ibky, ibkz, id, idim, idim2, idim3, ii,       &
    !$omp iisav, ivx, iups, ivy, ivz, ixx, iyy, izz)                  
    !$omp do schedule(static)
#endif
      do ivz = 1,nvz                !increments in z-direction
        ibkz = (ivz-1)*nvx*nvy

        do ivy = 1,nvy              !increments in y-direction
          ibky = (ivy-1)*nvx

          do ivx = 1,nvx            !increments in x-direction 
            ibk = ibkz+ibky+ivx

!c  loop over three -ve faces

            do idim = 1,3           !loop over dimensions
              ixx = ivx
              iyy = ivy
              izz = ivz

!c  compute in -tive face direction only

              if (idim.eq.1) then           !in x-direction
                ixx = ixx-1
                id = ibk-1
                idim2 = 2
                idim3 = 3
              elseif (idim.eq.2) then       !in y-direction
                iyy = iyy-1
                id = ibk-nvx
                idim2 = 3
                idim3 = 1
              elseif (idim.eq.3) then       !in z-direction
                izz = izz-1
                id = ibk-nvx*nvy
                idim2 = 1
                idim3 = 2
              endif

!c  skip if edge

              if (ixx.le.0 .or. iyy.le.0 .or. izz.le.0) cycle

!c  find -ve face in row of connected cells to ibk

              do ii = ia(ibk),ia(ibk+1)-1
                if (ja(ii).eq.id) then
                  iisav = ii
                  go to 211
                endif
              end do
              
              if (rank == 0 .and. b_enable_output) then
                write(ilog,*) ' error-cannot find id in list-infcrt_a 1'
                write(ilog,*) ' ibk, id ', ibk, id
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop

211           continue


!c  find darcy flux between node pair
#ifdef OPENMP
    !$omp critical
#endif

              if (b_use_fixed_flow_vel) then
              
                if (b_use_zero_flow_vel) then
                  cinfrt_va(iisav) = r0
                else
                  !c TBD
                end if
              
              else
                if (variably_saturated) then
                  if (upstream) then
                    iups = 'i'                          !h_i >= h_j
                    if (hhead(id).gt.hhead(ibk)) then   !h_j > h_i
                      iups = 'j'
                    end if
                  end if

                  cinfrt_va(iisav) = - fluxvs(upstream,hhead(ibk),      &
                                             hhead(id),relperm(ibk),    &
                                             relperm(id),iups,          &
                                             cinfvs(ii))

                elseif (fully_saturated) then
  
                  cinfrt_va(iisav) = - fluxfs(uvsnew(ibk),uvsnew(id),   &
                                             cinfvs(ii))
                end if

!c  matrix is symmetric n a symbolic sense, since cinfrt_va between 
!c  cell ibk and id is equal to - cinfrt_va between cells id and ibk
                cinfrt_va(isymm(iisav)) = - cinfrt_va(iisav)
              end if
#ifdef OPENMP
    !$omp end critical
#endif
            end do
          end do
        end do
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif 

!c  compute the influence coefficients for dispersive flux terms
!c  loop over the number of "pseudo dispersion elements"

!c  zero the influence coefficient for dispersive flux term
!#ifdef OPENMP
!    !$omp parallel                                                    &
!    !$omp if (nvols > numofloops_thred_infcrt_a_2)                    &
!    !$omp num_threads(numofthreads_global)                            &
!    !$omp default(shared)                                             &
!    !$omp private (ibk, ii)                  
!    !$omp do schedule(static)
!#endif
!      do ibk = 1, nmax
!        do ii = ia(ibk),ia(ibk+1)-1
!          cinfrt_da(ii) = r0
!        end do
!      end do
!#ifdef OPENMP
!    !$omp end do
!    !$omp end parallel
!#endif 
      cinfrt_da(:) = r0
      if (diff_coff) then
        cinfrt_da_ic(:,:) = r0
      end if

!c  loop over control volumes
#ifdef OPENMP
    !$omp parallel                                                    &
    !$omp if (nvols > numofloops_thred_infcrt_a_3)                    &
    !$omp num_threads(numofthreads_global)                            &
    !$omp default(shared)                                             &
    !$omp private (ibk, ic, id, idim, idim2, idim3, iface, ii,        &
    !$omp iisav, ipair, irk_ibk, irk_id, iups, ivol,                  &
    !$omp ivx, ivy, ivz, ivxp, ivxn, ivyp, ivyn, ivzp, ivzn,          &
    !$omp ivxgbl, ivygbl, ivzgbl, ivxpgbl, ivypgbl, ivzpgbl,          &
    !$omp ivxngbl, ivyngbl, ivzngbl,                                  &
    !$omp jtemp, jvol, jzn, ndim, npair,                              &
    !$omp areax, aread, areaf, areai, delx_i, delx_j, dely_i,         &
    !$omp dely_j, delz_i, delz_j, diffav, diff_eff,                   &
    !$omp diff_eff1, diff_eff2, diff_i, diff_ij, diff_j,              &
    !$omp diffav_tensor, diff_eff_tensor,                             &
    !$omp diff_i_tensor, diff_j_tensor,                               &
    !$omp diff_eff1_tensor, diff_eff2_tensor,                         &
    !$omp dist, disx_avg, disy_avg, disz_avg, dflux, fvpair,          &
    !$omp marchieav, satav, tauav, por_i, por_j, por1, por2,          &
    !$omp porav, tau_i, tau_j, tend, vel, vmag, vx2, vy2, vz2,        &
    !$omp so_av)                                                      
    !$omp do schedule(static)
#endif
      do ivz = 1, nvz          !increments in z-direction
        ivzgbl = ivz+nvzgls-1 
        do ivy = 1, nvy       !increments in y-direction
          ivygbl = ivy+nvygls-1 
          do ivx = 1, nvx    !increments in x-direction                
            ivxgbl = ivx+nvxgls-1  
            
            so_av = r0

!c  find node pairs for elemental velocities as well
!c  as influence coefficient for node pairs within dipersion element

!            call cliqdisp (nvx, nvy, nvz, ivx, ivy, ivz,
!     &                        fvpair, npair, aread, d, half_cells,
!     &                        nmax,idbg)
            call cliqdisp (nvx, nvy, nvz, ivx, ivy, ivz,           &
                      fvpair, npair,aread,areax,dist,d, half_cells,&
                      ia, ja, njamxc,                              &
                      nmax,idbg,cinfrad,radial_coord)     

!c  check if fully connected "pseudo dispersion element"
!c  was found for dimensionality of problem

!CMX               if ((nvx .gt. 1 .and. npair(1) .eq. 0) .or.            &
!CMX                   (nvy .gt. 1 .and. npair(2) .eq. 0) .or.            &
!CMX                   (nvz .gt. 1 .and. npair(3) .eq. 0)) cycle

            if (((nvx .gt. 1 .and. npair(1) .eq. 0) .or.          &
                (nvy .gt. 1 .and. npair(2) .eq. 0) .or.           &
                (nvz .gt. 1 .and. npair(3) .eq. 0)) .and.         &
                (type_averaging_De.ne.'harmonic' .or.             &
                (.not.harmonic_porosity)) .and.                   &
                ((type_averaging_De.eq.'arithmetic' .and.         &
                (harmonic_porosity)) .or.                         &
                 trim(type_averaging_De).eq.'')) cycle

 !c  pointers to previous colums in x,y and z
              ivxp = ivx-1
              ivxn = ivx+1
              ivyp = ivy-1
              ivyn = ivy+1
              ivzp = ivz-1
              ivzn = ivz+1

              ivxpgbl = ivxgbl-1
              ivxngbl = ivxgbl+1
              ivypgbl = ivygbl-1
              ivyngbl = ivygbl+1
              ivzpgbl = ivzgbl-1
              ivzngbl = ivzgbl+1

!c              loop over the dimensions x,y,z

              do idim = 1, 3

                idim2 = idim + 1
                idim3 = idim + 2
                if (idim2 .gt. 3) idim2 = idim2 - 3
                if (idim3 .gt. 3) idim3 = idim3 - 3

!c  zero advective velocity

                vel(idim) = r0

!c  loop over the number of node pairs in the dimension

                do ipair = 1, npair(idim)

                  ibk = fvpair(idim, ipair, 1)
                  id = fvpair(idim, ipair, 2)

                  do ii = ia(ibk), ia(ibk+1)-1
                    if (ja(ii) .eq. id) then
                      iisav = ii
                      go to 431
                    endif
                  end do
                  if (rank == 0 .and. b_enable_output) then
                    write(ilog,*) ' error-cannot find id in list-infcrt_a 2'
                    write(ilog,*) ' ibk, id ', ibk, id
                    close(ilog)
                  end if
#ifdef PETSC
                  call petsc_mpi_finalize
#endif
                  stop

431               continue

                  iface(idim, ipair) = iisav

!c  calculate average interfacial area between nodes
                  if (.not.b_use_fixed_flow_vel) then
!cprovi------------------------------------------------
!cprovi Assign the interfacial area
!cprovi------------------------------------------------                
                    areai = areax(idim, ipair)

!c  find darcy flux between node pair

                    if (variably_saturated) then
                      if (upstream) then
                        iups = 'i'                            !h_i >= h_j
                        if (hhead(id).gt.hhead(ibk)) then     !h_j > h_i
                          iups = 'j'
                        end if
                      end if
  
                      dflux = - fluxvs(upstream,hhead(ibk),      &
                                      hhead(id),relperm(ibk),    &
                                      relperm(id),iups,          &
                                      cinfvs(iisav))
  
                    elseif (fully_saturated) then 
  
                      dflux = - fluxfs(uvsnew(ibk),uvsnew(id),   &
                                       cinfvs(iisav))
                    end if


!c  velocity is the flux (m^3/day) divided
!c  by the interfacial area between the two nodes

                    vel(idim) = vel(idim) + dflux / areai
                  end if
                end do

!c  find the average elemental velocity in the
!c  x,y,z directions
                if (.not.b_use_fixed_flow_vel) then
                  vel(idim) = vel(idim)/(float( npair(idim) ) + eps)
                end if
              end do

              if (b_use_fixed_flow_vel) then
                vel(1) = fixed_flow_vel%x
                vel(2) = fixed_flow_vel%y
                vel(3) = fixed_flow_vel%z
              end if

!cmx-------------------------------------------------------------------
!cmx-------------------------------------------------------------------
!cmx     Not harmonic average in porosity and/or De
!cmx-------------------------------------------------------------------
!cmx-------------------------------------------------------------------
              if (.not.harmonic_porosity .and.                       &
                 (type_averaging_De.ne.'harmonic') .or.              &
                 (type_averaging_De.eq.'arithmetic' .and.            &
                 (harmonic_porosity)) .or.                           &
                 trim(type_averaging_De).eq.'') then

!c  average porosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element

                porav = r0
                do idim = 1, 3
                  do ipair = 1, npair(idim)
                    ibk = fvpair(idim, ipair, 1)
                    id = fvpair(idim, ipair, 2)
                    porav = porav                    &
                         + dmin1( r1, pornew(ibk) )  &
                         + dmin1( r1, pornew(id) )
                  end do
                end do 

                ndim = 0
                if (nvx .gt. 1) ndim = ndim + 1
                if (nvy .gt. 1) ndim = ndim + 1
                if (nvz .gt. 1) ndim = ndim + 1
                porav = porav / float(ndim) / r2**ndim
               
!c  average tortuosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element
                if (assigned_tau) then
                  tauav = r0
                  do idim = 1, 3
                    do ipair = 1, npair(idim)
                      ibk = fvpair(idim, ipair, 1)
                      id = fvpair(idim, ipair, 2)
 !c                     tauav = tauav                               &
 !c                           + dmin1(r1, tau(ibk) * tau_fac(ibk))  &
 !c                           + dmin1(r1, tau(id) * tau_fac(id))
                      tauav = tauav                               &
                            + tau(ibk) * tau_fac(ibk)             &
                            + tau(id) * tau_fac(id)
                    end do
                  end do 

                  ndim = 0
                  if (nvx .gt. 1) ndim = ndim + 1
                  if (nvy .gt. 1) ndim = ndim + 1
                  if (nvz .gt. 1) ndim = ndim + 1
                  tauav = tauav / float(ndim) / r2**ndim             
                end if   

!c  calculate average dispersivities for the "pseudo
!c  dispersion element"

                diffav = r0                
                disx_avg = r0
                disy_avg = r0
                disz_avg = r0
                diffav_tensor = tensor_zero

                do idim = 1, 3                      !loop over dimensions
                  do ipair = 1, npair(idim)        !node pairs

                    ibk = fvpair(idim, ipair, 1)
                    id = fvpair(idim, ipair, 2)

!c  material property -> currently hardwired

                    irk_ibk = mprop(ibk)
                    irk_id = mprop(id)

                    if (type_diffu == 0) then
                      diffav = diffav          &
                             + diffu           &
                             + diffu
                    else if (type_diffu > 0) then
                      diffav_tensor = diffav_tensor  &
                                    + diffu_tensor   &
                                    + diffu_tensor
                    end if

                    disx_avg = disx_avg        &
                             + disx(irk_ibk)   &
                             + disx(irk_id)

                    disy_avg = disy_avg        &
                             + disy(irk_ibk)   &
                             + disy(irk_id)

                    disz_avg = disz_avg        &
                             + disz(irk_ibk)   &
                             + disz(irk_id)

                  end do                           !node pairs
                end do                              !dimensions 

                if (type_diffu == 0) then
                  diffav = diffav / float(ndim) / r2**ndim
                else if (type_diffu > 0) then
                  diffav_tensor = diffav_tensor / (float(ndim) * r2**ndim)
                end if
                disx_avg = disx_avg / float(ndim) / r2**ndim
                disy_avg = disy_avg / float(ndim) / r2**ndim
                disz_avg = disz_avg / float(ndim) / r2**ndim

                if (b_water_freezing) then
                  if (tkel(ibk) < pressure_melt_k(ibk,r0) .or.         &
                    tkel(id) < pressure_melt_k(id,r0)) then
                    if (type_diffu == 0) then
                      diffav = diffav*frozen_diffu
                    else if (type_diffu > 0) then
                      diffav_tensor = diffav_tensor*frozen_diffu
                    end if
                  end if
                end if

!c  calculate the dispersion tensor for the "pseudo dispersion element"
!c  average porosity of the element

                satav = r0
                so_av = r0
                do idim = 1, 3
                  do ipair = 1, npair(idim)
                    ibk = fvpair(idim, ipair, 1)
                    id = fvpair(idim, ipair, 2)
                    satav = satav                      &
                          + dmin1( r1, sanew(ibk) )    &
                          + dmin1( r1, sanew(id) )
                        so_av = so_av                      &
                          + dmin1( r1, sonew(ibk) )    &
                          + dmin1( r1, sonew(id) )                     
                  end do
                end do
                satav = satav / float(ndim) / r2**ndim
                so_av = so_av / float(ndim) / r2**ndim

                vx2 = vel(1)**2
                vy2 = vel(2)**2
                vz2 = vel(3)**2
                vmag = dsqrt(vx2 + vy2 + vz2)
                vx2 = vx2 / (vmag + eps)
                vy2 = vy2 / (vmag + eps)
                vz2 = vz2 / (vmag + eps)
               
!c  calculate the average marchie factor

                marchieav = r0
                do idim = 1, 3
                  do ipair = 1, npair(idim)
                    ibk = fvpair(idim, ipair, 1)
                    id = fvpair(idim, ipair, 2)
                    marchieav = marchieav + marchies(ibk) + marchies(id)
                  end do
                end do
                marchieav = marchieav / float(ndim) / r2**ndim

!c  calculate effective diffusion coefficient
!c_bubbles use averaged diffusion coefficient
                if (.not.diff_coff) then
                  if (type_averaging_De .ne. 'arithmetic De' ) then      ! if first calculating porav, then diff_eff
                    if (type_diffu == 0) then
                      diff_eff = diffcoff(diffav,satav,porav,          &
                                    tortuosity_corr,assigned_tau,      &
                                    tauav,type_tortuosity,marchieav,   &
                                    so_av,tor_corr_a_mq,tor_corr_b_mq)
                    else if (type_diffu > 0) then
                      diff_eff_tensor = diffcoff(                      &
                                diffav_tensor,satav,porav,             &
                                tortuosity_corr,assigned_tau,          &
                                tauav,type_tortuosity,marchieav,       &
                                so_av,tor_corr_a_mq,tor_corr_b_mq)
                    end if
                  else   ! if first calculating diff_eff1 and diff_eff2, then diff_eff, CMX
!CMX Mar. 2013
                    por1 = 0.0d0
                    por2 = 0.0d0
                    
                    por1 = dmin1( r1, pornew(ibk) )
                    por2 = dmin1( r1, pornew(id) )

                    if (type_diffu == 0) then
                      diff_eff1 = diffcoff(diffav,satav,por1,            &
                                      tortuosity_corr,assigned_tau,      &
                                      tauav,type_tortuosity,marchieav,   &
                                      so_av,tor_corr_a_mq,tor_corr_b_mq)
                      diff_eff2 = diffcoff(diffav,satav,por2,            &
                                      tortuosity_corr,assigned_tau,      &
                                      tauav,type_tortuosity,marchieav,   &
                                      so_av,tor_corr_a_mq,tor_corr_b_mq)
                      diff_eff = (diff_eff1 + diff_eff2)/2
                    else if (type_diffu > 0) then
                      diff_eff1_tensor = diffcoff(                       &
                                diffav_tensor,satav,por1,                &
                                tortuosity_corr,assigned_tau,            &
                                tauav,type_tortuosity,marchieav,         &
                                so_av,tor_corr_a_mq,tor_corr_b_mq)
                      diff_eff2_tensor = diffcoff(                       &
                                diffav_tensor,satav,por2,                &
                                tortuosity_corr,assigned_tau,            &
                                tauav,type_tortuosity,marchieav,         &
                                so_av,tor_corr_a_mq,tor_corr_b_mq)
                      diff_eff_tensor = (diff_eff1_tensor +              &
                                         diff_eff2_tensor)/2
                    end if
                  end if      ! if diff_ave
! prc -------------------------------------------------------------------
! prc Modified for Multicomponent diffusion
! prc diff_eff = r0 the diffusion coefficient will be taken out from 
! prc dispersion coefficient.
! prc -------------------------------------------------------------------

                  if (multi_diff) then
                    if (type_diffu == 0) then
                      diff_eff = r0
                    else if (type_diffu > 0) then
                      diff_eff_tensor = tensor_zero
                    end if
                  end if    
         
! prc -------------------------------------------------------------------
! prc -------------------------------------------------------------------
                  if (type_diffu == 0) then
                    tend(1) = disx_avg * vx2        &
                            + disy_avg * vy2        &
                            + disz_avg * vz2        &
                            + diff_eff
   
                    tend(2) = disy_avg * vx2        &
                            + disx_avg * vy2        &
                            + disz_avg * vz2        &
                            + diff_eff
   
                    tend(3) = disz_avg * vx2        &
                            + disz_avg * vy2        &
                            + disx_avg * vz2        &
                            + diff_eff
                  else if (type_diffu > 0) then
                    tend(1) = disx_avg * vx2        &
                            + disy_avg * vy2        &
                            + disz_avg * vz2        &
                            + diff_eff_tensor%xx
   
                    tend(2) = disy_avg * vx2        &
                            + disx_avg * vy2        &
                            + disz_avg * vz2        &
                            + diff_eff_tensor%yy
   
                    tend(3) = disz_avg * vx2        &
                            + disz_avg * vy2        &
                            + disx_avg * vz2        &
                            + diff_eff_tensor%zz
                  end if

!c  build total influence coefficient from all elemental contributions
#ifdef OPENMP
    !$omp critical
#endif
                  do idim = 1, 3                   !loop over dimensions
 
!c  adjust for 1d-, 2d, 3d - discretization

                    do ipair = 1, npair(idim)             !node pairs
  
                      iisav = iface(idim, ipair)

                      cinfrt_da(iisav) = cinfrt_da(iisav)     &
                                       + tend(idim)           &
                                       * aread(idim, ipair)

                      cinfrt_da(isymm(iisav)) =                        &
                                              cinfrt_da(isymm(iisav))  &
                                              + tend(idim)             &
                                              * aread(idim, ipair)

                    end do                                !node pairs
                  end do                           !loop over dimensions
#ifdef OPENMP
    !$omp end critical
#endif
               
                else 
               
                  do ic = 1,nc

                    if (type_diff_ic == 0) then
                      diff_eff = diffcoff(diff_ic(ic),satav,porav,     &
                                 tortuosity_corr,assigned_tau,         &
                                 tauav,type_tortuosity,marchieav,      &
                                 so_av,tor_corr_a_mq,tor_corr_b_mq)

                      tend(1) = disx_avg * vx2       &
                              + disy_avg * vy2       &
                              + disz_avg * vz2       &
                              + diff_eff

                      tend(2) = disy_avg * vx2       &
                              + disx_avg * vy2       &
                              + disz_avg * vz2       &
                              + diff_eff

                      tend(3) = disz_avg * vx2       &
                              + disz_avg * vy2       &
                              + disx_avg * vz2       &
                              + diff_eff
                    else if (type_diff_ic > 0) then
                      diff_eff_tensor = diffcoff(                      &
                                diff_ic_tensor(ic),satav,porav,        &
                                tortuosity_corr,assigned_tau,          &
                                tauav,type_tortuosity,marchieav,       &
                                so_av,tor_corr_a_mq,tor_corr_b_mq)

                      tend(1) = disx_avg * vx2       &
                              + disy_avg * vy2       &
                              + disz_avg * vz2       &
                              + diff_eff_tensor%xx

                      tend(2) = disy_avg * vx2       &
                              + disx_avg * vy2       &
                              + disz_avg * vz2       &
                              + diff_eff_tensor%yy

                      tend(3) = disz_avg * vx2       &
                              + disz_avg * vy2       &
                              + disx_avg * vz2       &
                              + diff_eff_tensor%zz
                    end if

!c  build total influence coefficient from all elemental contributions
#ifdef OPENMP
    !$omp critical
#endif 
                    do idim = 1, 3                   !loop over dimensions
 
!c  adjust for 1d-, 2d, 3d - discretization

                      do ipair = 1, npair(idim)             !node pairs
  
                        iisav = iface(idim, ipair)

                        cinfrt_da_ic(ic,iisav) =                  &
                                       cinfrt_da_ic(ic,iisav)     &
                                       + tend(idim)               &
                                       * aread(idim, ipair)

                        cinfrt_da_ic(ic,isymm(iisav)) =               &
                                        cinfrt_da_ic(ic,isymm(iisav)) &
                                        + tend(idim)                  & 
                                        * aread(idim, ipair)

                      end do                                !node pairs
                    end do                             !loop over dimensions 
#ifdef OPENMP
    !$omp end critical
#endif                   
                  end do                
                end if  
!cmx-----------------------------------------------------------------------
!cmx-----------------------------------------------------------------------
!cmx-----------------------------------------------------------------------
!cmx-----Harmonic averaging of effective diffusion-------------------------
!cmx-------It is only valid when harmonic ---
!cmx-----------------------------------------------------------------------           
              else ! Harmonic averaging of effective diffusion 
!c  average porosity of the element
!c  note: each node is included in "ndim" number of node
!c        pairs, therefore the average must be divided
!c        by ndim as well as the number of nodes in the
!c        element
!c    changed Nov.09
                ndim = 0
                if (nvx .gt. 1) ndim = ndim + 1
                if (nvy .gt. 1) ndim = ndim + 1
                if (nvz .gt. 1) ndim = ndim + 1
!c  calculate average dispersivities for the "pseudo
!c  dispersion element"

                diffav = r0
                diffav_tensor = tensor_zero
                disx_avg = r0
                disy_avg = r0
                disz_avg = r0

                do idim = 1, 3                      !loop over dimensions
                  do ipair = 1, npair(idim)        !node pairs

                    ibk = fvpair(idim, ipair, 1)
                    id = fvpair(idim, ipair, 2)

!c  material property -> currently hardwired

                    irk_ibk = mprop(ibk)
                    irk_id = mprop(id)

                    disx_avg = disx_avg       &
                             + disx(irk_ibk)  &
                             + disx(irk_id)

                    disy_avg = disy_avg       &
                             + disy(irk_ibk)  &
                             + disy(irk_id)

                    disz_avg = disz_avg       &
                             + disz(irk_ibk)  &
                             + disz(irk_id)

                  end do                            !node pairs
                end do                              !dimensions

                disx_avg = disx_avg / float(ndim) / r2**ndim
                disy_avg = disy_avg / float(ndim) / r2**ndim
                disz_avg = disz_avg / float(ndim) / r2**ndim

!c  calculate the dispersion tensor for the "pseudo dispersion element"
!c  average porosity of the element
!c    changed: Nov. 09
                vx2 = vel(1)**2
                vy2 = vel(2)**2
                vz2 = vel(3)**2
                vmag = dsqrt(vx2 + vy2 + vz2)
                vx2 = vx2 / (vmag + eps)
                vy2 = vy2 / (vmag + eps)
                vz2 = vz2 / (vmag + eps)

!c  calculate effective diffusion coefficient               

                tend(1) = disx_avg * vx2    &
                        + disy_avg * vy2    &
                        + disz_avg * vz2

                tend(2) = disy_avg * vx2    &
                        + disx_avg * vy2    &
                        + disz_avg * vz2

                tend(3) = disz_avg * vx2    &
                        + disz_avg * vy2    &
                        + disx_avg * vz2


!c  build total influence coefficient from all elemental contributions
#ifdef OPENMP
    !$omp critical
#endif
                do idim = 1, 3                  !loop over dimensions

!c  adjust for 1d-, 2d, 3d - discretization

                  do ipair = 1, npair(idim)            !node pairs
 
                    iisav = iface(idim, ipair)

                    cinfrt_da(iisav) = cinfrt_da(iisav)     &
                                     + tend(idim)           &
                                     * aread(idim, ipair)

                    cinfrt_da(isymm(iisav)) =               &
                                    cinfrt_da(isymm(iisav)) &
                                     + tend(idim)           &
                                     * aread(idim, ipair)

                  end do                                !node pairs
                end do                          !loop over dimensions
#ifdef OPENMP
    !$omp end critical
#endif

!c  pointer to current control volume

#ifdef OPENMP
                ivol = ((ivz-1)*nvy + ivy-1) * nvx + ivx
#else
                ivol = ivol+1
#endif
!CMX March 2013  300        ivol = ibk
                jtemp = ia(ivol)

!c  assign conductivities for current control volume
!c    changed: Nov. 09, not used for the time being

           
                por_i = pornew(ivol) !assign porosity
                if (assigned_tau) then
                  tau_i = tau(ivol)*tau_fac(ivol)    !
                end if 

                satav=dmin1(r1, sanew(ivol))
                so_av=dmin1(r1, sonew(ivol))
                marchieav = marchies(ivol)

                if (type_diffu == 0) then
                  diffav=diffu
                  diff_i = diffcoff(diffav,satav,por_i,tortuosity_corr,& 
                             assigned_tau,tau_i,type_tortuosity,       &
                             marchieav,                                &
                             so_av,tor_corr_a_mq,tor_corr_b_mq) 
                else if (type_diffu > 0) then
                  diffav_tensor = diffu_tensor
                  diff_i_tensor = diffcoff(                            &
                          diffav_tensor,satav,por_i,tortuosity_corr,   & 
                          assigned_tau,tau_i,type_tortuosity,          &
                          marchieav,                                   &
                          so_av,tor_corr_a_mq,tor_corr_b_mq) 
                end if

                if (b_water_freezing) then
                  if (tkel(ivol) < pressure_melt_k(ivol,r0)) then
                    if (type_diffu == 0) then
                      diff_i = diff_i*frozen_diffu
                    else if (type_diffu > 0) then
                      diff_i_tensor = diff_i_tensor*frozen_diffu
                    end if
                  end if
                end if

                jtemp = jtemp+1          ! skip diagonal

!c  assign interfacial distances of current control volume

                if (half_cells) then            !half_cells on boundary

                  if (nvx.gt.1) then                        !in x-direction
                    if (ivxgbl.eq.1.or.ivxgbl.eq.nvxgbl) then        !boundary
                      delx_i = delx(ivxgbl)
                    elseif (ivxgbl.gt.0.and.ivxgbl.lt.nvxgbl) then  !interior
                      delx_i = rhalf*delx(ivxgbl) 
                    end if
                  end if

                  if (nvy.gt.1) then                        !in y-direction
                    if (ivygbl.eq.1.or.ivygbl.eq.nvygbl) then        !boundary
                      dely_i = dely(ivygbl)
                    elseif (ivygbl.gt.0.and.ivygbl.lt.nvygbl) then  !interior
                      dely_i = rhalf*dely(ivygbl) 
                    end if
                  end if

                  if (nvz.gt.1) then                        !in z-direction
                    if (ivzgbl.eq.1.or.ivzgbl.eq.nvzgbl) then        !boundary
                      delz_i = delz(ivzgbl)
                    elseif (ivzgbl.gt.0.and.ivzgbl.lt.nvzgbl) then  !interior
                      delz_i = rhalf*delz(ivzgbl) 
                    end if
                  end if

                else                            !full cells on boundary

                  if (nvx.gt.1) then                        !in x-direction
                    delx_i = rhalf*delx(ivxgbl) 
                  end if

                  if (nvy.gt.1) then                        !in y-direction
                    dely_i = rhalf*dely(ivygbl) 
                  end if

                  if (nvz.gt.1) then                        !in z-direction
                    delz_i = rhalf*delz(ivzgbl) 
                  end if

                end if                          !(half_cells)

!c  calculate influence coefficients in x-direction

                if (nvx.gt.1) then              !connections in x-direction

                  if (ivxp.gt.0) then          !left connection  (2)
                    areaf = dely(ivygbl)*delz(ivzgbl)
                    if (half_cells) then        !half cells on boundary
                      if (ivxpgbl.eq.1) then
                        delx_j = delx(ivxpgbl)
                      elseif (ivxpgbl.gt.1) then
                        delx_j = rhalf*delx(ivxpgbl)       
                      end if
                    else                        !full cells on boundary
                      delx_j = rhalf*delx(ivxpgbl)       
                    end if                      !(half_cells)
                    jvol = ja(jtemp)             
                    jzn = mprop(jvol)
             
                    por_j = pornew(jvol)
                    if (assigned_tau) then
                      tau_j = tau(jvol)*tau_fac(jvol)    !
                    end if 

                    satav=dmin1(r1, sanew(jvol))
                    so_av=dmin1(r1, sonew(jvol))
                    marchieav = marchies(jvol)
               
                    if (type_diffu == 0) then
                      diffav=diffu
                      diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,  &
                                   assigned_tau,tau_j,type_tortuosity,       &
                                   marchieav,so_av,                          &
                                   tor_corr_a_mq,tor_corr_b_mq)
                    else if (type_diffu > 0) then
                      diffav_tensor=diffu_tensor
                      diff_j_tensor = diffcoff(                              &
                              diffav_tensor,satav,por_j,tortuosity_corr,     &
                              assigned_tau,tau_j,type_tortuosity,            &
                              marchieav,so_av,                               &
                              tor_corr_a_mq,tor_corr_b_mq)
                    end if

                    if (b_water_freezing) then
                      if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                        if (type_diffu == 0) then                         
                          diff_j = diff_j*frozen_diffu
                        else if (type_diffu > 0) then
                          diff_j_tensor = diff_j_tensor*frozen_diffu
                        end if
                      end if
                    end if                                  

 !c correct for radial coord

                    if (radial_coord) then                    
                      areaf = r2*pi*delz(ivzgbl)*(xg(ivol) - delx_i)
                      cinfrad(jtemp) = areaf                      
                    end if
                

!c  permeability update due to porosity changes

                    if (type_diffu > 0) then
                      diff_i = diff_i_tensor%xx
                      diff_j = diff_j_tensor%xx
                    end if

                    diff_ij = diff_i*diff_j

                    if(diff_ij.gt.0.0) then
                      cinfrt_da(jtemp) =  cinfrt_da(jtemp)+            &
!CMX Mar.13                      cinfrt_da(iisav) =  cinfrt_da(iisav)+               &
                            diff_ij*areaf/(diff_i*delx_j+ diff_j*delx_i)
                    endif

                    jtemp = jtemp+1
                  end if

                  if (ivxn.le.nvx) then        !right connection  (3)
                    areaf = dely(ivygbl)*delz(ivzgbl)
                    if (half_cells) then        !half cells on boundary
                      if (ivxngbl.eq.nvxgbl) then
                        delx_j = delx(ivxngbl)
                      elseif (ivxngbl.lt.nvxgbl) then
                        delx_j = rhalf*delx(ivxngbl)       
                      end if
                    else                        !full cells on boundary
                      delx_j = rhalf*delx(ivxngbl)
                    end if                      !(half_cells)
                    jvol = ja(jtemp)             
                    jzn = mprop(jvol)
             
                    por_j = pornew(jvol)
                    if (assigned_tau) then
                      tau_j = tau(jvol)*tau_fac(jvol)    !
                    end if

                    satav=dmin1(r1, sanew(jvol))
                    so_av=dmin1(r1, sonew(jvol))
                    marchieav = marchies(jvol)

                    if (type_diffu == 0) then
                      diffav=diffu
                      diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,  &
                                   assigned_tau,tau_j,type_tortuosity,       &
                                   marchieav,so_av,                          &
                                   tor_corr_a_mq,tor_corr_b_mq)
                    else if (type_diffu > 0) then
                      diffav_tensor=diffu_tensor
                      diff_j_tensor = diffcoff(                              &
                              diffav_tensor,satav,por_j,tortuosity_corr,     &
                              assigned_tau,tau_j,type_tortuosity,            &
                              marchieav,so_av,                               &
                              tor_corr_a_mq,tor_corr_b_mq)
                    end if

                    if (b_water_freezing) then
                      if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                        if (type_diffu == 0) then
                          diff_j = diff_j*frozen_diffu
                        else if (type_diffu > 0) then
                          diff_j_tensor = diff_j_tensor*frozen_diffu
                        end if
                      end if
                    end if 

!c correct for radial coord

                    if (radial_coord) then
                    
                      areaf = r2*pi*delz(ivzgbl)*(xg(ivol) + delx_i)
                      cinfrad(jtemp) = areaf
                      
                    end if
!c  De update due to porosity changes

                    if (type_diffu > 0) then
                      diff_i = diff_i_tensor%xx
                      diff_j = diff_j_tensor%xx
                    end if

                    diff_ij = diff_i*diff_j

                    if(diff_ij.gt.0.0) then 
                      cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
!CMX Mar. 13                      cinfrt_da(isymm(iisav)) =  cinfrt_da(isymm(iisav))+               &
                      diff_ij*areaf/(diff_i*delx_j+diff_j*delx_i)
                    endif

                    jtemp = jtemp+1
                    !The following cinfrt_da is not needed, DSU 
                    !else
                    !    cinfrt_da(isymm(iisav)) =  cinfrt_da(iisav)           !cmx Mar. 13
                  end if

                end if                          !connections in x-direction

!c  calculate influence coefficients in y-direction

                if (nvy.gt.1) then              !connections in y-direction

                  if (ivypgbl.gt.0) then          !front connection (4)
                    areaf = delx(ivxgbl)*delz(ivzgbl)
                    if (half_cells) then        !half cells on boundary
                      if (ivypgbl.eq.1) then
                        dely_j = dely(ivypgbl)
                      elseif (ivypgbl.gt.1) then
                        dely_j = rhalf*dely(ivypgbl)       
                      end if
                    else                        !full cells on boundary
                      dely_j = rhalf*dely(ivypgbl)       
                    end if                      !(half_cells)
                    jvol = ja(jtemp)             
                    jzn = mprop(jvol)
                   
                    por_j = pornew(jvol)
                    if (assigned_tau) then
                      tau_j = tau(jvol)*tau_fac(jvol)    !
                    end if

                    satav=dmin1(r1, sanew(jvol))
                    so_av=dmin1(r1, sonew(jvol))
                    marchieav = marchies(jvol)

                    if (type_diffu == 0) then
                      diffav=diffu
                      diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,  & 
                                   assigned_tau,tau_j,type_tortuosity,       &
                                   marchieav,so_av,                          &
                                   tor_corr_a_mq,tor_corr_b_mq)
                    else if (type_diffu > 0) then
                      diffav_tensor=diffu_tensor
                      diff_j_tensor = diffcoff(                              &
                              diffav_tensor,satav,por_j,tortuosity_corr,     & 
                              assigned_tau,tau_j,type_tortuosity,            &
                              marchieav,so_av,                               &
                              tor_corr_a_mq,tor_corr_b_mq)
                    end if

                    if (b_water_freezing) then
                      if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                        if (type_diffu == 0) then
                          diff_j = diff_j*frozen_diffu
                        else if (type_diffu > 0) then
                          diff_j = diff_j*frozen_diffu
                        end if
                      end if
                    end if 

!c no correct for radial coord in y direction
                
!c  permeability update due to porosity changes

                    if (type_diffu > 0) then
                      diff_i = diff_i_tensor%yy
                      diff_j = diff_j_tensor%yy
                    end if

                    diff_ij = diff_i*diff_j

                    if(diff_ij.gt.0.0) then
                      cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                           diff_ij*areaf/(diff_i*dely_j+diff_j*dely_i)
                    endif
                    jtemp = jtemp+1
                  end if

                  if (ivyn.le.nvy) then        !back connection (5)
                    areaf = delx(ivxgbl)*delz(ivzgbl)
                    if (half_cells) then        !half cells on boundary
                      if (ivyngbl.eq.nvygbl) then
                        dely_j = dely(ivyngbl)
                      elseif (ivyngbl.lt.nvygbl) then
                        dely_j = rhalf*dely(ivyngbl)
                      end if
                    else                        !full cells on boundary
                      dely_j = rhalf*dely(ivyngbl)
                    end if                      !(half_cells)
                    jvol = ja(jtemp)             
                    jzn = mprop(jvol)
                 
                    por_j = pornew(jvol)
                    if (assigned_tau) then
                      tau_j = tau(jvol)*tau_fac(jvol)    !
                    end if

                    satav=dmin1(r1, sanew(jvol))
                    so_av=dmin1(r1, sonew(jvol))
                    marchieav = marchies(jvol)

                    if (type_diffu == 0) then
                      diffav=diffu
                      diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,  & 
                                   assigned_tau,tau_j,type_tortuosity,       &
                                   marchieav,so_av,                          &
                                   tor_corr_a_mq,tor_corr_b_mq)
                    else if (type_diffu > 0) then
                      diffav_tensor=diffu_tensor
                      diff_j_tensor = diffcoff(                              &
                              diffav_tensor,satav,por_j,tortuosity_corr,     & 
                              assigned_tau,tau_j,type_tortuosity,            &
                              marchieav,so_av,                               &
                              tor_corr_a_mq,tor_corr_b_mq)
                    end if

                    if (b_water_freezing) then
                      if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                        if (type_diffu == 0) then
                          diff_j = diff_j*frozen_diffu
                        else if (type_diffu > 0) then
                          diff_j_tensor = diff_j_tensor*frozen_diffu
                        end if
                      end if
                    end if                                  
                
!c no correct for radial coord in y direction
                
!c  permeability update due to porosity changes

                    if (type_diffu > 0) then
                      diff_i = diff_i_tensor%yy
                      diff_j = diff_j_tensor%yy
                    end if

                    diff_ij = diff_i*diff_j

                    if(diff_ij.gt.0.0) then
                      cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                           diff_ij*areaf/(diff_i*dely_j+diff_j*dely_i)
                    endif

                    jtemp = jtemp+1
                
                  end if

                endif                          !connections in y-direction

!c  calculate influence coefficients in z-direction

                if (nvz.gt.1) then              !connections in z-direction

                  if (ivzpgbl.gt.0) then          !bottom connection (6)
                    areaf = delx(ivxgbl)*dely(ivygbl)
                    if (half_cells) then        !half cells on boundary
                      if (ivzpgbl.eq.1) then
                        delz_j = delz(ivzpgbl)
                      elseif (ivzpgbl.gt.1) then
                        delz_j = rhalf*delz(ivzpgbl)       
                      end if
                    else                        !full cells on boundary
                      delz_j = rhalf*delz(ivzpgbl)       
                    end if                      !(half_cells)
                    jvol = ja(jtemp)             
                    jzn = mprop(jvol)
                 
                    por_j = pornew(jvol)
                    if (assigned_tau) then
                      tau_j = tau(jvol)*tau_fac(jvol)
                    end if

                    satav=dmin1(r1, sanew(jvol))
                    so_av=dmin1(r1, sonew(jvol))
                    marchieav = marchies(jvol)

                    if (type_diffu == 0) then
                      diffav=diffu
                      diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,  & 
                                   assigned_tau,tau_j,type_tortuosity,       &
                                   marchieav,so_av,                          &
                                   tor_corr_a_mq,tor_corr_b_mq)
                    else if (type_diffu > 0) then
                      diffav_tensor=diffu_tensor
                      diff_j_tensor = diffcoff(                              &
                              diffav_tensor,satav,por_j,tortuosity_corr,     & 
                              assigned_tau,tau_j,type_tortuosity,            &
                              marchieav,so_av,                               &
                              tor_corr_a_mq,tor_corr_b_mq)
                    end if

                    if (b_water_freezing) then
                      if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                        if (type_diffu == 0) then
                          diff_j = diff_j*frozen_diffu
                        else if (type_diffu > 0) then
                          diff_j_tensor = diff_j_tensor*frozen_diffu
                        end if
                      end if
                    end if
                
!c correct for radial coord
                    if (radial_coord) then
                      if (half_cells) then
                        if (ivxgbl .eq. 1) then
                          areaf = pi*delx(ivxgbl)*delx(ivxgbl)
                        elseif (ivxgbl .eq. nvxgbl) then
                          areaf = r2*pi*(xg(ivol)-0.5*delx(ivxgbl))*delx(ivxgbl)
                        else ! full cell in xx direction
                          areaf = r2*pi*xg(ivol)*delx(ivxgbl)
                        end if
                      else ! full cells
                        areaf = r2*pi*xg(ivol)*delx(ivxgbl)
                    end if
                
                    cinfrad(jtemp)=areaf
               
                  end if
                
!c  permeability update due to porosity changes

                  if (type_diffu > 0) then
                    diff_i = diff_i_tensor%zz
                    diff_j = diff_j_tensor%zz
                  end if
 
                  diff_ij = diff_i*diff_j

                  if(diff_ij.gt.0.0) then
                    cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                         diff_ij*areaf/(diff_i*delz_j+diff_j*delz_i)
                  endif

                  jtemp = jtemp+1
                end if

                if (ivzn.le.nvz) then        !top connection (7)
                  areaf = delx(ivxgbl)*dely(ivygbl)
                  if (half_cells) then        !half cells on boundary
                    if (ivzngbl.eq.nvzgbl) then
                      delz_j = delz(ivzngbl)
                    elseif (ivzngbl.lt.nvzgbl) then
                      delz_j = rhalf*delz(ivzngbl)
                    end if
                  else                        !full cells on boundary
                    delz_j = rhalf*delz(ivzngbl)
                  end if                      !(half_cells)
                  jvol = ja(jtemp)             
                  jzn = mprop(jvol)
               
                  por_j = pornew(jvol)
                  if (assigned_tau) then
                    tau_j = tau(jvol)*tau_fac(jvol)    !
                  end if

                  satav=dmin1(r1, sanew(jvol))        !satav=dmin1(r1, sanew(ivol)), bug? DSU 2013-2-28
                  so_av=dmin1(r1, sonew(jvol))
                  marchieav = marchies(jvol)

                  if (type_diffu == 0) then
                    diffav=diffu
                    diff_j = diffcoff(diffav,satav,por_j,tortuosity_corr,    & 
                                   assigned_tau,tau_j,type_tortuosity,       &
                                   marchieav,so_av,                          &
                                   tor_corr_a_mq,tor_corr_b_mq)
                  else if (type_diffu > 0) then
                    diffav_tensor=diffu_tensor
                    diff_j_tensor = diffcoff(                                &
                            diffav_tensor,satav,por_j,tortuosity_corr,       & 
                            assigned_tau,tau_j,type_tortuosity,              &
                            marchieav,so_av,                                 &
                            tor_corr_a_mq,tor_corr_b_mq)
                  end if

                  if (b_water_freezing) then
                    if (tkel(jvol) < pressure_melt_k(jvol,r0)) then
                      if (type_diffu == 0) then
                        diff_j = diff_j*frozen_diffu
                      else if (type_diffu > 0) then
                        diff_j_tensor = diff_j_tensor*frozen_diffu
                      end if
                    end if
                  end if

!c correct for radial coord
                  if (radial_coord) then
                    if (half_cells) then
                      if (ivxgbl .eq. 1) then
                        areaf = pi*delx(ivxgbl)*delx(ivxgbl)
                      elseif (ivxgbl .eq. nvxgbl) then
                        areaf = r2*pi*(xg(ivol)-0.5*delx(ivxgbl))*delx(ivxgbl)
                      else ! full cell in xx direction
                        areaf = r2*pi*xg(ivol)*delx(ivxgbl)
                      end if
                    else ! full cells
                      areaf = r2*pi*xg(ivol)*delx(ivxgbl)
                    end if
                  
                    cinfrad(jtemp)=areaf                 
                  end if


!c  permeability update due to porosity changes

                  if (type_diffu > 0) then
                    diff_i = diff_i_tensor%zz
                    diff_j = diff_j_tensor%zz
                  end if
 
                  diff_ij = diff_i*diff_j

                  if(diff_ij.gt.0.0) then
                    cinfrt_da(jtemp) =  cinfrt_da(jtemp)+               &
                         diff_ij*areaf/(diff_i*delz_j+diff_j*delz_i)
                  endif

                  jtemp = jtemp+1
                
                end if

              end if                          !connections in z-direction
           
           
            end if 
           
          end do
        end do  
      end do
#ifdef OPENMP
    !$omp end do
    !$omp end parallel
#endif

!cdbg
#ifdef DEBUG
      info_debug = 0

      if (info_debug.gt.0) then
      
      do ibk = 1,nmax
       do ii = ia(ibk),ia(ibk+1)-1
         write(idbg,*) 'cinfrt_va(',ii,') = ',cinfrt_va(ii)
       end do
      end do
      do ibk = 1,nmax
       do ii = ia(ibk),ia(ibk+1)-1
         write(idbg,*) 'cinfrt_va(',ii,') = ',cinfrt_va(ii)
         write(idbg,*) 'cinfrt_da(',ii,') = ',cinfrt_da(ii)
       end do
      end do
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop
      
      end if    ! (info_debug.gt.0)
#endif
!cdbg

      return
      end

