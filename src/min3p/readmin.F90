!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 826 $
!> $Author: dsu $
!> $Date: 2022-03-24 10:10:16 -0700 (Thu, 24 Mar 2022) $
!> $URL: https://min3psvn.ubc.ca/svn/min3p_thcm/branches/dsu_new_add_2024Jan/src/min3p/readmin.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine readmin
!c -------------------
!c
!c read database for minerals and assign to permanent storage
!c
!c written by:      Uli Mayer - February 8, 96
!c
!c last modified:   Uli Mayer - March 6, 96
!c                  full set of backward reactions included
!c                  Uli Mayer - April 24, 97
!c                  zero order reactions included
!c                  Uli Mayer - July 21, 97
!c                  new rate law for surface controlled
!c                  reactions included
!c                  Uli Mayer - May 21, 99
!c                  added Monod terms
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c                                                                    I O
!c passed:   integer*4:
!c           ----------
!c           imdbs              = unit number - databse for minerals  + -
!c           ilog               = unit number, log book               + -
!c           idbg               = unit number - debugging file        + -
!c           icnv               = unit number - data conversion       + -
!c
!c common:
!c chem.f:   real*8:
!c           -------
!c           densm(nm)          = densities of minerals               * +
!c           dgcm(nm)           = activation energy for               * +
!c                                dissolution-precipitation
!c                                reaction
!c           dhcm(nm)           = enthalpy change of dissolution-     * +
!c                                precipitation reaction
!c           diffm(ndr*nm,nthreads)
!c                              = diffusion coefficient of primary    * +
!c                                reactant through surface coating
!c           eqms(nm)           = equilibrium constants for minerals  * +
!c                                at standard temperatures
!c           fmdi(nrc*nm)       = inhibition factors                  * +
!c           fmdm(nrc*nm)       = monod factors                       * +
!c           gfwm(nm)           = gram formula weight of minerals     * +
!c           orddc(nrc*nm)      = order of free species in            * +
!c                                dissolution reaction
!c           orddcx(nrc*nm)     = order of secondary aqueous          * +
!c                                species in dissolution reaction
!c           orddt(nrc*nm)      = order of total aqueous component    * +
!c                                concentration in dissolution
!c                                reaction
!c           ordm(ndr*nm)       = exponent m for reaction rate law    * +
!c           ordmdm(nrc*nm)     = order of monod terms for            * +
!c                                dissolution-precipitation reactions
!c           ordn(ndr*nm)       = exponent n for reaction rate law    * +
!c           rateds(ndr*nm)     = rate constants for dissolution      * +
!c                                reactions at standard temperature
!c           xnud(ndr*nm)       = stoichiometric coefficients of      * +
!c                                reacting species in transport
!c                                controlled dissolution reaction
!c           xnum(nm*nc)        = stoichiometric coefficients of free * +
!c                                species in mineral
!c
!c           integer*4:
!c           ----------
!c           iam(nm+1)          = row pointer array to                * +
!c                                stoichiometric coefficients of
!c                                free species in mineral
!c           iamd(nm+1)         = pointer array to dissolution        * +
!c                                reactions
!c           iamdc(ndr*nm+1)    = pointer array to free species       * +
!c                                involved in dissolution reactions
!c           iamdcx(ndr*nm+1)   = pointer array to secondary aqueous  * +
!c                                species involved in dissolution
!c                                reactions
!c           iamdi(ndr*nm+1)    = row pointer array to reactants      * +
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms)
!c           iamdm(ndr*nm+1)    = row pointer array to reactants      * +
!c                                in dissolution-precipitation
!c                                reactions (monod terms)
!c           iamdt(ndr*nm+1)    = pointer array to total aqueous      * +
!c                                component concentrations involved
!c                                in dissolution/precipitation
!c                                reactions
!c           jam(nm*nc)         = column pointer array to             * +
!c                                stoichiometric coefficients of
!c                                free species in mineral
!c           jamdc(nrc*nm)      = pointer array to free species       * +
!c                                involved in dissolution reactions
!c           jamdcx(nrc*nm)     = pointer array to secondary aqueous  * +
!c                                species involved in dissolution
!c                                reactions
!c           jamdi(nrc*nm)       = column pointer array to reactants   * +
!c                                in dissolution-precipitation
!c                                reactions (inhibition terms)
!c           jamdm(nrc*nm)      = column pointer array to reactants   * +
!c                                in dissolution-precipitation
!c                                reactions (monod terms)
!c           jamdt(nrc*nm)      = pointer array to total aqueous      * +
!c                                component concentrations involved
!c                                in dissolution/precipitation
!c                                reactions
!c           l_namem(nm)        = length of mineral names             + -
!c           l_namemp(nm)       = length of names of parallel         * +
!c                                dissolution-precipitation reactions
!c           nc                 = number of components                + -
!c           nm                 = number of minerals                  + -
!c           nx                 = number of secondary aqueous species + -
!c
!c           logical:
!c           --------
!c           far_from_equil(nm) = .true.  -> far from equilibrium     * +
!c           temp_corr          = .true.  -> specify constant         + -
!c                                           temperature
!c                                .false. -> use standard
!c                                           temperature
!c
!c           character:
!c           ----------
!c           namec(nc)          = component names                     + -
!c           namem(nm)          = mineral names                       + -
!c           namemp(ndr*nm)     = names for parallel                  * +
!c                                dissolution-precipitation reactions
!c           namex(nx)          = names of secondary aqueous species  + -
!c           namet(:)           = species names (temporary)           * *
!c           rate_control(nm)   = rate controlling process for        * +
!c                                dissolution-precipitation reaction
!c                                'surface'   = surface controlled
!c                                              reaction
!c                                'transport' = transport controlled
!c                                              reaction
!c                                'mixed'     = mixed control
!c           reaction_type(nm)  = 'reversible'                        * +
!c                                'dissolution_to_equilibrium'
!c                                'precipitation_to_equilibrium'
!c                                'dissolution_far_from_equilibrium'
!c                                'precipitation_far_from_equilibrium'
!c                                'monod'
!c                                'raoult'
!c
!c local:    real*8:
!c           -------
!c           ordt(100)          = array for temporary storage of
!c                                reaction orders
!c           r10                = constant
!c           r86400             = constant
!c           value(100)         = array for temporary storage
!c           value2(100)        = array for temporary storage
!c           xnumt(100)         = array for temporary storage of
!c                                stoichiometric coefficients of
!c                                component in mineral
!c           integer*4:
!c           ----------
!c           ic                 = counter (components)
!c           icount             = counter (check number of species)
!c           icur               = counter (position in compressed
!c                                         array)
!c           idc                = counter
!c           idcx               = counter
!c           ireac              = counter
!c           ireac2             = counter
!c           idt                = counter
!c           iend               = pointer
!c           im                 = counter (minerals)
!c           imdi               = counter (inhibition terms)
!c           imdm               = counter (monod terms)
!c           istart             = pointer
!c           iv                 = counter (temporarily stored values)
!c           ix                 = counter (complexed species)
!c           l_string           = length of text string
!c           l_sufx             = length of suffix
!c           ndc                = number of component species
!c                                involved in dissolution reaction
!c           ndcx               = number of complexed species
!c                                involved in dissolution reaction
!c           ndt                = number of components in form of
!c                                total aqueous component
!c                                concentrations
!c                                involved in dissolution reaction
!c           nmdi               = number of inhibition terms
!c           nmdm               = number of monoid terms
!c           nreac              = number of parallel dissolution
!c                                reactions for one mineral
!c           npc                = number of component species
!c                                involved in precipitation reaction
!c           npcx               = number of complexed species
!c                                involved in precipitation reaction
!c           nprec              = number of parallel precipitation
!c                                reactions for one mineral
!c           nv                 = number of temporarily stored
!c                                values
!c
!c           logical:
!c           --------
!c           comment_line       = .true.  -> read comment line
!c           done               = .true.  -> exit search
!c           found              = .true.  -> exit search
!c           next_entry         = .true.  -> database entry for
!c                                           next mineral
!c
!c           character:
!c           ----------
!c           string             = character string
!c           suffix             = file suffix name
!c           name               = name of mineral currently
!c                                processed
!c
!c external: -
!c ----------------------------------------------------------------------

      subroutine readmin(imdbs,ilog,idbg,icnv)

      use parm
      use chem
      use gen, only : rank, b_enable_output
#ifdef PETSC
      use petsc_mpi_common, only : petsc_mpi_finalize
#endif
      implicit none

      integer :: imdbs, ilog, idbg, icvn
      real*8 :: xnumt, ordt, value, value2 
      character*1 string, suffix
      character*72 name
      character*256 :: strbuffer
      dimension xnumt(100),ordt(100),value(100),value2(100)
      logical comment_line,done,found,next_entry

      !local variables
      real*8 :: r10, r86400
      integer :: i, i2,  im, iv, icount, ic, icur, istart, iend,       &
                 istart2, iend2, istop2, ireac, ireac2, icnv, idt,     &
                 idc, ix, idcx, imdi, imdm, info_debug, l_sufx,        &
                 l_string, ndt, ndc, ndcx, nmdm, nmdi, nreac, nv
      parameter (r10 = 10.0d0, r86400 = 86400.0d0)

!c initialize pointer arrays for compressed storage

      iam(1) = 1
      iamd(1) = 1
      iamdc(1) = 1
      iamdcx(1) = 1
      iamdt(1) = 1
      iamdm(1) = 1
      iamdi(1) = 1

!c  loop over minerals specified for simulation

      do im = 1,nm

!c  loop over minerals in database,
!c  search for match
!c  read all mineral data and store in compressed format
!c  exit when done or if mineral not found

        done = .false.

        do while (.not.done)

!c  skip over comment lines in database

          comment_line = .true.
          do while (comment_line)
            read (imdbs,'(a1)',err=999) string
            if (string.ne.'!') comment_line = .false.
          end do

!c  backspace to start of database entry for current mineral

          backspace(imdbs)

!c  read mineral name

          read(imdbs,*,err=999) name

!c  look for match, as long end of file is not reached or
!c  match is found

!c  mineral is found --> read data

          if (name.eq.namem(im)) then

            done = .true.

!c  read rate control and reaction type for
!c  dissolution-precipitation reaction,

            read(imdbs,*,err=999) rate_control(im),reaction_type(im)

!c  check type of reaction and define, if equilibrium coefficient
!c  is defined and if saturation index calulationes will be conducted,
!c  exit program if error in database

            if (reaction_type(im).eq.'reversible' .or.                &
     &          reaction_type(im).eq.'dissolution_to_equilibrium' .or.&
     &          reaction_type(im).eq.                                 &
     &          'precipitation_to_equilibrium'.or.                    &
     &          reaction_type(im).eq.'raoult') then
                                                                       
              far_from_equil(im) = .false.
                                                                       
            elseif (reaction_type(im).eq.                             &
     &              'dissolution_far_from_equilibrium' .or.           &
     &              reaction_type(im).eq.                             &
     &              'precipitation_far_from_equilibrium' .or.         &
     &              reaction_type(im).eq.'monod') then
                                                                       
              far_from_equil(im) = .true.
                                                                       
            else
              if (rank == 0) then                                                          
                write(ilog,*) 'SIMULATION TERMINATED'                    
                write(ilog,*) 'error reading database "mineral.dbs"'     
                l_string = index(reaction_type(im),' ')-1                
                if (l_string.eq.-1.or.l_string.gt.72) then               
                  l_string = 72                                          
                end if                                                   
                write(ilog,*) 'reaction type ',reaction_type(im)       &
     &                        (:l_string),' not defined'
                close(ilog)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop

            end if

!c  read gram formula weight, density, enthalpy change and activation
!c  energy

            if (temp_corr) then
              read(imdbs,*,err=999) gfwm(im), densm(im),              &
     &                              dhcm(im), dgcm(im)
            else
              read(imdbs,*,err=999) gfwm(im), densm(im)
            end if

!c  read number of parallel reactions and define if reaction
!c  stoichiometry is specified generally or seperately for each
!c  parallel reaction

            read(imdbs,*,err=999) nreac

!c  read equilibrium constant, number and names of components and
!c  stoichiometric coefficients of components in mineral

            if (far_from_equil(im)) then
              read(imdbs,*,err=999) nv,(namet(iv),xnumt(iv),iv=1,nv)
            else
              read(imdbs,*,err=999) eqms(im),nv,                      &
     &                              (namet(iv),xnumt(iv),iv=1,nv)
              eqms(im) = r10 ** (-eqms(im))
            end if

!c  pointer array to row in stoichiometric reaction matrix for
!c  next mineral

            iam(im+1) = iam(im)+nv

!c  check if all components for mineral are specified in general
!c  input file
!c  set up pointer array to column in stoichiometric matrix

            icount = 0
            ic = 0
            do while ((icount.lt.nv).and.(ic.lt.nc))
              ic = ic+1
              iv = 0
              found = .false.
              do while ((iv.lt.nv).and.(.not.found))
                iv = iv+1
                if (namet(iv).eq.namec(ic)) then
                  found = .true.
                  icount = icount+1
                  icur = iam(im)+iv-1
                  jam(icur) = ic
                end if
              end do
            end do

!c  if component is missing, exit

            if (icount.ne.nv) then
              if (rank == 0) then  
                write(ilog,'(72a)') ('-',i=1,72)
                write(ilog,'(a,a12,a)')'component species for ',       &
     &                               name,' is missing'
                write(ilog,'(72a)') ('-',i=1,72)
              end if
#ifdef PETSC
              call petsc_mpi_finalize
#endif
              stop

!c  all components available --> read data and assign to arrays

            elseif (icount.eq.nv) then

!c  assign stoichiometric coefficients

              istart = iam(im)
              iend = iam(im+1)-1
              iv = 0
              do i = istart,iend
                iv = iv+1
                xnum(i) = xnumt(iv)
              end do

!c  assign position for next mineral im+1

              iamd(im+1) = iamd(im) + nreac

!c  loop over number of parallel dissolution/precipitation reactions
!c  for mineral im

              istart = iamd(im)
              iend = iamd(im+1)-1

              ireac2 = 0

              do ireac = istart,iend

!c  assign names for parallel reactions

                ireac2 = ireac2+1
                !Deprecated, use internal convert instead. DSU
                !rewind(icnv)
                !write(icnv,'(i1)') ireac2
                !rewind(icnv)
                !read(icnv,'(a1)') suffix
                write(suffix,'(i1)') ireac2
                l_sufx = 1

                namemp(ireac) = namem(im)(:l_namem(im))//'_'//        &
     &                          suffix(:l_sufx)

!c  define length of namemp(ireac)

                l_namemp(ireac) = index(namemp(ireac),' ')-1
                if (l_namemp(ireac).eq.-1.or.l_namemp(ireac).gt.14) then
                  l_namemp(ireac) = 14
                end if

!c  read data

                if (rate_control(im).eq.'surface') then
                  read(imdbs,*,err=999) ndt, ndc, ndcx, rateds(ireac),&
     &                          ordm(ireac), ordn(ireac)

!c  convert log rate constant to rate constant and convert time units
!c  from seconds to days

                  rateds(ireac) = r10**(rateds(ireac))*r86400

                elseif (rate_control(im).eq.'transport') then

                  read(imdbs,*,err=999) ndt, ndc, ndcx, diffms(ireac), &
     &                          xnud(ireac)

!c  convert diffusion coefficient from [m^2/s] to [m^2/d]

                  diffms(ireac) = diffms(ireac)*r86400

!cdsu  save this coefficient for later use, diffusion coefficient at standard temperature, by dwilson November 24, 2015
                  diffm(ireac,:) = diffms(ireac)

                end if

!c  assign pointer arrays for reacting species

                iamdt(ireac+1) = iamdt(ireac) + ndt
                iamdc(ireac+1) = iamdc(ireac) + ndc
                iamdcx(ireac+1) = iamdcx(ireac) + ndcx

!c  read names of participating species and order of reaction from
!c  database and store in temporary array, skip for zero order reactions

                if (ndt+ndc+ndcx.gt.0) then

                  read(imdbs,*,err=999) (namet(i),ordt(i),            &
     &                                   i=1,ndt+ndc+ndcx)

!c  check if all components/species involved in particular reaction
!c  are specified in general input file and assign pointer to species
!c  and order of reaction
!c
!c  components - total aqueous component concentrations

                  icount = 0
                  ic = 0
                  do while ((icount.lt.ndt).and.(ic.lt.nc))
                    found = .false.
                    idt = 0
                    ic = ic+1
                    do while ((idt.lt.ndt).and.(.not.found))
                      idt = idt+1
                      if (namet(idt).eq.namec(ic)) then
                        found = .true.
                        icount = icount+1
                        icur = iamdt(ireac)+idt-1
                        jamdt(icur) = ic
                        orddt(icur) = ordt(idt)
                      end if
                    end do
                  end do

!c  if component is missing --> exit

                  if (icount.ne.ndt) then
                    if (rank == 0) then
                      write(ilog,'(72a)') ('-',i=1,72)
                      write(ilog,'(2a,a12,a)') 'component promoting ', &
     &                           'dissolution of ',name,' is missing'
                      write(ilog,'(72a)') ('-',i=1,72)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if

!c  components as species in solution

                  icount = 0
                  ic = 0
                  do while ((icount.lt.ndc).and.(ic.lt.nc))
                    found = .false.
                    idc = 0
                    ic = ic+1
                    do while ((idc.lt.ndc).and.(.not.found))
                      idc = idc+1
                      if (namet(ndt+idc).eq.namec(ic)) then
                        found = .true.
                        icount = icount+1
                        icur = iamdc(ireac)+idc-1
                        jamdc(icur) = ic
                        orddc(icur) = ordt(ndt+idc)
                      end if
                    end do
                  end do

!c  if component as species in solution is missing --> exit

                  if (icount.ne.ndc) then
                    if (rank == 0) then  
                      write(ilog,'(72a)') ('-',i=1,72)
                      write(ilog,'(2a,a12,a)') 'species promoting ',   &
     &                           'dissolution of ',name,' is missing'
                      write(ilog,'(72a)') ('-',i=1,72)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if

!c  for aqueous complexes

                  icount = 0
                  ix = 0
                  do while ((icount.lt.ndcx).and.(ix.lt.nx))
                    found = .false.
                    idcx = 0
                    ix = ix+1
                    do while ((idcx.lt.ndcx).and.(.not.found))
                      idcx = idcx+1
                      if (namet(ndt+ndc+idcx).eq.namex(ix)) then
                        found = .true.
                        icount = icount+1
                        icur = iamdcx(ireac)+idcx-1
                        jamdcx(icur) = ix
                        orddcx(icur) = ordt(ndt+ndc+idcx)
                      end if
                    end do
                  end do

!c  if aqueous complex is missing --> exit

                  if (icount.ne.ndcx) then
                    if (rank == 0) then  
                      write(ilog,'(72a)') ('-',i=1,72)
                      write(ilog,'(2a,a12,a)') 'aqueous complex ',     &
     &                           'promoting dissolution of ',name,     &
     &                           ' is missing'
                      write(ilog,'(72a)') ('-',i=1,72)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if

                end if        !(ndt+ndc+ndcx.gt.0)

              end do        !number of parallel reactions

!c  read Monod and inhibition terms

              if (reaction_type(im).eq.'monod') then

!c  read number of monod terms

                read(imdbs,*,err=999) nmdm

!c  assign row pointer for reactants in monod-terms

                iamdm(im+1) = iamdm(im) + nmdm

!c  read names of reacting species for monod terms from
!c  database and store in temporary array, skip for zero order reaction

                if (nmdm.gt.0) then

                  read(imdbs,*,err=999) (namet(i),value(i),value2(i),i=1,nmdm)

!c  check if all reactants involved in monod terms
!c  are specified as components
!c  assign pointer to species and order of reaction

!c  components - total aqueous component concentrations

                  icount = 0
                  imdm = 0
                  do while (imdm.lt.nmdm)
                    imdm = imdm+1
                    ic = 0
                    found = .false.
                    do while ((icount.lt.nmdm).and.(ic.lt.nc)         &
     &                         .and.(.not.found))
                      ic = ic+1
                      if (namet(imdm).eq.namec(ic)) then
                        found = .true.
                        icount = icount+1
                        icur = iamdm(im)+imdm-1
                        jamdm(icur) = ic
                        fmdm(icur) = value(imdm)
                        ordmdm(icur) = value2(imdm)
                      end if
                    end do
                  end do

!c  if component is missing --> exit

                  if (icount.ne.nmdm) then
                    if (rank == 0) then  
                      write(ilog,'(72a)') ('-',i=1,72)
                      write(ilog,'(5a)')                                &
     &                      'component for dissolution-precipitation ', &
     &                      'reaction ',namem(im)(:l_namem(im)),        &
     &                      ' is missing'
                      write(ilog,'(72a)') ('-',i=1,72)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if

                end if      !nmdm.gt.0

!c  read number of inhibition terms

                read(imdbs,*,err=999) nmdi

!c  assign row pointer for reactants in inhibitition-terms

                iamdi(im+1) = iamdi(im) + nmdi

!c  read names of reacting species for inhibition terms from
!c  database and store in temporary array

                if (nmdi.gt.0) then

                  read(imdbs,*,err=999) (namet(i),value(i),i=1,nmdi)

!c  check if all reactants involved in inhibition terms
!c  are specified as components
!c  assign pointer to species and order of reaction

!c  components - total aqueous component concentrations

                  icount = 0
                  ic = 0
                  do while ((icount.lt.nmdi).and.(ic.lt.nc))
                    found = .false.
                    imdi = 0
                    ic = ic+1
                    do while ((imdi.lt.nmdi).and.(.not.found))
                      imdi = imdi+1
                      if (namet(imdi).eq.namec(ic)) then
                        found = .true.
                        icount = icount+1
                        icur = iamdi(im)+imdi-1
                        jamdi(icur) = ic
                        fmdi(icur) = value(imdi)
                      end if
                    end do
                  end do

!c  if component is missing --> exit

                  if (icount.ne.nmdi) then
                    if (rank == 0) then  
                      write(ilog,'(72a)') ('-',i=1,72)
                      write(ilog,'(5a)')                                &
     &                      'component for dissolution-precipitation ', &
     &                      'reaction ',namem(im)(:l_namem(im)),        &
     &                      ' is missing'
                      write(ilog,'(72a)') ('-',i=1,72)
                    end if
#ifdef PETSC
                    call petsc_mpi_finalize
#endif
                    stop
                  end if

                end if        !nmdi.gt.0

              else

!c  assign pointers for non-monod type reactions

                iamdm(im+1) = iamdm(im)
                iamdi(im+1) = iamdi(im)

              end if        !(reaction_type(im).eq.'monod')

!c  rewind mineral database to search for next mineral, doing this
!c  allows the specification of minerals in an arbitray order

              rewind(imdbs)

            end if

!c  go to next mineral, if no match was found

          elseif ((name.ne.namem(im)).and.    &
     &            (name.ne.'end')) then

            next_entry = .false.
            do while (.not.next_entry)
              read (imdbs,'(a1)',err=999) string
              if (string.eq.'!') then
                next_entry = .true.
              end if
            end do

            backspace(imdbs)

!c  exit if end of file is reached and mineral specified was not found

          elseif (name.eq.'end') then
            if (rank == 0) then
              write(ilog,'(72a)') ('-',i=1,72)
              write(ilog,'(4a)') 'mineral ',trim(namem(im)),' not in database ',&
     &                       '- check input file'
              write(ilog,'(72a)') ('-',i=1,72)
            end if
#ifdef PETSC
            call petsc_mpi_finalize
#endif
            stop

          end if

        end do                 !end - loop over minerals database
      end do                   !end - loop over specified minerals

      goto 1000

999   continue
      backspace(imdbs)
      read(imdbs,'(a)') strbuffer
      if (rank == 0) then
        write(ilog,*) 'SIMULATION TERMINATED'
        write(ilog,'(2a)') 'error reading in mineral database (readmin.F90): ',trim(strbuffer)
        write(*,*) 'SIMULATION TERMINATED'
        write(*,'(2a)') 'error reading in mineral database (readmin.F90): ',trim(strbuffer)
        close(ilog)
      end if
#ifdef PETSC
      call petsc_mpi_finalize
#endif
      stop

!cdbg ---- activate this section for purposes of debugging -----

1000   continue
     
#ifdef DEBUG
     
      info_debug = 0

      if (info_debug.gt.0) then
        write(idbg,'(a)') 'returning from readmin ...'
        do im=1,nm
          write(idbg,'(a72,1x,a12)') namem(im),rate_control(im)
          write(idbg,'(a,a72)') reaction_type(im)
          if (far_from_equil(im)) then
            write(idbg,'(a)') 'reaction far from equilibrium'
          end if
          if (.not.far_from_equil(im)) then
            write(idbg,'(a,1pe15.6e3)') 'eqms  ',-dlog10(eqms(im))
          end if
          write(idbg,'(a,1pe15.6e3)') 'gfwm  ',gfwm(im)
          write(idbg,'(a,1pe15.6e3)') 'densm ',densm(im)
          write(idbg,'(a,1pe15.6e3)') 'dhcm  ',dhcm(im)
          write(idbg,'(a,1pe15.6e3)') 'dgcm  ',dgcm(im)
          write(idbg,'(a,i10)') 'iam    ',iam(im)

!c  echo check for stoichiometric coefficients

          istart = iam(im)
          iend = iam(im+1)-1
          do i = istart, iend
            icur = jam(i)
            write(idbg,'(i5,2x,a72,a,i5,a,1pe15.6e3)') i,namec(icur),  &
     &                 ' jam ',jam(i),' xnum ',xnum(i)
          end do

!c  echo check dissolution/precipitation reactions

          write(idbg,'(a,i10)') 'iamd   ',iamd(im)
          istart = iamd(im)
          iend = iamd(im+1)-1
          do i = istart, iend
            if (rate_control(im).eq.'surface') then
              write(idbg,'(i5,4(a,1pe15.6e3))') i,                    &
     &                                 ' ordm ',ordm(i),              &
     &                                 ' ordn ',ordn(i),              &
     &                                 ' rateds',dlog10(rateds(i)),   &
     &                                 ' diffm ',r86400*diffms(i)
            elseif (rate_control(im).eq.'transport') then              
              write(idbg,'(i5,a,1pe15.6e3)') i,' xnud ',xnud(i)
            end if                                                     
            write(idbg,'(3(a,1x,i10,1x))') 'iamdt   ',iamdt(i),       &
     &                                     'iamdc   ',iamdc(i),       &
     &                                     'iamdcx  ',iamdcx(i)        
            istart2 = iamdt(i)                                         
            iend2 = iamdt(i+1)-1                                       
            do i2 = istart2,iend2                                      
              icur = jamdt(i2)                                         
              write(idbg,'(i5,2x,a72,a,i5,a,1pe15.6e3)') i2,namec(icur), &
                    ' jamdt ',jamdt(i2), ' orddt ',orddt(i2)
            end do
                                                                       
            istart2 = iamdc(i)                                         
            iend2 = iamdc(i+1)-1                                       
            do i2 = istart2,iend2                                      
              icur = jamdc(i2)                                         
              write(idbg,'(i5,2x,a72,a,i5,a,1pe15.6e3)') i2,namec(icur), &
                    ' jamdc ',jamdc(i2), ' orddc ',orddc(i2)
            end do
                                                                       
            istart2 = iamdcx(i)                                        
            iend2 = iamdcx(i+1)-1                                      
            do i2 = istart2,iend2                                      
              icur = jamdcx(i2)                                        
              write(idbg,'(i5,2x,a72,a,i5,a,1pe15.6e3)') i2,namex(icur), &
                    ' jamdcx ',jamdcx(i2), ' orddcx ',orddcx(i2)
            end do
          end do

!c  monod terms

          write(idbg,'(a,1x,i10,1x)') 'iamdm   ',iamdm(im)
          istart2 = iamdm(im)
          istop2 = iamdm(im+1)-1
          do i2 = istart2,istop2
            icur = jamdm(i2)
            write(idbg,'(i5,2x,a72,a,i5,2(a,1pe15.6e3))') i2,namec(icur),&
                  ' jamdm ',jamdm(i2), ' fmdm ',fmdm(i2),              &
                  ' ordmdm ',ordmdm(i2)
          end do

!c  inhibition terms

          write(idbg,'(a,1x,i10,1x)') 'iamdi   ',iamdi(im)
          istart2 = iamdi(im)
          istop2 = iamdi(im+1)-1
          do i2 = istart2,istop2
            icur = jamdi(i2)
            write(idbg,'(i5,2x,a72,a,i5,a,1pe15.6e3)') i2,namec(icur), &
                  ' jamdi ',jamdi(i2), ' fmdi ',fmdi(i2)
          end do

          write(idbg,*) '----------------------------------------------'
        end do
      end if

      if (info_debug.gt.1) then
#ifdef PETSC
        call petsc_mpi_finalize
#endif
        stop
      end if
#endif
!cdbg

      return
      end
